"use strict";
(self["webpackChunknusery_man_frontend"] = self["webpackChunknusery_man_frontend"] || []).push([["main"],{

/***/ "./node_modules/@symfony/webpack-encore/node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/App.vue?vue&type=script&setup=true&lang=js":
/*!************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/@symfony/webpack-encore/node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/App.vue?vue&type=script&setup=true&lang=js ***!
  \************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");
/* harmony import */ var _layout_DashboardLayout_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../layout/DashboardLayout.vue */ "./src/layout/DashboardLayout.vue");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __name: 'App',
  setup: function setup(__props, _ref) {
    var __expose = _ref.expose;
    __expose();
    var message = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)('Hoo');
    var __returned__ = {
      message: message,
      ref: vue__WEBPACK_IMPORTED_MODULE_0__.ref,
      DashboardLayout: _layout_DashboardLayout_vue__WEBPACK_IMPORTED_MODULE_1__["default"]
    };
    Object.defineProperty(__returned__, '__isScriptSetup', {
      enumerable: false,
      value: true
    });
    return __returned__;
  }
});

/***/ }),

/***/ "./node_modules/@symfony/webpack-encore/node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/App.vue?vue&type=template&id=617ab0be":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/@symfony/webpack-encore/node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/App.vue?vue&type=template&id=617ab0be ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)($setup["DashboardLayout"], null, {
    "default": (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(function () {
      return [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("h1", null, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($setup.message), 1 /* TEXT */)])];
    }),
    _: 1 /* STABLE */
  });
}

/***/ }),

/***/ "./node_modules/@symfony/webpack-encore/node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/layout/DashboardLayout.vue?vue&type=template&id=4977e71c&scoped=true":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/@symfony/webpack-encore/node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/layout/DashboardLayout.vue?vue&type=template&id=4977e71c&scoped=true ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");

var _hoisted_1 = {
  "class": "app-layout"
};
var _hoisted_2 = {
  "class": "sidebar"
};
var _hoisted_3 = {
  "class": "menu"
};
var _hoisted_4 = {
  "class": "main-container"
};
function render(_ctx, _cache) {
  var _component_router_link = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("router-link");
  var _component_router_view = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("router-view");
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("aside", _hoisted_2, [_cache[6] || (_cache[6] = (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", {
    "class": "logo"
  }, "Nursery Manager", -1 /* HOISTED */)), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("nav", _hoisted_3, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_router_link, {
    to: "/",
    exact: "",
    "active-class": "active"
  }, {
    "default": (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(function () {
      return _cache[0] || (_cache[0] = [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", {
        "class": "menu-item"
      }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("img", {
        src: "",
        alt: "Home"
      }), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("span", null, "Home")], -1 /* HOISTED */)]);
    }),
    _: 1 /* STABLE */
  }), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_router_link, {
    to: "/espace-enfant",
    "active-class": "active"
  }, {
    "default": (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(function () {
      return _cache[1] || (_cache[1] = [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", {
        "class": "menu-item"
      }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("img", {
        src: "",
        alt: "Espace enfant"
      }), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("span", null, "Espace enfant")], -1 /* HOISTED */)]);
    }),
    _: 1 /* STABLE */
  }), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_router_link, {
    to: "/espace-parent",
    "active-class": "active"
  }, {
    "default": (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(function () {
      return _cache[2] || (_cache[2] = [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", {
        "class": "menu-item"
      }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("img", {
        src: "",
        alt: "Espace parent"
      }), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("span", null, "Espace parent")], -1 /* HOISTED */)]);
    }),
    _: 1 /* STABLE */
  }), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_router_link, {
    to: "/planning",
    "active-class": "active"
  }, {
    "default": (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(function () {
      return _cache[3] || (_cache[3] = [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", {
        "class": "menu-item"
      }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("img", {
        src: "",
        alt: "Planning"
      }), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("span", null, "Planning")], -1 /* HOISTED */)]);
    }),
    _: 1 /* STABLE */
  }), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_router_link, {
    to: "/personnel",
    "active-class": "active"
  }, {
    "default": (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(function () {
      return _cache[4] || (_cache[4] = [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", {
        "class": "menu-item"
      }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("img", {
        src: "",
        alt: "Personnel"
      }), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("span", null, "Personnel")], -1 /* HOISTED */)]);
    }),
    _: 1 /* STABLE */
  }), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_router_link, {
    to: "/parametre",
    "active-class": "active"
  }, {
    "default": (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(function () {
      return _cache[5] || (_cache[5] = [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", {
        "class": "menu-item"
      }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("img", {
        src: "",
        alt: "Paramètre"
      }), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("span", null, "Paramètre")], -1 /* HOISTED */)]);
    }),
    _: 1 /* STABLE */
  })])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("main", _hoisted_4, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_router_view)])]);
}

/***/ }),

/***/ "./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BASE_TRANSITION: () => (/* binding */ BASE_TRANSITION),
/* harmony export */   BindingTypes: () => (/* binding */ BindingTypes),
/* harmony export */   CAMELIZE: () => (/* binding */ CAMELIZE),
/* harmony export */   CAPITALIZE: () => (/* binding */ CAPITALIZE),
/* harmony export */   CREATE_BLOCK: () => (/* binding */ CREATE_BLOCK),
/* harmony export */   CREATE_COMMENT: () => (/* binding */ CREATE_COMMENT),
/* harmony export */   CREATE_ELEMENT_BLOCK: () => (/* binding */ CREATE_ELEMENT_BLOCK),
/* harmony export */   CREATE_ELEMENT_VNODE: () => (/* binding */ CREATE_ELEMENT_VNODE),
/* harmony export */   CREATE_SLOTS: () => (/* binding */ CREATE_SLOTS),
/* harmony export */   CREATE_STATIC: () => (/* binding */ CREATE_STATIC),
/* harmony export */   CREATE_TEXT: () => (/* binding */ CREATE_TEXT),
/* harmony export */   CREATE_VNODE: () => (/* binding */ CREATE_VNODE),
/* harmony export */   CompilerDeprecationTypes: () => (/* binding */ CompilerDeprecationTypes),
/* harmony export */   ConstantTypes: () => (/* binding */ ConstantTypes),
/* harmony export */   ElementTypes: () => (/* binding */ ElementTypes),
/* harmony export */   ErrorCodes: () => (/* binding */ ErrorCodes),
/* harmony export */   FRAGMENT: () => (/* binding */ FRAGMENT),
/* harmony export */   GUARD_REACTIVE_PROPS: () => (/* binding */ GUARD_REACTIVE_PROPS),
/* harmony export */   IS_MEMO_SAME: () => (/* binding */ IS_MEMO_SAME),
/* harmony export */   IS_REF: () => (/* binding */ IS_REF),
/* harmony export */   KEEP_ALIVE: () => (/* binding */ KEEP_ALIVE),
/* harmony export */   MERGE_PROPS: () => (/* binding */ MERGE_PROPS),
/* harmony export */   NORMALIZE_CLASS: () => (/* binding */ NORMALIZE_CLASS),
/* harmony export */   NORMALIZE_PROPS: () => (/* binding */ NORMALIZE_PROPS),
/* harmony export */   NORMALIZE_STYLE: () => (/* binding */ NORMALIZE_STYLE),
/* harmony export */   Namespaces: () => (/* binding */ Namespaces),
/* harmony export */   NodeTypes: () => (/* binding */ NodeTypes),
/* harmony export */   OPEN_BLOCK: () => (/* binding */ OPEN_BLOCK),
/* harmony export */   POP_SCOPE_ID: () => (/* binding */ POP_SCOPE_ID),
/* harmony export */   PUSH_SCOPE_ID: () => (/* binding */ PUSH_SCOPE_ID),
/* harmony export */   RENDER_LIST: () => (/* binding */ RENDER_LIST),
/* harmony export */   RENDER_SLOT: () => (/* binding */ RENDER_SLOT),
/* harmony export */   RESOLVE_COMPONENT: () => (/* binding */ RESOLVE_COMPONENT),
/* harmony export */   RESOLVE_DIRECTIVE: () => (/* binding */ RESOLVE_DIRECTIVE),
/* harmony export */   RESOLVE_DYNAMIC_COMPONENT: () => (/* binding */ RESOLVE_DYNAMIC_COMPONENT),
/* harmony export */   RESOLVE_FILTER: () => (/* binding */ RESOLVE_FILTER),
/* harmony export */   SET_BLOCK_TRACKING: () => (/* binding */ SET_BLOCK_TRACKING),
/* harmony export */   SUSPENSE: () => (/* binding */ SUSPENSE),
/* harmony export */   TELEPORT: () => (/* binding */ TELEPORT),
/* harmony export */   TO_DISPLAY_STRING: () => (/* binding */ TO_DISPLAY_STRING),
/* harmony export */   TO_HANDLERS: () => (/* binding */ TO_HANDLERS),
/* harmony export */   TO_HANDLER_KEY: () => (/* binding */ TO_HANDLER_KEY),
/* harmony export */   TS_NODE_TYPES: () => (/* binding */ TS_NODE_TYPES),
/* harmony export */   UNREF: () => (/* binding */ UNREF),
/* harmony export */   WITH_CTX: () => (/* binding */ WITH_CTX),
/* harmony export */   WITH_DIRECTIVES: () => (/* binding */ WITH_DIRECTIVES),
/* harmony export */   WITH_MEMO: () => (/* binding */ WITH_MEMO),
/* harmony export */   advancePositionWithClone: () => (/* binding */ advancePositionWithClone),
/* harmony export */   advancePositionWithMutation: () => (/* binding */ advancePositionWithMutation),
/* harmony export */   assert: () => (/* binding */ assert),
/* harmony export */   baseCompile: () => (/* binding */ baseCompile),
/* harmony export */   baseParse: () => (/* binding */ baseParse),
/* harmony export */   buildDirectiveArgs: () => (/* binding */ buildDirectiveArgs),
/* harmony export */   buildProps: () => (/* binding */ buildProps),
/* harmony export */   buildSlots: () => (/* binding */ buildSlots),
/* harmony export */   checkCompatEnabled: () => (/* binding */ checkCompatEnabled),
/* harmony export */   convertToBlock: () => (/* binding */ convertToBlock),
/* harmony export */   createArrayExpression: () => (/* binding */ createArrayExpression),
/* harmony export */   createAssignmentExpression: () => (/* binding */ createAssignmentExpression),
/* harmony export */   createBlockStatement: () => (/* binding */ createBlockStatement),
/* harmony export */   createCacheExpression: () => (/* binding */ createCacheExpression),
/* harmony export */   createCallExpression: () => (/* binding */ createCallExpression),
/* harmony export */   createCompilerError: () => (/* binding */ createCompilerError),
/* harmony export */   createCompoundExpression: () => (/* binding */ createCompoundExpression),
/* harmony export */   createConditionalExpression: () => (/* binding */ createConditionalExpression),
/* harmony export */   createForLoopParams: () => (/* binding */ createForLoopParams),
/* harmony export */   createFunctionExpression: () => (/* binding */ createFunctionExpression),
/* harmony export */   createIfStatement: () => (/* binding */ createIfStatement),
/* harmony export */   createInterpolation: () => (/* binding */ createInterpolation),
/* harmony export */   createObjectExpression: () => (/* binding */ createObjectExpression),
/* harmony export */   createObjectProperty: () => (/* binding */ createObjectProperty),
/* harmony export */   createReturnStatement: () => (/* binding */ createReturnStatement),
/* harmony export */   createRoot: () => (/* binding */ createRoot),
/* harmony export */   createSequenceExpression: () => (/* binding */ createSequenceExpression),
/* harmony export */   createSimpleExpression: () => (/* binding */ createSimpleExpression),
/* harmony export */   createStructuralDirectiveTransform: () => (/* binding */ createStructuralDirectiveTransform),
/* harmony export */   createTemplateLiteral: () => (/* binding */ createTemplateLiteral),
/* harmony export */   createTransformContext: () => (/* binding */ createTransformContext),
/* harmony export */   createVNodeCall: () => (/* binding */ createVNodeCall),
/* harmony export */   errorMessages: () => (/* binding */ errorMessages),
/* harmony export */   extractIdentifiers: () => (/* binding */ extractIdentifiers),
/* harmony export */   findDir: () => (/* binding */ findDir),
/* harmony export */   findProp: () => (/* binding */ findProp),
/* harmony export */   forAliasRE: () => (/* binding */ forAliasRE),
/* harmony export */   generate: () => (/* binding */ generate),
/* harmony export */   generateCodeFrame: () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_0__.generateCodeFrame),
/* harmony export */   getBaseTransformPreset: () => (/* binding */ getBaseTransformPreset),
/* harmony export */   getConstantType: () => (/* binding */ getConstantType),
/* harmony export */   getMemoedVNodeCall: () => (/* binding */ getMemoedVNodeCall),
/* harmony export */   getVNodeBlockHelper: () => (/* binding */ getVNodeBlockHelper),
/* harmony export */   getVNodeHelper: () => (/* binding */ getVNodeHelper),
/* harmony export */   hasDynamicKeyVBind: () => (/* binding */ hasDynamicKeyVBind),
/* harmony export */   hasScopeRef: () => (/* binding */ hasScopeRef),
/* harmony export */   helperNameMap: () => (/* binding */ helperNameMap),
/* harmony export */   injectProp: () => (/* binding */ injectProp),
/* harmony export */   isCoreComponent: () => (/* binding */ isCoreComponent),
/* harmony export */   isFnExpression: () => (/* binding */ isFnExpression),
/* harmony export */   isFnExpressionBrowser: () => (/* binding */ isFnExpressionBrowser),
/* harmony export */   isFnExpressionNode: () => (/* binding */ isFnExpressionNode),
/* harmony export */   isFunctionType: () => (/* binding */ isFunctionType),
/* harmony export */   isInDestructureAssignment: () => (/* binding */ isInDestructureAssignment),
/* harmony export */   isInNewExpression: () => (/* binding */ isInNewExpression),
/* harmony export */   isMemberExpression: () => (/* binding */ isMemberExpression),
/* harmony export */   isMemberExpressionBrowser: () => (/* binding */ isMemberExpressionBrowser),
/* harmony export */   isMemberExpressionNode: () => (/* binding */ isMemberExpressionNode),
/* harmony export */   isReferencedIdentifier: () => (/* binding */ isReferencedIdentifier),
/* harmony export */   isSimpleIdentifier: () => (/* binding */ isSimpleIdentifier),
/* harmony export */   isSlotOutlet: () => (/* binding */ isSlotOutlet),
/* harmony export */   isStaticArgOf: () => (/* binding */ isStaticArgOf),
/* harmony export */   isStaticExp: () => (/* binding */ isStaticExp),
/* harmony export */   isStaticProperty: () => (/* binding */ isStaticProperty),
/* harmony export */   isStaticPropertyKey: () => (/* binding */ isStaticPropertyKey),
/* harmony export */   isTemplateNode: () => (/* binding */ isTemplateNode),
/* harmony export */   isText: () => (/* binding */ isText$1),
/* harmony export */   isVSlot: () => (/* binding */ isVSlot),
/* harmony export */   locStub: () => (/* binding */ locStub),
/* harmony export */   noopDirectiveTransform: () => (/* binding */ noopDirectiveTransform),
/* harmony export */   processExpression: () => (/* binding */ processExpression),
/* harmony export */   processFor: () => (/* binding */ processFor),
/* harmony export */   processIf: () => (/* binding */ processIf),
/* harmony export */   processSlotOutlet: () => (/* binding */ processSlotOutlet),
/* harmony export */   registerRuntimeHelpers: () => (/* binding */ registerRuntimeHelpers),
/* harmony export */   resolveComponentType: () => (/* binding */ resolveComponentType),
/* harmony export */   stringifyExpression: () => (/* binding */ stringifyExpression),
/* harmony export */   toValidAssetId: () => (/* binding */ toValidAssetId),
/* harmony export */   trackSlotScopes: () => (/* binding */ trackSlotScopes),
/* harmony export */   trackVForSlotScopes: () => (/* binding */ trackVForSlotScopes),
/* harmony export */   transform: () => (/* binding */ transform),
/* harmony export */   transformBind: () => (/* binding */ transformBind),
/* harmony export */   transformElement: () => (/* binding */ transformElement),
/* harmony export */   transformExpression: () => (/* binding */ transformExpression),
/* harmony export */   transformModel: () => (/* binding */ transformModel),
/* harmony export */   transformOn: () => (/* binding */ transformOn),
/* harmony export */   traverseNode: () => (/* binding */ traverseNode),
/* harmony export */   unwrapTSNode: () => (/* binding */ unwrapTSNode),
/* harmony export */   walkBlockDeclarations: () => (/* binding */ walkBlockDeclarations),
/* harmony export */   walkFunctionParams: () => (/* binding */ walkFunctionParams),
/* harmony export */   walkIdentifiers: () => (/* binding */ walkIdentifiers),
/* harmony export */   warnDeprecation: () => (/* binding */ warnDeprecation)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
/**
* @vue/compiler-core v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/



const FRAGMENT = Symbol( true ? `Fragment` : 0);
const TELEPORT = Symbol( true ? `Teleport` : 0);
const SUSPENSE = Symbol( true ? `Suspense` : 0);
const KEEP_ALIVE = Symbol( true ? `KeepAlive` : 0);
const BASE_TRANSITION = Symbol(
   true ? `BaseTransition` : 0
);
const OPEN_BLOCK = Symbol( true ? `openBlock` : 0);
const CREATE_BLOCK = Symbol( true ? `createBlock` : 0);
const CREATE_ELEMENT_BLOCK = Symbol(
   true ? `createElementBlock` : 0
);
const CREATE_VNODE = Symbol( true ? `createVNode` : 0);
const CREATE_ELEMENT_VNODE = Symbol(
   true ? `createElementVNode` : 0
);
const CREATE_COMMENT = Symbol(
   true ? `createCommentVNode` : 0
);
const CREATE_TEXT = Symbol(
   true ? `createTextVNode` : 0
);
const CREATE_STATIC = Symbol(
   true ? `createStaticVNode` : 0
);
const RESOLVE_COMPONENT = Symbol(
   true ? `resolveComponent` : 0
);
const RESOLVE_DYNAMIC_COMPONENT = Symbol(
   true ? `resolveDynamicComponent` : 0
);
const RESOLVE_DIRECTIVE = Symbol(
   true ? `resolveDirective` : 0
);
const RESOLVE_FILTER = Symbol(
   true ? `resolveFilter` : 0
);
const WITH_DIRECTIVES = Symbol(
   true ? `withDirectives` : 0
);
const RENDER_LIST = Symbol( true ? `renderList` : 0);
const RENDER_SLOT = Symbol( true ? `renderSlot` : 0);
const CREATE_SLOTS = Symbol( true ? `createSlots` : 0);
const TO_DISPLAY_STRING = Symbol(
   true ? `toDisplayString` : 0
);
const MERGE_PROPS = Symbol( true ? `mergeProps` : 0);
const NORMALIZE_CLASS = Symbol(
   true ? `normalizeClass` : 0
);
const NORMALIZE_STYLE = Symbol(
   true ? `normalizeStyle` : 0
);
const NORMALIZE_PROPS = Symbol(
   true ? `normalizeProps` : 0
);
const GUARD_REACTIVE_PROPS = Symbol(
   true ? `guardReactiveProps` : 0
);
const TO_HANDLERS = Symbol( true ? `toHandlers` : 0);
const CAMELIZE = Symbol( true ? `camelize` : 0);
const CAPITALIZE = Symbol( true ? `capitalize` : 0);
const TO_HANDLER_KEY = Symbol(
   true ? `toHandlerKey` : 0
);
const SET_BLOCK_TRACKING = Symbol(
   true ? `setBlockTracking` : 0
);
const PUSH_SCOPE_ID = Symbol( true ? `pushScopeId` : 0);
const POP_SCOPE_ID = Symbol( true ? `popScopeId` : 0);
const WITH_CTX = Symbol( true ? `withCtx` : 0);
const UNREF = Symbol( true ? `unref` : 0);
const IS_REF = Symbol( true ? `isRef` : 0);
const WITH_MEMO = Symbol( true ? `withMemo` : 0);
const IS_MEMO_SAME = Symbol( true ? `isMemoSame` : 0);
const helperNameMap = {
  [FRAGMENT]: `Fragment`,
  [TELEPORT]: `Teleport`,
  [SUSPENSE]: `Suspense`,
  [KEEP_ALIVE]: `KeepAlive`,
  [BASE_TRANSITION]: `BaseTransition`,
  [OPEN_BLOCK]: `openBlock`,
  [CREATE_BLOCK]: `createBlock`,
  [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
  [CREATE_VNODE]: `createVNode`,
  [CREATE_ELEMENT_VNODE]: `createElementVNode`,
  [CREATE_COMMENT]: `createCommentVNode`,
  [CREATE_TEXT]: `createTextVNode`,
  [CREATE_STATIC]: `createStaticVNode`,
  [RESOLVE_COMPONENT]: `resolveComponent`,
  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
  [RESOLVE_DIRECTIVE]: `resolveDirective`,
  [RESOLVE_FILTER]: `resolveFilter`,
  [WITH_DIRECTIVES]: `withDirectives`,
  [RENDER_LIST]: `renderList`,
  [RENDER_SLOT]: `renderSlot`,
  [CREATE_SLOTS]: `createSlots`,
  [TO_DISPLAY_STRING]: `toDisplayString`,
  [MERGE_PROPS]: `mergeProps`,
  [NORMALIZE_CLASS]: `normalizeClass`,
  [NORMALIZE_STYLE]: `normalizeStyle`,
  [NORMALIZE_PROPS]: `normalizeProps`,
  [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
  [TO_HANDLERS]: `toHandlers`,
  [CAMELIZE]: `camelize`,
  [CAPITALIZE]: `capitalize`,
  [TO_HANDLER_KEY]: `toHandlerKey`,
  [SET_BLOCK_TRACKING]: `setBlockTracking`,
  [PUSH_SCOPE_ID]: `pushScopeId`,
  [POP_SCOPE_ID]: `popScopeId`,
  [WITH_CTX]: `withCtx`,
  [UNREF]: `unref`,
  [IS_REF]: `isRef`,
  [WITH_MEMO]: `withMemo`,
  [IS_MEMO_SAME]: `isMemoSame`
};
function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach((s) => {
    helperNameMap[s] = helpers[s];
  });
}

const Namespaces = {
  "HTML": 0,
  "0": "HTML",
  "SVG": 1,
  "1": "SVG",
  "MATH_ML": 2,
  "2": "MATH_ML"
};
const NodeTypes = {
  "ROOT": 0,
  "0": "ROOT",
  "ELEMENT": 1,
  "1": "ELEMENT",
  "TEXT": 2,
  "2": "TEXT",
  "COMMENT": 3,
  "3": "COMMENT",
  "SIMPLE_EXPRESSION": 4,
  "4": "SIMPLE_EXPRESSION",
  "INTERPOLATION": 5,
  "5": "INTERPOLATION",
  "ATTRIBUTE": 6,
  "6": "ATTRIBUTE",
  "DIRECTIVE": 7,
  "7": "DIRECTIVE",
  "COMPOUND_EXPRESSION": 8,
  "8": "COMPOUND_EXPRESSION",
  "IF": 9,
  "9": "IF",
  "IF_BRANCH": 10,
  "10": "IF_BRANCH",
  "FOR": 11,
  "11": "FOR",
  "TEXT_CALL": 12,
  "12": "TEXT_CALL",
  "VNODE_CALL": 13,
  "13": "VNODE_CALL",
  "JS_CALL_EXPRESSION": 14,
  "14": "JS_CALL_EXPRESSION",
  "JS_OBJECT_EXPRESSION": 15,
  "15": "JS_OBJECT_EXPRESSION",
  "JS_PROPERTY": 16,
  "16": "JS_PROPERTY",
  "JS_ARRAY_EXPRESSION": 17,
  "17": "JS_ARRAY_EXPRESSION",
  "JS_FUNCTION_EXPRESSION": 18,
  "18": "JS_FUNCTION_EXPRESSION",
  "JS_CONDITIONAL_EXPRESSION": 19,
  "19": "JS_CONDITIONAL_EXPRESSION",
  "JS_CACHE_EXPRESSION": 20,
  "20": "JS_CACHE_EXPRESSION",
  "JS_BLOCK_STATEMENT": 21,
  "21": "JS_BLOCK_STATEMENT",
  "JS_TEMPLATE_LITERAL": 22,
  "22": "JS_TEMPLATE_LITERAL",
  "JS_IF_STATEMENT": 23,
  "23": "JS_IF_STATEMENT",
  "JS_ASSIGNMENT_EXPRESSION": 24,
  "24": "JS_ASSIGNMENT_EXPRESSION",
  "JS_SEQUENCE_EXPRESSION": 25,
  "25": "JS_SEQUENCE_EXPRESSION",
  "JS_RETURN_STATEMENT": 26,
  "26": "JS_RETURN_STATEMENT"
};
const ElementTypes = {
  "ELEMENT": 0,
  "0": "ELEMENT",
  "COMPONENT": 1,
  "1": "COMPONENT",
  "SLOT": 2,
  "2": "SLOT",
  "TEMPLATE": 3,
  "3": "TEMPLATE"
};
const ConstantTypes = {
  "NOT_CONSTANT": 0,
  "0": "NOT_CONSTANT",
  "CAN_SKIP_PATCH": 1,
  "1": "CAN_SKIP_PATCH",
  "CAN_CACHE": 2,
  "2": "CAN_CACHE",
  "CAN_STRINGIFY": 3,
  "3": "CAN_STRINGIFY"
};
const locStub = {
  start: { line: 1, column: 1, offset: 0 },
  end: { line: 1, column: 1, offset: 0 },
  source: ""
};
function createRoot(children, source = "") {
  return {
    type: 0,
    source,
    children,
    helpers: /* @__PURE__ */ new Set(),
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: [],
    temps: 0,
    codegenNode: void 0,
    loc: locStub
  };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent = false, loc = locStub) {
  if (context) {
    if (isBlock) {
      context.helper(OPEN_BLOCK);
      context.helper(getVNodeBlockHelper(context.inSSR, isComponent));
    } else {
      context.helper(getVNodeHelper(context.inSSR, isComponent));
    }
    if (directives) {
      context.helper(WITH_DIRECTIVES);
    }
  }
  return {
    type: 13,
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent,
    loc
  };
}
function createArrayExpression(elements, loc = locStub) {
  return {
    type: 17,
    loc,
    elements
  };
}
function createObjectExpression(properties, loc = locStub) {
  return {
    type: 15,
    loc,
    properties
  };
}
function createObjectProperty(key, value) {
  return {
    type: 16,
    loc: locStub,
    key: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(key) ? createSimpleExpression(key, true) : key,
    value
  };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
  return {
    type: 4,
    loc,
    content,
    isStatic,
    constType: isStatic ? 3 : constType
  };
}
function createInterpolation(content, loc) {
  return {
    type: 5,
    loc,
    content: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(content) ? createSimpleExpression(content, false, loc) : content
  };
}
function createCompoundExpression(children, loc = locStub) {
  return {
    type: 8,
    loc,
    children
  };
}
function createCallExpression(callee, args = [], loc = locStub) {
  return {
    type: 14,
    loc,
    callee,
    arguments: args
  };
}
function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
  return {
    type: 18,
    params,
    returns,
    newline,
    isSlot,
    loc
  };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
  return {
    type: 19,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  };
}
function createCacheExpression(index, value, needPauseTracking = false, inVOnce = false) {
  return {
    type: 20,
    index,
    value,
    needPauseTracking,
    inVOnce,
    needArraySpread: false,
    loc: locStub
  };
}
function createBlockStatement(body) {
  return {
    type: 21,
    body,
    loc: locStub
  };
}
function createTemplateLiteral(elements) {
  return {
    type: 22,
    elements,
    loc: locStub
  };
}
function createIfStatement(test, consequent, alternate) {
  return {
    type: 23,
    test,
    consequent,
    alternate,
    loc: locStub
  };
}
function createAssignmentExpression(left, right) {
  return {
    type: 24,
    left,
    right,
    loc: locStub
  };
}
function createSequenceExpression(expressions) {
  return {
    type: 25,
    expressions,
    loc: locStub
  };
}
function createReturnStatement(returns) {
  return {
    type: 26,
    returns,
    loc: locStub
  };
}
function getVNodeHelper(ssr, isComponent) {
  return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent) {
  return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
function convertToBlock(node, { helper, removeHelper, inSSR }) {
  if (!node.isBlock) {
    node.isBlock = true;
    removeHelper(getVNodeHelper(inSSR, node.isComponent));
    helper(OPEN_BLOCK);
    helper(getVNodeBlockHelper(inSSR, node.isComponent));
  }
}

const defaultDelimitersOpen = new Uint8Array([123, 123]);
const defaultDelimitersClose = new Uint8Array([125, 125]);
function isTagStartChar(c) {
  return c >= 97 && c <= 122 || c >= 65 && c <= 90;
}
function isWhitespace(c) {
  return c === 32 || c === 10 || c === 9 || c === 12 || c === 13;
}
function isEndOfTagSection(c) {
  return c === 47 || c === 62 || isWhitespace(c);
}
function toCharCodes(str) {
  const ret = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    ret[i] = str.charCodeAt(i);
  }
  return ret;
}
const Sequences = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  // CDATA[
  CdataEnd: new Uint8Array([93, 93, 62]),
  // ]]>
  CommentEnd: new Uint8Array([45, 45, 62]),
  // `-->`
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  // `<\/script`
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  // `</style`
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
  // `</title`
  TextareaEnd: new Uint8Array([
    60,
    47,
    116,
    101,
    120,
    116,
    97,
    114,
    101,
    97
  ])
  // `</textarea
};
class Tokenizer {
  constructor(stack, cbs) {
    this.stack = stack;
    this.cbs = cbs;
    /** The current state the tokenizer is in. */
    this.state = 1;
    /** The read buffer. */
    this.buffer = "";
    /** The beginning of the section that is currently being read. */
    this.sectionStart = 0;
    /** The index within the buffer that we are currently looking at. */
    this.index = 0;
    /** The start of the last entity. */
    this.entityStart = 0;
    /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
    this.baseState = 1;
    /** For special parsing behavior inside of script and style tags. */
    this.inRCDATA = false;
    /** For disabling RCDATA tags handling */
    this.inXML = false;
    /** For disabling interpolation parsing in v-pre */
    this.inVPre = false;
    /** Record newline positions for fast line / column calculation */
    this.newlines = [];
    this.mode = 0;
    this.delimiterOpen = defaultDelimitersOpen;
    this.delimiterClose = defaultDelimitersClose;
    this.delimiterIndex = -1;
    this.currentSequence = void 0;
    this.sequenceIndex = 0;
  }
  get inSFCRoot() {
    return this.mode === 2 && this.stack.length === 0;
  }
  reset() {
    this.state = 1;
    this.mode = 0;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = 1;
    this.inRCDATA = false;
    this.currentSequence = void 0;
    this.newlines.length = 0;
    this.delimiterOpen = defaultDelimitersOpen;
    this.delimiterClose = defaultDelimitersClose;
  }
  /**
   * Generate Position object with line / column information using recorded
   * newline positions. We know the index is always going to be an already
   * processed index, so all the newlines up to this index should have been
   * recorded.
   */
  getPos(index) {
    let line = 1;
    let column = index + 1;
    for (let i = this.newlines.length - 1; i >= 0; i--) {
      const newlineIndex = this.newlines[i];
      if (index > newlineIndex) {
        line = i + 2;
        column = index - newlineIndex;
        break;
      }
    }
    return {
      column,
      line,
      offset: index
    };
  }
  peek() {
    return this.buffer.charCodeAt(this.index + 1);
  }
  stateText(c) {
    if (c === 60) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = 5;
      this.sectionStart = this.index;
    } else if (!this.inVPre && c === this.delimiterOpen[0]) {
      this.state = 2;
      this.delimiterIndex = 0;
      this.stateInterpolationOpen(c);
    }
  }
  stateInterpolationOpen(c) {
    if (c === this.delimiterOpen[this.delimiterIndex]) {
      if (this.delimiterIndex === this.delimiterOpen.length - 1) {
        const start = this.index + 1 - this.delimiterOpen.length;
        if (start > this.sectionStart) {
          this.cbs.ontext(this.sectionStart, start);
        }
        this.state = 3;
        this.sectionStart = start;
      } else {
        this.delimiterIndex++;
      }
    } else if (this.inRCDATA) {
      this.state = 32;
      this.stateInRCDATA(c);
    } else {
      this.state = 1;
      this.stateText(c);
    }
  }
  stateInterpolation(c) {
    if (c === this.delimiterClose[0]) {
      this.state = 4;
      this.delimiterIndex = 0;
      this.stateInterpolationClose(c);
    }
  }
  stateInterpolationClose(c) {
    if (c === this.delimiterClose[this.delimiterIndex]) {
      if (this.delimiterIndex === this.delimiterClose.length - 1) {
        this.cbs.oninterpolation(this.sectionStart, this.index + 1);
        if (this.inRCDATA) {
          this.state = 32;
        } else {
          this.state = 1;
        }
        this.sectionStart = this.index + 1;
      } else {
        this.delimiterIndex++;
      }
    } else {
      this.state = 3;
      this.stateInterpolation(c);
    }
  }
  stateSpecialStartSequence(c) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      isEndOfTagSection(c)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (c | 32) === this.currentSequence[this.sequenceIndex]
    );
    if (!isMatch) {
      this.inRCDATA = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = 6;
    this.stateInTagName(c);
  }
  /** Look for an end tag. For <title> and <textarea>, also decode entities. */
  stateInRCDATA(c) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c === 62 || isWhitespace(c)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c);
        this.inRCDATA = false;
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd || this.currentSequence === Sequences.TextareaEnd && !this.inSFCRoot) {
        if (!this.inVPre && c === this.delimiterOpen[0]) {
          this.state = 2;
          this.delimiterIndex = 0;
          this.stateInterpolationOpen(c);
        }
      } else if (this.fastForwardTo(60)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c === 60);
    }
  }
  stateCDATASequence(c) {
    if (c === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = 28;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = 23;
      this.stateInDeclaration(c);
    }
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(c) {
    while (++this.index < this.buffer.length) {
      const cc = this.buffer.charCodeAt(this.index);
      if (cc === 10) {
        this.newlines.push(this.index);
      }
      if (cc === c) {
        return true;
      }
    }
    this.index = this.buffer.length - 1;
    return false;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(c) {
    if (c === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index - 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index - 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = 1;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  startSpecial(sequence, offset) {
    this.enterRCDATA(sequence, offset);
    this.state = 31;
  }
  enterRCDATA(sequence, offset) {
    this.inRCDATA = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
  }
  stateBeforeTagName(c) {
    if (c === 33) {
      this.state = 22;
      this.sectionStart = this.index + 1;
    } else if (c === 63) {
      this.state = 24;
      this.sectionStart = this.index + 1;
    } else if (isTagStartChar(c)) {
      this.sectionStart = this.index;
      if (this.mode === 0) {
        this.state = 6;
      } else if (this.inSFCRoot) {
        this.state = 34;
      } else if (!this.inXML) {
        if (c === 116) {
          this.state = 30;
        } else {
          this.state = c === 115 ? 29 : 6;
        }
      } else {
        this.state = 6;
      }
    } else if (c === 47) {
      this.state = 8;
    } else {
      this.state = 1;
      this.stateText(c);
    }
  }
  stateInTagName(c) {
    if (isEndOfTagSection(c)) {
      this.handleTagName(c);
    }
  }
  stateInSFCRootTagName(c) {
    if (isEndOfTagSection(c)) {
      const tag = this.buffer.slice(this.sectionStart, this.index);
      if (tag !== "template") {
        this.enterRCDATA(toCharCodes(`</` + tag), 0);
      }
      this.handleTagName(c);
    }
  }
  handleTagName(c) {
    this.cbs.onopentagname(this.sectionStart, this.index);
    this.sectionStart = -1;
    this.state = 11;
    this.stateBeforeAttrName(c);
  }
  stateBeforeClosingTagName(c) {
    if (isWhitespace(c)) ; else if (c === 62) {
      if (true) {
        this.cbs.onerr(14, this.index);
      }
      this.state = 1;
      this.sectionStart = this.index + 1;
    } else {
      this.state = isTagStartChar(c) ? 9 : 27;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c) {
    if (c === 62 || isWhitespace(c)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = 10;
      this.stateAfterClosingTagName(c);
    }
  }
  stateAfterClosingTagName(c) {
    if (c === 62) {
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttrName(c) {
    if (c === 62) {
      this.cbs.onopentagend(this.index);
      if (this.inRCDATA) {
        this.state = 32;
      } else {
        this.state = 1;
      }
      this.sectionStart = this.index + 1;
    } else if (c === 47) {
      this.state = 7;
      if (( true) && this.peek() !== 62) {
        this.cbs.onerr(22, this.index);
      }
    } else if (c === 60 && this.peek() === 47) {
      this.cbs.onopentagend(this.index);
      this.state = 5;
      this.sectionStart = this.index;
    } else if (!isWhitespace(c)) {
      if (( true) && c === 61) {
        this.cbs.onerr(
          19,
          this.index
        );
      }
      this.handleAttrStart(c);
    }
  }
  handleAttrStart(c) {
    if (c === 118 && this.peek() === 45) {
      this.state = 13;
      this.sectionStart = this.index;
    } else if (c === 46 || c === 58 || c === 64 || c === 35) {
      this.cbs.ondirname(this.index, this.index + 1);
      this.state = 14;
      this.sectionStart = this.index + 1;
    } else {
      this.state = 12;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c) {
    if (c === 62) {
      this.cbs.onselfclosingtag(this.index);
      this.state = 1;
      this.sectionStart = this.index + 1;
      this.inRCDATA = false;
    } else if (!isWhitespace(c)) {
      this.state = 11;
      this.stateBeforeAttrName(c);
    }
  }
  stateInAttrName(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    } else if (( true) && (c === 34 || c === 39 || c === 60)) {
      this.cbs.onerr(
        17,
        this.index
      );
    }
  }
  stateInDirName(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirname(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    } else if (c === 58) {
      this.cbs.ondirname(this.sectionStart, this.index);
      this.state = 14;
      this.sectionStart = this.index + 1;
    } else if (c === 46) {
      this.cbs.ondirname(this.sectionStart, this.index);
      this.state = 16;
      this.sectionStart = this.index + 1;
    }
  }
  stateInDirArg(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirarg(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    } else if (c === 91) {
      this.state = 15;
    } else if (c === 46) {
      this.cbs.ondirarg(this.sectionStart, this.index);
      this.state = 16;
      this.sectionStart = this.index + 1;
    }
  }
  stateInDynamicDirArg(c) {
    if (c === 93) {
      this.state = 14;
    } else if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirarg(this.sectionStart, this.index + 1);
      this.handleAttrNameEnd(c);
      if (true) {
        this.cbs.onerr(
          27,
          this.index
        );
      }
    }
  }
  stateInDirModifier(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirmodifier(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    } else if (c === 46) {
      this.cbs.ondirmodifier(this.sectionStart, this.index);
      this.sectionStart = this.index + 1;
    }
  }
  handleAttrNameEnd(c) {
    this.sectionStart = this.index;
    this.state = 17;
    this.cbs.onattribnameend(this.index);
    this.stateAfterAttrName(c);
  }
  stateAfterAttrName(c) {
    if (c === 61) {
      this.state = 18;
    } else if (c === 47 || c === 62) {
      this.cbs.onattribend(0, this.sectionStart);
      this.sectionStart = -1;
      this.state = 11;
      this.stateBeforeAttrName(c);
    } else if (!isWhitespace(c)) {
      this.cbs.onattribend(0, this.sectionStart);
      this.handleAttrStart(c);
    }
  }
  stateBeforeAttrValue(c) {
    if (c === 34) {
      this.state = 19;
      this.sectionStart = this.index + 1;
    } else if (c === 39) {
      this.state = 20;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace(c)) {
      this.sectionStart = this.index;
      this.state = 21;
      this.stateInAttrValueNoQuotes(c);
    }
  }
  handleInAttrValue(c, quote) {
    if (c === quote || this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(
        quote === 34 ? 3 : 2,
        this.index + 1
      );
      this.state = 11;
    }
  }
  stateInAttrValueDoubleQuotes(c) {
    this.handleInAttrValue(c, 34);
  }
  stateInAttrValueSingleQuotes(c) {
    this.handleInAttrValue(c, 39);
  }
  stateInAttrValueNoQuotes(c) {
    if (isWhitespace(c) || c === 62) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(1, this.index);
      this.state = 11;
      this.stateBeforeAttrName(c);
    } else if (( true) && c === 34 || c === 39 || c === 60 || c === 61 || c === 96) {
      this.cbs.onerr(
        18,
        this.index
      );
    } else ;
  }
  stateBeforeDeclaration(c) {
    if (c === 91) {
      this.state = 26;
      this.sequenceIndex = 0;
    } else {
      this.state = c === 45 ? 25 : 23;
    }
  }
  stateInDeclaration(c) {
    if (c === 62 || this.fastForwardTo(62)) {
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c) {
    if (c === 62 || this.fastForwardTo(62)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c) {
    if (c === 45) {
      this.state = 28;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = 23;
    }
  }
  stateInSpecialComment(c) {
    if (c === 62 || this.fastForwardTo(62)) {
      this.cbs.oncomment(this.sectionStart, this.index);
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c) {
    if (c === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (c === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = 6;
      this.stateInTagName(c);
    }
  }
  stateBeforeSpecialT(c) {
    if (c === Sequences.TitleEnd[3]) {
      this.startSpecial(Sequences.TitleEnd, 4);
    } else if (c === Sequences.TextareaEnd[3]) {
      this.startSpecial(Sequences.TextareaEnd, 4);
    } else {
      this.state = 6;
      this.stateInTagName(c);
    }
  }
  startEntity() {
  }
  stateInEntity() {
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse(input) {
    this.buffer = input;
    while (this.index < this.buffer.length) {
      const c = this.buffer.charCodeAt(this.index);
      if (c === 10) {
        this.newlines.push(this.index);
      }
      switch (this.state) {
        case 1: {
          this.stateText(c);
          break;
        }
        case 2: {
          this.stateInterpolationOpen(c);
          break;
        }
        case 3: {
          this.stateInterpolation(c);
          break;
        }
        case 4: {
          this.stateInterpolationClose(c);
          break;
        }
        case 31: {
          this.stateSpecialStartSequence(c);
          break;
        }
        case 32: {
          this.stateInRCDATA(c);
          break;
        }
        case 26: {
          this.stateCDATASequence(c);
          break;
        }
        case 19: {
          this.stateInAttrValueDoubleQuotes(c);
          break;
        }
        case 12: {
          this.stateInAttrName(c);
          break;
        }
        case 13: {
          this.stateInDirName(c);
          break;
        }
        case 14: {
          this.stateInDirArg(c);
          break;
        }
        case 15: {
          this.stateInDynamicDirArg(c);
          break;
        }
        case 16: {
          this.stateInDirModifier(c);
          break;
        }
        case 28: {
          this.stateInCommentLike(c);
          break;
        }
        case 27: {
          this.stateInSpecialComment(c);
          break;
        }
        case 11: {
          this.stateBeforeAttrName(c);
          break;
        }
        case 6: {
          this.stateInTagName(c);
          break;
        }
        case 34: {
          this.stateInSFCRootTagName(c);
          break;
        }
        case 9: {
          this.stateInClosingTagName(c);
          break;
        }
        case 5: {
          this.stateBeforeTagName(c);
          break;
        }
        case 17: {
          this.stateAfterAttrName(c);
          break;
        }
        case 20: {
          this.stateInAttrValueSingleQuotes(c);
          break;
        }
        case 18: {
          this.stateBeforeAttrValue(c);
          break;
        }
        case 8: {
          this.stateBeforeClosingTagName(c);
          break;
        }
        case 10: {
          this.stateAfterClosingTagName(c);
          break;
        }
        case 29: {
          this.stateBeforeSpecialS(c);
          break;
        }
        case 30: {
          this.stateBeforeSpecialT(c);
          break;
        }
        case 21: {
          this.stateInAttrValueNoQuotes(c);
          break;
        }
        case 7: {
          this.stateInSelfClosingTag(c);
          break;
        }
        case 23: {
          this.stateInDeclaration(c);
          break;
        }
        case 22: {
          this.stateBeforeDeclaration(c);
          break;
        }
        case 25: {
          this.stateBeforeComment(c);
          break;
        }
        case 24: {
          this.stateInProcessingInstruction(c);
          break;
        }
        case 33: {
          this.stateInEntity();
          break;
        }
      }
      this.index++;
    }
    this.cleanup();
    this.finish();
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    if (this.sectionStart !== this.index) {
      if (this.state === 1 || this.state === 32 && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === 19 || this.state === 20 || this.state === 21) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  finish() {
    this.handleTrailingData();
    this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const endIndex = this.buffer.length;
    if (this.sectionStart >= endIndex) {
      return;
    }
    if (this.state === 28) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex);
      }
    } else if (this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9) ; else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitCodePoint(cp, consumed) {
  }
}

const CompilerDeprecationTypes = {
  "COMPILER_IS_ON_ELEMENT": "COMPILER_IS_ON_ELEMENT",
  "COMPILER_V_BIND_SYNC": "COMPILER_V_BIND_SYNC",
  "COMPILER_V_BIND_OBJECT_ORDER": "COMPILER_V_BIND_OBJECT_ORDER",
  "COMPILER_V_ON_NATIVE": "COMPILER_V_ON_NATIVE",
  "COMPILER_V_IF_V_FOR_PRECEDENCE": "COMPILER_V_IF_V_FOR_PRECEDENCE",
  "COMPILER_NATIVE_TEMPLATE": "COMPILER_NATIVE_TEMPLATE",
  "COMPILER_INLINE_TEMPLATE": "COMPILER_INLINE_TEMPLATE",
  "COMPILER_FILTERS": "COMPILER_FILTERS"
};
const deprecationData = {
  ["COMPILER_IS_ON_ELEMENT"]: {
    message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
    link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
  },
  ["COMPILER_V_BIND_SYNC"]: {
    message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
  },
  ["COMPILER_V_BIND_OBJECT_ORDER"]: {
    message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
  },
  ["COMPILER_V_ON_NATIVE"]: {
    message: `.native modifier for v-on has been removed as is no longer necessary.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
  },
  ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
    message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
  },
  ["COMPILER_NATIVE_TEMPLATE"]: {
    message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
  },
  ["COMPILER_INLINE_TEMPLATE"]: {
    message: `"inline-template" has been removed in Vue 3.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
  },
  ["COMPILER_FILTERS"]: {
    message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
  }
};
function getCompatValue(key, { compatConfig }) {
  const value = compatConfig && compatConfig[key];
  if (key === "MODE") {
    return value || 3;
  } else {
    return value;
  }
}
function isCompatEnabled(key, context) {
  const mode = getCompatValue("MODE", context);
  const value = getCompatValue(key, context);
  return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
  const enabled = isCompatEnabled(key, context);
  if ( true && enabled) {
    warnDeprecation(key, context, loc, ...args);
  }
  return enabled;
}
function warnDeprecation(key, context, loc, ...args) {
  const val = getCompatValue(key, context);
  if (val === "suppress-warning") {
    return;
  }
  const { message, link } = deprecationData[key];
  const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
  const err = new SyntaxError(msg);
  err.code = key;
  if (loc) err.loc = loc;
  context.onWarn(err);
}

function defaultOnError(error) {
  throw error;
}
function defaultOnWarn(msg) {
   true && console.warn(`[Vue warn] ${msg.message}`);
}
function createCompilerError(code, loc, messages, additionalMessage) {
  const msg =  true ? (messages || errorMessages)[code] + (additionalMessage || ``) : 0;
  const error = new SyntaxError(String(msg));
  error.code = code;
  error.loc = loc;
  return error;
}
const ErrorCodes = {
  "ABRUPT_CLOSING_OF_EMPTY_COMMENT": 0,
  "0": "ABRUPT_CLOSING_OF_EMPTY_COMMENT",
  "CDATA_IN_HTML_CONTENT": 1,
  "1": "CDATA_IN_HTML_CONTENT",
  "DUPLICATE_ATTRIBUTE": 2,
  "2": "DUPLICATE_ATTRIBUTE",
  "END_TAG_WITH_ATTRIBUTES": 3,
  "3": "END_TAG_WITH_ATTRIBUTES",
  "END_TAG_WITH_TRAILING_SOLIDUS": 4,
  "4": "END_TAG_WITH_TRAILING_SOLIDUS",
  "EOF_BEFORE_TAG_NAME": 5,
  "5": "EOF_BEFORE_TAG_NAME",
  "EOF_IN_CDATA": 6,
  "6": "EOF_IN_CDATA",
  "EOF_IN_COMMENT": 7,
  "7": "EOF_IN_COMMENT",
  "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT": 8,
  "8": "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT",
  "EOF_IN_TAG": 9,
  "9": "EOF_IN_TAG",
  "INCORRECTLY_CLOSED_COMMENT": 10,
  "10": "INCORRECTLY_CLOSED_COMMENT",
  "INCORRECTLY_OPENED_COMMENT": 11,
  "11": "INCORRECTLY_OPENED_COMMENT",
  "INVALID_FIRST_CHARACTER_OF_TAG_NAME": 12,
  "12": "INVALID_FIRST_CHARACTER_OF_TAG_NAME",
  "MISSING_ATTRIBUTE_VALUE": 13,
  "13": "MISSING_ATTRIBUTE_VALUE",
  "MISSING_END_TAG_NAME": 14,
  "14": "MISSING_END_TAG_NAME",
  "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES": 15,
  "15": "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES",
  "NESTED_COMMENT": 16,
  "16": "NESTED_COMMENT",
  "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME": 17,
  "17": "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME",
  "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE": 18,
  "18": "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE",
  "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME": 19,
  "19": "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME",
  "UNEXPECTED_NULL_CHARACTER": 20,
  "20": "UNEXPECTED_NULL_CHARACTER",
  "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME": 21,
  "21": "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME",
  "UNEXPECTED_SOLIDUS_IN_TAG": 22,
  "22": "UNEXPECTED_SOLIDUS_IN_TAG",
  "X_INVALID_END_TAG": 23,
  "23": "X_INVALID_END_TAG",
  "X_MISSING_END_TAG": 24,
  "24": "X_MISSING_END_TAG",
  "X_MISSING_INTERPOLATION_END": 25,
  "25": "X_MISSING_INTERPOLATION_END",
  "X_MISSING_DIRECTIVE_NAME": 26,
  "26": "X_MISSING_DIRECTIVE_NAME",
  "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END": 27,
  "27": "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END",
  "X_V_IF_NO_EXPRESSION": 28,
  "28": "X_V_IF_NO_EXPRESSION",
  "X_V_IF_SAME_KEY": 29,
  "29": "X_V_IF_SAME_KEY",
  "X_V_ELSE_NO_ADJACENT_IF": 30,
  "30": "X_V_ELSE_NO_ADJACENT_IF",
  "X_V_FOR_NO_EXPRESSION": 31,
  "31": "X_V_FOR_NO_EXPRESSION",
  "X_V_FOR_MALFORMED_EXPRESSION": 32,
  "32": "X_V_FOR_MALFORMED_EXPRESSION",
  "X_V_FOR_TEMPLATE_KEY_PLACEMENT": 33,
  "33": "X_V_FOR_TEMPLATE_KEY_PLACEMENT",
  "X_V_BIND_NO_EXPRESSION": 34,
  "34": "X_V_BIND_NO_EXPRESSION",
  "X_V_ON_NO_EXPRESSION": 35,
  "35": "X_V_ON_NO_EXPRESSION",
  "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET": 36,
  "36": "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET",
  "X_V_SLOT_MIXED_SLOT_USAGE": 37,
  "37": "X_V_SLOT_MIXED_SLOT_USAGE",
  "X_V_SLOT_DUPLICATE_SLOT_NAMES": 38,
  "38": "X_V_SLOT_DUPLICATE_SLOT_NAMES",
  "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN": 39,
  "39": "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN",
  "X_V_SLOT_MISPLACED": 40,
  "40": "X_V_SLOT_MISPLACED",
  "X_V_MODEL_NO_EXPRESSION": 41,
  "41": "X_V_MODEL_NO_EXPRESSION",
  "X_V_MODEL_MALFORMED_EXPRESSION": 42,
  "42": "X_V_MODEL_MALFORMED_EXPRESSION",
  "X_V_MODEL_ON_SCOPE_VARIABLE": 43,
  "43": "X_V_MODEL_ON_SCOPE_VARIABLE",
  "X_V_MODEL_ON_PROPS": 44,
  "44": "X_V_MODEL_ON_PROPS",
  "X_INVALID_EXPRESSION": 45,
  "45": "X_INVALID_EXPRESSION",
  "X_KEEP_ALIVE_INVALID_CHILDREN": 46,
  "46": "X_KEEP_ALIVE_INVALID_CHILDREN",
  "X_PREFIX_ID_NOT_SUPPORTED": 47,
  "47": "X_PREFIX_ID_NOT_SUPPORTED",
  "X_MODULE_MODE_NOT_SUPPORTED": 48,
  "48": "X_MODULE_MODE_NOT_SUPPORTED",
  "X_CACHE_HANDLER_NOT_SUPPORTED": 49,
  "49": "X_CACHE_HANDLER_NOT_SUPPORTED",
  "X_SCOPE_ID_NOT_SUPPORTED": 50,
  "50": "X_SCOPE_ID_NOT_SUPPORTED",
  "X_VNODE_HOOKS": 51,
  "51": "X_VNODE_HOOKS",
  "X_V_BIND_INVALID_SAME_NAME_ARGUMENT": 52,
  "52": "X_V_BIND_INVALID_SAME_NAME_ARGUMENT",
  "__EXTEND_POINT__": 53,
  "53": "__EXTEND_POINT__"
};
const errorMessages = {
  // parse errors
  [0]: "Illegal comment.",
  [1]: "CDATA section is allowed only in XML context.",
  [2]: "Duplicate attribute.",
  [3]: "End tag cannot have attributes.",
  [4]: "Illegal '/' in tags.",
  [5]: "Unexpected EOF in tag.",
  [6]: "Unexpected EOF in CDATA section.",
  [7]: "Unexpected EOF in comment.",
  [8]: "Unexpected EOF in script.",
  [9]: "Unexpected EOF in tag.",
  [10]: "Incorrectly closed comment.",
  [11]: "Incorrectly opened comment.",
  [12]: "Illegal tag name. Use '&lt;' to print '<'.",
  [13]: "Attribute value was expected.",
  [14]: "End tag name was expected.",
  [15]: "Whitespace was expected.",
  [16]: "Unexpected '<!--' in comment.",
  [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
  [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
  [19]: "Attribute name cannot start with '='.",
  [21]: "'<?' is allowed only in XML context.",
  [20]: `Unexpected null character.`,
  [22]: "Illegal '/' in tags.",
  // Vue-specific parse errors
  [23]: "Invalid end tag.",
  [24]: "Element is missing end tag.",
  [25]: "Interpolation end sign was not found.",
  [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
  [26]: "Legal directive name was expected.",
  // transform errors
  [28]: `v-if/v-else-if is missing expression.`,
  [29]: `v-if/else branches must use unique keys.`,
  [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
  [31]: `v-for is missing expression.`,
  [32]: `v-for has invalid expression.`,
  [33]: `<template v-for> key should be placed on the <template> tag.`,
  [34]: `v-bind is missing expression.`,
  [52]: `v-bind with same-name shorthand only allows static argument.`,
  [35]: `v-on is missing expression.`,
  [36]: `Unexpected custom directive on <slot> outlet.`,
  [37]: `Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
  [38]: `Duplicate slot names found. `,
  [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
  [40]: `v-slot can only be used on components or <template> tags.`,
  [41]: `v-model is missing expression.`,
  [42]: `v-model value must be a valid JavaScript member expression.`,
  [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
  [44]: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
  [45]: `Error parsing JavaScript expression: `,
  [46]: `<KeepAlive> expects exactly one child component.`,
  [51]: `@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.`,
  // generic errors
  [47]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
  [48]: `ES module mode is not supported in this build of compiler.`,
  [49]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
  [50]: `"scopeId" option is only supported in module mode.`,
  // just to fulfill types
  [53]: ``
};

function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = /* @__PURE__ */ Object.create(null)) {
  {
    return;
  }
}
function isReferencedIdentifier(id, parent, parentStack) {
  {
    return false;
  }
}
function isInDestructureAssignment(parent, parentStack) {
  if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
    let i = parentStack.length;
    while (i--) {
      const p = parentStack[i];
      if (p.type === "AssignmentExpression") {
        return true;
      } else if (p.type !== "ObjectProperty" && !p.type.endsWith("Pattern")) {
        break;
      }
    }
  }
  return false;
}
function isInNewExpression(parentStack) {
  let i = parentStack.length;
  while (i--) {
    const p = parentStack[i];
    if (p.type === "NewExpression") {
      return true;
    } else if (p.type !== "MemberExpression") {
      break;
    }
  }
  return false;
}
function walkFunctionParams(node, onIdent) {
  for (const p of node.params) {
    for (const id of extractIdentifiers(p)) {
      onIdent(id);
    }
  }
}
function walkBlockDeclarations(block, onIdent) {
  for (const stmt of block.body) {
    if (stmt.type === "VariableDeclaration") {
      if (stmt.declare) continue;
      for (const decl of stmt.declarations) {
        for (const id of extractIdentifiers(decl.id)) {
          onIdent(id);
        }
      }
    } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
      if (stmt.declare || !stmt.id) continue;
      onIdent(stmt.id);
    } else if (isForStatement(stmt)) {
      walkForStatement(stmt, true, onIdent);
    }
  }
}
function isForStatement(stmt) {
  return stmt.type === "ForOfStatement" || stmt.type === "ForInStatement" || stmt.type === "ForStatement";
}
function walkForStatement(stmt, isVar, onIdent) {
  const variable = stmt.type === "ForStatement" ? stmt.init : stmt.left;
  if (variable && variable.type === "VariableDeclaration" && (variable.kind === "var" ? isVar : !isVar)) {
    for (const decl of variable.declarations) {
      for (const id of extractIdentifiers(decl.id)) {
        onIdent(id);
      }
    }
  }
}
function extractIdentifiers(param, nodes = []) {
  switch (param.type) {
    case "Identifier":
      nodes.push(param);
      break;
    case "MemberExpression":
      let object = param;
      while (object.type === "MemberExpression") {
        object = object.object;
      }
      nodes.push(object);
      break;
    case "ObjectPattern":
      for (const prop of param.properties) {
        if (prop.type === "RestElement") {
          extractIdentifiers(prop.argument, nodes);
        } else {
          extractIdentifiers(prop.value, nodes);
        }
      }
      break;
    case "ArrayPattern":
      param.elements.forEach((element) => {
        if (element) extractIdentifiers(element, nodes);
      });
      break;
    case "RestElement":
      extractIdentifiers(param.argument, nodes);
      break;
    case "AssignmentPattern":
      extractIdentifiers(param.left, nodes);
      break;
  }
  return nodes;
}
const isFunctionType = (node) => {
  return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
};
const isStaticProperty = (node) => node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
const isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
const TS_NODE_TYPES = [
  "TSAsExpression",
  // foo as number
  "TSTypeAssertion",
  // (<number>foo)
  "TSNonNullExpression",
  // foo!
  "TSInstantiationExpression",
  // foo<string>
  "TSSatisfiesExpression"
  // foo satisfies T
];
function unwrapTSNode(node) {
  if (TS_NODE_TYPES.includes(node.type)) {
    return unwrapTSNode(node.expression);
  } else {
    return node;
  }
}

const isStaticExp = (p) => p.type === 4 && p.isStatic;
function isCoreComponent(tag) {
  switch (tag) {
    case "Teleport":
    case "teleport":
      return TELEPORT;
    case "Suspense":
    case "suspense":
      return SUSPENSE;
    case "KeepAlive":
    case "keep-alive":
      return KEEP_ALIVE;
    case "BaseTransition":
    case "base-transition":
      return BASE_TRANSITION;
  }
}
const nonIdentifierRE = /^\d|[^\$\w\xA0-\uFFFF]/;
const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
const getExpSource = (exp) => exp.type === 4 ? exp.content : exp.loc.source;
const isMemberExpressionBrowser = (exp) => {
  const path = getExpSource(exp).trim().replace(whitespaceRE, (s) => s.trim());
  let state = 0 /* inMemberExp */;
  let stateStack = [];
  let currentOpenBracketCount = 0;
  let currentOpenParensCount = 0;
  let currentStringType = null;
  for (let i = 0; i < path.length; i++) {
    const char = path.charAt(i);
    switch (state) {
      case 0 /* inMemberExp */:
        if (char === "[") {
          stateStack.push(state);
          state = 1 /* inBrackets */;
          currentOpenBracketCount++;
        } else if (char === "(") {
          stateStack.push(state);
          state = 2 /* inParens */;
          currentOpenParensCount++;
        } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
          return false;
        }
        break;
      case 1 /* inBrackets */:
        if (char === `'` || char === `"` || char === "`") {
          stateStack.push(state);
          state = 3 /* inString */;
          currentStringType = char;
        } else if (char === `[`) {
          currentOpenBracketCount++;
        } else if (char === `]`) {
          if (!--currentOpenBracketCount) {
            state = stateStack.pop();
          }
        }
        break;
      case 2 /* inParens */:
        if (char === `'` || char === `"` || char === "`") {
          stateStack.push(state);
          state = 3 /* inString */;
          currentStringType = char;
        } else if (char === `(`) {
          currentOpenParensCount++;
        } else if (char === `)`) {
          if (i === path.length - 1) {
            return false;
          }
          if (!--currentOpenParensCount) {
            state = stateStack.pop();
          }
        }
        break;
      case 3 /* inString */:
        if (char === currentStringType) {
          state = stateStack.pop();
          currentStringType = null;
        }
        break;
    }
  }
  return !currentOpenBracketCount && !currentOpenParensCount;
};
const isMemberExpressionNode = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP ;
const isMemberExpression = isMemberExpressionBrowser ;
const fnExpRE = /^\s*(async\s*)?(\([^)]*?\)|[\w$_]+)\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
const isFnExpressionBrowser = (exp) => fnExpRE.test(getExpSource(exp));
const isFnExpressionNode = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP ;
const isFnExpression = isFnExpressionBrowser ;
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
  return advancePositionWithMutation(
    {
      offset: pos.offset,
      line: pos.line,
      column: pos.column
    },
    source,
    numberOfCharacters
  );
}
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
  let linesCount = 0;
  let lastNewLinePos = -1;
  for (let i = 0; i < numberOfCharacters; i++) {
    if (source.charCodeAt(i) === 10) {
      linesCount++;
      lastNewLinePos = i;
    }
  }
  pos.offset += numberOfCharacters;
  pos.line += linesCount;
  pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
  return pos;
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg || `unexpected compiler condition`);
  }
}
function findDir(node, name, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 7 && (allowEmpty || p.exp) && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(name) ? p.name === name : name.test(p.name))) {
      return p;
    }
  }
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (dynamicOnly) continue;
      if (p.name === name && (p.value || allowEmpty)) {
        return p;
      }
    } else if (p.name === "bind" && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) {
      return p;
    }
  }
}
function isStaticArgOf(arg, name) {
  return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
  return node.props.some(
    (p) => p.type === 7 && p.name === "bind" && (!p.arg || // v-bind="obj"
    p.arg.type !== 4 || // v-bind:[_ctx.foo]
    !p.arg.isStatic)
    // v-bind:[foo]
  );
}
function isText$1(node) {
  return node.type === 5 || node.type === 2;
}
function isVSlot(p) {
  return p.type === 7 && p.name === "slot";
}
function isTemplateNode(node) {
  return node.type === 1 && node.tagType === 3;
}
function isSlotOutlet(node) {
  return node.type === 1 && node.tagType === 2;
}
const propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
function getUnnormalizedProps(props, callPath = []) {
  if (props && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props) && props.type === 14) {
    const callee = props.callee;
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(callee) && propsHelperSet.has(callee)) {
      return getUnnormalizedProps(
        props.arguments[0],
        callPath.concat(props)
      );
    }
  }
  return [props, callPath];
}
function injectProp(node, prop, context) {
  let propsWithInjection;
  let props = node.type === 13 ? node.props : node.arguments[2];
  let callPath = [];
  let parentCall;
  if (props && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props) && props.type === 14) {
    const ret = getUnnormalizedProps(props);
    props = ret[0];
    callPath = ret[1];
    parentCall = callPath[callPath.length - 1];
  }
  if (props == null || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props)) {
    propsWithInjection = createObjectExpression([prop]);
  } else if (props.type === 14) {
    const first = props.arguments[0];
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(first) && first.type === 15) {
      if (!hasProp(prop, first)) {
        first.properties.unshift(prop);
      }
    } else {
      if (props.callee === TO_HANDLERS) {
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ]);
      } else {
        props.arguments.unshift(createObjectExpression([prop]));
      }
    }
    !propsWithInjection && (propsWithInjection = props);
  } else if (props.type === 15) {
    if (!hasProp(prop, props)) {
      props.properties.unshift(prop);
    }
    propsWithInjection = props;
  } else {
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
      createObjectExpression([prop]),
      props
    ]);
    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - 2];
    }
  }
  if (node.type === 13) {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.props = propsWithInjection;
    }
  } else {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.arguments[2] = propsWithInjection;
    }
  }
}
function hasProp(prop, props) {
  let result = false;
  if (prop.key.type === 4) {
    const propKeyName = prop.key.content;
    result = props.properties.some(
      (p) => p.key.type === 4 && p.key.content === propKeyName
    );
  }
  return result;
}
function toValidAssetId(name, type) {
  return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
    return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
  })}`;
}
function hasScopeRef(node, ids) {
  if (!node || Object.keys(ids).length === 0) {
    return false;
  }
  switch (node.type) {
    case 1:
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 7 && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
          return true;
        }
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 11:
      if (hasScopeRef(node.source, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 9:
      return node.branches.some((b) => hasScopeRef(b, ids));
    case 10:
      if (hasScopeRef(node.condition, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 4:
      return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];
    case 8:
      return node.children.some((c) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(c) && hasScopeRef(c, ids));
    case 5:
    case 12:
      return hasScopeRef(node.content, ids);
    case 2:
    case 3:
    case 20:
      return false;
    default:
      if (true) ;
      return false;
  }
}
function getMemoedVNodeCall(node) {
  if (node.type === 14 && node.callee === WITH_MEMO) {
    return node.arguments[1].returns;
  } else {
    return node;
  }
}
const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/;

const defaultParserOptions = {
  parseMode: "base",
  ns: 0,
  delimiters: [`{{`, `}}`],
  getNamespace: () => 0,
  isVoidTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
  isPreTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
  isIgnoreNewlineTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
  isCustomElement: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
  onError: defaultOnError,
  onWarn: defaultOnWarn,
  comments: !!("development" !== "production"),
  prefixIdentifiers: false
};
let currentOptions = defaultParserOptions;
let currentRoot = null;
let currentInput = "";
let currentOpenTag = null;
let currentProp = null;
let currentAttrValue = "";
let currentAttrStartIndex = -1;
let currentAttrEndIndex = -1;
let inPre = 0;
let inVPre = false;
let currentVPreBoundary = null;
const stack = [];
const tokenizer = new Tokenizer(stack, {
  onerr: emitError,
  ontext(start, end) {
    onText(getSlice(start, end), start, end);
  },
  ontextentity(char, start, end) {
    onText(char, start, end);
  },
  oninterpolation(start, end) {
    if (inVPre) {
      return onText(getSlice(start, end), start, end);
    }
    let innerStart = start + tokenizer.delimiterOpen.length;
    let innerEnd = end - tokenizer.delimiterClose.length;
    while (isWhitespace(currentInput.charCodeAt(innerStart))) {
      innerStart++;
    }
    while (isWhitespace(currentInput.charCodeAt(innerEnd - 1))) {
      innerEnd--;
    }
    let exp = getSlice(innerStart, innerEnd);
    if (exp.includes("&")) {
      {
        exp = currentOptions.decodeEntities(exp, false);
      }
    }
    addNode({
      type: 5,
      content: createExp(exp, false, getLoc(innerStart, innerEnd)),
      loc: getLoc(start, end)
    });
  },
  onopentagname(start, end) {
    const name = getSlice(start, end);
    currentOpenTag = {
      type: 1,
      tag: name,
      ns: currentOptions.getNamespace(name, stack[0], currentOptions.ns),
      tagType: 0,
      // will be refined on tag close
      props: [],
      children: [],
      loc: getLoc(start - 1, end),
      codegenNode: void 0
    };
  },
  onopentagend(end) {
    endOpenTag(end);
  },
  onclosetag(start, end) {
    const name = getSlice(start, end);
    if (!currentOptions.isVoidTag(name)) {
      let found = false;
      for (let i = 0; i < stack.length; i++) {
        const e = stack[i];
        if (e.tag.toLowerCase() === name.toLowerCase()) {
          found = true;
          if (i > 0) {
            emitError(24, stack[0].loc.start.offset);
          }
          for (let j = 0; j <= i; j++) {
            const el = stack.shift();
            onCloseTag(el, end, j < i);
          }
          break;
        }
      }
      if (!found) {
        emitError(23, backTrack(start, 60));
      }
    }
  },
  onselfclosingtag(end) {
    const name = currentOpenTag.tag;
    currentOpenTag.isSelfClosing = true;
    endOpenTag(end);
    if (stack[0] && stack[0].tag === name) {
      onCloseTag(stack.shift(), end);
    }
  },
  onattribname(start, end) {
    currentProp = {
      type: 6,
      name: getSlice(start, end),
      nameLoc: getLoc(start, end),
      value: void 0,
      loc: getLoc(start)
    };
  },
  ondirname(start, end) {
    const raw = getSlice(start, end);
    const name = raw === "." || raw === ":" ? "bind" : raw === "@" ? "on" : raw === "#" ? "slot" : raw.slice(2);
    if (!inVPre && name === "") {
      emitError(26, start);
    }
    if (inVPre || name === "") {
      currentProp = {
        type: 6,
        name: raw,
        nameLoc: getLoc(start, end),
        value: void 0,
        loc: getLoc(start)
      };
    } else {
      currentProp = {
        type: 7,
        name,
        rawName: raw,
        exp: void 0,
        arg: void 0,
        modifiers: raw === "." ? [createSimpleExpression("prop")] : [],
        loc: getLoc(start)
      };
      if (name === "pre") {
        inVPre = tokenizer.inVPre = true;
        currentVPreBoundary = currentOpenTag;
        const props = currentOpenTag.props;
        for (let i = 0; i < props.length; i++) {
          if (props[i].type === 7) {
            props[i] = dirToAttr(props[i]);
          }
        }
      }
    }
  },
  ondirarg(start, end) {
    if (start === end) return;
    const arg = getSlice(start, end);
    if (inVPre) {
      currentProp.name += arg;
      setLocEnd(currentProp.nameLoc, end);
    } else {
      const isStatic = arg[0] !== `[`;
      currentProp.arg = createExp(
        isStatic ? arg : arg.slice(1, -1),
        isStatic,
        getLoc(start, end),
        isStatic ? 3 : 0
      );
    }
  },
  ondirmodifier(start, end) {
    const mod = getSlice(start, end);
    if (inVPre) {
      currentProp.name += "." + mod;
      setLocEnd(currentProp.nameLoc, end);
    } else if (currentProp.name === "slot") {
      const arg = currentProp.arg;
      if (arg) {
        arg.content += "." + mod;
        setLocEnd(arg.loc, end);
      }
    } else {
      const exp = createSimpleExpression(mod, true, getLoc(start, end));
      currentProp.modifiers.push(exp);
    }
  },
  onattribdata(start, end) {
    currentAttrValue += getSlice(start, end);
    if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
    currentAttrEndIndex = end;
  },
  onattribentity(char, start, end) {
    currentAttrValue += char;
    if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
    currentAttrEndIndex = end;
  },
  onattribnameend(end) {
    const start = currentProp.loc.start.offset;
    const name = getSlice(start, end);
    if (currentProp.type === 7) {
      currentProp.rawName = name;
    }
    if (currentOpenTag.props.some(
      (p) => (p.type === 7 ? p.rawName : p.name) === name
    )) {
      emitError(2, start);
    }
  },
  onattribend(quote, end) {
    if (currentOpenTag && currentProp) {
      setLocEnd(currentProp.loc, end);
      if (quote !== 0) {
        if (currentAttrValue.includes("&")) {
          currentAttrValue = currentOptions.decodeEntities(
            currentAttrValue,
            true
          );
        }
        if (currentProp.type === 6) {
          if (currentProp.name === "class") {
            currentAttrValue = condense(currentAttrValue).trim();
          }
          if (quote === 1 && !currentAttrValue) {
            emitError(13, end);
          }
          currentProp.value = {
            type: 2,
            content: currentAttrValue,
            loc: quote === 1 ? getLoc(currentAttrStartIndex, currentAttrEndIndex) : getLoc(currentAttrStartIndex - 1, currentAttrEndIndex + 1)
          };
          if (tokenizer.inSFCRoot && currentOpenTag.tag === "template" && currentProp.name === "lang" && currentAttrValue && currentAttrValue !== "html") {
            tokenizer.enterRCDATA(toCharCodes(`</template`), 0);
          }
        } else {
          let expParseMode = 0 /* Normal */;
          currentProp.exp = createExp(
            currentAttrValue,
            false,
            getLoc(currentAttrStartIndex, currentAttrEndIndex),
            0,
            expParseMode
          );
          if (currentProp.name === "for") {
            currentProp.forParseResult = parseForExpression(currentProp.exp);
          }
          let syncIndex = -1;
          if (currentProp.name === "bind" && (syncIndex = currentProp.modifiers.findIndex(
            (mod) => mod.content === "sync"
          )) > -1 && checkCompatEnabled(
            "COMPILER_V_BIND_SYNC",
            currentOptions,
            currentProp.loc,
            currentProp.rawName
          )) {
            currentProp.name = "model";
            currentProp.modifiers.splice(syncIndex, 1);
          }
        }
      }
      if (currentProp.type !== 7 || currentProp.name !== "pre") {
        currentOpenTag.props.push(currentProp);
      }
    }
    currentAttrValue = "";
    currentAttrStartIndex = currentAttrEndIndex = -1;
  },
  oncomment(start, end) {
    if (currentOptions.comments) {
      addNode({
        type: 3,
        content: getSlice(start, end),
        loc: getLoc(start - 4, end + 3)
      });
    }
  },
  onend() {
    const end = currentInput.length;
    if (( true) && tokenizer.state !== 1) {
      switch (tokenizer.state) {
        case 5:
        case 8:
          emitError(5, end);
          break;
        case 3:
        case 4:
          emitError(
            25,
            tokenizer.sectionStart
          );
          break;
        case 28:
          if (tokenizer.currentSequence === Sequences.CdataEnd) {
            emitError(6, end);
          } else {
            emitError(7, end);
          }
          break;
        case 6:
        case 7:
        case 9:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        // "
        case 20:
        // '
        case 21:
          emitError(9, end);
          break;
      }
    }
    for (let index = 0; index < stack.length; index++) {
      onCloseTag(stack[index], end - 1);
      emitError(24, stack[index].loc.start.offset);
    }
  },
  oncdata(start, end) {
    if (stack[0].ns !== 0) {
      onText(getSlice(start, end), start, end);
    } else {
      emitError(1, start - 9);
    }
  },
  onprocessinginstruction(start) {
    if ((stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
      emitError(
        21,
        start - 1
      );
    }
  }
});
const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
const stripParensRE = /^\(|\)$/g;
function parseForExpression(input) {
  const loc = input.loc;
  const exp = input.content;
  const inMatch = exp.match(forAliasRE);
  if (!inMatch) return;
  const [, LHS, RHS] = inMatch;
  const createAliasExpression = (content, offset, asParam = false) => {
    const start = loc.start.offset + offset;
    const end = start + content.length;
    return createExp(
      content,
      false,
      getLoc(start, end),
      0,
      asParam ? 1 /* Params */ : 0 /* Normal */
    );
  };
  const result = {
    source: createAliasExpression(RHS.trim(), exp.indexOf(RHS, LHS.length)),
    value: void 0,
    key: void 0,
    index: void 0,
    finalized: false
  };
  let valueContent = LHS.trim().replace(stripParensRE, "").trim();
  const trimmedOffset = LHS.indexOf(valueContent);
  const iteratorMatch = valueContent.match(forIteratorRE);
  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, "").trim();
    const keyContent = iteratorMatch[1].trim();
    let keyOffset;
    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result.key = createAliasExpression(keyContent, keyOffset, true);
    }
    if (iteratorMatch[2]) {
      const indexContent = iteratorMatch[2].trim();
      if (indexContent) {
        result.index = createAliasExpression(
          indexContent,
          exp.indexOf(
            indexContent,
            result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length
          ),
          true
        );
      }
    }
  }
  if (valueContent) {
    result.value = createAliasExpression(valueContent, trimmedOffset, true);
  }
  return result;
}
function getSlice(start, end) {
  return currentInput.slice(start, end);
}
function endOpenTag(end) {
  if (tokenizer.inSFCRoot) {
    currentOpenTag.innerLoc = getLoc(end + 1, end + 1);
  }
  addNode(currentOpenTag);
  const { tag, ns } = currentOpenTag;
  if (ns === 0 && currentOptions.isPreTag(tag)) {
    inPre++;
  }
  if (currentOptions.isVoidTag(tag)) {
    onCloseTag(currentOpenTag, end);
  } else {
    stack.unshift(currentOpenTag);
    if (ns === 1 || ns === 2) {
      tokenizer.inXML = true;
    }
  }
  currentOpenTag = null;
}
function onText(content, start, end) {
  {
    const tag = stack[0] && stack[0].tag;
    if (tag !== "script" && tag !== "style" && content.includes("&")) {
      content = currentOptions.decodeEntities(content, false);
    }
  }
  const parent = stack[0] || currentRoot;
  const lastNode = parent.children[parent.children.length - 1];
  if (lastNode && lastNode.type === 2) {
    lastNode.content += content;
    setLocEnd(lastNode.loc, end);
  } else {
    parent.children.push({
      type: 2,
      content,
      loc: getLoc(start, end)
    });
  }
}
function onCloseTag(el, end, isImplied = false) {
  if (isImplied) {
    setLocEnd(el.loc, backTrack(end, 60));
  } else {
    setLocEnd(el.loc, lookAhead(end, 62) + 1);
  }
  if (tokenizer.inSFCRoot) {
    if (el.children.length) {
      el.innerLoc.end = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, el.children[el.children.length - 1].loc.end);
    } else {
      el.innerLoc.end = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, el.innerLoc.start);
    }
    el.innerLoc.source = getSlice(
      el.innerLoc.start.offset,
      el.innerLoc.end.offset
    );
  }
  const { tag, ns, children } = el;
  if (!inVPre) {
    if (tag === "slot") {
      el.tagType = 2;
    } else if (isFragmentTemplate(el)) {
      el.tagType = 3;
    } else if (isComponent(el)) {
      el.tagType = 1;
    }
  }
  if (!tokenizer.inRCDATA) {
    el.children = condenseWhitespace(children);
  }
  if (ns === 0 && currentOptions.isIgnoreNewlineTag(tag)) {
    const first = children[0];
    if (first && first.type === 2) {
      first.content = first.content.replace(/^\r?\n/, "");
    }
  }
  if (ns === 0 && currentOptions.isPreTag(tag)) {
    inPre--;
  }
  if (currentVPreBoundary === el) {
    inVPre = tokenizer.inVPre = false;
    currentVPreBoundary = null;
  }
  if (tokenizer.inXML && (stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
    tokenizer.inXML = false;
  }
  {
    const props = el.props;
    if ( true && isCompatEnabled(
      "COMPILER_V_IF_V_FOR_PRECEDENCE",
      currentOptions
    )) {
      let hasIf = false;
      let hasFor = false;
      for (let i = 0; i < props.length; i++) {
        const p = props[i];
        if (p.type === 7) {
          if (p.name === "if") {
            hasIf = true;
          } else if (p.name === "for") {
            hasFor = true;
          }
        }
        if (hasIf && hasFor) {
          warnDeprecation(
            "COMPILER_V_IF_V_FOR_PRECEDENCE",
            currentOptions,
            el.loc
          );
          break;
        }
      }
    }
    if (!tokenizer.inSFCRoot && isCompatEnabled(
      "COMPILER_NATIVE_TEMPLATE",
      currentOptions
    ) && el.tag === "template" && !isFragmentTemplate(el)) {
       true && warnDeprecation(
        "COMPILER_NATIVE_TEMPLATE",
        currentOptions,
        el.loc
      );
      const parent = stack[0] || currentRoot;
      const index = parent.children.indexOf(el);
      parent.children.splice(index, 1, ...el.children);
    }
    const inlineTemplateProp = props.find(
      (p) => p.type === 6 && p.name === "inline-template"
    );
    if (inlineTemplateProp && checkCompatEnabled(
      "COMPILER_INLINE_TEMPLATE",
      currentOptions,
      inlineTemplateProp.loc
    ) && el.children.length) {
      inlineTemplateProp.value = {
        type: 2,
        content: getSlice(
          el.children[0].loc.start.offset,
          el.children[el.children.length - 1].loc.end.offset
        ),
        loc: inlineTemplateProp.loc
      };
    }
  }
}
function lookAhead(index, c) {
  let i = index;
  while (currentInput.charCodeAt(i) !== c && i < currentInput.length - 1) i++;
  return i;
}
function backTrack(index, c) {
  let i = index;
  while (currentInput.charCodeAt(i) !== c && i >= 0) i--;
  return i;
}
const specialTemplateDir = /* @__PURE__ */ new Set(["if", "else", "else-if", "for", "slot"]);
function isFragmentTemplate({ tag, props }) {
  if (tag === "template") {
    for (let i = 0; i < props.length; i++) {
      if (props[i].type === 7 && specialTemplateDir.has(props[i].name)) {
        return true;
      }
    }
  }
  return false;
}
function isComponent({ tag, props }) {
  if (currentOptions.isCustomElement(tag)) {
    return false;
  }
  if (tag === "component" || isUpperCase(tag.charCodeAt(0)) || isCoreComponent(tag) || currentOptions.isBuiltInComponent && currentOptions.isBuiltInComponent(tag) || currentOptions.isNativeTag && !currentOptions.isNativeTag(tag)) {
    return true;
  }
  for (let i = 0; i < props.length; i++) {
    const p = props[i];
    if (p.type === 6) {
      if (p.name === "is" && p.value) {
        if (p.value.content.startsWith("vue:")) {
          return true;
        } else if (checkCompatEnabled(
          "COMPILER_IS_ON_ELEMENT",
          currentOptions,
          p.loc
        )) {
          return true;
        }
      }
    } else if (// :is on plain element - only treat as component in compat mode
    p.name === "bind" && isStaticArgOf(p.arg, "is") && checkCompatEnabled(
      "COMPILER_IS_ON_ELEMENT",
      currentOptions,
      p.loc
    )) {
      return true;
    }
  }
  return false;
}
function isUpperCase(c) {
  return c > 64 && c < 91;
}
const windowsNewlineRE = /\r\n/g;
function condenseWhitespace(nodes, tag) {
  const shouldCondense = currentOptions.whitespace !== "preserve";
  let removedWhitespace = false;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (node.type === 2) {
      if (!inPre) {
        if (isAllWhitespace(node.content)) {
          const prev = nodes[i - 1] && nodes[i - 1].type;
          const next = nodes[i + 1] && nodes[i + 1].type;
          if (!prev || !next || shouldCondense && (prev === 3 && (next === 3 || next === 1) || prev === 1 && (next === 3 || next === 1 && hasNewlineChar(node.content)))) {
            removedWhitespace = true;
            nodes[i] = null;
          } else {
            node.content = " ";
          }
        } else if (shouldCondense) {
          node.content = condense(node.content);
        }
      } else {
        node.content = node.content.replace(windowsNewlineRE, "\n");
      }
    }
  }
  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function isAllWhitespace(str) {
  for (let i = 0; i < str.length; i++) {
    if (!isWhitespace(str.charCodeAt(i))) {
      return false;
    }
  }
  return true;
}
function hasNewlineChar(str) {
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c === 10 || c === 13) {
      return true;
    }
  }
  return false;
}
function condense(str) {
  let ret = "";
  let prevCharIsWhitespace = false;
  for (let i = 0; i < str.length; i++) {
    if (isWhitespace(str.charCodeAt(i))) {
      if (!prevCharIsWhitespace) {
        ret += " ";
        prevCharIsWhitespace = true;
      }
    } else {
      ret += str[i];
      prevCharIsWhitespace = false;
    }
  }
  return ret;
}
function addNode(node) {
  (stack[0] || currentRoot).children.push(node);
}
function getLoc(start, end) {
  return {
    start: tokenizer.getPos(start),
    // @ts-expect-error allow late attachment
    end: end == null ? end : tokenizer.getPos(end),
    // @ts-expect-error allow late attachment
    source: end == null ? end : getSlice(start, end)
  };
}
function cloneLoc(loc) {
  return getLoc(loc.start.offset, loc.end.offset);
}
function setLocEnd(loc, end) {
  loc.end = tokenizer.getPos(end);
  loc.source = getSlice(loc.start.offset, end);
}
function dirToAttr(dir) {
  const attr = {
    type: 6,
    name: dir.rawName,
    nameLoc: getLoc(
      dir.loc.start.offset,
      dir.loc.start.offset + dir.rawName.length
    ),
    value: void 0,
    loc: dir.loc
  };
  if (dir.exp) {
    const loc = dir.exp.loc;
    if (loc.end.offset < dir.loc.end.offset) {
      loc.start.offset--;
      loc.start.column--;
      loc.end.offset++;
      loc.end.column++;
    }
    attr.value = {
      type: 2,
      content: dir.exp.content,
      loc
    };
  }
  return attr;
}
function createExp(content, isStatic = false, loc, constType = 0, parseMode = 0 /* Normal */) {
  const exp = createSimpleExpression(content, isStatic, loc, constType);
  return exp;
}
function emitError(code, index, message) {
  currentOptions.onError(
    createCompilerError(code, getLoc(index, index), void 0, message)
  );
}
function reset() {
  tokenizer.reset();
  currentOpenTag = null;
  currentProp = null;
  currentAttrValue = "";
  currentAttrStartIndex = -1;
  currentAttrEndIndex = -1;
  stack.length = 0;
}
function baseParse(input, options) {
  reset();
  currentInput = input;
  currentOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, defaultParserOptions);
  if (options) {
    let key;
    for (key in options) {
      if (options[key] != null) {
        currentOptions[key] = options[key];
      }
    }
  }
  if (true) {
    if (!currentOptions.decodeEntities) {
      throw new Error(
        `[@vue/compiler-core] decodeEntities option is required in browser builds.`
      );
    }
  }
  tokenizer.mode = currentOptions.parseMode === "html" ? 1 : currentOptions.parseMode === "sfc" ? 2 : 0;
  tokenizer.inXML = currentOptions.ns === 1 || currentOptions.ns === 2;
  const delimiters = options && options.delimiters;
  if (delimiters) {
    tokenizer.delimiterOpen = toCharCodes(delimiters[0]);
    tokenizer.delimiterClose = toCharCodes(delimiters[1]);
  }
  const root = currentRoot = createRoot([], input);
  tokenizer.parse(currentInput);
  root.loc = getLoc(0, input.length);
  root.children = condenseWhitespace(root.children);
  currentRoot = null;
  return root;
}

function cacheStatic(root, context) {
  walk(
    root,
    void 0,
    context,
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    isSingleElementRoot(root, root.children[0])
  );
}
function isSingleElementRoot(root, child) {
  const { children } = root;
  return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
}
function walk(node, parent, context, doNotHoistNode = false, inFor = false) {
  const { children } = node;
  const toCache = [];
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.type === 1 && child.tagType === 0) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType > 0) {
        if (constantType >= 2) {
          child.codegenNode.patchFlag = -1;
          toCache.push(child);
          continue;
        }
      } else {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          const flag = codegenNode.patchFlag;
          if ((flag === void 0 || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
            const props = getNodeProps(child);
            if (props) {
              codegenNode.props = context.hoist(props);
            }
          }
          if (codegenNode.dynamicProps) {
            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
          }
        }
      }
    } else if (child.type === 12) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType >= 2) {
        toCache.push(child);
        continue;
      }
    }
    if (child.type === 1) {
      const isComponent = child.tagType === 1;
      if (isComponent) {
        context.scopes.vSlot++;
      }
      walk(child, node, context, false, inFor);
      if (isComponent) {
        context.scopes.vSlot--;
      }
    } else if (child.type === 11) {
      walk(child, node, context, child.children.length === 1, true);
    } else if (child.type === 9) {
      for (let i2 = 0; i2 < child.branches.length; i2++) {
        walk(
          child.branches[i2],
          node,
          context,
          child.branches[i2].children.length === 1,
          inFor
        );
      }
    }
  }
  let cachedAsArray = false;
  if (toCache.length === children.length && node.type === 1) {
    if (node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node.codegenNode.children)) {
      node.codegenNode.children = getCacheExpression(
        createArrayExpression(node.codegenNode.children)
      );
      cachedAsArray = true;
    } else if (node.tagType === 1 && node.codegenNode && node.codegenNode.type === 13 && node.codegenNode.children && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node.codegenNode.children) && node.codegenNode.children.type === 15) {
      const slot = getSlotNode(node.codegenNode, "default");
      if (slot) {
        slot.returns = getCacheExpression(
          createArrayExpression(slot.returns)
        );
        cachedAsArray = true;
      }
    } else if (node.tagType === 3 && parent && parent.type === 1 && parent.tagType === 1 && parent.codegenNode && parent.codegenNode.type === 13 && parent.codegenNode.children && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(parent.codegenNode.children) && parent.codegenNode.children.type === 15) {
      const slotName = findDir(node, "slot", true);
      const slot = slotName && slotName.arg && getSlotNode(parent.codegenNode, slotName.arg);
      if (slot) {
        slot.returns = getCacheExpression(
          createArrayExpression(slot.returns)
        );
        cachedAsArray = true;
      }
    }
  }
  if (!cachedAsArray) {
    for (const child of toCache) {
      child.codegenNode = context.cache(child.codegenNode);
    }
  }
  function getCacheExpression(value) {
    const exp = context.cache(value);
    if (inFor && context.hmr) {
      exp.needArraySpread = true;
    }
    return exp;
  }
  function getSlotNode(node2, name) {
    if (node2.children && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node2.children) && node2.children.type === 15) {
      const slot = node2.children.properties.find(
        (p) => p.key === name || p.key.content === name
      );
      return slot && slot.value;
    }
  }
  if (toCache.length && context.transformHoist) {
    context.transformHoist(children, context, node);
  }
}
function getConstantType(node, context) {
  const { constantCache } = context;
  switch (node.type) {
    case 1:
      if (node.tagType !== 0) {
        return 0;
      }
      const cached = constantCache.get(node);
      if (cached !== void 0) {
        return cached;
      }
      const codegenNode = node.codegenNode;
      if (codegenNode.type !== 13) {
        return 0;
      }
      if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject" && node.tag !== "math") {
        return 0;
      }
      if (codegenNode.patchFlag === void 0) {
        let returnType2 = 3;
        const generatedPropsType = getGeneratedPropsConstantType(node, context);
        if (generatedPropsType === 0) {
          constantCache.set(node, 0);
          return 0;
        }
        if (generatedPropsType < returnType2) {
          returnType2 = generatedPropsType;
        }
        for (let i = 0; i < node.children.length; i++) {
          const childType = getConstantType(node.children[i], context);
          if (childType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (childType < returnType2) {
            returnType2 = childType;
          }
        }
        if (returnType2 > 1) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7 && p.name === "bind" && p.exp) {
              const expType = getConstantType(p.exp, context);
              if (expType === 0) {
                constantCache.set(node, 0);
                return 0;
              }
              if (expType < returnType2) {
                returnType2 = expType;
              }
            }
          }
        }
        if (codegenNode.isBlock) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7) {
              constantCache.set(node, 0);
              return 0;
            }
          }
          context.removeHelper(OPEN_BLOCK);
          context.removeHelper(
            getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)
          );
          codegenNode.isBlock = false;
          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
        }
        constantCache.set(node, returnType2);
        return returnType2;
      } else {
        constantCache.set(node, 0);
        return 0;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return getConstantType(node.content, context);
    case 4:
      return node.constType;
    case 8:
      let returnType = 3;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(child)) {
          continue;
        }
        const childType = getConstantType(child, context);
        if (childType === 0) {
          return 0;
        } else if (childType < returnType) {
          returnType = childType;
        }
      }
      return returnType;
    case 20:
      return 2;
    default:
      if (true) ;
      return 0;
  }
}
const allowHoistedHelperSet = /* @__PURE__ */ new Set([
  NORMALIZE_CLASS,
  NORMALIZE_STYLE,
  NORMALIZE_PROPS,
  GUARD_REACTIVE_PROPS
]);
function getConstantTypeOfHelperCall(value, context) {
  if (value.type === 14 && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(value.callee) && allowHoistedHelperSet.has(value.callee)) {
    const arg = value.arguments[0];
    if (arg.type === 4) {
      return getConstantType(arg, context);
    } else if (arg.type === 14) {
      return getConstantTypeOfHelperCall(arg, context);
    }
  }
  return 0;
}
function getGeneratedPropsConstantType(node, context) {
  let returnType = 3;
  const props = getNodeProps(node);
  if (props && props.type === 15) {
    const { properties } = props;
    for (let i = 0; i < properties.length; i++) {
      const { key, value } = properties[i];
      const keyType = getConstantType(key, context);
      if (keyType === 0) {
        return keyType;
      }
      if (keyType < returnType) {
        returnType = keyType;
      }
      let valueType;
      if (value.type === 4) {
        valueType = getConstantType(value, context);
      } else if (value.type === 14) {
        valueType = getConstantTypeOfHelperCall(value, context);
      } else {
        valueType = 0;
      }
      if (valueType === 0) {
        return valueType;
      }
      if (valueType < returnType) {
        returnType = valueType;
      }
    }
  }
  return returnType;
}
function getNodeProps(node) {
  const codegenNode = node.codegenNode;
  if (codegenNode.type === 13) {
    return codegenNode.props;
  }
}

function createTransformContext(root, {
  filename = "",
  prefixIdentifiers = false,
  hoistStatic = false,
  hmr = false,
  cacheHandlers = false,
  nodeTransforms = [],
  directiveTransforms = {},
  transformHoist = null,
  isBuiltInComponent = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP,
  isCustomElement = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP,
  expressionPlugins = [],
  scopeId = null,
  slotted = true,
  ssr = false,
  inSSR = false,
  ssrCssVars = ``,
  bindingMetadata = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ,
  inline = false,
  isTS = false,
  onError = defaultOnError,
  onWarn = defaultOnWarn,
  compatConfig
}) {
  const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
  const context = {
    // options
    filename,
    selfName: nameMatch && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(nameMatch[1])),
    prefixIdentifiers,
    hoistStatic,
    hmr,
    cacheHandlers,
    nodeTransforms,
    directiveTransforms,
    transformHoist,
    isBuiltInComponent,
    isCustomElement,
    expressionPlugins,
    scopeId,
    slotted,
    ssr,
    inSSR,
    ssrCssVars,
    bindingMetadata,
    inline,
    isTS,
    onError,
    onWarn,
    compatConfig,
    // state
    root,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    cached: [],
    constantCache: /* @__PURE__ */ new WeakMap(),
    temps: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    grandParent: null,
    currentNode: root,
    childIndex: 0,
    inVOnce: false,
    // methods
    helper(name) {
      const count = context.helpers.get(name) || 0;
      context.helpers.set(name, count + 1);
      return name;
    },
    removeHelper(name) {
      const count = context.helpers.get(name);
      if (count) {
        const currentCount = count - 1;
        if (!currentCount) {
          context.helpers.delete(name);
        } else {
          context.helpers.set(name, currentCount);
        }
      }
    },
    helperString(name) {
      return `_${helperNameMap[context.helper(name)]}`;
    },
    replaceNode(node) {
      if (true) {
        if (!context.currentNode) {
          throw new Error(`Node being replaced is already removed.`);
        }
        if (!context.parent) {
          throw new Error(`Cannot replace root node.`);
        }
      }
      context.parent.children[context.childIndex] = context.currentNode = node;
    },
    removeNode(node) {
      if ( true && !context.parent) {
        throw new Error(`Cannot remove root node.`);
      }
      const list = context.parent.children;
      const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
      if ( true && removalIndex < 0) {
        throw new Error(`node being removed is not a child of current parent`);
      }
      if (!node || node === context.currentNode) {
        context.currentNode = null;
        context.onNodeRemoved();
      } else {
        if (context.childIndex > removalIndex) {
          context.childIndex--;
          context.onNodeRemoved();
        }
      }
      context.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP,
    addIdentifiers(exp) {
    },
    removeIdentifiers(exp) {
    },
    hoist(exp) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(exp)) exp = createSimpleExpression(exp);
      context.hoists.push(exp);
      const identifier = createSimpleExpression(
        `_hoisted_${context.hoists.length}`,
        false,
        exp.loc,
        2
      );
      identifier.hoisted = exp;
      return identifier;
    },
    cache(exp, isVNode = false, inVOnce = false) {
      const cacheExp = createCacheExpression(
        context.cached.length,
        exp,
        isVNode,
        inVOnce
      );
      context.cached.push(cacheExp);
      return cacheExp;
    }
  };
  {
    context.filters = /* @__PURE__ */ new Set();
  }
  return context;
}
function transform(root, options) {
  const context = createTransformContext(root, options);
  traverseNode(root, context);
  if (options.hoistStatic) {
    cacheStatic(root, context);
  }
  if (!options.ssr) {
    createRootCodegen(root, context);
  }
  root.helpers = /* @__PURE__ */ new Set([...context.helpers.keys()]);
  root.components = [...context.components];
  root.directives = [...context.directives];
  root.imports = context.imports;
  root.hoists = context.hoists;
  root.temps = context.temps;
  root.cached = context.cached;
  root.transformed = true;
  {
    root.filters = [...context.filters];
  }
}
function createRootCodegen(root, context) {
  const { helper } = context;
  const { children } = root;
  if (children.length === 1) {
    const child = children[0];
    if (isSingleElementRoot(root, child) && child.codegenNode) {
      const codegenNode = child.codegenNode;
      if (codegenNode.type === 13) {
        convertToBlock(codegenNode, context);
      }
      root.codegenNode = codegenNode;
    } else {
      root.codegenNode = child;
    }
  } else if (children.length > 1) {
    let patchFlag = 64;
    if ( true && children.filter((c) => c.type !== 3).length === 1) {
      patchFlag |= 2048;
    }
    root.codegenNode = createVNodeCall(
      context,
      helper(FRAGMENT),
      void 0,
      root.children,
      patchFlag,
      void 0,
      void 0,
      true,
      void 0,
      false
    );
  } else ;
}
function traverseChildren(parent, context) {
  let i = 0;
  const nodeRemoved = () => {
    i--;
  };
  for (; i < parent.children.length; i++) {
    const child = parent.children[i];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child)) continue;
    context.grandParent = context.parent;
    context.parent = parent;
    context.childIndex = i;
    context.onNodeRemoved = nodeRemoved;
    traverseNode(child, context);
  }
}
function traverseNode(node, context) {
  context.currentNode = node;
  const { nodeTransforms } = context;
  const exitFns = [];
  for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
    const onExit = nodeTransforms[i2](node, context);
    if (onExit) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(onExit)) {
        exitFns.push(...onExit);
      } else {
        exitFns.push(onExit);
      }
    }
    if (!context.currentNode) {
      return;
    } else {
      node = context.currentNode;
    }
  }
  switch (node.type) {
    case 3:
      if (!context.ssr) {
        context.helper(CREATE_COMMENT);
      }
      break;
    case 5:
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING);
      }
      break;
    // for container types, further traverse downwards
    case 9:
      for (let i2 = 0; i2 < node.branches.length; i2++) {
        traverseNode(node.branches[i2], context);
      }
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      traverseChildren(node, context);
      break;
  }
  context.currentNode = node;
  let i = exitFns.length;
  while (i--) {
    exitFns[i]();
  }
}
function createStructuralDirectiveTransform(name, fn) {
  const matches = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(name) ? (n) => n === name : (n) => name.test(n);
  return (node, context) => {
    if (node.type === 1) {
      const { props } = node;
      if (node.tagType === 3 && props.some(isVSlot)) {
        return;
      }
      const exitFns = [];
      for (let i = 0; i < props.length; i++) {
        const prop = props[i];
        if (prop.type === 7 && matches(prop.name)) {
          props.splice(i, 1);
          i--;
          const onExit = fn(node, prop, context);
          if (onExit) exitFns.push(onExit);
        }
      }
      return exitFns;
    }
  };
}

const PURE_ANNOTATION = `/*@__PURE__*/`;
const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
function createCodegenContext(ast, {
  mode = "function",
  prefixIdentifiers = mode === "module",
  sourceMap = false,
  filename = `template.vue.html`,
  scopeId = null,
  optimizeImports = false,
  runtimeGlobalName = `Vue`,
  runtimeModuleName = `vue`,
  ssrRuntimeModuleName = "vue/server-renderer",
  ssr = false,
  isTS = false,
  inSSR = false
}) {
  const context = {
    mode,
    prefixIdentifiers,
    sourceMap,
    filename,
    scopeId,
    optimizeImports,
    runtimeGlobalName,
    runtimeModuleName,
    ssrRuntimeModuleName,
    ssr,
    isTS,
    inSSR,
    source: ast.source,
    code: ``,
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: void 0,
    helper(key) {
      return `_${helperNameMap[key]}`;
    },
    push(code, newlineIndex = -2 /* None */, node) {
      context.code += code;
    },
    indent() {
      newline(++context.indentLevel);
    },
    deindent(withoutNewLine = false) {
      if (withoutNewLine) {
        --context.indentLevel;
      } else {
        newline(--context.indentLevel);
      }
    },
    newline() {
      newline(context.indentLevel);
    }
  };
  function newline(n) {
    context.push("\n" + `  `.repeat(n), 0 /* Start */);
  }
  return context;
}
function generate(ast, options = {}) {
  const context = createCodegenContext(ast, options);
  if (options.onContextCreated) options.onContextCreated(context);
  const {
    mode,
    push,
    prefixIdentifiers,
    indent,
    deindent,
    newline,
    scopeId,
    ssr
  } = context;
  const helpers = Array.from(ast.helpers);
  const hasHelpers = helpers.length > 0;
  const useWithBlock = !prefixIdentifiers && mode !== "module";
  const preambleContext = context;
  {
    genFunctionPreamble(ast, preambleContext);
  }
  const functionName = ssr ? `ssrRender` : `render`;
  const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  const signature = args.join(", ");
  {
    push(`function ${functionName}(${signature}) {`);
  }
  indent();
  if (useWithBlock) {
    push(`with (_ctx) {`);
    indent();
    if (hasHelpers) {
      push(
        `const { ${helpers.map(aliasHelper).join(", ")} } = _Vue
`,
        -1 /* End */
      );
      newline();
    }
  }
  if (ast.components.length) {
    genAssets(ast.components, "component", context);
    if (ast.directives.length || ast.temps > 0) {
      newline();
    }
  }
  if (ast.directives.length) {
    genAssets(ast.directives, "directive", context);
    if (ast.temps > 0) {
      newline();
    }
  }
  if (ast.filters && ast.filters.length) {
    newline();
    genAssets(ast.filters, "filter", context);
    newline();
  }
  if (ast.temps > 0) {
    push(`let `);
    for (let i = 0; i < ast.temps; i++) {
      push(`${i > 0 ? `, ` : ``}_temp${i}`);
    }
  }
  if (ast.components.length || ast.directives.length || ast.temps) {
    push(`
`, 0 /* Start */);
    newline();
  }
  if (!ssr) {
    push(`return `);
  }
  if (ast.codegenNode) {
    genNode(ast.codegenNode, context);
  } else {
    push(`null`);
  }
  if (useWithBlock) {
    deindent();
    push(`}`);
  }
  deindent();
  push(`}`);
  return {
    ast,
    code: context.code,
    preamble: ``,
    map: context.map ? context.map.toJSON() : void 0
  };
}
function genFunctionPreamble(ast, context) {
  const {
    ssr,
    prefixIdentifiers,
    push,
    newline,
    runtimeModuleName,
    runtimeGlobalName,
    ssrRuntimeModuleName
  } = context;
  const VueBinding = runtimeGlobalName;
  const helpers = Array.from(ast.helpers);
  if (helpers.length > 0) {
    {
      push(`const _Vue = ${VueBinding}
`, -1 /* End */);
      if (ast.hoists.length) {
        const staticHelpers = [
          CREATE_VNODE,
          CREATE_ELEMENT_VNODE,
          CREATE_COMMENT,
          CREATE_TEXT,
          CREATE_STATIC
        ].filter((helper) => helpers.includes(helper)).map(aliasHelper).join(", ");
        push(`const { ${staticHelpers} } = _Vue
`, -1 /* End */);
      }
    }
  }
  genHoists(ast.hoists, context);
  newline();
  push(`return `);
}
function genAssets(assets, type, { helper, push, newline, isTS }) {
  const resolver = helper(
    type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE
  );
  for (let i = 0; i < assets.length; i++) {
    let id = assets[i];
    const maybeSelfReference = id.endsWith("__self");
    if (maybeSelfReference) {
      id = id.slice(0, -6);
    }
    push(
      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`
    );
    if (i < assets.length - 1) {
      newline();
    }
  }
}
function genHoists(hoists, context) {
  if (!hoists.length) {
    return;
  }
  context.pure = true;
  const { push, newline } = context;
  newline();
  for (let i = 0; i < hoists.length; i++) {
    const exp = hoists[i];
    if (exp) {
      push(`const _hoisted_${i + 1} = `);
      genNode(exp, context);
      newline();
    }
  }
  context.pure = false;
}
function isText(n) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
}
function genNodeListAsArray(nodes, context) {
  const multilines = nodes.length > 3 ||  true && nodes.some((n) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(n) || !isText(n));
  context.push(`[`);
  multilines && context.indent();
  genNodeList(nodes, context, multilines);
  multilines && context.deindent();
  context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
  const { push, newline } = context;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node)) {
      push(node, -3 /* Unknown */);
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node)) {
      genNodeListAsArray(node, context);
    } else {
      genNode(node, context);
    }
    if (i < nodes.length - 1) {
      if (multilines) {
        comma && push(",");
        newline();
      } else {
        comma && push(", ");
      }
    }
  }
}
function genNode(node, context) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node)) {
    context.push(node, -3 /* Unknown */);
    return;
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(node)) {
    context.push(context.helper(node));
    return;
  }
  switch (node.type) {
    case 1:
    case 9:
    case 11:
       true && assert(
        node.codegenNode != null,
        `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`
      );
      genNode(node.codegenNode, context);
      break;
    case 2:
      genText(node, context);
      break;
    case 4:
      genExpression(node, context);
      break;
    case 5:
      genInterpolation(node, context);
      break;
    case 12:
      genNode(node.codegenNode, context);
      break;
    case 8:
      genCompoundExpression(node, context);
      break;
    case 3:
      genComment(node, context);
      break;
    case 13:
      genVNodeCall(node, context);
      break;
    case 14:
      genCallExpression(node, context);
      break;
    case 15:
      genObjectExpression(node, context);
      break;
    case 17:
      genArrayExpression(node, context);
      break;
    case 18:
      genFunctionExpression(node, context);
      break;
    case 19:
      genConditionalExpression(node, context);
      break;
    case 20:
      genCacheExpression(node, context);
      break;
    case 21:
      genNodeList(node.body, context, true, false);
      break;
    // SSR only types
    case 22:
      break;
    case 23:
      break;
    case 24:
      break;
    case 25:
      break;
    case 26:
      break;
    /* v8 ignore start */
    case 10:
      break;
    default:
      if (true) {
        assert(false, `unhandled codegen node type: ${node.type}`);
        const exhaustiveCheck = node;
        return exhaustiveCheck;
      }
  }
}
function genText(node, context) {
  context.push(JSON.stringify(node.content), -3 /* Unknown */, node);
}
function genExpression(node, context) {
  const { content, isStatic } = node;
  context.push(
    isStatic ? JSON.stringify(content) : content,
    -3 /* Unknown */,
    node
  );
}
function genInterpolation(node, context) {
  const { push, helper, pure } = context;
  if (pure) push(PURE_ANNOTATION);
  push(`${helper(TO_DISPLAY_STRING)}(`);
  genNode(node.content, context);
  push(`)`);
}
function genCompoundExpression(node, context) {
  for (let i = 0; i < node.children.length; i++) {
    const child = node.children[i];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child)) {
      context.push(child, -3 /* Unknown */);
    } else {
      genNode(child, context);
    }
  }
}
function genExpressionAsPropertyKey(node, context) {
  const { push } = context;
  if (node.type === 8) {
    push(`[`);
    genCompoundExpression(node, context);
    push(`]`);
  } else if (node.isStatic) {
    const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
    push(text, -2 /* None */, node);
  } else {
    push(`[${node.content}]`, -3 /* Unknown */, node);
  }
}
function genComment(node, context) {
  const { push, helper, pure } = context;
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(
    `${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`,
    -3 /* Unknown */,
    node
  );
}
function genVNodeCall(node, context) {
  const { push, helper, pure } = context;
  const {
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent
  } = node;
  let patchFlagString;
  if (patchFlag) {
    if (true) {
      if (patchFlag < 0) {
        patchFlagString = patchFlag + ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[patchFlag]} */`;
      } else {
        const flagNames = Object.keys(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames).map(Number).filter((n) => n > 0 && patchFlag & n).map((n) => _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[n]).join(`, `);
        patchFlagString = patchFlag + ` /* ${flagNames} */`;
      }
    } else {}
  }
  if (directives) {
    push(helper(WITH_DIRECTIVES) + `(`);
  }
  if (isBlock) {
    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
  }
  if (pure) {
    push(PURE_ANNOTATION);
  }
  const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent) : getVNodeHelper(context.inSSR, isComponent);
  push(helper(callHelper) + `(`, -2 /* None */, node);
  genNodeList(
    genNullableArgs([tag, props, children, patchFlagString, dynamicProps]),
    context
  );
  push(`)`);
  if (isBlock) {
    push(`)`);
  }
  if (directives) {
    push(`, `);
    genNode(directives, context);
    push(`)`);
  }
}
function genNullableArgs(args) {
  let i = args.length;
  while (i--) {
    if (args[i] != null) break;
  }
  return args.slice(0, i + 1).map((arg) => arg || `null`);
}
function genCallExpression(node, context) {
  const { push, helper, pure } = context;
  const callee = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node.callee) ? node.callee : helper(node.callee);
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(callee + `(`, -2 /* None */, node);
  genNodeList(node.arguments, context);
  push(`)`);
}
function genObjectExpression(node, context) {
  const { push, indent, deindent, newline } = context;
  const { properties } = node;
  if (!properties.length) {
    push(`{}`, -2 /* None */, node);
    return;
  }
  const multilines = properties.length > 1 ||  true && properties.some((p) => p.value.type !== 4);
  push(multilines ? `{` : `{ `);
  multilines && indent();
  for (let i = 0; i < properties.length; i++) {
    const { key, value } = properties[i];
    genExpressionAsPropertyKey(key, context);
    push(`: `);
    genNode(value, context);
    if (i < properties.length - 1) {
      push(`,`);
      newline();
    }
  }
  multilines && deindent();
  push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
  genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
  const { push, indent, deindent } = context;
  const { params, returns, body, newline, isSlot } = node;
  if (isSlot) {
    push(`_${helperNameMap[WITH_CTX]}(`);
  }
  push(`(`, -2 /* None */, node);
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(params)) {
    genNodeList(params, context);
  } else if (params) {
    genNode(params, context);
  }
  push(`) => `);
  if (newline || body) {
    push(`{`);
    indent();
  }
  if (returns) {
    if (newline) {
      push(`return `);
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(returns)) {
      genNodeListAsArray(returns, context);
    } else {
      genNode(returns, context);
    }
  } else if (body) {
    genNode(body, context);
  }
  if (newline || body) {
    deindent();
    push(`}`);
  }
  if (isSlot) {
    if (node.isNonScopedSlot) {
      push(`, undefined, true`);
    }
    push(`)`);
  }
}
function genConditionalExpression(node, context) {
  const { test, consequent, alternate, newline: needNewline } = node;
  const { push, indent, deindent, newline } = context;
  if (test.type === 4) {
    const needsParens = !isSimpleIdentifier(test.content);
    needsParens && push(`(`);
    genExpression(test, context);
    needsParens && push(`)`);
  } else {
    push(`(`);
    genNode(test, context);
    push(`)`);
  }
  needNewline && indent();
  context.indentLevel++;
  needNewline || push(` `);
  push(`? `);
  genNode(consequent, context);
  context.indentLevel--;
  needNewline && newline();
  needNewline || push(` `);
  push(`: `);
  const isNested = alternate.type === 19;
  if (!isNested) {
    context.indentLevel++;
  }
  genNode(alternate, context);
  if (!isNested) {
    context.indentLevel--;
  }
  needNewline && deindent(
    true
    /* without newline */
  );
}
function genCacheExpression(node, context) {
  const { push, helper, indent, deindent, newline } = context;
  const { needPauseTracking, needArraySpread } = node;
  if (needArraySpread) {
    push(`[...(`);
  }
  push(`_cache[${node.index}] || (`);
  if (needPauseTracking) {
    indent();
    push(`${helper(SET_BLOCK_TRACKING)}(-1`);
    if (node.inVOnce) push(`, true`);
    push(`),`);
    newline();
    push(`(`);
  }
  push(`_cache[${node.index}] = `);
  genNode(node.value, context);
  if (needPauseTracking) {
    push(`).cacheIndex = ${node.index},`);
    newline();
    push(`${helper(SET_BLOCK_TRACKING)}(1),`);
    newline();
    push(`_cache[${node.index}]`);
    deindent();
  }
  push(`)`);
  if (needArraySpread) {
    push(`)]`);
  }
}

const prohibitedKeywordRE = new RegExp(
  "\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b"
);
const stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
  const exp = node.content;
  if (!exp.trim()) {
    return;
  }
  try {
    new Function(
      asRawStatements ? ` ${exp} ` : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`
    );
  } catch (e) {
    let message = e.message;
    const keywordMatch = exp.replace(stripStringRE, "").match(prohibitedKeywordRE);
    if (keywordMatch) {
      message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
    }
    context.onError(
      createCompilerError(
        45,
        node.loc,
        void 0,
        message
      )
    );
  }
}

const transformExpression = (node, context) => {
  if (node.type === 5) {
    node.content = processExpression(
      node.content,
      context
    );
  } else if (node.type === 1) {
    const memo = findDir(node, "memo");
    for (let i = 0; i < node.props.length; i++) {
      const dir = node.props[i];
      if (dir.type === 7 && dir.name !== "for") {
        const exp = dir.exp;
        const arg = dir.arg;
        if (exp && exp.type === 4 && !(dir.name === "on" && arg) && // key has been processed in transformFor(vMemo + vFor)
        !(memo && arg && arg.type === 4 && arg.content === "key")) {
          dir.exp = processExpression(
            exp,
            context,
            // slot args must be processed as function params
            dir.name === "slot"
          );
        }
        if (arg && arg.type === 4 && !arg.isStatic) {
          dir.arg = processExpression(arg, context);
        }
      }
    }
  }
};
function processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {
  {
    if (true) {
      validateBrowserExpression(node, context, asParams, asRawStatements);
    }
    return node;
  }
}
function stringifyExpression(exp) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(exp)) {
    return exp;
  } else if (exp.type === 4) {
    return exp.content;
  } else {
    return exp.children.map(stringifyExpression).join("");
  }
}

const transformIf = createStructuralDirectiveTransform(
  /^(if|else|else-if)$/,
  (node, dir, context) => {
    return processIf(node, dir, context, (ifNode, branch, isRoot) => {
      const siblings = context.parent.children;
      let i = siblings.indexOf(ifNode);
      let key = 0;
      while (i-- >= 0) {
        const sibling = siblings[i];
        if (sibling && sibling.type === 9) {
          key += sibling.branches.length;
        }
      }
      return () => {
        if (isRoot) {
          ifNode.codegenNode = createCodegenNodeForBranch(
            branch,
            key,
            context
          );
        } else {
          const parentCondition = getParentCondition(ifNode.codegenNode);
          parentCondition.alternate = createCodegenNodeForBranch(
            branch,
            key + ifNode.branches.length - 1,
            context
          );
        }
      };
    });
  }
);
function processIf(node, dir, context, processCodegen) {
  if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
    const loc = dir.exp ? dir.exp.loc : node.loc;
    context.onError(
      createCompilerError(28, dir.loc)
    );
    dir.exp = createSimpleExpression(`true`, false, loc);
  }
  if ( true && dir.exp) {
    validateBrowserExpression(dir.exp, context);
  }
  if (dir.name === "if") {
    const branch = createIfBranch(node, dir);
    const ifNode = {
      type: 9,
      loc: cloneLoc(node.loc),
      branches: [branch]
    };
    context.replaceNode(ifNode);
    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    const siblings = context.parent.children;
    const comments = [];
    let i = siblings.indexOf(node);
    while (i-- >= -1) {
      const sibling = siblings[i];
      if (sibling && sibling.type === 3) {
        context.removeNode(sibling);
         true && comments.unshift(sibling);
        continue;
      }
      if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
        context.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 9) {
        if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
          context.onError(
            createCompilerError(30, node.loc)
          );
        }
        context.removeNode();
        const branch = createIfBranch(node, dir);
        if ( true && comments.length && // #3619 ignore comments if the v-if is direct child of <transition>
        !(context.parent && context.parent.type === 1 && (context.parent.tag === "transition" || context.parent.tag === "Transition"))) {
          branch.children = [...comments, ...branch.children];
        }
        if (true) {
          const key = branch.userKey;
          if (key) {
            sibling.branches.forEach(({ userKey }) => {
              if (isSameKey(userKey, key)) {
                context.onError(
                  createCompilerError(
                    29,
                    branch.userKey.loc
                  )
                );
              }
            });
          }
        }
        sibling.branches.push(branch);
        const onExit = processCodegen && processCodegen(sibling, branch, false);
        traverseNode(branch, context);
        if (onExit) onExit();
        context.currentNode = null;
      } else {
        context.onError(
          createCompilerError(30, node.loc)
        );
      }
      break;
    }
  }
}
function createIfBranch(node, dir) {
  const isTemplateIf = node.tagType === 3;
  return {
    type: 10,
    loc: node.loc,
    condition: dir.name === "else" ? void 0 : dir.exp,
    children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
    userKey: findProp(node, `key`),
    isTemplateIf
  };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
  if (branch.condition) {
    return createConditionalExpression(
      branch.condition,
      createChildrenCodegenNode(branch, keyIndex, context),
      // make sure to pass in asBlock: true so that the comment node call
      // closes the current block.
      createCallExpression(context.helper(CREATE_COMMENT), [
         true ? '"v-if"' : 0,
        "true"
      ])
    );
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context);
  }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
  const { helper } = context;
  const keyProperty = createObjectProperty(
    `key`,
    createSimpleExpression(
      `${keyIndex}`,
      false,
      locStub,
      2
    )
  );
  const { children } = branch;
  const firstChild = children[0];
  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11) {
      const vnodeCall = firstChild.codegenNode;
      injectProp(vnodeCall, keyProperty, context);
      return vnodeCall;
    } else {
      let patchFlag = 64;
      if ( true && !branch.isTemplateIf && children.filter((c) => c.type !== 3).length === 1) {
        patchFlag |= 2048;
      }
      return createVNodeCall(
        context,
        helper(FRAGMENT),
        createObjectExpression([keyProperty]),
        children,
        patchFlag,
        void 0,
        void 0,
        true,
        false,
        false,
        branch.loc
      );
    }
  } else {
    const ret = firstChild.codegenNode;
    const vnodeCall = getMemoedVNodeCall(ret);
    if (vnodeCall.type === 13) {
      convertToBlock(vnodeCall, context);
    }
    injectProp(vnodeCall, keyProperty, context);
    return ret;
  }
}
function isSameKey(a, b) {
  if (!a || a.type !== b.type) {
    return false;
  }
  if (a.type === 6) {
    if (a.value.content !== b.value.content) {
      return false;
    }
  } else {
    const exp = a.exp;
    const branchExp = b.exp;
    if (exp.type !== branchExp.type) {
      return false;
    }
    if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
      return false;
    }
  }
  return true;
}
function getParentCondition(node) {
  while (true) {
    if (node.type === 19) {
      if (node.alternate.type === 19) {
        node = node.alternate;
      } else {
        return node;
      }
    } else if (node.type === 20) {
      node = node.value;
    }
  }
}

const transformBind = (dir, _node, context) => {
  const { modifiers, loc } = dir;
  const arg = dir.arg;
  let { exp } = dir;
  if (exp && exp.type === 4 && !exp.content.trim()) {
    {
      exp = void 0;
    }
  }
  if (!exp) {
    if (arg.type !== 4 || !arg.isStatic) {
      context.onError(
        createCompilerError(
          52,
          arg.loc
        )
      );
      return {
        props: [
          createObjectProperty(arg, createSimpleExpression("", true, loc))
        ]
      };
    }
    transformBindShorthand(dir);
    exp = dir.exp;
  }
  if (arg.type !== 4) {
    arg.children.unshift(`(`);
    arg.children.push(`) || ""`);
  } else if (!arg.isStatic) {
    arg.content = `${arg.content} || ""`;
  }
  if (modifiers.some((mod) => mod.content === "camel")) {
    if (arg.type === 4) {
      if (arg.isStatic) {
        arg.content = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(arg.content);
      } else {
        arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
      }
    } else {
      arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
      arg.children.push(`)`);
    }
  }
  if (!context.inSSR) {
    if (modifiers.some((mod) => mod.content === "prop")) {
      injectPrefix(arg, ".");
    }
    if (modifiers.some((mod) => mod.content === "attr")) {
      injectPrefix(arg, "^");
    }
  }
  return {
    props: [createObjectProperty(arg, exp)]
  };
};
const transformBindShorthand = (dir, context) => {
  const arg = dir.arg;
  const propName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(arg.content);
  dir.exp = createSimpleExpression(propName, false, arg.loc);
};
const injectPrefix = (arg, prefix) => {
  if (arg.type === 4) {
    if (arg.isStatic) {
      arg.content = prefix + arg.content;
    } else {
      arg.content = `\`${prefix}\${${arg.content}}\``;
    }
  } else {
    arg.children.unshift(`'${prefix}' + (`);
    arg.children.push(`)`);
  }
};

const transformFor = createStructuralDirectiveTransform(
  "for",
  (node, dir, context) => {
    const { helper, removeHelper } = context;
    return processFor(node, dir, context, (forNode) => {
      const renderExp = createCallExpression(helper(RENDER_LIST), [
        forNode.source
      ]);
      const isTemplate = isTemplateNode(node);
      const memo = findDir(node, "memo");
      const keyProp = findProp(node, `key`, false, true);
      const isDirKey = keyProp && keyProp.type === 7;
      if (isDirKey && !keyProp.exp) {
        transformBindShorthand(keyProp);
      }
      let keyExp = keyProp && (keyProp.type === 6 ? keyProp.value ? createSimpleExpression(keyProp.value.content, true) : void 0 : keyProp.exp);
      const keyProperty = keyProp && keyExp ? createObjectProperty(`key`, keyExp) : null;
      const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
      const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
      forNode.codegenNode = createVNodeCall(
        context,
        helper(FRAGMENT),
        void 0,
        renderExp,
        fragmentFlag,
        void 0,
        void 0,
        true,
        !isStableFragment,
        false,
        node.loc
      );
      return () => {
        let childBlock;
        const { children } = forNode;
        if (( true) && isTemplate) {
          node.children.some((c) => {
            if (c.type === 1) {
              const key = findProp(c, "key");
              if (key) {
                context.onError(
                  createCompilerError(
                    33,
                    key.loc
                  )
                );
                return true;
              }
            }
          });
        }
        const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
        const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
        if (slotOutlet) {
          childBlock = slotOutlet.codegenNode;
          if (isTemplate && keyProperty) {
            injectProp(childBlock, keyProperty, context);
          }
        } else if (needFragmentWrapper) {
          childBlock = createVNodeCall(
            context,
            helper(FRAGMENT),
            keyProperty ? createObjectExpression([keyProperty]) : void 0,
            node.children,
            64,
            void 0,
            void 0,
            true,
            void 0,
            false
          );
        } else {
          childBlock = children[0].codegenNode;
          if (isTemplate && keyProperty) {
            injectProp(childBlock, keyProperty, context);
          }
          if (childBlock.isBlock !== !isStableFragment) {
            if (childBlock.isBlock) {
              removeHelper(OPEN_BLOCK);
              removeHelper(
                getVNodeBlockHelper(context.inSSR, childBlock.isComponent)
              );
            } else {
              removeHelper(
                getVNodeHelper(context.inSSR, childBlock.isComponent)
              );
            }
          }
          childBlock.isBlock = !isStableFragment;
          if (childBlock.isBlock) {
            helper(OPEN_BLOCK);
            helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
          } else {
            helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
          }
        }
        if (memo) {
          const loop = createFunctionExpression(
            createForLoopParams(forNode.parseResult, [
              createSimpleExpression(`_cached`)
            ])
          );
          loop.body = createBlockStatement([
            createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
            createCompoundExpression([
              `if (_cached`,
              ...keyExp ? [` && _cached.key === `, keyExp] : [],
              ` && ${context.helperString(
                IS_MEMO_SAME
              )}(_cached, _memo)) return _cached`
            ]),
            createCompoundExpression([`const _item = `, childBlock]),
            createSimpleExpression(`_item.memo = _memo`),
            createSimpleExpression(`return _item`)
          ]);
          renderExp.arguments.push(
            loop,
            createSimpleExpression(`_cache`),
            createSimpleExpression(String(context.cached.length))
          );
          context.cached.push(null);
        } else {
          renderExp.arguments.push(
            createFunctionExpression(
              createForLoopParams(forNode.parseResult),
              childBlock,
              true
            )
          );
        }
      };
    });
  }
);
function processFor(node, dir, context, processCodegen) {
  if (!dir.exp) {
    context.onError(
      createCompilerError(31, dir.loc)
    );
    return;
  }
  const parseResult = dir.forParseResult;
  if (!parseResult) {
    context.onError(
      createCompilerError(32, dir.loc)
    );
    return;
  }
  finalizeForParseResult(parseResult, context);
  const { addIdentifiers, removeIdentifiers, scopes } = context;
  const { source, value, key, index } = parseResult;
  const forNode = {
    type: 11,
    loc: dir.loc,
    source,
    valueAlias: value,
    keyAlias: key,
    objectIndexAlias: index,
    parseResult,
    children: isTemplateNode(node) ? node.children : [node]
  };
  context.replaceNode(forNode);
  scopes.vFor++;
  const onExit = processCodegen && processCodegen(forNode);
  return () => {
    scopes.vFor--;
    if (onExit) onExit();
  };
}
function finalizeForParseResult(result, context) {
  if (result.finalized) return;
  if (true) {
    validateBrowserExpression(result.source, context);
    if (result.key) {
      validateBrowserExpression(
        result.key,
        context,
        true
      );
    }
    if (result.index) {
      validateBrowserExpression(
        result.index,
        context,
        true
      );
    }
    if (result.value) {
      validateBrowserExpression(
        result.value,
        context,
        true
      );
    }
  }
  result.finalized = true;
}
function createForLoopParams({ value, key, index }, memoArgs = []) {
  return createParamsList([value, key, index, ...memoArgs]);
}
function createParamsList(args) {
  let i = args.length;
  while (i--) {
    if (args[i]) break;
  }
  return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
}

const defaultFallback = createSimpleExpression(`undefined`, false);
const trackSlotScopes = (node, context) => {
  if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
    const vSlot = findDir(node, "slot");
    if (vSlot) {
      vSlot.exp;
      context.scopes.vSlot++;
      return () => {
        context.scopes.vSlot--;
      };
    }
  }
};
const trackVForSlotScopes = (node, context) => {
  let vFor;
  if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, "for"))) {
    const result = vFor.forParseResult;
    if (result) {
      finalizeForParseResult(result, context);
      const { value, key, index } = result;
      const { addIdentifiers, removeIdentifiers } = context;
      value && addIdentifiers(value);
      key && addIdentifiers(key);
      index && addIdentifiers(index);
      return () => {
        value && removeIdentifiers(value);
        key && removeIdentifiers(key);
        index && removeIdentifiers(index);
      };
    }
  }
};
const buildClientSlotFn = (props, _vForExp, children, loc) => createFunctionExpression(
  props,
  children,
  false,
  true,
  children.length ? children[0].loc : loc
);
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
  context.helper(WITH_CTX);
  const { children, loc } = node;
  const slotsProperties = [];
  const dynamicSlots = [];
  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
  const onComponentSlot = findDir(node, "slot", true);
  if (onComponentSlot) {
    const { arg, exp } = onComponentSlot;
    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }
    slotsProperties.push(
      createObjectProperty(
        arg || createSimpleExpression("default", true),
        buildSlotFn(exp, void 0, children, loc)
      )
    );
  }
  let hasTemplateSlots = false;
  let hasNamedDefaultSlot = false;
  const implicitDefaultChildren = [];
  const seenSlotNames = /* @__PURE__ */ new Set();
  let conditionalBranchIndex = 0;
  for (let i = 0; i < children.length; i++) {
    const slotElement = children[i];
    let slotDir;
    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
      if (slotElement.type !== 3) {
        implicitDefaultChildren.push(slotElement);
      }
      continue;
    }
    if (onComponentSlot) {
      context.onError(
        createCompilerError(37, slotDir.loc)
      );
      break;
    }
    hasTemplateSlots = true;
    const { children: slotChildren, loc: slotLoc } = slotElement;
    const {
      arg: slotName = createSimpleExpression(`default`, true),
      exp: slotProps,
      loc: dirLoc
    } = slotDir;
    let staticSlotName;
    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : `default`;
    } else {
      hasDynamicSlots = true;
    }
    const vFor = findDir(slotElement, "for");
    const slotFunction = buildSlotFn(slotProps, vFor, slotChildren, slotLoc);
    let vIf;
    let vElse;
    if (vIf = findDir(slotElement, "if")) {
      hasDynamicSlots = true;
      dynamicSlots.push(
        createConditionalExpression(
          vIf.exp,
          buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++),
          defaultFallback
        )
      );
    } else if (vElse = findDir(
      slotElement,
      /^else(-if)?$/,
      true
      /* allowEmpty */
    )) {
      let j = i;
      let prev;
      while (j--) {
        prev = children[j];
        if (prev.type !== 3) {
          break;
        }
      }
      if (prev && isTemplateNode(prev) && findDir(prev, /^(else-)?if$/)) {
        let conditional = dynamicSlots[dynamicSlots.length - 1];
        while (conditional.alternate.type === 19) {
          conditional = conditional.alternate;
        }
        conditional.alternate = vElse.exp ? createConditionalExpression(
          vElse.exp,
          buildDynamicSlot(
            slotName,
            slotFunction,
            conditionalBranchIndex++
          ),
          defaultFallback
        ) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
      } else {
        context.onError(
          createCompilerError(30, vElse.loc)
        );
      }
    } else if (vFor) {
      hasDynamicSlots = true;
      const parseResult = vFor.forParseResult;
      if (parseResult) {
        finalizeForParseResult(parseResult, context);
        dynamicSlots.push(
          createCallExpression(context.helper(RENDER_LIST), [
            parseResult.source,
            createFunctionExpression(
              createForLoopParams(parseResult),
              buildDynamicSlot(slotName, slotFunction),
              true
            )
          ])
        );
      } else {
        context.onError(
          createCompilerError(
            32,
            vFor.loc
          )
        );
      }
    } else {
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context.onError(
            createCompilerError(
              38,
              dirLoc
            )
          );
          continue;
        }
        seenSlotNames.add(staticSlotName);
        if (staticSlotName === "default") {
          hasNamedDefaultSlot = true;
        }
      }
      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }
  if (!onComponentSlot) {
    const buildDefaultSlotProperty = (props, children2) => {
      const fn = buildSlotFn(props, void 0, children2, loc);
      if (context.compatConfig) {
        fn.isNonScopedSlot = true;
      }
      return createObjectProperty(`default`, fn);
    };
    if (!hasTemplateSlots) {
      slotsProperties.push(buildDefaultSlotProperty(void 0, children));
    } else if (implicitDefaultChildren.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
      if (hasNamedDefaultSlot) {
        context.onError(
          createCompilerError(
            39,
            implicitDefaultChildren[0].loc
          )
        );
      } else {
        slotsProperties.push(
          buildDefaultSlotProperty(void 0, implicitDefaultChildren)
        );
      }
    }
  }
  const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
  let slots = createObjectExpression(
    slotsProperties.concat(
      createObjectProperty(
        `_`,
        // 2 = compiled but dynamic = can skip normalization, but must run diff
        // 1 = compiled and static = can skip normalization AND diff as optimized
        createSimpleExpression(
          slotFlag + ( true ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.slotFlagsText[slotFlag]} */` : 0),
          false
        )
      )
    ),
    loc
  );
  if (dynamicSlots.length) {
    slots = createCallExpression(context.helper(CREATE_SLOTS), [
      slots,
      createArrayExpression(dynamicSlots)
    ]);
  }
  return {
    slots,
    hasDynamicSlots
  };
}
function buildDynamicSlot(name, fn, index) {
  const props = [
    createObjectProperty(`name`, name),
    createObjectProperty(`fn`, fn)
  ];
  if (index != null) {
    props.push(
      createObjectProperty(`key`, createSimpleExpression(String(index), true))
    );
  }
  return createObjectExpression(props);
}
function hasForwardedSlots(children) {
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    switch (child.type) {
      case 1:
        if (child.tagType === 2 || hasForwardedSlots(child.children)) {
          return true;
        }
        break;
      case 9:
        if (hasForwardedSlots(child.branches)) return true;
        break;
      case 10:
      case 11:
        if (hasForwardedSlots(child.children)) return true;
        break;
    }
  }
  return false;
}
function isNonWhitespaceContent(node) {
  if (node.type !== 2 && node.type !== 12)
    return true;
  return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
}

const directiveImportMap = /* @__PURE__ */ new WeakMap();
const transformElement = (node, context) => {
  return function postTransformElement() {
    node = context.currentNode;
    if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
      return;
    }
    const { tag, props } = node;
    const isComponent = node.tagType === 1;
    let vnodeTag = isComponent ? resolveComponentType(node, context) : `"${tag}"`;
    const isDynamicComponent = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
    let vnodeProps;
    let vnodeChildren;
    let patchFlag = 0;
    let vnodeDynamicProps;
    let dynamicPropNames;
    let vnodeDirectives;
    let shouldUseBlock = (
      // dynamic component may resolve to plain elements
      isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent && // <svg> and <foreignObject> must be forced into blocks so that block
      // updates inside get proper isSVG flag at runtime. (#639, #643)
      // This is technically web-specific, but splitting the logic out of core
      // leads to too much unnecessary complexity.
      (tag === "svg" || tag === "foreignObject" || tag === "math")
    );
    if (props.length > 0) {
      const propsBuildResult = buildProps(
        node,
        context,
        void 0,
        isComponent,
        isDynamicComponent
      );
      vnodeProps = propsBuildResult.props;
      patchFlag = propsBuildResult.patchFlag;
      dynamicPropNames = propsBuildResult.dynamicPropNames;
      const directives = propsBuildResult.directives;
      vnodeDirectives = directives && directives.length ? createArrayExpression(
        directives.map((dir) => buildDirectiveArgs(dir, context))
      ) : void 0;
      if (propsBuildResult.shouldUseBlock) {
        shouldUseBlock = true;
      }
    }
    if (node.children.length > 0) {
      if (vnodeTag === KEEP_ALIVE) {
        shouldUseBlock = true;
        patchFlag |= 1024;
        if ( true && node.children.length > 1) {
          context.onError(
            createCompilerError(46, {
              start: node.children[0].loc.start,
              end: node.children[node.children.length - 1].loc.end,
              source: ""
            })
          );
        }
      }
      const shouldBuildAsSlots = isComponent && // Teleport is not a real component and has dedicated runtime handling
      vnodeTag !== TELEPORT && // explained above.
      vnodeTag !== KEEP_ALIVE;
      if (shouldBuildAsSlots) {
        const { slots, hasDynamicSlots } = buildSlots(node, context);
        vnodeChildren = slots;
        if (hasDynamicSlots) {
          patchFlag |= 1024;
        }
      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
        const child = node.children[0];
        const type = child.type;
        const hasDynamicTextChild = type === 5 || type === 8;
        if (hasDynamicTextChild && getConstantType(child, context) === 0) {
          patchFlag |= 1;
        }
        if (hasDynamicTextChild || type === 2) {
          vnodeChildren = child;
        } else {
          vnodeChildren = node.children;
        }
      } else {
        vnodeChildren = node.children;
      }
    }
    if (dynamicPropNames && dynamicPropNames.length) {
      vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
    }
    node.codegenNode = createVNodeCall(
      context,
      vnodeTag,
      vnodeProps,
      vnodeChildren,
      patchFlag === 0 ? void 0 : patchFlag,
      vnodeDynamicProps,
      vnodeDirectives,
      !!shouldUseBlock,
      false,
      isComponent,
      node.loc
    );
  };
};
function resolveComponentType(node, context, ssr = false) {
  let { tag } = node;
  const isExplicitDynamic = isComponentTag(tag);
  const isProp = findProp(
    node,
    "is",
    false,
    true
    /* allow empty */
  );
  if (isProp) {
    if (isExplicitDynamic || isCompatEnabled(
      "COMPILER_IS_ON_ELEMENT",
      context
    )) {
      let exp;
      if (isProp.type === 6) {
        exp = isProp.value && createSimpleExpression(isProp.value.content, true);
      } else {
        exp = isProp.exp;
        if (!exp) {
          exp = createSimpleExpression(`is`, false, isProp.arg.loc);
        }
      }
      if (exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
          exp
        ]);
      }
    } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
      tag = isProp.value.content.slice(4);
    }
  }
  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
  if (builtIn) {
    if (!ssr) context.helper(builtIn);
    return builtIn;
  }
  context.helper(RESOLVE_COMPONENT);
  context.components.add(tag);
  return toValidAssetId(tag, `component`);
}
function buildProps(node, context, props = node.props, isComponent, isDynamicComponent, ssr = false) {
  const { tag, loc: elementLoc, children } = node;
  let properties = [];
  const mergeArgs = [];
  const runtimeDirectives = [];
  const hasChildren = children.length > 0;
  let shouldUseBlock = false;
  let patchFlag = 0;
  let hasRef = false;
  let hasClassBinding = false;
  let hasStyleBinding = false;
  let hasHydrationEventBinding = false;
  let hasDynamicKeys = false;
  let hasVnodeHook = false;
  const dynamicPropNames = [];
  const pushMergeArg = (arg) => {
    if (properties.length) {
      mergeArgs.push(
        createObjectExpression(dedupeProperties(properties), elementLoc)
      );
      properties = [];
    }
    if (arg) mergeArgs.push(arg);
  };
  const pushRefVForMarker = () => {
    if (context.scopes.vFor > 0) {
      properties.push(
        createObjectProperty(
          createSimpleExpression("ref_for", true),
          createSimpleExpression("true")
        )
      );
    }
  };
  const analyzePatchFlag = ({ key, value }) => {
    if (isStaticExp(key)) {
      const name = key.content;
      const isEventHandler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(name);
      if (isEventHandler && (!isComponent || isDynamicComponent) && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      name.toLowerCase() !== "onclick" && // omit v-model handlers
      name !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
      !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isReservedProp)(name)) {
        hasHydrationEventBinding = true;
      }
      if (isEventHandler && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isReservedProp)(name)) {
        hasVnodeHook = true;
      }
      if (isEventHandler && value.type === 14) {
        value = value.arguments[0];
      }
      if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
        return;
      }
      if (name === "ref") {
        hasRef = true;
      } else if (name === "class") {
        hasClassBinding = true;
      } else if (name === "style") {
        hasStyleBinding = true;
      } else if (name !== "key" && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
      if (isComponent && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
    } else {
      hasDynamicKeys = true;
    }
  };
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (prop.type === 6) {
      const { loc, name, nameLoc, value } = prop;
      let isStatic = true;
      if (name === "ref") {
        hasRef = true;
        pushRefVForMarker();
      }
      if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      ))) {
        continue;
      }
      properties.push(
        createObjectProperty(
          createSimpleExpression(name, true, nameLoc),
          createSimpleExpression(
            value ? value.content : "",
            isStatic,
            value ? value.loc : loc
          )
        )
      );
    } else {
      const { name, arg, exp, loc, modifiers } = prop;
      const isVBind = name === "bind";
      const isVOn = name === "on";
      if (name === "slot") {
        if (!isComponent) {
          context.onError(
            createCompilerError(40, loc)
          );
        }
        continue;
      }
      if (name === "once" || name === "memo") {
        continue;
      }
      if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      ))) {
        continue;
      }
      if (isVOn && ssr) {
        continue;
      }
      if (
        // #938: elements with dynamic keys should be forced into blocks
        isVBind && isStaticArgOf(arg, "key") || // inline before-update hooks need to force block so that it is invoked
        // before children
        isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")
      ) {
        shouldUseBlock = true;
      }
      if (isVBind && isStaticArgOf(arg, "ref")) {
        pushRefVForMarker();
      }
      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;
        if (exp) {
          if (isVBind) {
            pushRefVForMarker();
            pushMergeArg();
            {
              if (true) {
                const hasOverridableKeys = mergeArgs.some((arg2) => {
                  if (arg2.type === 15) {
                    return arg2.properties.some(({ key }) => {
                      if (key.type !== 4 || !key.isStatic) {
                        return true;
                      }
                      return key.content !== "class" && key.content !== "style" && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(key.content);
                    });
                  } else {
                    return true;
                  }
                });
                if (hasOverridableKeys) {
                  checkCompatEnabled(
                    "COMPILER_V_BIND_OBJECT_ORDER",
                    context,
                    loc
                  );
                }
              }
              if (isCompatEnabled(
                "COMPILER_V_BIND_OBJECT_ORDER",
                context
              )) {
                mergeArgs.unshift(exp);
                continue;
              }
            }
            mergeArgs.push(exp);
          } else {
            pushMergeArg({
              type: 14,
              loc,
              callee: context.helper(TO_HANDLERS),
              arguments: isComponent ? [exp] : [exp, `true`]
            });
          }
        } else {
          context.onError(
            createCompilerError(
              isVBind ? 34 : 35,
              loc
            )
          );
        }
        continue;
      }
      if (isVBind && modifiers.some((mod) => mod.content === "prop")) {
        patchFlag |= 32;
      }
      const directiveTransform = context.directiveTransforms[name];
      if (directiveTransform) {
        const { props: props2, needRuntime } = directiveTransform(prop, node, context);
        !ssr && props2.forEach(analyzePatchFlag);
        if (isVOn && arg && !isStaticExp(arg)) {
          pushMergeArg(createObjectExpression(props2, elementLoc));
        } else {
          properties.push(...props2);
        }
        if (needRuntime) {
          runtimeDirectives.push(prop);
          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(needRuntime)) {
            directiveImportMap.set(prop, needRuntime);
          }
        }
      } else if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isBuiltInDirective)(name)) {
        runtimeDirectives.push(prop);
        if (hasChildren) {
          shouldUseBlock = true;
        }
      }
    }
  }
  let propsExpression = void 0;
  if (mergeArgs.length) {
    pushMergeArg();
    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(
        context.helper(MERGE_PROPS),
        mergeArgs,
        elementLoc
      );
    } else {
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(
      dedupeProperties(properties),
      elementLoc
    );
  }
  if (hasDynamicKeys) {
    patchFlag |= 16;
  } else {
    if (hasClassBinding && !isComponent) {
      patchFlag |= 2;
    }
    if (hasStyleBinding && !isComponent) {
      patchFlag |= 4;
    }
    if (dynamicPropNames.length) {
      patchFlag |= 8;
    }
    if (hasHydrationEventBinding) {
      patchFlag |= 32;
    }
  }
  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
    patchFlag |= 512;
  }
  if (!context.inSSR && propsExpression) {
    switch (propsExpression.type) {
      case 15:
        let classKeyIndex = -1;
        let styleKeyIndex = -1;
        let hasDynamicKey = false;
        for (let i = 0; i < propsExpression.properties.length; i++) {
          const key = propsExpression.properties[i].key;
          if (isStaticExp(key)) {
            if (key.content === "class") {
              classKeyIndex = i;
            } else if (key.content === "style") {
              styleKeyIndex = i;
            }
          } else if (!key.isHandlerKey) {
            hasDynamicKey = true;
          }
        }
        const classProp = propsExpression.properties[classKeyIndex];
        const styleProp = propsExpression.properties[styleKeyIndex];
        if (!hasDynamicKey) {
          if (classProp && !isStaticExp(classProp.value)) {
            classProp.value = createCallExpression(
              context.helper(NORMALIZE_CLASS),
              [classProp.value]
            );
          }
          if (styleProp && // the static style is compiled into an object,
          // so use `hasStyleBinding` to ensure that it is a dynamic style binding
          (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || // v-bind:style and style both exist,
          // v-bind:style with static literal object
          styleProp.value.type === 17)) {
            styleProp.value = createCallExpression(
              context.helper(NORMALIZE_STYLE),
              [styleProp.value]
            );
          }
        } else {
          propsExpression = createCallExpression(
            context.helper(NORMALIZE_PROPS),
            [propsExpression]
          );
        }
        break;
      case 14:
        break;
      default:
        propsExpression = createCallExpression(
          context.helper(NORMALIZE_PROPS),
          [
            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
              propsExpression
            ])
          ]
        );
        break;
    }
  }
  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag,
    dynamicPropNames,
    shouldUseBlock
  };
}
function dedupeProperties(properties) {
  const knownProps = /* @__PURE__ */ new Map();
  const deduped = [];
  for (let i = 0; i < properties.length; i++) {
    const prop = properties[i];
    if (prop.key.type === 8 || !prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }
    const name = prop.key.content;
    const existing = knownProps.get(name);
    if (existing) {
      if (name === "style" || name === "class" || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(name)) {
        mergeAsArray(existing, prop);
      }
    } else {
      knownProps.set(name, prop);
      deduped.push(prop);
    }
  }
  return deduped;
}
function mergeAsArray(existing, incoming) {
  if (existing.value.type === 17) {
    existing.value.elements.push(incoming.value);
  } else {
    existing.value = createArrayExpression(
      [existing.value, incoming.value],
      existing.loc
    );
  }
}
function buildDirectiveArgs(dir, context) {
  const dirArgs = [];
  const runtime = directiveImportMap.get(dir);
  if (runtime) {
    dirArgs.push(context.helperString(runtime));
  } else {
    {
      context.helper(RESOLVE_DIRECTIVE);
      context.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, `directive`));
    }
  }
  const { loc } = dir;
  if (dir.exp) dirArgs.push(dir.exp);
  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push(`void 0`);
    }
    dirArgs.push(dir.arg);
  }
  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(`void 0`);
    }
    const trueExpression = createSimpleExpression(`true`, false, loc);
    dirArgs.push(
      createObjectExpression(
        dir.modifiers.map(
          (modifier) => createObjectProperty(modifier, trueExpression)
        ),
        loc
      )
    );
  }
  return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
  let propsNamesString = `[`;
  for (let i = 0, l = props.length; i < l; i++) {
    propsNamesString += JSON.stringify(props[i]);
    if (i < l - 1) propsNamesString += ", ";
  }
  return propsNamesString + `]`;
}
function isComponentTag(tag) {
  return tag === "component" || tag === "Component";
}

const transformSlotOutlet = (node, context) => {
  if (isSlotOutlet(node)) {
    const { children, loc } = node;
    const { slotName, slotProps } = processSlotOutlet(node, context);
    const slotArgs = [
      context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
      slotName,
      "{}",
      "undefined",
      "true"
    ];
    let expectedLen = 2;
    if (slotProps) {
      slotArgs[2] = slotProps;
      expectedLen = 3;
    }
    if (children.length) {
      slotArgs[3] = createFunctionExpression([], children, false, false, loc);
      expectedLen = 4;
    }
    if (context.scopeId && !context.slotted) {
      expectedLen = 5;
    }
    slotArgs.splice(expectedLen);
    node.codegenNode = createCallExpression(
      context.helper(RENDER_SLOT),
      slotArgs,
      loc
    );
  }
};
function processSlotOutlet(node, context) {
  let slotName = `"default"`;
  let slotProps = void 0;
  const nonNameProps = [];
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (p.value) {
        if (p.name === "name") {
          slotName = JSON.stringify(p.value.content);
        } else {
          p.name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(p.name);
          nonNameProps.push(p);
        }
      }
    } else {
      if (p.name === "bind" && isStaticArgOf(p.arg, "name")) {
        if (p.exp) {
          slotName = p.exp;
        } else if (p.arg && p.arg.type === 4) {
          const name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(p.arg.content);
          slotName = p.exp = createSimpleExpression(name, false, p.arg.loc);
        }
      } else {
        if (p.name === "bind" && p.arg && isStaticExp(p.arg)) {
          p.arg.content = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(p.arg.content);
        }
        nonNameProps.push(p);
      }
    }
  }
  if (nonNameProps.length > 0) {
    const { props, directives } = buildProps(
      node,
      context,
      nonNameProps,
      false,
      false
    );
    slotProps = props;
    if (directives.length) {
      context.onError(
        createCompilerError(
          36,
          directives[0].loc
        )
      );
    }
  }
  return {
    slotName,
    slotProps
  };
}

const transformOn = (dir, node, context, augmentor) => {
  const { loc, modifiers, arg } = dir;
  if (!dir.exp && !modifiers.length) {
    context.onError(createCompilerError(35, loc));
  }
  let eventName;
  if (arg.type === 4) {
    if (arg.isStatic) {
      let rawName = arg.content;
      if ( true && rawName.startsWith("vnode")) {
        context.onError(createCompilerError(51, arg.loc));
      }
      if (rawName.startsWith("vue:")) {
        rawName = `vnode-${rawName.slice(4)}`;
      }
      const eventString = node.tagType !== 0 || rawName.startsWith("vnode") || !/[A-Z]/.test(rawName) ? (
        // for non-element and vnode lifecycle event listeners, auto convert
        // it to camelCase. See issue #2249
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(rawName))
      ) : (
        // preserve case for plain element listeners that have uppercase
        // letters, as these may be custom elements' custom events
        `on:${rawName}`
      );
      eventName = createSimpleExpression(eventString, true, arg.loc);
    } else {
      eventName = createCompoundExpression([
        `${context.helperString(TO_HANDLER_KEY)}(`,
        arg,
        `)`
      ]);
    }
  } else {
    eventName = arg;
    eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
    eventName.children.push(`)`);
  }
  let exp = dir.exp;
  if (exp && !exp.content.trim()) {
    exp = void 0;
  }
  let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
  if (exp) {
    const isMemberExp = isMemberExpression(exp);
    const isInlineStatement = !(isMemberExp || isFnExpression(exp));
    const hasMultipleStatements = exp.content.includes(`;`);
    if (true) {
      validateBrowserExpression(
        exp,
        context,
        false,
        hasMultipleStatements
      );
    }
    if (isInlineStatement || shouldCache && isMemberExp) {
      exp = createCompoundExpression([
        `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
        exp,
        hasMultipleStatements ? `}` : `)`
      ]);
    }
  }
  let ret = {
    props: [
      createObjectProperty(
        eventName,
        exp || createSimpleExpression(`() => {}`, false, loc)
      )
    ]
  };
  if (augmentor) {
    ret = augmentor(ret);
  }
  if (shouldCache) {
    ret.props[0].value = context.cache(ret.props[0].value);
  }
  ret.props.forEach((p) => p.key.isHandlerKey = true);
  return ret;
};

const transformText = (node, context) => {
  if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
    return () => {
      const children = node.children;
      let currentContainer = void 0;
      let hasText = false;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isText$1(child)) {
          hasText = true;
          for (let j = i + 1; j < children.length; j++) {
            const next = children[j];
            if (isText$1(next)) {
              if (!currentContainer) {
                currentContainer = children[i] = createCompoundExpression(
                  [child],
                  child.loc
                );
              }
              currentContainer.children.push(` + `, next);
              children.splice(j, 1);
              j--;
            } else {
              currentContainer = void 0;
              break;
            }
          }
        }
      }
      if (!hasText || // if this is a plain element with a single text child, leave it
      // as-is since the runtime has dedicated fast path for this by directly
      // setting textContent of the element.
      // for component root it's always normalized anyway.
      children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && // #3756
      // custom directives can potentially add DOM elements arbitrarily,
      // we need to avoid setting textContent of the element at runtime
      // to avoid accidentally overwriting the DOM elements added
      // by the user through custom directives.
      !node.props.find(
        (p) => p.type === 7 && !context.directiveTransforms[p.name]
      ) && // in compat mode, <template> tags with no special directives
      // will be rendered as a fragment so its children must be
      // converted into vnodes.
      !(node.tag === "template"))) {
        return;
      }
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isText$1(child) || child.type === 8) {
          const callArgs = [];
          if (child.type !== 2 || child.content !== " ") {
            callArgs.push(child);
          }
          if (!context.ssr && getConstantType(child, context) === 0) {
            callArgs.push(
              1 + ( true ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[1]} */` : 0)
            );
          }
          children[i] = {
            type: 12,
            content: child,
            loc: child.loc,
            codegenNode: createCallExpression(
              context.helper(CREATE_TEXT),
              callArgs
            )
          };
        }
      }
    };
  }
};

const seen$1 = /* @__PURE__ */ new WeakSet();
const transformOnce = (node, context) => {
  if (node.type === 1 && findDir(node, "once", true)) {
    if (seen$1.has(node) || context.inVOnce || context.inSSR) {
      return;
    }
    seen$1.add(node);
    context.inVOnce = true;
    context.helper(SET_BLOCK_TRACKING);
    return () => {
      context.inVOnce = false;
      const cur = context.currentNode;
      if (cur.codegenNode) {
        cur.codegenNode = context.cache(
          cur.codegenNode,
          true,
          true
        );
      }
    };
  }
};

const transformModel = (dir, node, context) => {
  const { exp, arg } = dir;
  if (!exp) {
    context.onError(
      createCompilerError(41, dir.loc)
    );
    return createTransformProps();
  }
  const rawExp = exp.loc.source.trim();
  const expString = exp.type === 4 ? exp.content : rawExp;
  const bindingType = context.bindingMetadata[rawExp];
  if (bindingType === "props" || bindingType === "props-aliased") {
    context.onError(createCompilerError(44, exp.loc));
    return createTransformProps();
  }
  const maybeRef = false;
  if (!expString.trim() || !isMemberExpression(exp) && !maybeRef) {
    context.onError(
      createCompilerError(42, exp.loc)
    );
    return createTransformProps();
  }
  const propName = arg ? arg : createSimpleExpression("modelValue", true);
  const eventName = arg ? isStaticExp(arg) ? `onUpdate:${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(arg.content)}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
  let assignmentExp;
  const eventArg = context.isTS ? `($event: any)` : `$event`;
  {
    assignmentExp = createCompoundExpression([
      `${eventArg} => ((`,
      exp,
      `) = $event)`
    ]);
  }
  const props = [
    // modelValue: foo
    createObjectProperty(propName, dir.exp),
    // "onUpdate:modelValue": $event => (foo = $event)
    createObjectProperty(eventName, assignmentExp)
  ];
  if (dir.modifiers.length && node.tagType === 1) {
    const modifiers = dir.modifiers.map((m) => m.content).map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
    const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
    props.push(
      createObjectProperty(
        modifiersKey,
        createSimpleExpression(
          `{ ${modifiers} }`,
          false,
          dir.loc,
          2
        )
      )
    );
  }
  return createTransformProps(props);
};
function createTransformProps(props = []) {
  return { props };
}

const validDivisionCharRE = /[\w).+\-_$\]]/;
const transformFilter = (node, context) => {
  if (!isCompatEnabled("COMPILER_FILTERS", context)) {
    return;
  }
  if (node.type === 5) {
    rewriteFilter(node.content, context);
  } else if (node.type === 1) {
    node.props.forEach((prop) => {
      if (prop.type === 7 && prop.name !== "for" && prop.exp) {
        rewriteFilter(prop.exp, context);
      }
    });
  }
};
function rewriteFilter(node, context) {
  if (node.type === 4) {
    parseFilter(node, context);
  } else {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if (typeof child !== "object") continue;
      if (child.type === 4) {
        parseFilter(child, context);
      } else if (child.type === 8) {
        rewriteFilter(node, context);
      } else if (child.type === 5) {
        rewriteFilter(child.content, context);
      }
    }
  }
}
function parseFilter(node, context) {
  const exp = node.content;
  let inSingle = false;
  let inDouble = false;
  let inTemplateString = false;
  let inRegex = false;
  let curly = 0;
  let square = 0;
  let paren = 0;
  let lastFilterIndex = 0;
  let c, prev, i, expression, filters = [];
  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 39 && prev !== 92) inSingle = false;
    } else if (inDouble) {
      if (c === 34 && prev !== 92) inDouble = false;
    } else if (inTemplateString) {
      if (c === 96 && prev !== 92) inTemplateString = false;
    } else if (inRegex) {
      if (c === 47 && prev !== 92) inRegex = false;
    } else if (c === 124 && // pipe
    exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
      if (expression === void 0) {
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 34:
          inDouble = true;
          break;
        // "
        case 39:
          inSingle = true;
          break;
        // '
        case 96:
          inTemplateString = true;
          break;
        // `
        case 40:
          paren++;
          break;
        // (
        case 41:
          paren--;
          break;
        // )
        case 91:
          square++;
          break;
        // [
        case 93:
          square--;
          break;
        // ]
        case 123:
          curly++;
          break;
        // {
        case 125:
          curly--;
          break;
      }
      if (c === 47) {
        let j = i - 1;
        let p;
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== " ") break;
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }
  if (expression === void 0) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }
  function pushFilter() {
    filters.push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }
  if (filters.length) {
     true && warnDeprecation(
      "COMPILER_FILTERS",
      context,
      node.loc
    );
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i], context);
    }
    node.content = expression;
    node.ast = void 0;
  }
}
function wrapFilter(exp, filter, context) {
  context.helper(RESOLVE_FILTER);
  const i = filter.indexOf("(");
  if (i < 0) {
    context.filters.add(filter);
    return `${toValidAssetId(filter, "filter")}(${exp})`;
  } else {
    const name = filter.slice(0, i);
    const args = filter.slice(i + 1);
    context.filters.add(name);
    return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
  }
}

const seen = /* @__PURE__ */ new WeakSet();
const transformMemo = (node, context) => {
  if (node.type === 1) {
    const dir = findDir(node, "memo");
    if (!dir || seen.has(node)) {
      return;
    }
    seen.add(node);
    return () => {
      const codegenNode = node.codegenNode || context.currentNode.codegenNode;
      if (codegenNode && codegenNode.type === 13) {
        if (node.tagType !== 1) {
          convertToBlock(codegenNode, context);
        }
        node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
          dir.exp,
          createFunctionExpression(void 0, codegenNode),
          `_cache`,
          String(context.cached.length)
        ]);
        context.cached.push(null);
      }
    };
  }
};

function getBaseTransformPreset(prefixIdentifiers) {
  return [
    [
      transformOnce,
      transformIf,
      transformMemo,
      transformFor,
      ...[transformFilter] ,
      ... true ? [transformExpression] : 0,
      transformSlotOutlet,
      transformElement,
      trackSlotScopes,
      transformText
    ],
    {
      on: transformOn,
      bind: transformBind,
      model: transformModel
    }
  ];
}
function baseCompile(source, options = {}) {
  const onError = options.onError || defaultOnError;
  const isModuleMode = options.mode === "module";
  {
    if (options.prefixIdentifiers === true) {
      onError(createCompilerError(47));
    } else if (isModuleMode) {
      onError(createCompilerError(48));
    }
  }
  const prefixIdentifiers = false;
  if (options.cacheHandlers) {
    onError(createCompilerError(49));
  }
  if (options.scopeId && !isModuleMode) {
    onError(createCompilerError(50));
  }
  const resolvedOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, {
    prefixIdentifiers
  });
  const ast = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(source) ? baseParse(source, resolvedOptions) : source;
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
  transform(
    ast,
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, resolvedOptions, {
      nodeTransforms: [
        ...nodeTransforms,
        ...options.nodeTransforms || []
        // user transforms
      ],
      directiveTransforms: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(
        {},
        directiveTransforms,
        options.directiveTransforms || {}
        // user transforms
      )
    })
  );
  return generate(ast, resolvedOptions);
}

const BindingTypes = {
  "DATA": "data",
  "PROPS": "props",
  "PROPS_ALIASED": "props-aliased",
  "SETUP_LET": "setup-let",
  "SETUP_CONST": "setup-const",
  "SETUP_REACTIVE_CONST": "setup-reactive-const",
  "SETUP_MAYBE_REF": "setup-maybe-ref",
  "SETUP_REF": "setup-ref",
  "OPTIONS": "options",
  "LITERAL_CONST": "literal-const"
};

const noopDirectiveTransform = () => ({ props: [] });




/***/ }),

/***/ "./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BASE_TRANSITION: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.BASE_TRANSITION),
/* harmony export */   BindingTypes: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.BindingTypes),
/* harmony export */   CAMELIZE: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CAMELIZE),
/* harmony export */   CAPITALIZE: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CAPITALIZE),
/* harmony export */   CREATE_BLOCK: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_BLOCK),
/* harmony export */   CREATE_COMMENT: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_COMMENT),
/* harmony export */   CREATE_ELEMENT_BLOCK: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_ELEMENT_BLOCK),
/* harmony export */   CREATE_ELEMENT_VNODE: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_ELEMENT_VNODE),
/* harmony export */   CREATE_SLOTS: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_SLOTS),
/* harmony export */   CREATE_STATIC: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_STATIC),
/* harmony export */   CREATE_TEXT: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_TEXT),
/* harmony export */   CREATE_VNODE: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_VNODE),
/* harmony export */   CompilerDeprecationTypes: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CompilerDeprecationTypes),
/* harmony export */   ConstantTypes: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.ConstantTypes),
/* harmony export */   DOMDirectiveTransforms: () => (/* binding */ DOMDirectiveTransforms),
/* harmony export */   DOMErrorCodes: () => (/* binding */ DOMErrorCodes),
/* harmony export */   DOMErrorMessages: () => (/* binding */ DOMErrorMessages),
/* harmony export */   DOMNodeTransforms: () => (/* binding */ DOMNodeTransforms),
/* harmony export */   ElementTypes: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.ElementTypes),
/* harmony export */   ErrorCodes: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.ErrorCodes),
/* harmony export */   FRAGMENT: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.FRAGMENT),
/* harmony export */   GUARD_REACTIVE_PROPS: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.GUARD_REACTIVE_PROPS),
/* harmony export */   IS_MEMO_SAME: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.IS_MEMO_SAME),
/* harmony export */   IS_REF: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.IS_REF),
/* harmony export */   KEEP_ALIVE: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.KEEP_ALIVE),
/* harmony export */   MERGE_PROPS: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.MERGE_PROPS),
/* harmony export */   NORMALIZE_CLASS: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_CLASS),
/* harmony export */   NORMALIZE_PROPS: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_PROPS),
/* harmony export */   NORMALIZE_STYLE: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_STYLE),
/* harmony export */   Namespaces: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.Namespaces),
/* harmony export */   NodeTypes: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NodeTypes),
/* harmony export */   OPEN_BLOCK: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.OPEN_BLOCK),
/* harmony export */   POP_SCOPE_ID: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.POP_SCOPE_ID),
/* harmony export */   PUSH_SCOPE_ID: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.PUSH_SCOPE_ID),
/* harmony export */   RENDER_LIST: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RENDER_LIST),
/* harmony export */   RENDER_SLOT: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RENDER_SLOT),
/* harmony export */   RESOLVE_COMPONENT: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_COMPONENT),
/* harmony export */   RESOLVE_DIRECTIVE: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_DIRECTIVE),
/* harmony export */   RESOLVE_DYNAMIC_COMPONENT: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_DYNAMIC_COMPONENT),
/* harmony export */   RESOLVE_FILTER: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_FILTER),
/* harmony export */   SET_BLOCK_TRACKING: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.SET_BLOCK_TRACKING),
/* harmony export */   SUSPENSE: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.SUSPENSE),
/* harmony export */   TELEPORT: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TELEPORT),
/* harmony export */   TO_DISPLAY_STRING: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_DISPLAY_STRING),
/* harmony export */   TO_HANDLERS: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_HANDLERS),
/* harmony export */   TO_HANDLER_KEY: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_HANDLER_KEY),
/* harmony export */   TRANSITION: () => (/* binding */ TRANSITION),
/* harmony export */   TRANSITION_GROUP: () => (/* binding */ TRANSITION_GROUP),
/* harmony export */   TS_NODE_TYPES: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TS_NODE_TYPES),
/* harmony export */   UNREF: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.UNREF),
/* harmony export */   V_MODEL_CHECKBOX: () => (/* binding */ V_MODEL_CHECKBOX),
/* harmony export */   V_MODEL_DYNAMIC: () => (/* binding */ V_MODEL_DYNAMIC),
/* harmony export */   V_MODEL_RADIO: () => (/* binding */ V_MODEL_RADIO),
/* harmony export */   V_MODEL_SELECT: () => (/* binding */ V_MODEL_SELECT),
/* harmony export */   V_MODEL_TEXT: () => (/* binding */ V_MODEL_TEXT),
/* harmony export */   V_ON_WITH_KEYS: () => (/* binding */ V_ON_WITH_KEYS),
/* harmony export */   V_ON_WITH_MODIFIERS: () => (/* binding */ V_ON_WITH_MODIFIERS),
/* harmony export */   V_SHOW: () => (/* binding */ V_SHOW),
/* harmony export */   WITH_CTX: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_CTX),
/* harmony export */   WITH_DIRECTIVES: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_DIRECTIVES),
/* harmony export */   WITH_MEMO: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_MEMO),
/* harmony export */   advancePositionWithClone: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.advancePositionWithClone),
/* harmony export */   advancePositionWithMutation: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.advancePositionWithMutation),
/* harmony export */   assert: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.assert),
/* harmony export */   baseCompile: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseCompile),
/* harmony export */   baseParse: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseParse),
/* harmony export */   buildDirectiveArgs: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildDirectiveArgs),
/* harmony export */   buildProps: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildProps),
/* harmony export */   buildSlots: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildSlots),
/* harmony export */   checkCompatEnabled: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.checkCompatEnabled),
/* harmony export */   compile: () => (/* binding */ compile),
/* harmony export */   convertToBlock: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.convertToBlock),
/* harmony export */   createArrayExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createArrayExpression),
/* harmony export */   createAssignmentExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createAssignmentExpression),
/* harmony export */   createBlockStatement: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createBlockStatement),
/* harmony export */   createCacheExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCacheExpression),
/* harmony export */   createCallExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression),
/* harmony export */   createCompilerError: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompilerError),
/* harmony export */   createCompoundExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression),
/* harmony export */   createConditionalExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createConditionalExpression),
/* harmony export */   createDOMCompilerError: () => (/* binding */ createDOMCompilerError),
/* harmony export */   createForLoopParams: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createForLoopParams),
/* harmony export */   createFunctionExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createFunctionExpression),
/* harmony export */   createIfStatement: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createIfStatement),
/* harmony export */   createInterpolation: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createInterpolation),
/* harmony export */   createObjectExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectExpression),
/* harmony export */   createObjectProperty: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty),
/* harmony export */   createReturnStatement: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createReturnStatement),
/* harmony export */   createRoot: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createRoot),
/* harmony export */   createSequenceExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSequenceExpression),
/* harmony export */   createSimpleExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression),
/* harmony export */   createStructuralDirectiveTransform: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createStructuralDirectiveTransform),
/* harmony export */   createTemplateLiteral: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createTemplateLiteral),
/* harmony export */   createTransformContext: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createTransformContext),
/* harmony export */   createVNodeCall: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createVNodeCall),
/* harmony export */   errorMessages: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.errorMessages),
/* harmony export */   extractIdentifiers: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.extractIdentifiers),
/* harmony export */   findDir: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findDir),
/* harmony export */   findProp: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp),
/* harmony export */   forAliasRE: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.forAliasRE),
/* harmony export */   generate: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.generate),
/* harmony export */   generateCodeFrame: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.generateCodeFrame),
/* harmony export */   getBaseTransformPreset: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getBaseTransformPreset),
/* harmony export */   getConstantType: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getConstantType),
/* harmony export */   getMemoedVNodeCall: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getMemoedVNodeCall),
/* harmony export */   getVNodeBlockHelper: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getVNodeBlockHelper),
/* harmony export */   getVNodeHelper: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getVNodeHelper),
/* harmony export */   hasDynamicKeyVBind: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasDynamicKeyVBind),
/* harmony export */   hasScopeRef: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasScopeRef),
/* harmony export */   helperNameMap: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.helperNameMap),
/* harmony export */   injectProp: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.injectProp),
/* harmony export */   isCoreComponent: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isCoreComponent),
/* harmony export */   isFnExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isFnExpression),
/* harmony export */   isFnExpressionBrowser: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isFnExpressionBrowser),
/* harmony export */   isFnExpressionNode: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isFnExpressionNode),
/* harmony export */   isFunctionType: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isFunctionType),
/* harmony export */   isInDestructureAssignment: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isInDestructureAssignment),
/* harmony export */   isInNewExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isInNewExpression),
/* harmony export */   isMemberExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpression),
/* harmony export */   isMemberExpressionBrowser: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpressionBrowser),
/* harmony export */   isMemberExpressionNode: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpressionNode),
/* harmony export */   isReferencedIdentifier: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isReferencedIdentifier),
/* harmony export */   isSimpleIdentifier: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isSimpleIdentifier),
/* harmony export */   isSlotOutlet: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isSlotOutlet),
/* harmony export */   isStaticArgOf: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticArgOf),
/* harmony export */   isStaticExp: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp),
/* harmony export */   isStaticProperty: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticProperty),
/* harmony export */   isStaticPropertyKey: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticPropertyKey),
/* harmony export */   isTemplateNode: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isTemplateNode),
/* harmony export */   isText: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isText),
/* harmony export */   isVSlot: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isVSlot),
/* harmony export */   locStub: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.locStub),
/* harmony export */   noopDirectiveTransform: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.noopDirectiveTransform),
/* harmony export */   parse: () => (/* binding */ parse),
/* harmony export */   parserOptions: () => (/* binding */ parserOptions),
/* harmony export */   processExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processExpression),
/* harmony export */   processFor: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processFor),
/* harmony export */   processIf: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processIf),
/* harmony export */   processSlotOutlet: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processSlotOutlet),
/* harmony export */   registerRuntimeHelpers: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeHelpers),
/* harmony export */   resolveComponentType: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponentType),
/* harmony export */   stringifyExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.stringifyExpression),
/* harmony export */   toValidAssetId: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.toValidAssetId),
/* harmony export */   trackSlotScopes: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.trackSlotScopes),
/* harmony export */   trackVForSlotScopes: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.trackVForSlotScopes),
/* harmony export */   transform: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transform),
/* harmony export */   transformBind: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformBind),
/* harmony export */   transformElement: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformElement),
/* harmony export */   transformExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformExpression),
/* harmony export */   transformModel: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformModel),
/* harmony export */   transformOn: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformOn),
/* harmony export */   transformStyle: () => (/* binding */ transformStyle),
/* harmony export */   traverseNode: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.traverseNode),
/* harmony export */   unwrapTSNode: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.unwrapTSNode),
/* harmony export */   walkBlockDeclarations: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkBlockDeclarations),
/* harmony export */   walkFunctionParams: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkFunctionParams),
/* harmony export */   walkIdentifiers: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkIdentifiers),
/* harmony export */   warnDeprecation: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.warnDeprecation)
/* harmony export */ });
/* harmony import */ var _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/compiler-core */ "./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
/**
* @vue/compiler-dom v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/




const V_MODEL_RADIO = Symbol( true ? `vModelRadio` : 0);
const V_MODEL_CHECKBOX = Symbol(
   true ? `vModelCheckbox` : 0
);
const V_MODEL_TEXT = Symbol( true ? `vModelText` : 0);
const V_MODEL_SELECT = Symbol(
   true ? `vModelSelect` : 0
);
const V_MODEL_DYNAMIC = Symbol(
   true ? `vModelDynamic` : 0
);
const V_ON_WITH_MODIFIERS = Symbol(
   true ? `vOnModifiersGuard` : 0
);
const V_ON_WITH_KEYS = Symbol(
   true ? `vOnKeysGuard` : 0
);
const V_SHOW = Symbol( true ? `vShow` : 0);
const TRANSITION = Symbol( true ? `Transition` : 0);
const TRANSITION_GROUP = Symbol(
   true ? `TransitionGroup` : 0
);
(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeHelpers)({
  [V_MODEL_RADIO]: `vModelRadio`,
  [V_MODEL_CHECKBOX]: `vModelCheckbox`,
  [V_MODEL_TEXT]: `vModelText`,
  [V_MODEL_SELECT]: `vModelSelect`,
  [V_MODEL_DYNAMIC]: `vModelDynamic`,
  [V_ON_WITH_MODIFIERS]: `withModifiers`,
  [V_ON_WITH_KEYS]: `withKeys`,
  [V_SHOW]: `vShow`,
  [TRANSITION]: `Transition`,
  [TRANSITION_GROUP]: `TransitionGroup`
});

let decoder;
function decodeHtmlBrowser(raw, asAttr = false) {
  if (!decoder) {
    decoder = document.createElement("div");
  }
  if (asAttr) {
    decoder.innerHTML = `<div foo="${raw.replace(/"/g, "&quot;")}">`;
    return decoder.children[0].getAttribute("foo");
  } else {
    decoder.innerHTML = raw;
    return decoder.textContent;
  }
}

const parserOptions = {
  parseMode: "html",
  isVoidTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isVoidTag,
  isNativeTag: (tag) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isMathMLTag)(tag),
  isPreTag: (tag) => tag === "pre",
  isIgnoreNewlineTag: (tag) => tag === "pre" || tag === "textarea",
  decodeEntities: decodeHtmlBrowser ,
  isBuiltInComponent: (tag) => {
    if (tag === "Transition" || tag === "transition") {
      return TRANSITION;
    } else if (tag === "TransitionGroup" || tag === "transition-group") {
      return TRANSITION_GROUP;
    }
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
  getNamespace(tag, parent, rootNamespace) {
    let ns = parent ? parent.ns : rootNamespace;
    if (parent && ns === 2) {
      if (parent.tag === "annotation-xml") {
        if (tag === "svg") {
          return 1;
        }
        if (parent.props.some(
          (a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml")
        )) {
          ns = 0;
        }
      } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
        ns = 0;
      }
    } else if (parent && ns === 1) {
      if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
        ns = 0;
      }
    }
    if (ns === 0) {
      if (tag === "svg") {
        return 1;
      }
      if (tag === "math") {
        return 2;
      }
    }
    return ns;
  }
};

const transformStyle = (node) => {
  if (node.type === 1) {
    node.props.forEach((p, i) => {
      if (p.type === 6 && p.name === "style" && p.value) {
        node.props[i] = {
          type: 7,
          name: `bind`,
          arg: (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`style`, true, p.loc),
          exp: parseInlineCSS(p.value.content, p.loc),
          modifiers: [],
          loc: p.loc
        };
      }
    });
  }
};
const parseInlineCSS = (cssText, loc) => {
  const normalized = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.parseStringStyle)(cssText);
  return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(
    JSON.stringify(normalized),
    false,
    loc,
    3
  );
};

function createDOMCompilerError(code, loc) {
  return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompilerError)(
    code,
    loc,
     true ? DOMErrorMessages : 0
  );
}
const DOMErrorCodes = {
  "X_V_HTML_NO_EXPRESSION": 53,
  "53": "X_V_HTML_NO_EXPRESSION",
  "X_V_HTML_WITH_CHILDREN": 54,
  "54": "X_V_HTML_WITH_CHILDREN",
  "X_V_TEXT_NO_EXPRESSION": 55,
  "55": "X_V_TEXT_NO_EXPRESSION",
  "X_V_TEXT_WITH_CHILDREN": 56,
  "56": "X_V_TEXT_WITH_CHILDREN",
  "X_V_MODEL_ON_INVALID_ELEMENT": 57,
  "57": "X_V_MODEL_ON_INVALID_ELEMENT",
  "X_V_MODEL_ARG_ON_ELEMENT": 58,
  "58": "X_V_MODEL_ARG_ON_ELEMENT",
  "X_V_MODEL_ON_FILE_INPUT_ELEMENT": 59,
  "59": "X_V_MODEL_ON_FILE_INPUT_ELEMENT",
  "X_V_MODEL_UNNECESSARY_VALUE": 60,
  "60": "X_V_MODEL_UNNECESSARY_VALUE",
  "X_V_SHOW_NO_EXPRESSION": 61,
  "61": "X_V_SHOW_NO_EXPRESSION",
  "X_TRANSITION_INVALID_CHILDREN": 62,
  "62": "X_TRANSITION_INVALID_CHILDREN",
  "X_IGNORED_SIDE_EFFECT_TAG": 63,
  "63": "X_IGNORED_SIDE_EFFECT_TAG",
  "__EXTEND_POINT__": 64,
  "64": "__EXTEND_POINT__"
};
const DOMErrorMessages = {
  [53]: `v-html is missing expression.`,
  [54]: `v-html will override element children.`,
  [55]: `v-text is missing expression.`,
  [56]: `v-text will override element children.`,
  [57]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
  [58]: `v-model argument is not supported on plain elements.`,
  [59]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
  [60]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
  [61]: `v-show is missing expression.`,
  [62]: `<Transition> expects exactly one child element or component.`,
  [63]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
};

const transformVHtml = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(53, loc)
    );
  }
  if (node.children.length) {
    context.onError(
      createDOMCompilerError(54, loc)
    );
    node.children.length = 0;
  }
  return {
    props: [
      (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)(
        (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`innerHTML`, true, loc),
        exp || (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)("", true)
      )
    ]
  };
};

const transformVText = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(55, loc)
    );
  }
  if (node.children.length) {
    context.onError(
      createDOMCompilerError(56, loc)
    );
    node.children.length = 0;
  }
  return {
    props: [
      (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)(
        (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`textContent`, true),
        exp ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getConstantType)(exp, context) > 0 ? exp : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(
          context.helperString(_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_DISPLAY_STRING),
          [exp],
          loc
        ) : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)("", true)
      )
    ]
  };
};

const transformModel = (dir, node, context) => {
  const baseResult = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformModel)(dir, node, context);
  if (!baseResult.props.length || node.tagType === 1) {
    return baseResult;
  }
  if (dir.arg) {
    context.onError(
      createDOMCompilerError(
        58,
        dir.arg.loc
      )
    );
  }
  function checkDuplicatedValue() {
    const value = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findDir)(node, "bind");
    if (value && (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticArgOf)(value.arg, "value")) {
      context.onError(
        createDOMCompilerError(
          60,
          value.loc
        )
      );
    }
  }
  const { tag } = node;
  const isCustomElement = context.isCustomElement(tag);
  if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
    let directiveToUse = V_MODEL_TEXT;
    let isInvalidType = false;
    if (tag === "input" || isCustomElement) {
      const type = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp)(node, `type`);
      if (type) {
        if (type.type === 7) {
          directiveToUse = V_MODEL_DYNAMIC;
        } else if (type.value) {
          switch (type.value.content) {
            case "radio":
              directiveToUse = V_MODEL_RADIO;
              break;
            case "checkbox":
              directiveToUse = V_MODEL_CHECKBOX;
              break;
            case "file":
              isInvalidType = true;
              context.onError(
                createDOMCompilerError(
                  59,
                  dir.loc
                )
              );
              break;
            default:
               true && checkDuplicatedValue();
              break;
          }
        }
      } else if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasDynamicKeyVBind)(node)) {
        directiveToUse = V_MODEL_DYNAMIC;
      } else {
         true && checkDuplicatedValue();
      }
    } else if (tag === "select") {
      directiveToUse = V_MODEL_SELECT;
    } else {
       true && checkDuplicatedValue();
    }
    if (!isInvalidType) {
      baseResult.needRuntime = context.helper(directiveToUse);
    }
  } else {
    context.onError(
      createDOMCompilerError(
        57,
        dir.loc
      )
    );
  }
  baseResult.props = baseResult.props.filter(
    (p) => !(p.key.type === 4 && p.key.content === "modelValue")
  );
  return baseResult;
};

const isEventOptionModifier = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(`passive,once,capture`);
const isNonKeyModifier = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(
  // event propagation management
  `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`
);
const maybeKeyModifier = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)("left,right");
const isKeyboardEvent = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(`onkeyup,onkeydown,onkeypress`);
const resolveModifiers = (key, modifiers, context, loc) => {
  const keyModifiers = [];
  const nonKeyModifiers = [];
  const eventOptionModifiers = [];
  for (let i = 0; i < modifiers.length; i++) {
    const modifier = modifiers[i].content;
    if (modifier === "native" && (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.checkCompatEnabled)(
      "COMPILER_V_ON_NATIVE",
      context,
      loc
    )) {
      eventOptionModifiers.push(modifier);
    } else if (isEventOptionModifier(modifier)) {
      eventOptionModifiers.push(modifier);
    } else {
      if (maybeKeyModifier(modifier)) {
        if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key)) {
          if (isKeyboardEvent(key.content.toLowerCase())) {
            keyModifiers.push(modifier);
          } else {
            nonKeyModifiers.push(modifier);
          }
        } else {
          keyModifiers.push(modifier);
          nonKeyModifiers.push(modifier);
        }
      } else {
        if (isNonKeyModifier(modifier)) {
          nonKeyModifiers.push(modifier);
        } else {
          keyModifiers.push(modifier);
        }
      }
    }
  }
  return {
    keyModifiers,
    nonKeyModifiers,
    eventOptionModifiers
  };
};
const transformClick = (key, event) => {
  const isStaticClick = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) && key.content.toLowerCase() === "onclick";
  return isStaticClick ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(event, true) : key.type !== 4 ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression)([
    `(`,
    key,
    `) === "onClick" ? "${event}" : (`,
    key,
    `)`
  ]) : key;
};
const transformOn = (dir, node, context) => {
  return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformOn)(dir, node, context, (baseResult) => {
    const { modifiers } = dir;
    if (!modifiers.length) return baseResult;
    let { key, value: handlerExp } = baseResult.props[0];
    const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
    if (nonKeyModifiers.includes("right")) {
      key = transformClick(key, `onContextmenu`);
    }
    if (nonKeyModifiers.includes("middle")) {
      key = transformClick(key, `onMouseup`);
    }
    if (nonKeyModifiers.length) {
      handlerExp = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helper(V_ON_WITH_MODIFIERS), [
        handlerExp,
        JSON.stringify(nonKeyModifiers)
      ]);
    }
    if (keyModifiers.length && // if event name is dynamic, always wrap with keys guard
    (!(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) || isKeyboardEvent(key.content.toLowerCase()))) {
      handlerExp = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helper(V_ON_WITH_KEYS), [
        handlerExp,
        JSON.stringify(keyModifiers)
      ]);
    }
    if (eventOptionModifiers.length) {
      const modifierPostfix = eventOptionModifiers.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join("");
      key = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`${key.content}${modifierPostfix}`, true) : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression)([`(`, key, `) + "${modifierPostfix}"`]);
    }
    return {
      props: [(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)(key, handlerExp)]
    };
  });
};

const transformShow = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(61, loc)
    );
  }
  return {
    props: [],
    needRuntime: context.helper(V_SHOW)
  };
};

const transformTransition = (node, context) => {
  if (node.type === 1 && node.tagType === 1) {
    const component = context.isBuiltInComponent(node.tag);
    if (component === TRANSITION) {
      return () => {
        if (!node.children.length) {
          return;
        }
        if (hasMultipleChildren(node)) {
          context.onError(
            createDOMCompilerError(
              62,
              {
                start: node.children[0].loc.start,
                end: node.children[node.children.length - 1].loc.end,
                source: ""
              }
            )
          );
        }
        const child = node.children[0];
        if (child.type === 1) {
          for (const p of child.props) {
            if (p.type === 7 && p.name === "show") {
              node.props.push({
                type: 6,
                name: "persisted",
                nameLoc: node.loc,
                value: void 0,
                loc: node.loc
              });
            }
          }
        }
      };
    }
  }
};
function hasMultipleChildren(node) {
  const children = node.children = node.children.filter(
    (c) => c.type !== 3 && !(c.type === 2 && !c.content.trim())
  );
  const child = children[0];
  return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
}

const ignoreSideEffectTags = (node, context) => {
  if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
     true && context.onError(
      createDOMCompilerError(
        63,
        node.loc
      )
    );
    context.removeNode();
  }
};

function isValidHTMLNesting(parent, child) {
  if (parent in onlyValidChildren) {
    return onlyValidChildren[parent].has(child);
  }
  if (child in onlyValidParents) {
    return onlyValidParents[child].has(parent);
  }
  if (parent in knownInvalidChildren) {
    if (knownInvalidChildren[parent].has(child)) return false;
  }
  if (child in knownInvalidParents) {
    if (knownInvalidParents[child].has(parent)) return false;
  }
  return true;
}
const headings = /* @__PURE__ */ new Set(["h1", "h2", "h3", "h4", "h5", "h6"]);
const emptySet = /* @__PURE__ */ new Set([]);
const onlyValidChildren = {
  head: /* @__PURE__ */ new Set([
    "base",
    "basefront",
    "bgsound",
    "link",
    "meta",
    "title",
    "noscript",
    "noframes",
    "style",
    "script",
    "template"
  ]),
  optgroup: /* @__PURE__ */ new Set(["option"]),
  select: /* @__PURE__ */ new Set(["optgroup", "option", "hr"]),
  // table
  table: /* @__PURE__ */ new Set(["caption", "colgroup", "tbody", "tfoot", "thead"]),
  tr: /* @__PURE__ */ new Set(["td", "th"]),
  colgroup: /* @__PURE__ */ new Set(["col"]),
  tbody: /* @__PURE__ */ new Set(["tr"]),
  thead: /* @__PURE__ */ new Set(["tr"]),
  tfoot: /* @__PURE__ */ new Set(["tr"]),
  // these elements can not have any children elements
  script: emptySet,
  iframe: emptySet,
  option: emptySet,
  textarea: emptySet,
  style: emptySet,
  title: emptySet
};
const onlyValidParents = {
  // sections
  html: emptySet,
  body: /* @__PURE__ */ new Set(["html"]),
  head: /* @__PURE__ */ new Set(["html"]),
  // table
  td: /* @__PURE__ */ new Set(["tr"]),
  colgroup: /* @__PURE__ */ new Set(["table"]),
  caption: /* @__PURE__ */ new Set(["table"]),
  tbody: /* @__PURE__ */ new Set(["table"]),
  tfoot: /* @__PURE__ */ new Set(["table"]),
  col: /* @__PURE__ */ new Set(["colgroup"]),
  th: /* @__PURE__ */ new Set(["tr"]),
  thead: /* @__PURE__ */ new Set(["table"]),
  tr: /* @__PURE__ */ new Set(["tbody", "thead", "tfoot"]),
  // data list
  dd: /* @__PURE__ */ new Set(["dl", "div"]),
  dt: /* @__PURE__ */ new Set(["dl", "div"]),
  // other
  figcaption: /* @__PURE__ */ new Set(["figure"]),
  // li: new Set(["ul", "ol"]),
  summary: /* @__PURE__ */ new Set(["details"]),
  area: /* @__PURE__ */ new Set(["map"])
};
const knownInvalidChildren = {
  p: /* @__PURE__ */ new Set([
    "address",
    "article",
    "aside",
    "blockquote",
    "center",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "fieldset",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "hgroup",
    "hr",
    "li",
    "main",
    "nav",
    "menu",
    "ol",
    "p",
    "pre",
    "section",
    "table",
    "ul"
  ]),
  svg: /* @__PURE__ */ new Set([
    "b",
    "blockquote",
    "br",
    "code",
    "dd",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "hr",
    "i",
    "img",
    "li",
    "menu",
    "meta",
    "ol",
    "p",
    "pre",
    "ruby",
    "s",
    "small",
    "span",
    "strong",
    "sub",
    "sup",
    "table",
    "u",
    "ul",
    "var"
  ])
};
const knownInvalidParents = {
  a: /* @__PURE__ */ new Set(["a"]),
  button: /* @__PURE__ */ new Set(["button"]),
  dd: /* @__PURE__ */ new Set(["dd", "dt"]),
  dt: /* @__PURE__ */ new Set(["dd", "dt"]),
  form: /* @__PURE__ */ new Set(["form"]),
  li: /* @__PURE__ */ new Set(["li"]),
  h1: headings,
  h2: headings,
  h3: headings,
  h4: headings,
  h5: headings,
  h6: headings
};

const validateHtmlNesting = (node, context) => {
  if (node.type === 1 && node.tagType === 0 && context.parent && context.parent.type === 1 && context.parent.tagType === 0 && !isValidHTMLNesting(context.parent.tag, node.tag)) {
    const error = new SyntaxError(
      `<${node.tag}> cannot be child of <${context.parent.tag}>, according to HTML specifications. This can cause hydration errors or potentially disrupt future functionality.`
    );
    error.loc = node.loc;
    context.onWarn(error);
  }
};

const DOMNodeTransforms = [
  transformStyle,
  ... true ? [transformTransition, validateHtmlNesting] : 0
];
const DOMDirectiveTransforms = {
  cloak: _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.noopDirectiveTransform,
  html: transformVHtml,
  text: transformVText,
  model: transformModel,
  // override compiler-core
  on: transformOn,
  // override compiler-core
  show: transformShow
};
function compile(src, options = {}) {
  return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseCompile)(
    src,
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, parserOptions, options, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...options.nodeTransforms || []
      ],
      directiveTransforms: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
        {},
        DOMDirectiveTransforms,
        options.directiveTransforms || {}
      ),
      transformHoist: null 
    })
  );
}
function parse(template, options = {}) {
  return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseParse)(template, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, parserOptions, options));
}




/***/ }),

/***/ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ARRAY_ITERATE_KEY: () => (/* binding */ ARRAY_ITERATE_KEY),
/* harmony export */   EffectFlags: () => (/* binding */ EffectFlags),
/* harmony export */   EffectScope: () => (/* binding */ EffectScope),
/* harmony export */   ITERATE_KEY: () => (/* binding */ ITERATE_KEY),
/* harmony export */   MAP_KEY_ITERATE_KEY: () => (/* binding */ MAP_KEY_ITERATE_KEY),
/* harmony export */   ReactiveEffect: () => (/* binding */ ReactiveEffect),
/* harmony export */   ReactiveFlags: () => (/* binding */ ReactiveFlags),
/* harmony export */   TrackOpTypes: () => (/* binding */ TrackOpTypes),
/* harmony export */   TriggerOpTypes: () => (/* binding */ TriggerOpTypes),
/* harmony export */   WatchErrorCodes: () => (/* binding */ WatchErrorCodes),
/* harmony export */   computed: () => (/* binding */ computed),
/* harmony export */   customRef: () => (/* binding */ customRef),
/* harmony export */   effect: () => (/* binding */ effect),
/* harmony export */   effectScope: () => (/* binding */ effectScope),
/* harmony export */   enableTracking: () => (/* binding */ enableTracking),
/* harmony export */   getCurrentScope: () => (/* binding */ getCurrentScope),
/* harmony export */   getCurrentWatcher: () => (/* binding */ getCurrentWatcher),
/* harmony export */   isProxy: () => (/* binding */ isProxy),
/* harmony export */   isReactive: () => (/* binding */ isReactive),
/* harmony export */   isReadonly: () => (/* binding */ isReadonly),
/* harmony export */   isRef: () => (/* binding */ isRef),
/* harmony export */   isShallow: () => (/* binding */ isShallow),
/* harmony export */   markRaw: () => (/* binding */ markRaw),
/* harmony export */   onEffectCleanup: () => (/* binding */ onEffectCleanup),
/* harmony export */   onScopeDispose: () => (/* binding */ onScopeDispose),
/* harmony export */   onWatcherCleanup: () => (/* binding */ onWatcherCleanup),
/* harmony export */   pauseTracking: () => (/* binding */ pauseTracking),
/* harmony export */   proxyRefs: () => (/* binding */ proxyRefs),
/* harmony export */   reactive: () => (/* binding */ reactive),
/* harmony export */   reactiveReadArray: () => (/* binding */ reactiveReadArray),
/* harmony export */   readonly: () => (/* binding */ readonly),
/* harmony export */   ref: () => (/* binding */ ref),
/* harmony export */   resetTracking: () => (/* binding */ resetTracking),
/* harmony export */   shallowReactive: () => (/* binding */ shallowReactive),
/* harmony export */   shallowReadArray: () => (/* binding */ shallowReadArray),
/* harmony export */   shallowReadonly: () => (/* binding */ shallowReadonly),
/* harmony export */   shallowRef: () => (/* binding */ shallowRef),
/* harmony export */   stop: () => (/* binding */ stop),
/* harmony export */   toRaw: () => (/* binding */ toRaw),
/* harmony export */   toReactive: () => (/* binding */ toReactive),
/* harmony export */   toReadonly: () => (/* binding */ toReadonly),
/* harmony export */   toRef: () => (/* binding */ toRef),
/* harmony export */   toRefs: () => (/* binding */ toRefs),
/* harmony export */   toValue: () => (/* binding */ toValue),
/* harmony export */   track: () => (/* binding */ track),
/* harmony export */   traverse: () => (/* binding */ traverse),
/* harmony export */   trigger: () => (/* binding */ trigger),
/* harmony export */   triggerRef: () => (/* binding */ triggerRef),
/* harmony export */   unref: () => (/* binding */ unref),
/* harmony export */   watch: () => (/* binding */ watch)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
/**
* @vue/reactivity v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/


function warn(msg, ...args) {
  console.warn(`[Vue warn] ${msg}`, ...args);
}

let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    /**
     * @internal
     */
    this._active = true;
    /**
     * @internal
     */
    this.effects = [];
    /**
     * @internal
     */
    this.cleanups = [];
    this._isPaused = false;
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = true;
      let i, l;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].pause();
        }
      }
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].pause();
      }
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active) {
      if (this._isPaused) {
        this._isPaused = false;
        let i, l;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].resume();
          }
        }
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].resume();
        }
      }
    }
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    } else if (true) {
      warn(`cannot run an inactive effect scope.`);
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      this._active = false;
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      this.effects.length = 0;
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      this.cleanups.length = 0;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn, failSilently = false) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  } else if ( true && !failSilently) {
    warn(
      `onScopeDispose() is called when there is no active effect scope to be associated with.`
    );
  }
}

let activeSub;
const EffectFlags = {
  "ACTIVE": 1,
  "1": "ACTIVE",
  "RUNNING": 2,
  "2": "RUNNING",
  "TRACKING": 4,
  "4": "TRACKING",
  "NOTIFIED": 8,
  "8": "NOTIFIED",
  "DIRTY": 16,
  "16": "DIRTY",
  "ALLOW_RECURSE": 32,
  "32": "ALLOW_RECURSE",
  "PAUSED": 64,
  "64": "PAUSED"
};
const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
class ReactiveEffect {
  constructor(fn) {
    this.fn = fn;
    /**
     * @internal
     */
    this.deps = void 0;
    /**
     * @internal
     */
    this.depsTail = void 0;
    /**
     * @internal
     */
    this.flags = 1 | 4;
    /**
     * @internal
     */
    this.next = void 0;
    /**
     * @internal
     */
    this.cleanup = void 0;
    this.scheduler = void 0;
    if (activeEffectScope && activeEffectScope.active) {
      activeEffectScope.effects.push(this);
    }
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    if (this.flags & 64) {
      this.flags &= ~64;
      if (pausedQueueEffects.has(this)) {
        pausedQueueEffects.delete(this);
        this.trigger();
      }
    }
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags & 2 && !(this.flags & 32)) {
      return;
    }
    if (!(this.flags & 8)) {
      batch(this);
    }
  }
  run() {
    if (!(this.flags & 1)) {
      return this.fn();
    }
    this.flags |= 2;
    cleanupEffect(this);
    prepareDeps(this);
    const prevEffect = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = this;
    shouldTrack = true;
    try {
      return this.fn();
    } finally {
      if ( true && activeSub !== this) {
        warn(
          "Active effect was not restored correctly - this is likely a Vue internal bug."
        );
      }
      cleanupDeps(this);
      activeSub = prevEffect;
      shouldTrack = prevShouldTrack;
      this.flags &= ~2;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let link = this.deps; link; link = link.nextDep) {
        removeSub(link);
      }
      this.deps = this.depsTail = void 0;
      cleanupEffect(this);
      this.onStop && this.onStop();
      this.flags &= ~1;
    }
  }
  trigger() {
    if (this.flags & 64) {
      pausedQueueEffects.add(this);
    } else if (this.scheduler) {
      this.scheduler();
    } else {
      this.runIfDirty();
    }
  }
  /**
   * @internal
   */
  runIfDirty() {
    if (isDirty(this)) {
      this.run();
    }
  }
  get dirty() {
    return isDirty(this);
  }
}
let batchDepth = 0;
let batchedSub;
let batchedComputed;
function batch(sub, isComputed = false) {
  sub.flags |= 8;
  if (isComputed) {
    sub.next = batchedComputed;
    batchedComputed = sub;
    return;
  }
  sub.next = batchedSub;
  batchedSub = sub;
}
function startBatch() {
  batchDepth++;
}
function endBatch() {
  if (--batchDepth > 0) {
    return;
  }
  if (batchedComputed) {
    let e = batchedComputed;
    batchedComputed = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= ~8;
      e = next;
    }
  }
  let error;
  while (batchedSub) {
    let e = batchedSub;
    batchedSub = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= ~8;
      if (e.flags & 1) {
        try {
          ;
          e.trigger();
        } catch (err) {
          if (!error) error = err;
        }
      }
      e = next;
    }
  }
  if (error) throw error;
}
function prepareDeps(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    link.version = -1;
    link.prevActiveLink = link.dep.activeLink;
    link.dep.activeLink = link;
  }
}
function cleanupDeps(sub) {
  let head;
  let tail = sub.depsTail;
  let link = tail;
  while (link) {
    const prev = link.prevDep;
    if (link.version === -1) {
      if (link === tail) tail = prev;
      removeSub(link);
      removeDep(link);
    } else {
      head = link;
    }
    link.dep.activeLink = link.prevActiveLink;
    link.prevActiveLink = void 0;
    link = prev;
  }
  sub.deps = head;
  sub.depsTail = tail;
}
function isDirty(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
      return true;
    }
  }
  if (sub._dirty) {
    return true;
  }
  return false;
}
function refreshComputed(computed) {
  if (computed.flags & 4 && !(computed.flags & 16)) {
    return;
  }
  computed.flags &= ~16;
  if (computed.globalVersion === globalVersion) {
    return;
  }
  computed.globalVersion = globalVersion;
  const dep = computed.dep;
  computed.flags |= 2;
  if (dep.version > 0 && !computed.isSSR && computed.deps && !isDirty(computed)) {
    computed.flags &= ~2;
    return;
  }
  const prevSub = activeSub;
  const prevShouldTrack = shouldTrack;
  activeSub = computed;
  shouldTrack = true;
  try {
    prepareDeps(computed);
    const value = computed.fn(computed._value);
    if (dep.version === 0 || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, computed._value)) {
      computed._value = value;
      dep.version++;
    }
  } catch (err) {
    dep.version++;
    throw err;
  } finally {
    activeSub = prevSub;
    shouldTrack = prevShouldTrack;
    cleanupDeps(computed);
    computed.flags &= ~2;
  }
}
function removeSub(link, soft = false) {
  const { dep, prevSub, nextSub } = link;
  if (prevSub) {
    prevSub.nextSub = nextSub;
    link.prevSub = void 0;
  }
  if (nextSub) {
    nextSub.prevSub = prevSub;
    link.nextSub = void 0;
  }
  if ( true && dep.subsHead === link) {
    dep.subsHead = nextSub;
  }
  if (dep.subs === link) {
    dep.subs = prevSub;
    if (!prevSub && dep.computed) {
      dep.computed.flags &= ~4;
      for (let l = dep.computed.deps; l; l = l.nextDep) {
        removeSub(l, true);
      }
    }
  }
  if (!soft && !--dep.sc && dep.map) {
    dep.map.delete(dep.key);
  }
}
function removeDep(link) {
  const { prevDep, nextDep } = link;
  if (prevDep) {
    prevDep.nextDep = nextDep;
    link.prevDep = void 0;
  }
  if (nextDep) {
    nextDep.prevDep = prevDep;
    link.nextDep = void 0;
  }
}
function effect(fn, options) {
  if (fn.effect instanceof ReactiveEffect) {
    fn = fn.effect.fn;
  }
  const e = new ReactiveEffect(fn);
  if (options) {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(e, options);
  }
  try {
    e.run();
  } catch (err) {
    e.stop();
    throw err;
  }
  const runner = e.run.bind(e);
  runner.effect = e;
  return runner;
}
function stop(runner) {
  runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function enableTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = true;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function onEffectCleanup(fn, failSilently = false) {
  if (activeSub instanceof ReactiveEffect) {
    activeSub.cleanup = fn;
  } else if ( true && !failSilently) {
    warn(
      `onEffectCleanup() was called when there was no active effect to associate with.`
    );
  }
}
function cleanupEffect(e) {
  const { cleanup } = e;
  e.cleanup = void 0;
  if (cleanup) {
    const prevSub = activeSub;
    activeSub = void 0;
    try {
      cleanup();
    } finally {
      activeSub = prevSub;
    }
  }
}

let globalVersion = 0;
class Link {
  constructor(sub, dep) {
    this.sub = sub;
    this.dep = dep;
    this.version = dep.version;
    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Dep {
  constructor(computed) {
    this.computed = computed;
    this.version = 0;
    /**
     * Link between this dep and the current active effect
     */
    this.activeLink = void 0;
    /**
     * Doubly linked list representing the subscribing effects (tail)
     */
    this.subs = void 0;
    /**
     * For object property deps cleanup
     */
    this.map = void 0;
    this.key = void 0;
    /**
     * Subscriber counter
     */
    this.sc = 0;
    if (true) {
      this.subsHead = void 0;
    }
  }
  track(debugInfo) {
    if (!activeSub || !shouldTrack || activeSub === this.computed) {
      return;
    }
    let link = this.activeLink;
    if (link === void 0 || link.sub !== activeSub) {
      link = this.activeLink = new Link(activeSub, this);
      if (!activeSub.deps) {
        activeSub.deps = activeSub.depsTail = link;
      } else {
        link.prevDep = activeSub.depsTail;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
      }
      addSub(link);
    } else if (link.version === -1) {
      link.version = this.version;
      if (link.nextDep) {
        const next = link.nextDep;
        next.prevDep = link.prevDep;
        if (link.prevDep) {
          link.prevDep.nextDep = next;
        }
        link.prevDep = activeSub.depsTail;
        link.nextDep = void 0;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
        if (activeSub.deps === link) {
          activeSub.deps = next;
        }
      }
    }
    if ( true && activeSub.onTrack) {
      activeSub.onTrack(
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(
          {
            effect: activeSub
          },
          debugInfo
        )
      );
    }
    return link;
  }
  trigger(debugInfo) {
    this.version++;
    globalVersion++;
    this.notify(debugInfo);
  }
  notify(debugInfo) {
    startBatch();
    try {
      if (true) {
        for (let head = this.subsHead; head; head = head.nextSub) {
          if (head.sub.onTrigger && !(head.sub.flags & 8)) {
            head.sub.onTrigger(
              (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(
                {
                  effect: head.sub
                },
                debugInfo
              )
            );
          }
        }
      }
      for (let link = this.subs; link; link = link.prevSub) {
        if (link.sub.notify()) {
          ;
          link.sub.dep.notify();
        }
      }
    } finally {
      endBatch();
    }
  }
}
function addSub(link) {
  link.dep.sc++;
  if (link.sub.flags & 4) {
    const computed = link.dep.computed;
    if (computed && !link.dep.subs) {
      computed.flags |= 4 | 16;
      for (let l = computed.deps; l; l = l.nextDep) {
        addSub(l);
      }
    }
    const currentTail = link.dep.subs;
    if (currentTail !== link) {
      link.prevSub = currentTail;
      if (currentTail) currentTail.nextSub = link;
    }
    if ( true && link.dep.subsHead === void 0) {
      link.dep.subsHead = link;
    }
    link.dep.subs = link;
  }
}
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol(
   true ? "Object iterate" : 0
);
const MAP_KEY_ITERATE_KEY = Symbol(
   true ? "Map keys iterate" : 0
);
const ARRAY_ITERATE_KEY = Symbol(
   true ? "Array iterate" : 0
);
function track(target, type, key) {
  if (shouldTrack && activeSub) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = new Dep());
      dep.map = depsMap;
      dep.key = key;
    }
    if (true) {
      dep.track({
        target,
        type,
        key
      });
    } else {}
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++;
    return;
  }
  const run = (dep) => {
    if (dep) {
      if (true) {
        dep.trigger({
          target,
          type,
          key,
          newValue,
          oldValue,
          oldTarget
        });
      } else {}
    }
  };
  startBatch();
  if (type === "clear") {
    depsMap.forEach(run);
  } else {
    const targetIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target);
    const isArrayIndex = targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key);
    if (targetIsArray && key === "length") {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key2) && key2 >= newLength) {
          run(dep);
        }
      });
    } else {
      if (key !== void 0 || depsMap.has(void 0)) {
        run(depsMap.get(key));
      }
      if (isArrayIndex) {
        run(depsMap.get(ARRAY_ITERATE_KEY));
      }
      switch (type) {
        case "add":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isArrayIndex) {
            run(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
            run(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
  }
  endBatch();
}
function getDepFromReactive(object, key) {
  const depMap = targetMap.get(object);
  return depMap && depMap.get(key);
}

function reactiveReadArray(array) {
  const raw = toRaw(array);
  if (raw === array) return raw;
  track(raw, "iterate", ARRAY_ITERATE_KEY);
  return isShallow(array) ? raw : raw.map(toReactive);
}
function shallowReadArray(arr) {
  track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
  return arr;
}
const arrayInstrumentations = {
  __proto__: null,
  [Symbol.iterator]() {
    return iterator(this, Symbol.iterator, toReactive);
  },
  concat(...args) {
    return reactiveReadArray(this).concat(
      ...args.map((x) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(x) ? reactiveReadArray(x) : x)
    );
  },
  entries() {
    return iterator(this, "entries", (value) => {
      value[1] = toReactive(value[1]);
      return value;
    });
  },
  every(fn, thisArg) {
    return apply(this, "every", fn, thisArg, void 0, arguments);
  },
  filter(fn, thisArg) {
    return apply(this, "filter", fn, thisArg, (v) => v.map(toReactive), arguments);
  },
  find(fn, thisArg) {
    return apply(this, "find", fn, thisArg, toReactive, arguments);
  },
  findIndex(fn, thisArg) {
    return apply(this, "findIndex", fn, thisArg, void 0, arguments);
  },
  findLast(fn, thisArg) {
    return apply(this, "findLast", fn, thisArg, toReactive, arguments);
  },
  findLastIndex(fn, thisArg) {
    return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(fn, thisArg) {
    return apply(this, "forEach", fn, thisArg, void 0, arguments);
  },
  includes(...args) {
    return searchProxy(this, "includes", args);
  },
  indexOf(...args) {
    return searchProxy(this, "indexOf", args);
  },
  join(separator) {
    return reactiveReadArray(this).join(separator);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...args) {
    return searchProxy(this, "lastIndexOf", args);
  },
  map(fn, thisArg) {
    return apply(this, "map", fn, thisArg, void 0, arguments);
  },
  pop() {
    return noTracking(this, "pop");
  },
  push(...args) {
    return noTracking(this, "push", args);
  },
  reduce(fn, ...args) {
    return reduce(this, "reduce", fn, args);
  },
  reduceRight(fn, ...args) {
    return reduce(this, "reduceRight", fn, args);
  },
  shift() {
    return noTracking(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(fn, thisArg) {
    return apply(this, "some", fn, thisArg, void 0, arguments);
  },
  splice(...args) {
    return noTracking(this, "splice", args);
  },
  toReversed() {
    return reactiveReadArray(this).toReversed();
  },
  toSorted(comparer) {
    return reactiveReadArray(this).toSorted(comparer);
  },
  toSpliced(...args) {
    return reactiveReadArray(this).toSpliced(...args);
  },
  unshift(...args) {
    return noTracking(this, "unshift", args);
  },
  values() {
    return iterator(this, "values", toReactive);
  }
};
function iterator(self, method, wrapValue) {
  const arr = shallowReadArray(self);
  const iter = arr[method]();
  if (arr !== self && !isShallow(self)) {
    iter._next = iter.next;
    iter.next = () => {
      const result = iter._next();
      if (result.value) {
        result.value = wrapValue(result.value);
      }
      return result;
    };
  }
  return iter;
}
const arrayProto = Array.prototype;
function apply(self, method, fn, thisArg, wrappedRetFn, args) {
  const arr = shallowReadArray(self);
  const needsWrap = arr !== self && !isShallow(self);
  const methodFn = arr[method];
  if (methodFn !== arrayProto[method]) {
    const result2 = methodFn.apply(self, args);
    return needsWrap ? toReactive(result2) : result2;
  }
  let wrappedFn = fn;
  if (arr !== self) {
    if (needsWrap) {
      wrappedFn = function(item, index) {
        return fn.call(this, toReactive(item), index, self);
      };
    } else if (fn.length > 2) {
      wrappedFn = function(item, index) {
        return fn.call(this, item, index, self);
      };
    }
  }
  const result = methodFn.call(arr, wrappedFn, thisArg);
  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
}
function reduce(self, method, fn, args) {
  const arr = shallowReadArray(self);
  let wrappedFn = fn;
  if (arr !== self) {
    if (!isShallow(self)) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, toReactive(item), index, self);
      };
    } else if (fn.length > 3) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, item, index, self);
      };
    }
  }
  return arr[method](wrappedFn, ...args);
}
function searchProxy(self, method, args) {
  const arr = toRaw(self);
  track(arr, "iterate", ARRAY_ITERATE_KEY);
  const res = arr[method](...args);
  if ((res === -1 || res === false) && isProxy(args[0])) {
    args[0] = toRaw(args[0]);
    return arr[method](...args);
  }
  return res;
}
function noTracking(self, method, args = []) {
  pauseTracking();
  startBatch();
  const res = toRaw(self)[method].apply(self, args);
  endBatch();
  resetTracking();
  return res;
}

const isNonTrackableKeys = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)
);
function hasOwnProperty(key) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key)) key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    if (key === "__v_skip") return target["__v_skip"];
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target);
    if (!isReadonly2) {
      let fn;
      if (targetIsArray && (fn = arrayInstrumentations[key])) {
        return fn;
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(
      target,
      key,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      isRef(target) ? target : receiver
    );
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key) ? res : res.value;
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key) ? Number(key) < target.length : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);
    const result = Reflect.set(
      target,
      key,
      value,
      isRef(target) ? target : receiver
    );
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    if (true) {
      warn(
        `Set operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  }
  deleteProperty(target, key) {
    if (true) {
      warn(
        `Delete operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);

const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    if (true) {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      warn(
        `${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)(type)} operation ${key}failed: target is readonly.`,
        toRaw(this)
      );
    }
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations(readonly, shallow) {
  const instrumentations = {
    get(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has } = getProto(rawTarget);
      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;
      if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    },
    get size() {
      const target = this["__v_raw"];
      !readonly && track(toRaw(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    },
    has(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    },
    forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;
      !readonly && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    }
  };
  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(
    instrumentations,
    readonly ? {
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear")
    } : {
      add(value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger(target, "add", value, value);
        }
        return this;
      },
      set(key, value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        } else if (true) {
          checkIdentityKeys(target, has, key);
        }
        const oldValue = get.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
        return this;
      },
      delete(key) {
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        } else if (true) {
          checkIdentityKeys(target, has, key);
        }
        const oldValue = get ? get.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0, oldValue);
        }
        return result;
      },
      clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const oldTarget =  true ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target) ? new Map(target) : new Set(target) : 0;
        const result = target.clear();
        if (hadItems) {
          trigger(
            target,
            "clear",
            void 0,
            void 0,
            oldTarget
          );
        }
        return result;
      }
    }
  );
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    instrumentations[method] = createIterableMethod(method, readonly, shallow);
  });
  return instrumentations;
}
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = createInstrumentations(isReadonly2, shallow);
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has.call(target, rawKey)) {
    const type = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(target);
    warn(
      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}

const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1 /* COMMON */;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2 /* COLLECTION */;
    default:
      return 0 /* INVALID */;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(target)) {
    if (true) {
      warn(
        `value cannot be made ${isReadonly2 ? "readonly" : "reactive"}: ${String(
          target
        )}`
      );
    }
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0 /* INVALID */) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return value ? !!value["__v_raw"] : false;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(value, "__v_skip") && Object.isExtensible(value)) {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.def)(value, "__v_skip", true);
  }
  return value;
}
const toReactive = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? reactive(value) : value;
const toReadonly = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? readonly(value) : value;

function isRef(r) {
  return r ? r["__v_isRef"] === true : false;
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, isShallow2) {
    this.dep = new Dep();
    this["__v_isRef"] = true;
    this["__v_isShallow"] = false;
    this._rawValue = isShallow2 ? value : toRaw(value);
    this._value = isShallow2 ? value : toReactive(value);
    this["__v_isShallow"] = isShallow2;
  }
  get value() {
    if (true) {
      this.dep.track({
        target: this,
        type: "get",
        key: "value"
      });
    } else {}
    return this._value;
  }
  set value(newValue) {
    const oldValue = this._rawValue;
    const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
    newValue = useDirectValue ? newValue : toRaw(newValue);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(newValue, oldValue)) {
      this._rawValue = newValue;
      this._value = useDirectValue ? newValue : toReactive(newValue);
      if (true) {
        this.dep.trigger({
          target: this,
          type: "set",
          key: "value",
          newValue,
          oldValue
        });
      } else {}
    }
  }
}
function triggerRef(ref2) {
  if (ref2.dep) {
    if (true) {
      ref2.dep.trigger({
        target: ref2,
        type: "set",
        key: "value",
        newValue: ref2._value
      });
    } else {}
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
function toValue(source) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(source) ? source() : unref(source);
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
  constructor(factory) {
    this["__v_isRef"] = true;
    this._value = void 0;
    const dep = this.dep = new Dep();
    const { get, set } = factory(dep.track.bind(dep), dep.trigger.bind(dep));
    this._get = get;
    this._set = set;
  }
  get value() {
    return this._value = this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
function toRefs(object) {
  if ( true && !isProxy(object)) {
    warn(`toRefs() expects a reactive object but received a plain one.`);
  }
  const ret = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this["__v_isRef"] = true;
    this._value = void 0;
  }
  get value() {
    const val = this._object[this._key];
    return this._value = val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
class GetterRefImpl {
  constructor(_getter) {
    this._getter = _getter;
    this["__v_isRef"] = true;
    this["__v_isReadonly"] = true;
    this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
function toRef(source, key, defaultValue) {
  if (isRef(source)) {
    return source;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(source)) {
    return new GetterRefImpl(source);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return ref(source);
  }
}
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}

class ComputedRefImpl {
  constructor(fn, setter, isSSR) {
    this.fn = fn;
    this.setter = setter;
    /**
     * @internal
     */
    this._value = void 0;
    /**
     * @internal
     */
    this.dep = new Dep(this);
    /**
     * @internal
     */
    this.__v_isRef = true;
    // TODO isolatedDeclarations "__v_isReadonly"
    // A computed is also a subscriber that tracks other deps
    /**
     * @internal
     */
    this.deps = void 0;
    /**
     * @internal
     */
    this.depsTail = void 0;
    /**
     * @internal
     */
    this.flags = 16;
    /**
     * @internal
     */
    this.globalVersion = globalVersion - 1;
    /**
     * @internal
     */
    this.next = void 0;
    // for backwards compat
    this.effect = this;
    this["__v_isReadonly"] = !setter;
    this.isSSR = isSSR;
  }
  /**
   * @internal
   */
  notify() {
    this.flags |= 16;
    if (!(this.flags & 8) && // avoid infinite self recursion
    activeSub !== this) {
      batch(this, true);
      return true;
    } else if (true) ;
  }
  get value() {
    const link =  true ? this.dep.track({
      target: this,
      type: "get",
      key: "value"
    }) : 0;
    refreshComputed(this);
    if (link) {
      link.version = this.dep.version;
    }
    return this._value;
  }
  set value(newValue) {
    if (this.setter) {
      this.setter(newValue);
    } else if (true) {
      warn("Write operation failed: computed value is readonly");
    }
  }
}
function computed(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(getterOrOptions)) {
    getter = getterOrOptions;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, isSSR);
  if ( true && debugOptions && !isSSR) {
    cRef.onTrack = debugOptions.onTrack;
    cRef.onTrigger = debugOptions.onTrigger;
  }
  return cRef;
}

const TrackOpTypes = {
  "GET": "get",
  "HAS": "has",
  "ITERATE": "iterate"
};
const TriggerOpTypes = {
  "SET": "set",
  "ADD": "add",
  "DELETE": "delete",
  "CLEAR": "clear"
};
const ReactiveFlags = {
  "SKIP": "__v_skip",
  "IS_REACTIVE": "__v_isReactive",
  "IS_READONLY": "__v_isReadonly",
  "IS_SHALLOW": "__v_isShallow",
  "RAW": "__v_raw",
  "IS_REF": "__v_isRef"
};

const WatchErrorCodes = {
  "WATCH_GETTER": 2,
  "2": "WATCH_GETTER",
  "WATCH_CALLBACK": 3,
  "3": "WATCH_CALLBACK",
  "WATCH_CLEANUP": 4,
  "4": "WATCH_CLEANUP"
};
const INITIAL_WATCHER_VALUE = {};
const cleanupMap = /* @__PURE__ */ new WeakMap();
let activeWatcher = void 0;
function getCurrentWatcher() {
  return activeWatcher;
}
function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
  if (owner) {
    let cleanups = cleanupMap.get(owner);
    if (!cleanups) cleanupMap.set(owner, cleanups = []);
    cleanups.push(cleanupFn);
  } else if ( true && !failSilently) {
    warn(
      `onWatcherCleanup() was called when there was no active watcher to associate with.`
    );
  }
}
function watch(source, cb, options = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ) {
  const { immediate, deep, once, scheduler, augmentJob, call } = options;
  const warnInvalidSource = (s) => {
    (options.onWarn || warn)(
      `Invalid watch source: `,
      s,
      `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`
    );
  };
  const reactiveGetter = (source2) => {
    if (deep) return source2;
    if (isShallow(source2) || deep === false || deep === 0)
      return traverse(source2, 1);
    return traverse(source2);
  };
  let effect;
  let getter;
  let cleanup;
  let boundCleanup;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(s)) {
        return call ? call(s, 2) : s();
      } else {
         true && warnInvalidSource(s);
      }
    });
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(source)) {
    if (cb) {
      getter = call ? () => call(source, 2) : source;
    } else {
      getter = () => {
        if (cleanup) {
          pauseTracking();
          try {
            cleanup();
          } finally {
            resetTracking();
          }
        }
        const currentEffect = activeWatcher;
        activeWatcher = effect;
        try {
          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
        } finally {
          activeWatcher = currentEffect;
        }
      };
    }
  } else {
    getter = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP;
     true && warnInvalidSource(source);
  }
  if (cb && deep) {
    const baseGetter = getter;
    const depth = deep === true ? Infinity : deep;
    getter = () => traverse(baseGetter(), depth);
  }
  const scope = getCurrentScope();
  const watchHandle = () => {
    effect.stop();
    if (scope && scope.active) {
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.remove)(scope.effects, effect);
    }
  };
  if (once && cb) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      watchHandle();
    };
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = (immediateFirstRun) => {
    if (!(effect.flags & 1) || !effect.dirty && !immediateFirstRun) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(v, oldValue[i])) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(newValue, oldValue))) {
        if (cleanup) {
          cleanup();
        }
        const currentWatcher = activeWatcher;
        activeWatcher = effect;
        try {
          const args = [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            boundCleanup
          ];
          call ? call(cb, 3, args) : (
            // @ts-expect-error
            cb(...args)
          );
          oldValue = newValue;
        } finally {
          activeWatcher = currentWatcher;
        }
      }
    } else {
      effect.run();
    }
  };
  if (augmentJob) {
    augmentJob(job);
  }
  effect = new ReactiveEffect(getter);
  effect.scheduler = scheduler ? () => scheduler(job, false) : job;
  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect);
  cleanup = effect.onStop = () => {
    const cleanups = cleanupMap.get(effect);
    if (cleanups) {
      if (call) {
        call(cleanups, 4);
      } else {
        for (const cleanup2 of cleanups) cleanup2();
      }
      cleanupMap.delete(effect);
    }
  };
  if (true) {
    effect.onTrack = options.onTrack;
    effect.onTrigger = options.onTrigger;
  }
  if (cb) {
    if (immediate) {
      job(true);
    } else {
      oldValue = effect.run();
    }
  } else if (scheduler) {
    scheduler(job.bind(null, true), true);
  } else {
    effect.run();
  }
  watchHandle.pause = effect.pause.bind(effect);
  watchHandle.resume = effect.resume.bind(effect);
  watchHandle.stop = watchHandle;
  return watchHandle;
}
function traverse(value, depth = Infinity, seen) {
  if (depth <= 0 || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  depth--;
  if (isRef(value)) {
    traverse(value.value, depth, seen);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], depth, seen);
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSet)(value) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(value)) {
    value.forEach((v) => {
      traverse(v, depth, seen);
    });
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value)) {
    for (const key in value) {
      traverse(value[key], depth, seen);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      if (Object.prototype.propertyIsEnumerable.call(value, key)) {
        traverse(value[key], depth, seen);
      }
    }
  }
  return value;
}




/***/ }),

/***/ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseTransition: () => (/* binding */ BaseTransition),
/* harmony export */   BaseTransitionPropsValidators: () => (/* binding */ BaseTransitionPropsValidators),
/* harmony export */   Comment: () => (/* binding */ Comment),
/* harmony export */   DeprecationTypes: () => (/* binding */ DeprecationTypes),
/* harmony export */   EffectScope: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.EffectScope),
/* harmony export */   ErrorCodes: () => (/* binding */ ErrorCodes),
/* harmony export */   ErrorTypeStrings: () => (/* binding */ ErrorTypeStrings),
/* harmony export */   Fragment: () => (/* binding */ Fragment),
/* harmony export */   KeepAlive: () => (/* binding */ KeepAlive),
/* harmony export */   ReactiveEffect: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),
/* harmony export */   Static: () => (/* binding */ Static),
/* harmony export */   Suspense: () => (/* binding */ Suspense),
/* harmony export */   Teleport: () => (/* binding */ Teleport),
/* harmony export */   Text: () => (/* binding */ Text),
/* harmony export */   TrackOpTypes: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.TrackOpTypes),
/* harmony export */   TriggerOpTypes: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.TriggerOpTypes),
/* harmony export */   assertNumber: () => (/* binding */ assertNumber),
/* harmony export */   callWithAsyncErrorHandling: () => (/* binding */ callWithAsyncErrorHandling),
/* harmony export */   callWithErrorHandling: () => (/* binding */ callWithErrorHandling),
/* harmony export */   camelize: () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize),
/* harmony export */   capitalize: () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize),
/* harmony export */   cloneVNode: () => (/* binding */ cloneVNode),
/* harmony export */   compatUtils: () => (/* binding */ compatUtils),
/* harmony export */   computed: () => (/* binding */ computed),
/* harmony export */   createBlock: () => (/* binding */ createBlock),
/* harmony export */   createCommentVNode: () => (/* binding */ createCommentVNode),
/* harmony export */   createElementBlock: () => (/* binding */ createElementBlock),
/* harmony export */   createElementVNode: () => (/* binding */ createBaseVNode),
/* harmony export */   createHydrationRenderer: () => (/* binding */ createHydrationRenderer),
/* harmony export */   createPropsRestProxy: () => (/* binding */ createPropsRestProxy),
/* harmony export */   createRenderer: () => (/* binding */ createRenderer),
/* harmony export */   createSlots: () => (/* binding */ createSlots),
/* harmony export */   createStaticVNode: () => (/* binding */ createStaticVNode),
/* harmony export */   createTextVNode: () => (/* binding */ createTextVNode),
/* harmony export */   createVNode: () => (/* binding */ createVNode),
/* harmony export */   customRef: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   defineAsyncComponent: () => (/* binding */ defineAsyncComponent),
/* harmony export */   defineComponent: () => (/* binding */ defineComponent),
/* harmony export */   defineEmits: () => (/* binding */ defineEmits),
/* harmony export */   defineExpose: () => (/* binding */ defineExpose),
/* harmony export */   defineModel: () => (/* binding */ defineModel),
/* harmony export */   defineOptions: () => (/* binding */ defineOptions),
/* harmony export */   defineProps: () => (/* binding */ defineProps),
/* harmony export */   defineSlots: () => (/* binding */ defineSlots),
/* harmony export */   devtools: () => (/* binding */ devtools),
/* harmony export */   effect: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   effectScope: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effectScope),
/* harmony export */   getCurrentInstance: () => (/* binding */ getCurrentInstance),
/* harmony export */   getCurrentScope: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),
/* harmony export */   getCurrentWatcher: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.getCurrentWatcher),
/* harmony export */   getTransitionRawChildren: () => (/* binding */ getTransitionRawChildren),
/* harmony export */   guardReactiveProps: () => (/* binding */ guardReactiveProps),
/* harmony export */   h: () => (/* binding */ h),
/* harmony export */   handleError: () => (/* binding */ handleError),
/* harmony export */   hasInjectionContext: () => (/* binding */ hasInjectionContext),
/* harmony export */   hydrateOnIdle: () => (/* binding */ hydrateOnIdle),
/* harmony export */   hydrateOnInteraction: () => (/* binding */ hydrateOnInteraction),
/* harmony export */   hydrateOnMediaQuery: () => (/* binding */ hydrateOnMediaQuery),
/* harmony export */   hydrateOnVisible: () => (/* binding */ hydrateOnVisible),
/* harmony export */   initCustomFormatter: () => (/* binding */ initCustomFormatter),
/* harmony export */   inject: () => (/* binding */ inject),
/* harmony export */   isMemoSame: () => (/* binding */ isMemoSame),
/* harmony export */   isProxy: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   isReactive: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   isReadonly: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   isRef: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   isRuntimeOnly: () => (/* binding */ isRuntimeOnly),
/* harmony export */   isShallow: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow),
/* harmony export */   isVNode: () => (/* binding */ isVNode),
/* harmony export */   markRaw: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   mergeDefaults: () => (/* binding */ mergeDefaults),
/* harmony export */   mergeModels: () => (/* binding */ mergeModels),
/* harmony export */   mergeProps: () => (/* binding */ mergeProps),
/* harmony export */   nextTick: () => (/* binding */ nextTick),
/* harmony export */   normalizeClass: () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass),
/* harmony export */   normalizeProps: () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeProps),
/* harmony export */   normalizeStyle: () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle),
/* harmony export */   onActivated: () => (/* binding */ onActivated),
/* harmony export */   onBeforeMount: () => (/* binding */ onBeforeMount),
/* harmony export */   onBeforeUnmount: () => (/* binding */ onBeforeUnmount),
/* harmony export */   onBeforeUpdate: () => (/* binding */ onBeforeUpdate),
/* harmony export */   onDeactivated: () => (/* binding */ onDeactivated),
/* harmony export */   onErrorCaptured: () => (/* binding */ onErrorCaptured),
/* harmony export */   onMounted: () => (/* binding */ onMounted),
/* harmony export */   onRenderTracked: () => (/* binding */ onRenderTracked),
/* harmony export */   onRenderTriggered: () => (/* binding */ onRenderTriggered),
/* harmony export */   onScopeDispose: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),
/* harmony export */   onServerPrefetch: () => (/* binding */ onServerPrefetch),
/* harmony export */   onUnmounted: () => (/* binding */ onUnmounted),
/* harmony export */   onUpdated: () => (/* binding */ onUpdated),
/* harmony export */   onWatcherCleanup: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.onWatcherCleanup),
/* harmony export */   openBlock: () => (/* binding */ openBlock),
/* harmony export */   popScopeId: () => (/* binding */ popScopeId),
/* harmony export */   provide: () => (/* binding */ provide),
/* harmony export */   proxyRefs: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   pushScopeId: () => (/* binding */ pushScopeId),
/* harmony export */   queuePostFlushCb: () => (/* binding */ queuePostFlushCb),
/* harmony export */   reactive: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   readonly: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   ref: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   registerRuntimeCompiler: () => (/* binding */ registerRuntimeCompiler),
/* harmony export */   renderList: () => (/* binding */ renderList),
/* harmony export */   renderSlot: () => (/* binding */ renderSlot),
/* harmony export */   resolveComponent: () => (/* binding */ resolveComponent),
/* harmony export */   resolveDirective: () => (/* binding */ resolveDirective),
/* harmony export */   resolveDynamicComponent: () => (/* binding */ resolveDynamicComponent),
/* harmony export */   resolveFilter: () => (/* binding */ resolveFilter),
/* harmony export */   resolveTransitionHooks: () => (/* binding */ resolveTransitionHooks),
/* harmony export */   setBlockTracking: () => (/* binding */ setBlockTracking),
/* harmony export */   setDevtoolsHook: () => (/* binding */ setDevtoolsHook),
/* harmony export */   setTransitionHooks: () => (/* binding */ setTransitionHooks),
/* harmony export */   shallowReactive: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   shallowReadonly: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   shallowRef: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   ssrContextKey: () => (/* binding */ ssrContextKey),
/* harmony export */   ssrUtils: () => (/* binding */ ssrUtils),
/* harmony export */   stop: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop),
/* harmony export */   toDisplayString: () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toDisplayString),
/* harmony export */   toHandlerKey: () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey),
/* harmony export */   toHandlers: () => (/* binding */ toHandlers),
/* harmony export */   toRaw: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   toRef: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   toRefs: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   toValue: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toValue),
/* harmony export */   transformVNodeArgs: () => (/* binding */ transformVNodeArgs),
/* harmony export */   triggerRef: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   unref: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   useAttrs: () => (/* binding */ useAttrs),
/* harmony export */   useId: () => (/* binding */ useId),
/* harmony export */   useModel: () => (/* binding */ useModel),
/* harmony export */   useSSRContext: () => (/* binding */ useSSRContext),
/* harmony export */   useSlots: () => (/* binding */ useSlots),
/* harmony export */   useTemplateRef: () => (/* binding */ useTemplateRef),
/* harmony export */   useTransitionState: () => (/* binding */ useTransitionState),
/* harmony export */   version: () => (/* binding */ version),
/* harmony export */   warn: () => (/* binding */ warn),
/* harmony export */   watch: () => (/* binding */ watch),
/* harmony export */   watchEffect: () => (/* binding */ watchEffect),
/* harmony export */   watchPostEffect: () => (/* binding */ watchPostEffect),
/* harmony export */   watchSyncEffect: () => (/* binding */ watchSyncEffect),
/* harmony export */   withAsyncContext: () => (/* binding */ withAsyncContext),
/* harmony export */   withCtx: () => (/* binding */ withCtx),
/* harmony export */   withDefaults: () => (/* binding */ withDefaults),
/* harmony export */   withDirectives: () => (/* binding */ withDirectives),
/* harmony export */   withMemo: () => (/* binding */ withMemo),
/* harmony export */   withScopeId: () => (/* binding */ withScopeId)
/* harmony export */ });
/* harmony import */ var _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/reactivity */ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
/**
* @vue/runtime-core v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/





const stack = [];
function pushWarningContext(vnode) {
  stack.push(vnode);
}
function popWarningContext() {
  stack.pop();
}
let isWarning = false;
function warn$1(msg, ...args) {
  if (isWarning) return;
  isWarning = true;
  (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        msg + args.map((a) => {
          var _a, _b;
          return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
  isWarning = false;
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {
    value = formatProp(key, (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value);
    return raw ? value : [`${key}=`, value];
  }
}
function assertNumber(val, type) {
  if (false) {}
  if (val === void 0) {
    return;
  } else if (typeof val !== "number") {
    warn$1(`${type} is not a valid number - got ${JSON.stringify(val)}.`);
  } else if (isNaN(val)) {
    warn$1(`${type} is NaN - the duration expression might be incorrect.`);
  }
}

const ErrorCodes = {
  "SETUP_FUNCTION": 0,
  "0": "SETUP_FUNCTION",
  "RENDER_FUNCTION": 1,
  "1": "RENDER_FUNCTION",
  "NATIVE_EVENT_HANDLER": 5,
  "5": "NATIVE_EVENT_HANDLER",
  "COMPONENT_EVENT_HANDLER": 6,
  "6": "COMPONENT_EVENT_HANDLER",
  "VNODE_HOOK": 7,
  "7": "VNODE_HOOK",
  "DIRECTIVE_HOOK": 8,
  "8": "DIRECTIVE_HOOK",
  "TRANSITION_HOOK": 9,
  "9": "TRANSITION_HOOK",
  "APP_ERROR_HANDLER": 10,
  "10": "APP_ERROR_HANDLER",
  "APP_WARN_HANDLER": 11,
  "11": "APP_WARN_HANDLER",
  "FUNCTION_REF": 12,
  "12": "FUNCTION_REF",
  "ASYNC_COMPONENT_LOADER": 13,
  "13": "ASYNC_COMPONENT_LOADER",
  "SCHEDULER": 14,
  "14": "SCHEDULER",
  "COMPONENT_UPDATE": 15,
  "15": "COMPONENT_UPDATE",
  "APP_UNMOUNT_CLEANUP": 16,
  "16": "APP_UNMOUNT_CLEANUP"
};
const ErrorTypeStrings$1 = {
  ["sp"]: "serverPrefetch hook",
  ["bc"]: "beforeCreate hook",
  ["c"]: "created hook",
  ["bm"]: "beforeMount hook",
  ["m"]: "mounted hook",
  ["bu"]: "beforeUpdate hook",
  ["u"]: "updated",
  ["bum"]: "beforeUnmount hook",
  ["um"]: "unmounted hook",
  ["a"]: "activated hook",
  ["da"]: "deactivated hook",
  ["ec"]: "errorCaptured hook",
  ["rtc"]: "renderTracked hook",
  ["rtg"]: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush",
  [15]: "component update",
  [16]: "app unmount cleanup function"
};
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn)) {
    const values = [];
    for (let i = 0; i < fn.length; i++) {
      values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
  } else if (true) {
    warn$1(
      `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof fn}`
    );
  }
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo =  true ? ErrorTypeStrings$1[type] : 0;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    if (errorHandler) {
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
      callWithErrorHandling(errorHandler, null, 10, [
        err,
        exposedInstance,
        errorInfo
      ]);
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
}
function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
  if (true) {
    const info = ErrorTypeStrings$1[type];
    if (contextVNode) {
      pushWarningContext(contextVNode);
    }
    warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
    if (contextVNode) {
      popWarningContext();
    }
    if (throwInDev) {
      throw err;
    } else {
      console.error(err);
    }
  } else {}
}

const queue = [];
let flushIndex = -1;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
  const p = currentFlushPromise || resolvedPromise;
  return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!(job.flags & 1)) {
    const jobId = getId(job);
    const lastJob = queue[queue.length - 1];
    if (!lastJob || // fast path when the job id is larger than the tail
    !(job.flags & 2) && jobId >= getId(lastJob)) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(jobId), 0, job);
    }
    job.flags |= 1;
    queueFlush();
  }
}
function queueFlush() {
  if (!currentFlushPromise) {
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function queuePostFlushCb(cb) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(cb)) {
    if (activePostFlushCbs && cb.id === -1) {
      activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
    } else if (!(cb.flags & 1)) {
      pendingPostFlushCbs.push(cb);
      cb.flags |= 1;
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
  if (true) {
    seen = seen || /* @__PURE__ */ new Map();
  }
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.flags & 2) {
      if (instance && cb.id !== instance.uid) {
        continue;
      }
      if ( true && checkRecursiveUpdates(seen, cb)) {
        continue;
      }
      queue.splice(i, 1);
      i--;
      if (cb.flags & 4) {
        cb.flags &= ~1;
      }
      cb();
      if (!(cb.flags & 4)) {
        cb.flags &= ~1;
      }
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a, b) => getId(a) - getId(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    if (true) {
      seen = seen || /* @__PURE__ */ new Map();
    }
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      const cb = activePostFlushCbs[postFlushIndex];
      if ( true && checkRecursiveUpdates(seen, cb)) {
        continue;
      }
      if (cb.flags & 4) {
        cb.flags &= ~1;
      }
      if (!(cb.flags & 8)) cb();
      cb.flags &= ~1;
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
function flushJobs(seen) {
  if (true) {
    seen = seen || /* @__PURE__ */ new Map();
  }
  const check =  true ? (job) => checkRecursiveUpdates(seen, job) : 0;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && !(job.flags & 8)) {
        if ( true && check(job)) {
          continue;
        }
        if (job.flags & 4) {
          job.flags &= ~1;
        }
        callWithErrorHandling(
          job,
          job.i,
          job.i ? 15 : 14
        );
        if (!(job.flags & 4)) {
          job.flags &= ~1;
        }
      }
    }
  } finally {
    for (; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job) {
        job.flags &= ~1;
      }
    }
    flushIndex = -1;
    queue.length = 0;
    flushPostFlushCbs(seen);
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}
function checkRecursiveUpdates(seen, fn) {
  const count = seen.get(fn) || 0;
  if (count > RECURSION_LIMIT) {
    const instance = fn.i;
    const componentName = instance && getComponentName(instance.type);
    handleError(
      `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
      null,
      10
    );
    return true;
  }
  seen.set(fn, count + 1);
  return false;
}

let isHmrUpdating = false;
const hmrDirtyComponents = /* @__PURE__ */ new Map();
if (true) {
  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
  };
}
const map = /* @__PURE__ */ new Map();
function registerHMR(instance) {
  const id = instance.type.__hmrId;
  let record = map.get(id);
  if (!record) {
    createRecord(id, instance.type);
    record = map.get(id);
  }
  record.instances.add(instance);
}
function unregisterHMR(instance) {
  map.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id, initialDef) {
  if (map.has(id)) {
    return false;
  }
  map.set(id, {
    initialDef: normalizeClassComponent(initialDef),
    instances: /* @__PURE__ */ new Set()
  });
  return true;
}
function normalizeClassComponent(component) {
  return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id, newRender) {
  const record = map.get(id);
  if (!record) {
    return;
  }
  record.initialDef.render = newRender;
  [...record.instances].forEach((instance) => {
    if (newRender) {
      instance.render = newRender;
      normalizeClassComponent(instance.type).render = newRender;
    }
    instance.renderCache = [];
    isHmrUpdating = true;
    instance.update();
    isHmrUpdating = false;
  });
}
function reload(id, newComp) {
  const record = map.get(id);
  if (!record) return;
  newComp = normalizeClassComponent(newComp);
  updateComponentDef(record.initialDef, newComp);
  const instances = [...record.instances];
  for (let i = 0; i < instances.length; i++) {
    const instance = instances[i];
    const oldComp = normalizeClassComponent(instance.type);
    let dirtyInstances = hmrDirtyComponents.get(oldComp);
    if (!dirtyInstances) {
      if (oldComp !== record.initialDef) {
        updateComponentDef(oldComp, newComp);
      }
      hmrDirtyComponents.set(oldComp, dirtyInstances = /* @__PURE__ */ new Set());
    }
    dirtyInstances.add(instance);
    instance.appContext.propsCache.delete(instance.type);
    instance.appContext.emitsCache.delete(instance.type);
    instance.appContext.optionsCache.delete(instance.type);
    if (instance.ceReload) {
      dirtyInstances.add(instance);
      instance.ceReload(newComp.styles);
      dirtyInstances.delete(instance);
    } else if (instance.parent) {
      queueJob(() => {
        isHmrUpdating = true;
        instance.parent.update();
        isHmrUpdating = false;
        dirtyInstances.delete(instance);
      });
    } else if (instance.appContext.reload) {
      instance.appContext.reload();
    } else if (typeof window !== "undefined") {
      window.location.reload();
    } else {
      console.warn(
        "[HMR] Root or manually mounted instance modified. Full reload required."
      );
    }
    if (instance.root.ce && instance !== instance.root) {
      instance.root.ce._removeChildStyle(oldComp);
    }
  }
  queuePostFlushCb(() => {
    hmrDirtyComponents.clear();
  });
}
function updateComponentDef(oldComp, newComp) {
  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(oldComp, newComp);
  for (const key in oldComp) {
    if (key !== "__file" && !(key in newComp)) {
      delete oldComp[key];
    }
  }
}
function tryWrap(fn) {
  return (id, arg) => {
    try {
      return fn(id, arg);
    } catch (e) {
      console.error(e);
      console.warn(
        `[HMR] Something went wrong during Vue component hot-reload. Full reload required.`
      );
    }
  };
}

let devtools$1;
let buffer = [];
let devtoolsNotInstalled = false;
function emit$1(event, ...args) {
  if (devtools$1) {
    devtools$1.emit(event, ...args);
  } else if (!devtoolsNotInstalled) {
    buffer.push({ event, args });
  }
}
function setDevtoolsHook$1(hook, target) {
  var _a, _b;
  devtools$1 = hook;
  if (devtools$1) {
    devtools$1.enabled = true;
    buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));
    buffer = [];
  } else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    // eslint-disable-next-line no-restricted-syntax
    !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))
  ) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook$1(newHook, target);
    });
    setTimeout(() => {
      if (!devtools$1) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        devtoolsNotInstalled = true;
        buffer = [];
      }
    }, 3e3);
  } else {
    devtoolsNotInstalled = true;
    buffer = [];
  }
}
function devtoolsInitApp(app, version) {
  emit$1("app:init" /* APP_INIT */, app, version, {
    Fragment,
    Text,
    Comment,
    Static
  });
}
function devtoolsUnmountApp(app) {
  emit$1("app:unmount" /* APP_UNMOUNT */, app);
}
const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook("component:added" /* COMPONENT_ADDED */);
const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */);
const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:removed" /* COMPONENT_REMOVED */
);
const devtoolsComponentRemoved = (component) => {
  if (devtools$1 && typeof devtools$1.cleanupBuffer === "function" && // remove the component if it wasn't buffered
  !devtools$1.cleanupBuffer(component)) {
    _devtoolsComponentRemoved(component);
  }
};
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function createDevtoolsComponentHook(hook) {
  return (component) => {
    emit$1(
      hook,
      component.appContext.app,
      component.uid,
      component.parent ? component.parent.uid : void 0,
      component
    );
  };
}
const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:start" /* PERFORMANCE_START */);
const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:end" /* PERFORMANCE_END */);
function createDevtoolsPerformanceHook(hook) {
  return (component, type, time) => {
    emit$1(hook, component.appContext.app, component.uid, component, type, time);
  };
}
function devtoolsComponentEmit(component, event, params) {
  emit$1(
    "component:emit" /* COMPONENT_EMIT */,
    component.appContext.app,
    component,
    event,
    params
  );
}

let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
const withScopeId = (_id) => withCtx;
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx) return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    if (true) {
      devtoolsComponentUpdated(ctx);
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}

function validateDirectiveName(name) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isBuiltInDirective)(name)) {
    warn$1("Do not use built-in directive ids as custom directive id: " + name);
  }
}
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
     true && warn$1(`withDirectives can only be used inside render functions.`);
    return vnode;
  }
  const instance = getComponentPublicInstance(currentRenderingInstance);
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ] = directives[i];
    if (dir) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.traverse)(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
    }
  }
}

const TeleportEndKey = Symbol("_vte");
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTeleportDeferred = (props) => props && (props.defer || props.defer === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(targetSelector)) {
    if (!select) {
       true && warn$1(
        `Current renderer does not support string target for Teleports. (missing querySelector renderer option)`
      );
      return null;
    } else {
      const target = select(targetSelector);
      if ( true && !target && !isTeleportDisabled(props)) {
        warn$1(
          `Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
        );
      }
      return target;
    }
  } else {
    if ( true && !targetSelector && !isTeleportDisabled(props)) {
      warn$1(`Invalid Teleport target: ${targetSelector}`);
    }
    return targetSelector;
  }
};
const TeleportImpl = {
  name: "Teleport",
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert, querySelector, createText, createComment }
    } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if ( true && isHmrUpdating) {
      optimized = false;
      dynamicChildren = null;
    }
    if (n1 == null) {
      const placeholder = n2.el =  true ? createComment("teleport start") : 0;
      const mainAnchor = n2.anchor =  true ? createComment("teleport end") : 0;
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          if (parentComponent && parentComponent.isCE) {
            parentComponent.ce._teleportTarget = container2;
          }
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountToTarget = () => {
        const target = n2.target = resolveTarget(n2.props, querySelector);
        const targetAnchor = prepareAnchor(target, n2, createText, insert);
        if (target) {
          if (namespace !== "svg" && isTargetSVG(target)) {
            namespace = "svg";
          } else if (namespace !== "mathml" && isTargetMathML(target)) {
            namespace = "mathml";
          }
          if (!disabled) {
            mount(target, targetAnchor);
            updateCssVars(n2, false);
          }
        } else if ( true && !disabled) {
          warn$1(
            "Invalid Teleport target on mount:",
            target,
            `(${typeof target})`
          );
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
        updateCssVars(n2, true);
      }
      if (isTeleportDeferred(n2.props)) {
        queuePostRenderEffect(() => {
          mountToTarget();
          n2.el.__isMounted = true;
        }, parentSuspense);
      } else {
        mountToTarget();
      }
    } else {
      if (isTeleportDeferred(n2.props) && !n1.el.__isMounted) {
        queuePostRenderEffect(() => {
          TeleportImpl.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
          delete n1.el.__isMounted;
        }, parentSuspense);
        return;
      }
      n2.el = n1.el;
      n2.targetStart = n1.targetStart;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      if (namespace === "svg" || isTargetSVG(target)) {
        namespace = "svg";
      } else if (namespace === "mathml" || isTargetMathML(target)) {
        namespace = "mathml";
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          false
        );
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        } else {
          if (n2.props && n1.props && n2.props.to !== n1.props.to) {
            n2.props.to = n1.props.to;
          }
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          } else if (true) {
            warn$1(
              "Invalid Teleport target on update:",
              target,
              `(${typeof target})`
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
      updateCssVars(n2, disabled);
    }
  },
  remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const {
      shapeFlag,
      children,
      anchor,
      targetStart,
      targetAnchor,
      target,
      props
    } = vnode;
    if (target) {
      hostRemove(targetStart);
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props);
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        unmount(
          child,
          parentComponent,
          parentSuspense,
          shouldRemove,
          !!child.dynamicChildren
        );
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(
          children[i],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector, insert, createText }
}, hydrateChildren) {
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  if (target) {
    const disabled = isTeleportDisabled(vnode.props);
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (disabled) {
        vnode.anchor = hydrateChildren(
          nextSibling(node),
          vnode,
          parentNode(node),
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        vnode.targetStart = targetNode;
        vnode.targetAnchor = targetNode && nextSibling(targetNode);
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          if (targetAnchor && targetAnchor.nodeType === 8) {
            if (targetAnchor.data === "teleport start anchor") {
              vnode.targetStart = targetAnchor;
            } else if (targetAnchor.data === "teleport anchor") {
              vnode.targetAnchor = targetAnchor;
              target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
              break;
            }
          }
          targetAnchor = nextSibling(targetAnchor);
        }
        if (!vnode.targetAnchor) {
          prepareAnchor(target, vnode, createText, insert);
        }
        hydrateChildren(
          targetNode && nextSibling(targetNode),
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode, disabled);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode, isDisabled) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node, anchor;
    if (isDisabled) {
      node = vnode.el;
      anchor = vnode.anchor;
    } else {
      node = vnode.targetStart;
      anchor = vnode.targetAnchor;
    }
    while (node && node !== anchor) {
      if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
function prepareAnchor(target, vnode, createText, insert) {
  const targetStart = vnode.targetStart = createText("");
  const targetAnchor = vnode.targetAnchor = createText("");
  targetStart[TeleportEndKey] = targetAnchor;
  if (target) {
    insert(targetStart, target);
    insert(targetAnchor, target);
  }
  return targetAnchor;
}

const leaveCbKey = Symbol("_leaveCb");
const enterCbKey = Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const recursiveGetSubtree = (instance) => {
  const subTree = instance.subTree;
  return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      const child = findNonCommentChild(children);
      const rawProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
      const { mode } = rawProps;
      if ( true && mode && mode !== "in-out" && mode !== "out-in" && mode !== "default") {
        warn$1(`invalid <transition> mode: ${mode}`);
      }
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getInnerChild$1(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      let enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance,
        // #11061, ensure enterHooks is fresh after clone
        (hooks) => enterHooks = hooks
      );
      if (innerChild.type !== Comment) {
        setTransitionHooks(innerChild, enterHooks);
      }
      let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
        let leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in" && innerChild.type !== Comment) {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (!(instance.job.flags & 8)) {
              instance.update();
            }
            delete leavingHooks.afterLeave;
            oldInnerChild = void 0;
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
            enterHooks.delayedLeave = () => {
              delayedLeave();
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
          };
        } else {
          oldInnerChild = void 0;
        }
      } else if (oldInnerChild) {
        oldInnerChild = void 0;
      }
      return child;
    };
  }
};
function findNonCommentChild(children) {
  let child = children[0];
  if (children.length > 1) {
    let hasFound = false;
    for (const c of children) {
      if (c.type !== Comment) {
        if ( true && hasFound) {
          warn$1(
            "<transition> can only be used on a single element or component. Use <transition-group> for lists."
          );
          break;
        }
        child = c;
        hasFound = true;
        if (false) {}
      }
    }
  }
  return child;
}
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance, postClone) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook(hook, args);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
      if (hook.every((hook2) => hook2.length <= 1)) done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        if (cancelled) {
          callHook(cancelHook, [el]);
        } else {
          callHook(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove) {
      const key2 = String(vnode.key);
      if (el[enterCbKey]) {
        el[enterCbKey](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove();
      }
      callHook(onBeforeLeave, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        remove();
        if (cancelled) {
          callHook(onLeaveCancelled, [el]);
        } else {
          callHook(onAfterLeave, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      const hooks2 = resolveTransitionHooks(
        vnode2,
        props,
        state,
        instance,
        postClone
      );
      if (postClone) postClone(hooks2);
      return hooks2;
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getInnerChild$1(vnode) {
  if (!isKeepAlive(vnode)) {
    if (isTeleport(vnode.type) && vnode.children) {
      return findNonCommentChild(vnode.children);
    }
    return vnode;
  }
  if ( true && vnode.component) {
    return vnode.component.subTree;
  }
  const { shapeFlag, children } = vnode;
  if (children) {
    if (shapeFlag & 16) {
      return children[0];
    }
    if (shapeFlag & 32 && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(children.default)) {
      return children.default();
    }
  }
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    vnode.transition = hooks;
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128) keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}

/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}

function useId() {
  const i = getCurrentInstance();
  if (i) {
    return (i.appContext.config.idPrefix || "v") + "-" + i.ids[0] + i.ids[1]++;
  } else if (true) {
    warn$1(
      `useId() is called when there is no active component instance to be associated with.`
    );
  }
  return "";
}
function markAsyncBoundary(instance) {
  instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
}

const knownTemplateRefs = /* @__PURE__ */ new WeakSet();
function useTemplateRef(key) {
  const i = getCurrentInstance();
  const r = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowRef)(null);
  if (i) {
    const refs = i.refs === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ ? i.refs = {} : i.refs;
    let desc;
    if ( true && (desc = Object.getOwnPropertyDescriptor(refs, key)) && !desc.configurable) {
      warn$1(`useTemplateRef('${key}') already exists.`);
    } else {
      Object.defineProperty(refs, key, {
        enumerable: true,
        get: () => r.value,
        set: (val) => r.value = val
      });
    }
  } else if (true) {
    warn$1(
      `useTemplateRef() is called when there is no active component instance to be associated with.`
    );
  }
  const ret =  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.readonly)(r) : 0;
  if (true) {
    knownTemplateRefs.add(ret);
  }
  return ret;
}

function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(rawRef)) {
    rawRef.forEach(
      (r, i) => setRef(
        r,
        oldRawRef && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
      setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
    }
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref } = rawRef;
  if ( true && !owner) {
    warn$1(
      `Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`
    );
    return;
  }
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  const rawSetupState = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(setupState);
  const canSetSetupRef = setupState === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ ? () => false : (key) => {
    if (true) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawSetupState, key) && !(0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(rawSetupState[key])) {
        warn$1(
          `Template ref "${key}" used on a non-ref value. It will not work in the production build.`
        );
      }
      if (knownTemplateRefs.has(rawSetupState[key])) {
        return false;
      }
    }
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawSetupState, key);
  };
  if (oldRef != null && oldRef !== ref) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(oldRef)) {
      refs[oldRef] = null;
      if (canSetSetupRef(oldRef)) {
        setupState[oldRef] = null;
      }
    } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(oldRef)) {
      oldRef.value = null;
    }
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)) {
    callWithErrorHandling(ref, owner, 12, [value, refs]);
  } else {
    const _isString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref);
    const _isRef = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? canSetSetupRef(ref) ? setupState[ref] : refs[ref] : ref.value;
          if (isUnmount) {
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(existing, refValue);
          } else {
            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing)) {
              if (_isString) {
                refs[ref] = [refValue];
                if (canSetSetupRef(ref)) {
                  setupState[ref] = refs[ref];
                }
              } else {
                ref.value = [refValue];
                if (rawRef.k) refs[rawRef.k] = ref.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref] = value;
          if (canSetSetupRef(ref)) {
            setupState[ref] = value;
          }
        } else if (_isRef) {
          ref.value = value;
          if (rawRef.k) refs[rawRef.k] = value;
        } else if (true) {
          warn$1("Invalid template ref type:", ref, `(${typeof ref})`);
        }
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    } else if (true) {
      warn$1("Invalid template ref type:", ref, `(${typeof ref})`);
    }
  }
}

let hasLoggedMismatchError = false;
const logMismatchError = () => {
  if (hasLoggedMismatchError) {
    return;
  }
  console.error("Hydration completed but contains mismatches.");
  hasLoggedMismatchError = true;
};
const isSVGContainer = (container) => container.namespaceURI.includes("svg") && container.tagName !== "foreignObject";
const isMathMLContainer = (container) => container.namespaceURI.includes("MathML");
const getContainerType = (container) => {
  if (container.nodeType !== 1) return void 0;
  if (isSVGContainer(container)) return "svg";
  if (isMathMLContainer(container)) return "mathml";
  return void 0;
};
const isComment = (node) => node.nodeType === 8;
function createHydrationFunctions(rendererInternals) {
  const {
    mt: mountComponent,
    p: patch,
    o: {
      patchProp,
      createText,
      nextSibling,
      parentNode,
      remove,
      insert,
      createComment
    }
  } = rendererInternals;
  const hydrate = (vnode, container) => {
    if (!container.hasChildNodes()) {
      ( true) && warn$1(
        `Attempting to hydrate existing markup but container is empty. Performing full mount instead.`
      );
      patch(null, vnode, container);
      flushPostFlushCbs();
      container._vnode = vnode;
      return;
    }
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const isFragmentStart = isComment(node) && node.data === "[";
    const onMismatch = () => handleMismatch(
      node,
      vnode,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      isFragmentStart
    );
    const { type, ref, shapeFlag, patchFlag } = vnode;
    let domType = node.nodeType;
    vnode.el = node;
    if (true) {
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(node, "__vnode", vnode, true);
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(node, "__vueParentComponent", parentComponent, true);
    }
    if (patchFlag === -2) {
      optimized = false;
      vnode.dynamicChildren = null;
    }
    let nextNode = null;
    switch (type) {
      case Text:
        if (domType !== 3) {
          if (vnode.children === "") {
            insert(vnode.el = createText(""), parentNode(node), node);
            nextNode = node;
          } else {
            nextNode = onMismatch();
          }
        } else {
          if (node.data !== vnode.children) {
            ( true) && warn$1(
              `Hydration text mismatch in`,
              node.parentNode,
              `
  - rendered on server: ${JSON.stringify(
                node.data
              )}
  - expected on client: ${JSON.stringify(vnode.children)}`
            );
            logMismatchError();
            node.data = vnode.children;
          }
          nextNode = nextSibling(node);
        }
        break;
      case Comment:
        if (isTemplateNode(node)) {
          nextNode = nextSibling(node);
          replaceNode(
            vnode.el = node.content.firstChild,
            node,
            parentComponent
          );
        } else if (domType !== 8 || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node);
        }
        break;
      case Static:
        if (isFragmentStart) {
          node = nextSibling(node);
          domType = node.nodeType;
        }
        if (domType === 1 || domType === 3) {
          nextNode = node;
          const needToAdoptContent = !vnode.children.length;
          for (let i = 0; i < vnode.staticCount; i++) {
            if (needToAdoptContent)
              vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
            if (i === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }
            nextNode = nextSibling(nextNode);
          }
          return isFragmentStart ? nextSibling(nextNode) : nextNode;
        } else {
          onMismatch();
        }
        break;
      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
        break;
      default:
        if (shapeFlag & 1) {
          if ((domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode(node)) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        } else if (shapeFlag & 6) {
          vnode.slotScopeIds = slotScopeIds;
          const container = parentNode(node);
          if (isFragmentStart) {
            nextNode = locateClosingAnchor(node);
          } else if (isComment(node) && node.data === "teleport start") {
            nextNode = locateClosingAnchor(node, node.data, "teleport end");
          } else {
            nextNode = nextSibling(node);
          }
          mountComponent(
            vnode,
            container,
            null,
            parentComponent,
            parentSuspense,
            getContainerType(container),
            optimized
          );
          if (isAsyncWrapper(vnode) && !vnode.type.__asyncResolved) {
            let subTree;
            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
            } else {
              subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
            }
            subTree.el = node;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64) {
          if (domType !== 8) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized,
              rendererInternals,
              hydrateChildren
            );
          }
        } else if (shapeFlag & 128) {
          nextNode = vnode.type.hydrate(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            getContainerType(parentNode(node)),
            slotScopeIds,
            optimized,
            rendererInternals,
            hydrateNode
          );
        } else if (true) {
          warn$1("Invalid HostVNode type:", type, `(${typeof type})`);
        }
    }
    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode);
    }
    return nextNode;
  };
  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const { type, props, patchFlag, shapeFlag, dirs, transition } = vnode;
    const forcePatch = type === "input" || type === "option";
    if (true) {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      let needCallTransitionHooks = false;
      if (isTemplateNode(el)) {
        needCallTransitionHooks = needTransition(
          null,
          // no need check parentSuspense in hydration
          transition
        ) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;
        const content = el.content.firstChild;
        if (needCallTransitionHooks) {
          transition.beforeEnter(content);
        }
        replaceNode(content, el, parentComponent);
        vnode.el = el = content;
      }
      if (shapeFlag & 16 && // skip if element has innerHTML / textContent
      !(props && (props.innerHTML || props.textContent))) {
        let next = hydrateChildren(
          el.firstChild,
          vnode,
          el,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        let hasWarned = false;
        while (next) {
          if (!isMismatchAllowed(el, 1 /* CHILDREN */)) {
            if (( true) && !hasWarned) {
              warn$1(
                `Hydration children mismatch on`,
                el,
                `
Server rendered element contains more child nodes than client vdom.`
              );
              hasWarned = true;
            }
            logMismatchError();
          }
          const cur = next;
          next = next.nextSibling;
          remove(cur);
        }
      } else if (shapeFlag & 8) {
        let clientText = vnode.children;
        if (clientText[0] === "\n" && (el.tagName === "PRE" || el.tagName === "TEXTAREA")) {
          clientText = clientText.slice(1);
        }
        if (el.textContent !== clientText) {
          if (!isMismatchAllowed(el, 0 /* TEXT */)) {
            ( true) && warn$1(
              `Hydration text content mismatch on`,
              el,
              `
  - rendered on server: ${el.textContent}
  - expected on client: ${vnode.children}`
            );
            logMismatchError();
          }
          el.textContent = vnode.children;
        }
      }
      if (props) {
        if (true) {
          const isCustomElement = el.tagName.includes("-");
          for (const key in props) {
            if (( true) && // #11189 skip if this node has directives that have created hooks
            // as it could have mutated the DOM in any possible way
            !(dirs && dirs.some((d) => d.dir.created)) && propHasMismatch(el, key, props[key], vnode, parentComponent)) {
              logMismatchError();
            }
            if (forcePatch && (key.endsWith("value") || key === "indeterminate") || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key) || // force hydrate v-bind with .prop modifiers
            key[0] === "." || isCustomElement) {
              patchProp(el, key, null, props[key], void 0, parentComponent);
            }
          }
        } else {}
      }
      let vnodeHooks;
      if (vnodeHooks = props && props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {
        queueEffectWithSuspense(() => {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    }
    return el.nextSibling;
  };
  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l = children.length;
    let hasWarned = false;
    for (let i = 0; i < l; i++) {
      const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
      const isText = vnode.type === Text;
      if (node) {
        if (isText && !optimized) {
          if (i + 1 < l && normalizeVNode(children[i + 1]).type === Text) {
            insert(
              createText(
                node.data.slice(vnode.children.length)
              ),
              container,
              nextSibling(node)
            );
            node.data = vnode.children;
          }
        }
        node = hydrateNode(
          node,
          vnode,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      } else if (isText && !vnode.children) {
        insert(vnode.el = createText(""), container);
      } else {
        if (!isMismatchAllowed(container, 1 /* CHILDREN */)) {
          if (( true) && !hasWarned) {
            warn$1(
              `Hydration children mismatch on`,
              container,
              `
Server rendered element contains fewer child nodes than client vdom.`
            );
            hasWarned = true;
          }
          logMismatchError();
        }
        patch(
          null,
          vnode,
          container,
          null,
          parentComponent,
          parentSuspense,
          getContainerType(container),
          slotScopeIds
        );
      }
    }
    return node;
  };
  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    const { slotScopeIds: fragmentSlotScopeIds } = vnode;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    const container = parentNode(node);
    const next = hydrateChildren(
      nextSibling(node),
      vnode,
      container,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      optimized
    );
    if (next && isComment(next) && next.data === "]") {
      return nextSibling(vnode.anchor = next);
    } else {
      logMismatchError();
      insert(vnode.anchor = createComment(`]`), container, next);
      return next;
    }
  };
  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
    if (!isMismatchAllowed(node.parentElement, 1 /* CHILDREN */)) {
      ( true) && warn$1(
        `Hydration node mismatch:
- rendered on server:`,
        node,
        node.nodeType === 3 ? `(text)` : isComment(node) && node.data === "[" ? `(start of fragment)` : ``,
        `
- expected on client:`,
        vnode.type
      );
      logMismatchError();
    }
    vnode.el = null;
    if (isFragment) {
      const end = locateClosingAnchor(node);
      while (true) {
        const next2 = nextSibling(node);
        if (next2 && next2 !== end) {
          remove(next2);
        } else {
          break;
        }
      }
    }
    const next = nextSibling(node);
    const container = parentNode(node);
    remove(node);
    patch(
      null,
      vnode,
      container,
      next,
      parentComponent,
      parentSuspense,
      getContainerType(container),
      slotScopeIds
    );
    if (parentComponent) {
      parentComponent.vnode.el = vnode.el;
      updateHOCHostEl(parentComponent, vnode.el);
    }
    return next;
  };
  const locateClosingAnchor = (node, open = "[", close = "]") => {
    let match = 0;
    while (node) {
      node = nextSibling(node);
      if (node && isComment(node)) {
        if (node.data === open) match++;
        if (node.data === close) {
          if (match === 0) {
            return nextSibling(node);
          } else {
            match--;
          }
        }
      }
    }
    return node;
  };
  const replaceNode = (newNode, oldNode, parentComponent) => {
    const parentNode2 = oldNode.parentNode;
    if (parentNode2) {
      parentNode2.replaceChild(newNode, oldNode);
    }
    let parent = parentComponent;
    while (parent) {
      if (parent.vnode.el === oldNode) {
        parent.vnode.el = parent.subTree.el = newNode;
      }
      parent = parent.parent;
    }
  };
  const isTemplateNode = (node) => {
    return node.nodeType === 1 && node.tagName === "TEMPLATE";
  };
  return [hydrate, hydrateNode];
}
function propHasMismatch(el, key, clientValue, vnode, instance) {
  let mismatchType;
  let mismatchKey;
  let actual;
  let expected;
  if (key === "class") {
    actual = el.getAttribute("class");
    expected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(clientValue);
    if (!isSetEqual(toClassSet(actual || ""), toClassSet(expected))) {
      mismatchType = 2 /* CLASS */;
      mismatchKey = `class`;
    }
  } else if (key === "style") {
    actual = el.getAttribute("style") || "";
    expected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(clientValue) ? clientValue : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.stringifyStyle)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)(clientValue));
    const actualMap = toStyleMap(actual);
    const expectedMap = toStyleMap(expected);
    if (vnode.dirs) {
      for (const { dir, value } of vnode.dirs) {
        if (dir.name === "show" && !value) {
          expectedMap.set("display", "none");
        }
      }
    }
    if (instance) {
      resolveCssVars(instance, vnode, expectedMap);
    }
    if (!isMapEqual(actualMap, expectedMap)) {
      mismatchType = 3 /* STYLE */;
      mismatchKey = "style";
    }
  } else if (el instanceof SVGElement && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isKnownSvgAttr)(key) || el instanceof HTMLElement && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isBooleanAttr)(key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isKnownHtmlAttr)(key))) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isBooleanAttr)(key)) {
      actual = el.hasAttribute(key);
      expected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.includeBooleanAttr)(clientValue);
    } else if (clientValue == null) {
      actual = el.hasAttribute(key);
      expected = false;
    } else {
      if (el.hasAttribute(key)) {
        actual = el.getAttribute(key);
      } else if (key === "value" && el.tagName === "TEXTAREA") {
        actual = el.value;
      } else {
        actual = false;
      }
      expected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isRenderableAttrValue)(clientValue) ? String(clientValue) : false;
    }
    if (actual !== expected) {
      mismatchType = 4 /* ATTRIBUTE */;
      mismatchKey = key;
    }
  }
  if (mismatchType != null && !isMismatchAllowed(el, mismatchType)) {
    const format = (v) => v === false ? `(not rendered)` : `${mismatchKey}="${v}"`;
    const preSegment = `Hydration ${MismatchTypeString[mismatchType]} mismatch on`;
    const postSegment = `
  - rendered on server: ${format(actual)}
  - expected on client: ${format(expected)}
  Note: this mismatch is check-only. The DOM will not be rectified in production due to performance overhead.
  You should fix the source of the mismatch.`;
    {
      warn$1(preSegment, el, postSegment);
    }
    return true;
  }
  return false;
}
function toClassSet(str) {
  return new Set(str.trim().split(/\s+/));
}
function isSetEqual(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  for (const s of a) {
    if (!b.has(s)) {
      return false;
    }
  }
  return true;
}
function toStyleMap(str) {
  const styleMap = /* @__PURE__ */ new Map();
  for (const item of str.split(";")) {
    let [key, value] = item.split(":");
    key = key.trim();
    value = value && value.trim();
    if (key && value) {
      styleMap.set(key, value);
    }
  }
  return styleMap;
}
function isMapEqual(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  for (const [key, value] of a) {
    if (value !== b.get(key)) {
      return false;
    }
  }
  return true;
}
function resolveCssVars(instance, vnode, expectedMap) {
  const root = instance.subTree;
  if (instance.getCssVars && (vnode === root || root && root.type === Fragment && root.children.includes(vnode))) {
    const cssVars = instance.getCssVars();
    for (const key in cssVars) {
      expectedMap.set(
        `--${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getEscapedCssVarName)(key, false)}`,
        String(cssVars[key])
      );
    }
  }
  if (vnode === root && instance.parent) {
    resolveCssVars(instance.parent, instance.vnode, expectedMap);
  }
}
const allowMismatchAttr = "data-allow-mismatch";
const MismatchTypeString = {
  [0 /* TEXT */]: "text",
  [1 /* CHILDREN */]: "children",
  [2 /* CLASS */]: "class",
  [3 /* STYLE */]: "style",
  [4 /* ATTRIBUTE */]: "attribute"
};
function isMismatchAllowed(el, allowedType) {
  if (allowedType === 0 /* TEXT */ || allowedType === 1 /* CHILDREN */) {
    while (el && !el.hasAttribute(allowMismatchAttr)) {
      el = el.parentElement;
    }
  }
  const allowedAttr = el && el.getAttribute(allowMismatchAttr);
  if (allowedAttr == null) {
    return false;
  } else if (allowedAttr === "") {
    return true;
  } else {
    const list = allowedAttr.split(",");
    if (allowedType === 0 /* TEXT */ && list.includes("children")) {
      return true;
    }
    return allowedAttr.split(",").includes(MismatchTypeString[allowedType]);
  }
}

const requestIdleCallback = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().requestIdleCallback || ((cb) => setTimeout(cb, 1));
const cancelIdleCallback = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().cancelIdleCallback || ((id) => clearTimeout(id));
const hydrateOnIdle = (timeout = 1e4) => (hydrate) => {
  const id = requestIdleCallback(hydrate, { timeout });
  return () => cancelIdleCallback(id);
};
function elementIsVisibleInViewport(el) {
  const { top, left, bottom, right } = el.getBoundingClientRect();
  const { innerHeight, innerWidth } = window;
  return (top > 0 && top < innerHeight || bottom > 0 && bottom < innerHeight) && (left > 0 && left < innerWidth || right > 0 && right < innerWidth);
}
const hydrateOnVisible = (opts) => (hydrate, forEach) => {
  const ob = new IntersectionObserver((entries) => {
    for (const e of entries) {
      if (!e.isIntersecting) continue;
      ob.disconnect();
      hydrate();
      break;
    }
  }, opts);
  forEach((el) => {
    if (!(el instanceof Element)) return;
    if (elementIsVisibleInViewport(el)) {
      hydrate();
      ob.disconnect();
      return false;
    }
    ob.observe(el);
  });
  return () => ob.disconnect();
};
const hydrateOnMediaQuery = (query) => (hydrate) => {
  if (query) {
    const mql = matchMedia(query);
    if (mql.matches) {
      hydrate();
    } else {
      mql.addEventListener("change", hydrate, { once: true });
      return () => mql.removeEventListener("change", hydrate);
    }
  }
};
const hydrateOnInteraction = (interactions = []) => (hydrate, forEach) => {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(interactions)) interactions = [interactions];
  let hasHydrated = false;
  const doHydrate = (e) => {
    if (!hasHydrated) {
      hasHydrated = true;
      teardown();
      hydrate();
      e.target.dispatchEvent(new e.constructor(e.type, e));
    }
  };
  const teardown = () => {
    forEach((el) => {
      for (const i of interactions) {
        el.removeEventListener(i, doHydrate);
      }
    });
  };
  forEach((el) => {
    for (const i of interactions) {
      el.addEventListener(i, doHydrate, { once: true });
    }
  });
  return teardown;
};
function forEachElement(node, cb) {
  if (isComment(node) && node.data === "[") {
    let depth = 1;
    let next = node.nextSibling;
    while (next) {
      if (next.nodeType === 1) {
        const result = cb(next);
        if (result === false) {
          break;
        }
      } else if (isComment(next)) {
        if (next.data === "]") {
          if (--depth === 0) break;
        } else if (next.data === "[") {
          depth++;
        }
      }
      next = next.nextSibling;
    }
  } else {
    cb(node);
  }
}

const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineAsyncComponent(source) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {
    source = { loader: source };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    hydrate: hydrateStrategy,
    timeout,
    // undefined = never times out
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve, reject) => {
          const userRetry = () => resolve(retry());
          const userFail = () => reject(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if ( true && !comp) {
        warn$1(
          `Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`
        );
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      if ( true && comp && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
        throw new Error(`Invalid async component load result: ${comp}`);
      }
      resolvedComp = comp;
      return comp;
    }));
  };
  return defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    __asyncHydrate(el, instance, hydrate) {
      const doHydrate = hydrateStrategy ? () => {
        const teardown = hydrateStrategy(
          hydrate,
          (cb) => forEachElement(el, cb)
        );
        if (teardown) {
          (instance.bum || (instance.bum = [])).push(teardown);
        }
      } : hydrate;
      if (resolvedComp) {
        doHydrate();
      } else {
        load().then(() => !instance.isUnmounted && doHydrate());
      }
    },
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      markAsyncBoundary(instance);
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(
          err,
          instance,
          13,
          !errorComponent
        );
      };
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then((comp) => {
          return () => createInnerComp(comp, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(false);
      const error = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)();
      const delayed = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(
              `Async component timed out after ${timeout}ms.`
            );
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          instance.parent.update();
        }
      }).catch((err) => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
function createInnerComp(comp, parent) {
  const { ref: ref2, props, children, ce } = parent.vnode;
  const vnode = createVNode(comp, props, children);
  vnode.ref = ref2;
  vnode.ce = ce;
  delete parent.vnode.ce;
  return vnode;
}

const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
  name: `KeepAlive`,
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return () => {
        const children = slots.default && slots.default();
        return children && children.length === 1 ? children[0] : children;
      };
    }
    const cache = /* @__PURE__ */ new Map();
    const keys = /* @__PURE__ */ new Set();
    let current = null;
    if (true) {
      instance.__v_cache = cache;
    }
    const parentSuspense = instance.suspense;
    const {
      renderer: {
        p: patch,
        m: move,
        um: _unmount,
        o: { createElement }
      }
    } = sharedContext;
    const storageContainer = createElement("div");
    sharedContext.activate = (vnode, container, anchor, namespace, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch(
        instance2.vnode,
        vnode,
        container,
        anchor,
        instance2,
        parentSuspense,
        namespace,
        vnode.slotScopeIds,
        optimized
      );
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
      if (true) {
        devtoolsComponentAdded(instance2);
      }
    };
    sharedContext.deactivate = (vnode) => {
      const instance2 = vnode.component;
      invalidateMount(instance2.m);
      invalidateMount(instance2.a);
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
      if (true) {
        devtoolsComponentAdded(instance2);
      }
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    function pruneCache(filter) {
      cache.forEach((vnode, key) => {
        const name = getComponentName(vnode.type);
        if (name && !filter(name)) {
          pruneCacheEntry(key);
        }
      });
    }
    function pruneCacheEntry(key) {
      const cached = cache.get(key);
      if (cached && (!current || !isSameVNodeType(cached, current))) {
        unmount(cached);
      } else if (current) {
        resetShapeFlag(current);
      }
      cache.delete(key);
      keys.delete(key);
    }
    watch(
      () => [props.include, props.exclude],
      ([include, exclude]) => {
        include && pruneCache((name) => matches(include, name));
        exclude && pruneCache((name) => !matches(exclude, name));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: true }
    );
    let pendingCacheKey = null;
    const cacheSubtree = () => {
      if (pendingCacheKey != null) {
        if (isSuspense(instance.subTree.type)) {
          queuePostRenderEffect(() => {
            cache.set(pendingCacheKey, getInnerChild(instance.subTree));
          }, instance.subTree.suspense);
        } else {
          cache.set(pendingCacheKey, getInnerChild(instance.subTree));
        }
      }
    };
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache.forEach((cached) => {
        const { subTree, suspense } = instance;
        const vnode = getInnerChild(subTree);
        if (cached.type === vnode.type && cached.key === vnode.key) {
          resetShapeFlag(vnode);
          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return current = null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        if (true) {
          warn$1(`KeepAlive should contain exactly one component child.`);
        }
        current = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      if (vnode.type === Comment) {
        current = null;
        return vnode;
      }
      const comp = vnode.type;
      const name = getComponentName(
        isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
      );
      const { include, exclude, max } = props;
      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        vnode.shapeFlag &= ~256;
        current = vnode;
        return rawVNode;
      }
      const key = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache.get(key);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys.delete(key);
        keys.add(key);
      } else {
        keys.add(key);
        if (max && keys.size > parseInt(max, 10)) {
          pruneCacheEntry(keys.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current = vnode;
      return isSuspense(rawVNode.type) ? rawVNode : vnode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(pattern)) {
    return pattern.some((p) => matches(p, name));
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(pattern)) {
    return pattern.split(",").includes(name);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isRegExp)(pattern)) {
    pattern.lastIndex = 0;
    return pattern.test(name);
  }
  return false;
}
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(keepAliveRoot[type], injected);
  }, target);
}
function resetShapeFlag(vnode) {
  vnode.shapeFlag &= ~256;
  vnode.shapeFlag &= ~512;
}
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}

function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      reset();
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  } else if (true) {
    const apiName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(ErrorTypeStrings$1[type].replace(/ hook$/, ""));
    warn$1(
      `${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup().` + (` If you are using async setup(), make sure to register lifecycle hooks before the first await statement.` )
    );
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => {
  if (!isInSSRComponentSetup || lifecycle === "sp") {
    injectHook(lifecycle, (...args) => hook(...args), target);
  }
};
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook(
  "bu"
);
const onUpdated = createHook("u");
const onBeforeUnmount = createHook(
  "bum"
);
const onUnmounted = createHook("um");
const onServerPrefetch = createHook(
  "sp"
);
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}

const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name || selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name) || selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name) || // global registration
      resolve(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    if ( true && warnMissing && !res) {
      const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
      warn$1(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
    }
    return res;
  } else if (true) {
    warn$1(
      `resolve${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(type.slice(0, -1))} can only be used in render() or setup().`
    );
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)] || registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name))]);
}

function renderList(source, renderItem, cache, index) {
  let ret;
  const cached = cache && cache[index];
  const sourceIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source);
  if (sourceIsArray || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source)) {
    const sourceIsReactiveArray = sourceIsArray && (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(source);
    let needsWrap = false;
    if (sourceIsReactiveArray) {
      needsWrap = !(0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow)(source);
      source = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadArray)(source);
    }
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(
        needsWrap ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toReactive)(source[i]) : source[i],
        i,
        void 0,
        cached && cached[i]
      );
    }
  } else if (typeof source === "number") {
    if ( true && !Number.isInteger(source)) {
      warn$1(`The v-for range expect an integer value but got ${source}.`);
    }
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached && cached[i])
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index] = ret;
  }
  return ret;
}

function createSlots(slots, dynamicSlots) {
  for (let i = 0; i < dynamicSlots.length; i++) {
    const slot = dynamicSlots[i];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.key ? (...args) => {
        const res = slot.fn(...args);
        if (res) res.key = slot.key;
        return res;
      } : slot.fn;
    }
  }
  return slots;
}

function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
    if (name !== "default") props.name = name;
    return openBlock(), createBlock(
      Fragment,
      null,
      [createVNode("slot", props, fallback && fallback())],
      64
    );
  }
  let slot = slots[name];
  if ( true && slot && slot.length > 1) {
    warn$1(
      `SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`
    );
    slot = () => [];
  }
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  validSlotContent && validSlotContent.key;
  const rendered = createBlock(
    Fragment,
    {
      key: (slotKey && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSymbol)(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
      (!validSlotContent && fallback ? "_fb" : "")
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child)) return true;
    if (child.type === Comment) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}

function toHandlers(obj, preserveCaseIfNecessary) {
  const ret = {};
  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
    warn$1(`v-on with no argument expects an object value.`);
    return ret;
  }
  for (const key in obj) {
    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(key)] = obj[key];
  }
  return ret;
}

const getPublicInstance = (i) => {
  if (!i) return null;
  if (isStatefulComponent(i)) return getComponentPublicInstance(i);
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) =>  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.props) : 0,
    $attrs: (i) =>  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.attrs) : 0,
    $slots: (i) =>  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.slots) : 0,
    $refs: (i) =>  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.refs) : 0,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $host: (i) => i.ce,
    $emit: (i) => i.emit,
    $options: (i) => __VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type,
    $forceUpdate: (i) => i.f || (i.f = () => {
      queueJob(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => __VUE_OPTIONS_API__ ? instanceWatch.bind(i) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
  })
);
const isReservedPrefix = (key) => key === "_" || key === "$";
const hasSetupBinding = (state, key) => state !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && !state.__isScriptSetup && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    if (key === "__v_skip") {
      return true;
    }
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    if ( true && key === "__isVue") {
      return true;
    }
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1 /* SETUP */:
            return setupState[key];
          case 2 /* DATA */:
            return data[key];
          case 4 /* CONTEXT */:
            return ctx[key];
          case 3 /* PROPS */:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1 /* SETUP */;
        return setupState[key];
      } else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
        accessCache[key] = 2 /* DATA */;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key)
      ) {
        accessCache[key] = 3 /* PROPS */;
        return props[key];
      } else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {
        accessCache[key] = 4 /* CONTEXT */;
        return ctx[key];
      } else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {
        accessCache[key] = 0 /* OTHER */;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance.attrs, "get", "");
         true && markAttrsAccessed();
      } else if ( true && key === "$slots") {
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, "get", key);
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {
      accessCache[key] = 4 /* CONTEXT */;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else if ( true && currentRenderingInstance && (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    key.indexOf("__v") !== 0)) {
      if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && isReservedPrefix(key[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
        warn$1(
          `Property ${JSON.stringify(
            key
          )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
        );
      } else if (instance === currentRenderingInstance) {
        warn$1(
          `Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`
        );
      }
    }
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if ( true && setupState.__isScriptSetup && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
      warn$1(`Cannot mutate <script setup> binding "${key}" from Options API.`);
      return false;
    } else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
      data[key] = value;
      return true;
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(instance.props, key)) {
       true && warn$1(`Attempting to mutate prop "${key}". Props are readonly.`);
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
       true && warn$1(
        `Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`
      );
      return false;
    } else {
      if ( true && key in instance.appContext.config.globalProperties) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          value
        });
      } else {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(publicPropertiesMap, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
if (true) {
  PublicInstanceProxyHandlers.ownKeys = (target) => {
    warn$1(
      `Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`
    );
    return Reflect.ownKeys(target);
  };
}
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, PublicInstanceProxyHandlers, {
  get(target, key) {
    if (key === Symbol.unscopables) {
      return;
    }
    return PublicInstanceProxyHandlers.get(target, key, target);
  },
  has(_, key) {
    const has = key[0] !== "_" && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isGloballyAllowed)(key);
    if ( true && !has && PublicInstanceProxyHandlers.has(_, key)) {
      warn$1(
        `Property ${JSON.stringify(
          key
        )} should not start with _ which is a reserved prefix for Vue internals.`
      );
    }
    return has;
  }
});
function createDevRenderContext(instance) {
  const target = {};
  Object.defineProperty(target, `_`, {
    configurable: true,
    enumerable: false,
    get: () => instance
  });
  Object.keys(publicPropertiesMap).forEach((key) => {
    Object.defineProperty(target, key, {
      configurable: true,
      enumerable: false,
      get: () => publicPropertiesMap[key](instance),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
    });
  });
  return target;
}
function exposePropsOnRenderContext(instance) {
  const {
    ctx,
    propsOptions: [propsOptions]
  } = instance;
  if (propsOptions) {
    Object.keys(propsOptions).forEach((key) => {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => instance.props[key],
        set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
      });
    });
  }
}
function exposeSetupStateOnRenderContext(instance) {
  const { ctx, setupState } = instance;
  Object.keys((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(setupState)).forEach((key) => {
    if (!setupState.__isScriptSetup) {
      if (isReservedPrefix(key[0])) {
        warn$1(
          `setup() return property ${JSON.stringify(
            key
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => setupState[key],
        set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
      });
    }
  });
}

const warnRuntimeUsage = (method) => warn$1(
  `${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`
);
function defineProps() {
  if (true) {
    warnRuntimeUsage(`defineProps`);
  }
  return null;
}
function defineEmits() {
  if (true) {
    warnRuntimeUsage(`defineEmits`);
  }
  return null;
}
function defineExpose(exposed) {
  if (true) {
    warnRuntimeUsage(`defineExpose`);
  }
}
function defineOptions(options) {
  if (true) {
    warnRuntimeUsage(`defineOptions`);
  }
}
function defineSlots() {
  if (true) {
    warnRuntimeUsage(`defineSlots`);
  }
  return null;
}
function defineModel() {
  if (true) {
    warnRuntimeUsage("defineModel");
  }
}
function withDefaults(props, defaults) {
  if (true) {
    warnRuntimeUsage(`withDefaults`);
  }
  return null;
}
function useSlots() {
  return getContext().slots;
}
function useAttrs() {
  return getContext().attrs;
}
function getContext() {
  const i = getCurrentInstance();
  if ( true && !i) {
    warn$1(`useContext() called without active instance.`);
  }
  return i.setupContext || (i.setupContext = createSetupContext(i));
}
function normalizePropsOrEmits(props) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(props) ? props.reduce(
    (normalized, p) => (normalized[p] = null, normalized),
    {}
  ) : props;
}
function mergeDefaults(raw, defaults) {
  const props = normalizePropsOrEmits(raw);
  for (const key in defaults) {
    if (key.startsWith("__skip")) continue;
    let opt = props[key];
    if (opt) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt)) {
        opt = props[key] = { type: opt, default: defaults[key] };
      } else {
        opt.default = defaults[key];
      }
    } else if (opt === null) {
      opt = props[key] = { default: defaults[key] };
    } else if (true) {
      warn$1(`props default key "${key}" has no corresponding declaration.`);
    }
    if (opt && defaults[`__skip_${key}`]) {
      opt.skipFactory = true;
    }
  }
  return props;
}
function mergeModels(a, b) {
  if (!a || !b) return a || b;
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(a) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(b)) return a.concat(b);
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
}
function createPropsRestProxy(props, excludedKeys) {
  const ret = {};
  for (const key in props) {
    if (!excludedKeys.includes(key)) {
      Object.defineProperty(ret, key, {
        enumerable: true,
        get: () => props[key]
      });
    }
  }
  return ret;
}
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance();
  if ( true && !ctx) {
    warn$1(
      `withAsyncContext called without active current instance. This is likely a bug.`
    );
  }
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(awaitable)) {
    awaitable = awaitable.catch((e) => {
      setCurrentInstance(ctx);
      throw e;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}

function createDuplicateChecker() {
  const cache = /* @__PURE__ */ Object.create(null);
  return (type, key) => {
    if (cache[key]) {
      warn$1(`${type} property "${key}" is already defined in ${cache[key]}.`);
    } else {
      cache[key] = type;
    }
  };
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties =  true ? createDuplicateChecker() : 0;
  if (true) {
    const [propsOptions] = instance.propsOptions;
    if (propsOptions) {
      for (const key in propsOptions) {
        checkDuplicateProperties("Props" /* PROPS */, key);
      }
    }
  }
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(methodHandler)) {
        if (true) {
          Object.defineProperty(ctx, key, {
            value: methodHandler.bind(publicThis),
            configurable: true,
            enumerable: true,
            writable: true
          });
        } else {}
        if (true) {
          checkDuplicateProperties("Methods" /* METHODS */, key);
        }
      } else if (true) {
        warn$1(
          `Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`
        );
      }
    }
  }
  if (dataOptions) {
    if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dataOptions)) {
      warn$1(
        `The data option must be a function. Plain object usage is no longer supported.`
      );
    }
    const data = dataOptions.call(publicThis, publicThis);
    if ( true && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(data)) {
      warn$1(
        `data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`
      );
    }
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(data)) {
       true && warn$1(`data() should return an object.`);
    } else {
      instance.data = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive)(data);
      if (true) {
        for (const key in data) {
          checkDuplicateProperties("Data" /* DATA */, key);
          if (!isReservedPrefix(key[0])) {
            Object.defineProperty(ctx, key, {
              configurable: true,
              enumerable: true,
              get: () => data[key],
              set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
            });
          }
        }
      }
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) ? opt.bind(publicThis, publicThis) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.get) ? opt.get.bind(publicThis, publicThis) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
      if ( true && get === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
        warn$1(`Computed property "${key}" has no getter.`);
      }
      const set = !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.set) ? opt.set.bind(publicThis) :  true ? () => {
        warn$1(
          `Write operation failed: computed property "${key}" is readonly.`
        );
      } : 0;
      const c = computed({
        get,
        set
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
      if (true) {
        checkDuplicateProperties("Computed" /* COMPUTED */, key);
      }
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components) instance.components = components;
  if (directives) instance.directives = directives;
  if (serverPrefetch) {
    markAsyncBoundary(instance);
  }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
    if (true) {
      checkDuplicateProperties("Inject" /* INJECT */, key);
    }
  }
}
function callHook(hook, instance, type) {
  callWithAsyncErrorHandling(
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook) ? hook.map((h) => h.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw)) {
    const handler = ctx[raw];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {
      {
        watch(getter, handler);
      }
    } else if (true) {
      warn$1(`Invalid watch handler specified by key "${raw}"`, handler);
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw)) {
    {
      watch(getter, raw.bind(publicThis));
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {
        watch(getter, handler, raw);
      } else if (true) {
        warn$1(`Invalid watch handler specified by key "${raw.handler}"`, handler);
      }
    }
  } else if (true) {
    warn$1(`Invalid watch option: "${key}"`, raw);
  }
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions(to, m, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") {
       true && warn$1(
        `"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`
      );
    } else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend))(
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(to) ? to.call(this, this) : to,
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(to) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  const merged = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}

function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp(rootComponent, rootProps = null) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(rootComponent)) {
      rootComponent = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, rootComponent);
    }
    if (rootProps != null && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(rootProps)) {
       true && warn$1(`root props passed to app.mount() must be an object.`);
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    const pluginCleanupFns = [];
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
        if (true) {
          warn$1(
            `app.config cannot be replaced. Modify individual options instead.`
          );
        }
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) {
           true && warn$1(`Plugin has already been applied to target app.`);
        } else if (plugin && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else if (true) {
          warn$1(
            `A plugin must either be a function or an object with an "install" function.`
          );
        }
        return app;
      },
      mixin(mixin) {
        if (__VUE_OPTIONS_API__) {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          } else if (true) {
            warn$1(
              "Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : "")
            );
          }
        } else if (true) {
          warn$1("Mixins are only available in builds supporting Options API");
        }
        return app;
      },
      component(name, component) {
        if (true) {
          validateComponentName(name, context.config);
        }
        if (!component) {
          return context.components[name];
        }
        if ( true && context.components[name]) {
          warn$1(`Component "${name}" has already been registered in target app.`);
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (true) {
          validateDirectiveName(name);
        }
        if (!directive) {
          return context.directives[name];
        }
        if ( true && context.directives[name]) {
          warn$1(`Directive "${name}" has already been registered in target app.`);
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, namespace) {
        if (!isMounted) {
          if ( true && rootContainer.__vue_app__) {
            warn$1(
              `There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`
            );
          }
          const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace === true) {
            namespace = "svg";
          } else if (namespace === false) {
            namespace = void 0;
          }
          if (true) {
            context.reload = () => {
              render(
                cloneVNode(vnode),
                rootContainer,
                namespace
              );
            };
          }
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, namespace);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          if (true) {
            app._instance = vnode.component;
            devtoolsInitApp(app, version);
          }
          return getComponentPublicInstance(vnode.component);
        } else if (true) {
          warn$1(
            `App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``
          );
        }
      },
      onUnmount(cleanupFn) {
        if ( true && typeof cleanupFn !== "function") {
          warn$1(
            `Expected function as first argument to app.onUnmount(), but got ${typeof cleanupFn}`
          );
        }
        pluginCleanupFns.push(cleanupFn);
      },
      unmount() {
        if (isMounted) {
          callWithAsyncErrorHandling(
            pluginCleanupFns,
            app._instance,
            16
          );
          render(null, app._container);
          if (true) {
            app._instance = null;
            devtoolsUnmountApp(app);
          }
          delete app._container.__vue_app__;
        } else if (true) {
          warn$1(`Cannot unmount an app that is not mounted.`);
        }
      },
      provide(key, value) {
        if ( true && key in context.provides) {
          warn$1(
            `App already provides property with key "${String(key)}". It will be overwritten with the new value.`
          );
        }
        context.provides[key] = value;
        return app;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app;
  };
}
let currentApp = null;

function provide(key, value) {
  if (!currentInstance) {
    if (true) {
      warn$1(`provide() can only be used inside setup().`);
    }
  } else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else if (true) {
      warn$1(`injection "${String(key)}" not found.`);
    }
  } else if (true) {
    warn$1(`inject() can only be used inside setup() or functional components.`);
  }
}
function hasInjectionContext() {
  return !!(currentInstance || currentRenderingInstance || currentApp);
}

const internalObjectProto = {};
const createInternalObject = () => Object.create(internalObjectProto);
const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;

function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = createInternalObject();
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (true) {
    validateProps(rawProps || {}, props, instance);
  }
  if (isStateful) {
    instance.props = isSSR ? props : (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive)(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function isInHmrContext(instance) {
  while (instance) {
    if (instance.type.__hmrId) return true;
    instance = instance.parent;
  }
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !( true && isInHmrContext(instance)) && (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) === key || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.trigger)(instance.attrs, "set", "");
  }
  if (true) {
    validateProps(rawProps || {}, props, instance);
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, camelKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
    const castValues = rawCastValues || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset();
        }
      } else {
        value = defaultValue;
      }
      if (instance.ce) {
        instance.ce._setProp(key, value);
      }
    }
    if (opt[0 /* shouldCast */]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1 /* shouldCastTrue */] && (value === "" || value === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key))) {
        value = true;
      }
    }
  }
  return value;
}
const mixinPropsCache = /* @__PURE__ */ new WeakMap();
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = __VUE_OPTIONS_API__ && asMixin ? mixinPropsCache : appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (__VUE_OPTIONS_API__ && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, props);
      if (keys) needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp)) {
      cache.set(comp, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR);
    }
    return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
    for (let i = 0; i < raw.length; i++) {
      if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw[i])) {
        warn$1(`props must be strings when using array syntax.`, raw[i]);
      }
      const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
      }
    }
  } else if (raw) {
    if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {
      warn$1(`invalid props options`, raw);
    }
    for (const key in raw) {
      const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) ? { type: opt } : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, opt);
        const propType = prop.type;
        let shouldCast = false;
        let shouldCastTrue = true;
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(propType)) {
          for (let index = 0; index < propType.length; ++index) {
            const type = propType[index];
            const typeName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(type) && type.name;
            if (typeName === "Boolean") {
              shouldCast = true;
              break;
            } else if (typeName === "String") {
              shouldCastTrue = false;
            }
          }
        } else {
          shouldCast = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(propType) && propType.name === "Boolean";
        }
        prop[0 /* shouldCast */] = shouldCast;
        prop[1 /* shouldCastTrue */] = shouldCastTrue;
        if (shouldCast || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(prop, "default")) {
          needCastKeys.push(normalizedKey);
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
    return true;
  } else if (true) {
    warn$1(`Invalid prop name: "${key}" is a reserved property.`);
  }
  return false;
}
function getType(ctor) {
  if (ctor === null) {
    return "null";
  }
  if (typeof ctor === "function") {
    return ctor.name || "";
  } else if (typeof ctor === "object") {
    const name = ctor.constructor && ctor.constructor.name;
    return name || "";
  }
  return "";
}
function validateProps(rawProps, props, instance) {
  const resolvedValues = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
  const options = instance.propsOptions[0];
  const camelizePropsKey = Object.keys(rawProps).map((key) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key));
  for (const key in options) {
    let opt = options[key];
    if (opt == null) continue;
    validateProp(
      key,
      resolvedValues[key],
      opt,
       true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(resolvedValues) : 0,
      !camelizePropsKey.includes(key)
    );
  }
}
function validateProp(name, value, prop, props, isAbsent) {
  const { type, required, validator, skipCheck } = prop;
  if (required && isAbsent) {
    warn$1('Missing required prop: "' + name + '"');
    return;
  }
  if (value == null && !required) {
    return;
  }
  if (type != null && type !== true && !skipCheck) {
    let isValid = false;
    const types = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(type) ? type : [type];
    const expectedTypes = [];
    for (let i = 0; i < types.length && !isValid; i++) {
      const { valid, expectedType } = assertType(value, types[i]);
      expectedTypes.push(expectedType || "");
      isValid = valid;
    }
    if (!isValid) {
      warn$1(getInvalidTypeMessage(name, value, expectedTypes));
      return;
    }
  }
  if (validator && !validator(value, props)) {
    warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
  }
}
const isSimpleType = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function assertType(value, type) {
  let valid;
  const expectedType = getType(type);
  if (expectedType === "null") {
    valid = value === null;
  } else if (isSimpleType(expectedType)) {
    const t = typeof value;
    valid = t === expectedType.toLowerCase();
    if (!valid && t === "object") {
      valid = value instanceof type;
    }
  } else if (expectedType === "Object") {
    valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value);
  } else if (expectedType === "Array") {
    valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid,
    expectedType
  };
}
function getInvalidTypeMessage(name, value, expectedTypes) {
  if (expectedTypes.length === 0) {
    return `Prop type [] for prop "${name}" won't match anything. Did you mean to use type Array instead?`;
  }
  let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join(" | ")}`;
  const expectedType = expectedTypes[0];
  const receivedType = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toRawType)(value);
  const expectedValue = styleValue(value, expectedType);
  const receivedValue = styleValue(value, receivedType);
  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += ` with value ${expectedValue}`;
  }
  message += `, got ${receivedType} `;
  if (isExplicable(receivedType)) {
    message += `with value ${receivedValue}.`;
  }
  return message;
}
function styleValue(value, type) {
  if (type === "String") {
    return `"${value}"`;
  } else if (type === "Number") {
    return `${Number(value)}`;
  } else {
    return `${value}`;
  }
}
function isExplicable(type) {
  const explicitTypes = ["string", "number", "boolean"];
  return explicitTypes.some((elem) => type.toLowerCase() === elem);
}
function isBoolean(...args) {
  return args.some((elem) => elem.toLowerCase() === "boolean");
}

const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if ( true && currentInstance && (!ctx || ctx.root === currentInstance.root)) {
      warn$1(
        `Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
      );
    }
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key)) continue;
    const value = rawSlots[key];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      if (true) {
        warn$1(
          `Non-function value encountered for slot "${key}". Prefer function slots for better performance.`
        );
      }
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  if ( true && !isKeepAlive(instance.vnode) && true) {
    warn$1(
      `Non-function value encountered for default slot. Prefer function slots for better performance.`
    );
  }
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const assignSlots = (slots, children, optimized) => {
  for (const key in children) {
    if (optimized || key !== "_") {
      slots[key] = children[key];
    }
  }
};
const initSlots = (instance, children, optimized) => {
  const slots = instance.slots = createInternalObject();
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      assignSlots(slots, children, optimized);
      if (optimized) {
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(slots, "_", type, true);
      }
    } else {
      normalizeObjectSlots(children, slots);
    }
  } else if (children) {
    normalizeVNodeSlots(instance, children);
  }
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if ( true && isHmrUpdating) {
        assignSlots(slots, children, optimized);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.trigger)(instance, "set", "$slots");
      } else if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        assignSlots(slots, children, optimized);
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};

let supported;
let perf;
function startMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    perf.mark(`vue-${type}-${instance.uid}`);
  }
  if (true) {
    devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
  }
}
function endMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    const startTag = `vue-${type}-${instance.uid}`;
    const endTag = startTag + `:end`;
    perf.mark(endTag);
    perf.measure(
      `<${formatComponentName(instance, instance.type)}> ${type}`,
      startTag,
      endTag
    );
    perf.clearMarks(startTag);
    perf.clearMarks(endTag);
  }
  if (true) {
    devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
  }
}
function isSupported() {
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else {
    supported = false;
  }
  return supported;
}

function initFeatureFlags() {
  const needWarn = [];
  if (typeof __VUE_OPTIONS_API__ !== "boolean") {
     true && needWarn.push(`__VUE_OPTIONS_API__`);
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_OPTIONS_API__ = true;
  }
  if (typeof __VUE_PROD_DEVTOOLS__ !== "boolean") {
     true && needWarn.push(`__VUE_PROD_DEVTOOLS__`);
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_PROD_DEVTOOLS__ = false;
  }
  if (typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ !== "boolean") {
     true && needWarn.push(`__VUE_PROD_HYDRATION_MISMATCH_DETAILS__`);
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = false;
  }
  if ( true && needWarn.length) {
    const multi = needWarn.length > 1;
    console.warn(
      `Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
    );
  }
}

const queuePostRenderEffect = queueEffectWithSuspense ;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
  {
    initFeatureFlags();
  }
  const target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)();
  target.__VUE__ = true;
  if (true) {
    setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
  }
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized =  true && isHmrUpdating ? false : !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace);
        } else if (true) {
          patchStaticNode(n1, n2, container, namespace);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (true) {
          warn$1("Invalid VNode type:", type, `(${typeof type})`);
        }
    }
    if (ref != null && parentComponent) {
      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, namespace) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace,
      n2.el,
      n2.anchor
    );
  };
  const patchStaticNode = (n1, n2, container, namespace) => {
    if (n2.children !== n1.children) {
      const anchor = hostNextSibling(n1.anchor);
      removeStaticNode(n1);
      [n2.el, n2.anchor] = hostInsertStaticContent(
        n2.children,
        container,
        anchor,
        namespace
      );
    } else {
      n2.el = n1.el;
      n2.anchor = n1.anchor;
    }
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace = "svg";
    } else if (n2.type === "math") {
      namespace = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
          hostPatchProp(el, key, null, props[key], namespace, parentComponent);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value, namespace);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (true) {
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(el, "__vnode", vnode, true);
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(el, "__vueParentComponent", parentComponent, true);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if ( true && subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
        subTree = filterSingleRoot(subTree.children) || subTree;
      }
      if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    if (true) {
      el.__vnode = n2;
    }
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    const newProps = n2.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if ( true && isHmrUpdating) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
      hostSetElementText(el, "");
    }
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds
      );
      if (true) {
        traverseStaticChildren(n1, n2);
      }
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, namespace, parentComponent);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, oldProps, newProps, parentComponent, namespace);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
    if (oldProps !== newProps) {
      if (oldProps !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace,
              parentComponent
            );
          }
        }
      }
      for (const key in newProps) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, namespace, parentComponent);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if ( true && // #5523 dev root fragment may inherit directives
    (isHmrUpdating || patchFlag & 2048)) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        if (true) {
          traverseStaticChildren(n1, n2);
        } else {}
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const instance = (initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    ));
    if ( true && instance.type.__hmrId) {
      registerHMR(instance);
    }
    if (true) {
      pushWarningContext(initialVNode);
      startMeasure(instance, `mount`);
    }
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      if (true) {
        startMeasure(instance, `init`);
      }
      setupComponent(instance, false, optimized);
      if (true) {
        endMeasure(instance, `init`);
      }
    }
    if (instance.asyncDep) {
      if ( true && isHmrUpdating) initialVNode.el = null;
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
    } else {
      setupRenderEffect(
        instance,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace,
        optimized
      );
    }
    if (true) {
      popWarningContext();
      endMeasure(instance, `mount`);
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        if (true) {
          pushWarningContext(n2);
        }
        updateComponentPreRender(instance, n2, optimized);
        if (true) {
          popWarningContext();
        }
        return;
      } else {
        instance.next = n2;
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent, root, type } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            if (true) {
              startMeasure(instance, `render`);
            }
            instance.subTree = renderComponentRoot(instance);
            if (true) {
              endMeasure(instance, `render`);
            }
            if (true) {
              startMeasure(instance, `hydrate`);
            }
            hydrateNode(
              el,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
            if (true) {
              endMeasure(instance, `hydrate`);
            }
          };
          if (isAsyncWrapperVNode && type.__asyncHydrate) {
            type.__asyncHydrate(
              el,
              instance,
              hydrateSubTree
            );
          } else {
            hydrateSubTree();
          }
        } else {
          if (root.ce) {
            root.ce._injectChildStyle(type);
          }
          if (true) {
            startMeasure(instance, `render`);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          if (true) {
            endMeasure(instance, `render`);
          }
          if (true) {
            startMeasure(instance, `patch`);
          }
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            namespace
          );
          if (true) {
            endMeasure(instance, `patch`);
          }
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        if (true) {
          devtoolsComponentAdded(instance);
        }
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
          if (nonHydratedAsyncRoot) {
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next;
        let vnodeHook;
        if (true) {
          pushWarningContext(next || instance.vnode);
        }
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        if (true) {
          startMeasure(instance, `render`);
        }
        const nextTree = renderComponentRoot(instance);
        if (true) {
          endMeasure(instance, `render`);
        }
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        if (true) {
          startMeasure(instance, `patch`);
        }
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          namespace
        );
        if (true) {
          endMeasure(instance, `patch`);
        }
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
        if (true) {
          devtoolsComponentUpdated(instance);
        }
        if (true) {
          popWarningContext();
        }
      }
    };
    instance.scope.on();
    const effect = instance.effect = new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect(componentUpdateFn);
    instance.scope.off();
    const update = instance.update = effect.run.bind(effect);
    const job = instance.job = effect.runIfDirty.bind(effect);
    job.i = instance;
    job.id = instance.uid;
    effect.scheduler = () => queueJob(job);
    toggleRecurse(instance, true);
    if (true) {
      effect.onTrack = instance.rtc ? (e) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtc, e) : void 0;
      effect.onTrigger = instance.rtg ? (e) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtg, e) : void 0;
    }
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
    flushPreFlushCbs(instance);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    c1 = c1 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
    c2 = c2 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          if ( true && keyToNewIndexMap.has(nextChild.key)) {
            warn$1(
              `Duplicate keys found during update:`,
              JSON.stringify(nextChild.key),
              `Make sure keys are unique.`
            );
          }
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove2 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove2();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove2, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs,
      cacheIndex
    } = vnode;
    if (patchFlag === -2) {
      optimized = false;
    }
    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode, true);
    }
    if (cacheIndex != null) {
      parentComponent.renderCache[cacheIndex] = void 0;
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      if ( true && vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {
        vnode.children.forEach((child) => {
          if (child.type === Comment) {
            hostRemove(child.el);
          } else {
            remove(child);
          }
        });
      } else {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    if ( true && instance.type.__hmrId) {
      unregisterHMR(instance);
    }
    const { bum, scope, job, subTree, um, m, a } = instance;
    invalidateMount(m);
    invalidateMount(a);
    if (bum) {
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bum);
    }
    scope.stop();
    if (job) {
      job.flags |= 8;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
    if (true) {
      devtoolsComponentRemoved(instance);
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    const el = hostNextSibling(vnode.anchor || vnode.el);
    const teleportEnd = el && el[TeleportEndKey];
    return teleportEnd ? hostNextSibling(teleportEnd) : el;
  };
  let isFlushing = false;
  const render = (vnode, container, namespace) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace
      );
    }
    container._vnode = vnode;
    if (!isFlushing) {
      isFlushing = true;
      flushPreFlushCbs();
      flushPostFlushCbs();
      isFlushing = false;
    }
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function resolveChildrenNamespace({ type, props }, currentNamespace) {
  return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect, job }, allowed) {
  if (allowed) {
    effect.flags |= 32;
    job.flags |= 4;
  } else {
    effect.flags &= ~32;
    job.flags &= ~4;
  }
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch1) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow && c2.patchFlag !== -2)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
      if ( true && c2.type === Comment && !c2.el) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p[v];
  }
  return result;
}
function locateNonHydratedAsyncRoot(instance) {
  const subComponent = instance.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
function invalidateMount(hooks) {
  if (hooks) {
    for (let i = 0; i < hooks.length; i++)
      hooks[i].flags |= 8;
  }
}

const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    if (!ctx) {
       true && warn$1(
        `Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`
      );
    }
    return ctx;
  }
};

function watchEffect(effect, options) {
  return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
  return doWatch(
    effect,
    null,
     true ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, options, { flush: "post" }) : 0
  );
}
function watchSyncEffect(effect, options) {
  return doWatch(
    effect,
    null,
     true ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, options, { flush: "sync" }) : 0
  );
}
function watch(source, cb, options) {
  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(cb)) {
    warn$1(
      `\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`
    );
  }
  return doWatch(source, cb, options);
}
function doWatch(source, cb, options = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
  const { immediate, deep, flush, once } = options;
  if ( true && !cb) {
    if (immediate !== void 0) {
      warn$1(
        `watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
    if (deep !== void 0) {
      warn$1(
        `watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
    if (once !== void 0) {
      warn$1(
        `watch() "once" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
  }
  const baseWatchOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, options);
  if (true) baseWatchOptions.onWarn = warn$1;
  const runsImmediately = cb && immediate || !cb && flush !== "post";
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else if (!runsImmediately) {
      const watchStopHandle = () => {
      };
      watchStopHandle.stop = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
      watchStopHandle.resume = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
      watchStopHandle.pause = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
      return watchStopHandle;
    }
  }
  const instance = currentInstance;
  baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);
  let isPre = false;
  if (flush === "post") {
    baseWatchOptions.scheduler = (job) => {
      queuePostRenderEffect(job, instance && instance.suspense);
    };
  } else if (flush !== "sync") {
    isPre = true;
    baseWatchOptions.scheduler = (job, isFirstRun) => {
      if (isFirstRun) {
        job();
      } else {
        queueJob(job);
      }
    };
  }
  baseWatchOptions.augmentJob = (job) => {
    if (cb) {
      job.flags |= 4;
    }
    if (isPre) {
      job.flags |= 2;
      if (instance) {
        job.id = instance.uid;
        job.i = instance;
      }
    }
  };
  const watchHandle = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.watch)(source, cb, baseWatchOptions);
  if (isInSSRComponentSetup) {
    if (ssrCleanup) {
      ssrCleanup.push(watchHandle);
    } else if (runsImmediately) {
      watchHandle();
    }
  }
  return watchHandle;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset();
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}

function useModel(props, name, options = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
  const i = getCurrentInstance();
  if ( true && !i) {
    warn$1(`useModel() called without active instance.`);
    return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)();
  }
  const camelizedName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name);
  if ( true && !i.propsOptions[0][camelizedName]) {
    warn$1(`useModel() called with prop "${name}" which is not declared.`);
    return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)();
  }
  const hyphenatedName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(name);
  const modifiers = getModelModifiers(props, camelizedName);
  const res = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.customRef)((track, trigger) => {
    let localValue;
    let prevSetValue = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    let prevEmittedValue;
    watchSyncEffect(() => {
      const propValue = props[camelizedName];
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(localValue, propValue)) {
        localValue = propValue;
        trigger();
      }
    });
    return {
      get() {
        track();
        return options.get ? options.get(localValue) : localValue;
      },
      set(value) {
        const emittedValue = options.set ? options.set(value) : value;
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(emittedValue, localValue) && !(prevSetValue !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(value, prevSetValue))) {
          return;
        }
        const rawProps = i.vnode.props;
        if (!(rawProps && // check if parent has passed v-model
        (name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && (`onUpdate:${name}` in rawProps || `onUpdate:${camelizedName}` in rawProps || `onUpdate:${hyphenatedName}` in rawProps))) {
          localValue = value;
          trigger();
        }
        i.emit(`update:${name}`, emittedValue);
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(value, emittedValue) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(value, prevSetValue) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(emittedValue, prevEmittedValue)) {
          trigger();
        }
        prevSetValue = value;
        prevEmittedValue = emittedValue;
      }
    };
  });
  res[Symbol.iterator] = () => {
    let i2 = 0;
    return {
      next() {
        if (i2 < 2) {
          return { value: i2++ ? modifiers || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ : res, done: false };
        } else {
          return { done: true };
        }
      }
    };
  };
  return res;
}
const getModelModifiers = (props, modelName) => {
  return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(modelName)}Modifiers`] || props[`${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(modelName)}Modifiers`];
};

function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted) return;
  const props = instance.vnode.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
  if (true) {
    const {
      emitsOptions,
      propsOptions: [propsOptions]
    } = instance;
    if (emitsOptions) {
      if (!(event in emitsOptions) && true) {
        if (!propsOptions || !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(event)) in propsOptions)) {
          warn$1(
            `Component emitted event "${event}" but it is neither declared in the emits option nor as an "${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(event))}" prop.`
          );
        }
      } else {
        const validator = emitsOptions[event];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(validator)) {
          const isValid = validator(...rawArgs);
          if (!isValid) {
            warn$1(
              `Invalid event arguments: event validation failed for event "${event}".`
            );
          }
        }
      }
    }
  }
  let args = rawArgs;
  const isModelListener = event.startsWith("update:");
  const modifiers = isModelListener && getModelModifiers(props, event.slice(7));
  if (modifiers) {
    if (modifiers.trim) {
      args = rawArgs.map((a) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(a) ? a.trim() : a);
    }
    if (modifiers.number) {
      args = rawArgs.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseToNumber);
    }
  }
  if (true) {
    devtoolsComponentEmit(instance, event, args);
  }
  if (true) {
    const lowerCaseEvent = event.toLowerCase();
    if (lowerCaseEvent !== event && props[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(lowerCaseEvent)]) {
      warn$1(
        `Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(
          instance,
          instance.type
        )} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(
          event
        )}" instead of "${event}".`
      );
    }
  }
  let handlerName;
  let handler = props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event)] || // also try camelCase event handler (#2249)
  props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(event))];
  if (!handler && isModelListener) {
    handler = props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (__VUE_OPTIONS_API__ && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, raw);
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key[0].toLowerCase() + key.slice(1)) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key);
}

let accessedAttrs = false;
function markAttrsAccessed() {
  accessedAttrs = true;
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit,
    render,
    renderCache,
    props,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  const prev = setCurrentRenderingInstance(instance);
  let result;
  let fallthroughAttrs;
  if (true) {
    accessedAttrs = false;
  }
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy =  true && setupState.__isScriptSetup ? new Proxy(proxyToUse, {
        get(target, key, receiver) {
          warn$1(
            `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          );
          return Reflect.get(target, key, receiver);
        }
      }) : proxyToUse;
      result = normalizeVNode(
        render.call(
          thisProxy,
          proxyToUse,
          renderCache,
           true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(props) : 0,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if ( true && attrs === props) {
        markAttrsAccessed();
      }
      result = normalizeVNode(
        render2.length > 1 ? render2(
           true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(props) : 0,
           true ? {
            get attrs() {
              markAttrsAccessed();
              return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(attrs);
            },
            slots,
            emit
          } : 0
        ) : render2(
           true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(props) : 0,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  let setRoot = void 0;
  if ( true && result.patchFlag > 0 && result.patchFlag & 2048) {
    [root, setRoot] = getChildRoot(result);
  }
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs, false, true);
      } else if ( true && !accessedAttrs && root.type !== Comment) {
        const allAttrs = Object.keys(attrs);
        const eventAttrs = [];
        const extraAttrs = [];
        for (let i = 0, l = allAttrs.length; i < l; i++) {
          const key = allAttrs[i];
          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {
              eventAttrs.push(key[2].toLowerCase() + key.slice(3));
            }
          } else {
            extraAttrs.push(key);
          }
        }
        if (extraAttrs.length) {
          warn$1(
            `Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`
          );
        }
        if (eventAttrs.length) {
          warn$1(
            `Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
          );
        }
      }
    }
  }
  if (vnode.dirs) {
    if ( true && !isElementRoot(root)) {
      warn$1(
        `Runtime directive used on component with non-element root node. The directives will not function as intended.`
      );
    }
    root = cloneVNode(root, null, false, true);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    if ( true && !isElementRoot(root)) {
      warn$1(
        `Component inside <Transition> renders non-element root node that cannot be animated.`
      );
    }
    setTransitionHooks(root, vnode.transition);
  }
  if ( true && setRoot) {
    setRoot(root);
  } else {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getChildRoot = (vnode) => {
  const rawChildren = vnode.children;
  const dynamicChildren = vnode.dynamicChildren;
  const childRoot = filterSingleRoot(rawChildren, false);
  if (!childRoot) {
    return [vnode, void 0];
  } else if ( true && childRoot.patchFlag > 0 && childRoot.patchFlag & 2048) {
    return getChildRoot(childRoot);
  }
  const index = rawChildren.indexOf(childRoot);
  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
  const setRoot = (updatedRoot) => {
    rawChildren[index] = updatedRoot;
    if (dynamicChildren) {
      if (dynamicIndex > -1) {
        dynamicChildren[dynamicIndex] = updatedRoot;
      } else if (updatedRoot.patchFlag > 0) {
        vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
      }
    }
  };
  return [normalizeVNode(childRoot), setRoot];
};
function filterSingleRoot(children, recurse = true) {
  let singleRoot;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (isVNode(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
          if ( true && recurse && singleRoot.patchFlag > 0 && singleRoot.patchFlag & 2048) {
            return filterSingleRoot(singleRoot.children);
          }
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
const isElementRoot = (vnode) => {
  return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if ( true && (prevChildren || nextChildren) && isHmrUpdating) {
    return true;
  }
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root = parent.subTree;
    if (root.suspense && root.suspense.activeBranch === vnode) {
      root.el = vnode.el;
    }
    if (root === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}

const isSuspense = (type) => type.__isSuspense;
let suspenseId = 0;
const SuspenseImpl = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
    if (n1 == null) {
      mountSuspense(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    } else {
      if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {
        n2.suspense = n1.suspense;
        n2.suspense.vnode = n2;
        n2.el = n1.el;
        return;
      }
      patchSuspense(
        n1,
        n2,
        container,
        anchor,
        parentComponent,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    }
  },
  hydrate: hydrateSuspense,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl ;
function triggerEvent(vnode, name) {
  const eventListener = vnode.props && vnode.props[name];
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(eventListener)) {
    eventListener();
  }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
  const {
    p: patch,
    o: { createElement }
  } = rendererInternals;
  const hiddenContainer = createElement("div");
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    container,
    hiddenContainer,
    anchor,
    namespace,
    slotScopeIds,
    optimized,
    rendererInternals
  );
  patch(
    null,
    suspense.pendingBranch = vnode.ssContent,
    hiddenContainer,
    null,
    parentComponent,
    suspense,
    namespace,
    slotScopeIds
  );
  if (suspense.deps > 0) {
    triggerEvent(vnode, "onPending");
    triggerEvent(vnode, "onFallback");
    patch(
      null,
      vnode.ssFallback,
      container,
      anchor,
      parentComponent,
      null,
      // fallback tree will not have suspense context
      namespace,
      slotScopeIds
    );
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve(false, true);
  }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
  const suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(newBranch, pendingBranch)) {
      patch(
        pendingBranch,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        if (!isHydrating) {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      }
    } else {
      suspense.pendingId = suspenseId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement("div");
      if (isInFallback) {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(
          activeBranch,
          newBranch,
          container,
          anchor,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        suspense.resolve(true);
      } else {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      patch(
        activeBranch,
        newBranch,
        container,
        anchor,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent(n2, "onPending");
      suspense.pendingBranch = newBranch;
      if (newBranch.shapeFlag & 512) {
        suspense.pendingId = newBranch.component.suspenseId;
      } else {
        suspense.pendingId = suspenseId++;
      }
      patch(
        null,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const { timeout, pendingId } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
let hasWarned = false;
function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  if ( true && !hasWarned) {
    hasWarned = true;
    console[console.info ? "info" : "log"](
      `<Suspense> is an experimental feature and its API will likely change.`
    );
  }
  const {
    p: patch,
    m: move,
    um: unmount,
    n: next,
    o: { parentNode, remove }
  } = rendererInternals;
  let parentSuspenseId;
  const isSuspensible = isVNodeSuspensible(vnode);
  if (isSuspensible) {
    if (parentSuspense && parentSuspense.pendingBranch) {
      parentSuspenseId = parentSuspense.pendingId;
      parentSuspense.deps++;
    }
  }
  const timeout = vnode.props ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(vnode.props.timeout) : void 0;
  if (true) {
    assertNumber(timeout, `Suspense timeout`);
  }
  const initialAnchor = anchor;
  const suspense = {
    vnode,
    parent: parentSuspense,
    parentComponent,
    namespace,
    container,
    hiddenContainer,
    deps: 0,
    pendingId: suspenseId++,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: !isHydrating,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false, sync = false) {
      if (true) {
        if (!resume && !suspense.pendingBranch) {
          throw new Error(
            `suspense.resolve() is called without a pending branch.`
          );
        }
        if (suspense.isUnmounted) {
          throw new Error(
            `suspense.resolve() is called on an already unmounted suspense boundary.`
          );
        }
      }
      const {
        vnode: vnode2,
        activeBranch,
        pendingBranch,
        pendingId,
        effects,
        parentComponent: parentComponent2,
        container: container2
      } = suspense;
      let delayEnter = false;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(
                pendingBranch,
                container2,
                anchor === initialAnchor ? next(activeBranch) : anchor,
                0
              );
              queuePostFlushCb(effects);
            }
          };
        }
        if (activeBranch) {
          if (parentNode(activeBranch.el) === container2) {
            anchor = next(activeBranch);
          }
          unmount(activeBranch, parentComponent2, suspense, true);
        }
        if (!delayEnter) {
          move(pendingBranch, container2, anchor, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent) {
        if (parent.pendingBranch) {
          parent.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent = parent.parent;
      }
      if (!hasUnresolvedAncestor && !delayEnter) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      if (isSuspensible) {
        if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0 && !sync) {
            parentSuspense.resolve();
          }
        }
      }
      triggerEvent(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, namespace: namespace2 } = suspense;
      triggerEvent(vnode2, "onFallback");
      const anchor2 = next(activeBranch);
      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        }
        patch(
          null,
          fallbackVNode,
          container2,
          anchor2,
          parentComponent2,
          null,
          // fallback tree will not have suspense context
          namespace2,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, fallbackVNode);
      };
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(
        activeBranch,
        parentComponent2,
        null,
        // no suspense so unmount hooks fire now
        true
        // shouldRemove
      );
      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type) {
      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect, optimized2) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch((err) => {
        handleError(err, instance, 0);
      }).then((asyncSetupResult) => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const { vnode: vnode2 } = instance;
        if (true) {
          pushWarningContext(vnode2);
        }
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode2.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(
          instance,
          vnode2,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          parentNode(hydratedEl || instance.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          hydratedEl ? null : next(instance.subTree),
          suspense,
          namespace,
          optimized2
        );
        if (placeholder) {
          remove(placeholder);
        }
        updateHOCHostEl(instance, vnode2.el);
        if (true) {
          popWarningContext();
        }
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense2, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(
          suspense.activeBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
      if (suspense.pendingBranch) {
        unmount(
          suspense.pendingBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
    }
  };
  return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    node.parentNode,
    // eslint-disable-next-line no-restricted-globals
    document.createElement("div"),
    null,
    namespace,
    slotScopeIds,
    optimized,
    rendererInternals,
    true
  );
  const result = hydrateNode(
    node,
    suspense.pendingBranch = vnode.ssContent,
    parentComponent,
    suspense,
    slotScopeIds,
    optimized
  );
  if (suspense.deps === 0) {
    suspense.resolve(false, true);
  }
  return result;
}
function normalizeSuspenseChildren(vnode) {
  const { shapeFlag, children } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(
    isSlotChildren ? children.default : children
  );
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
  let block;
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {
    const trackBlock = isBlockTreeEnabled && s._c;
    if (trackBlock) {
      s._d = false;
      openBlock();
    }
    s = s();
    if (trackBlock) {
      s._d = true;
      block = currentBlock;
      closeBlock();
    }
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(s)) {
    const singleChild = filterSingleRoot(s);
    if ( true && !singleChild && s.filter((child) => child !== NULL_DYNAMIC_COMPONENT).length > 0) {
      warn$1(`<Suspense> slots expect a single root node.`);
    }
    s = singleChild;
  }
  s = normalizeVNode(s);
  if (block && !s.dynamicChildren) {
    s.dynamicChildren = block.filter((c) => c !== s);
  }
  return s;
}
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  let el = branch.el;
  while (!el && branch.component) {
    branch = branch.component.subTree;
    el = branch.el;
  }
  vnode.el = el;
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
function isVNodeSuspensible(vnode) {
  const suspensible = vnode.props && vnode.props.suspensible;
  return suspensible != null && suspensible !== false;
}

const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value, inVOnce = false) {
  isBlockTreeEnabled += value;
  if (value < 0 && currentBlock && inVOnce) {
    currentBlock.hasOnce = true;
  }
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  if ( true && n2.shapeFlag & 6 && n1.component) {
    const dirtyInstances = hmrDirtyComponents.get(n2.type);
    if (dirtyInstances && dirtyInstances.has(n1.component)) {
      n1.shapeFlag &= ~256;
      n2.shapeFlag &= ~512;
      return false;
    }
  }
  return n1.type === n2.type && n1.key === n2.key;
}
let vnodeArgsTransformer;
function transformVNodeArgs(transformer) {
  vnodeArgsTransformer = transformer;
}
const createVNodeWithArgsTransform = (...args) => {
  return _createVNode(
    ...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args
  );
};
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref,
  ref_key,
  ref_for
}) => {
  if (typeof ref === "number") {
    ref = "" + ref;
  }
  return ref != null ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref) || (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref) ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for } : ref : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(children) ? 8 : 16;
  }
  if ( true && vnode.key !== vnode.key) {
    warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode =  true ? createVNodeWithArgsTransform : 0;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    if ( true && !type) {
      warn$1(`Invalid vnode type when creating vnode: ${type}.`);
    }
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(klass)) {
      props.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(klass);
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(style)) {
      if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(style) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(style)) {
        style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, style);
      }
      props.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)(style);
    }
  }
  const shapeFlag = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(type) ? 4 : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(type) ? 2 : 0;
  if ( true && shapeFlag & 4 && (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(type)) {
    type = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(type);
    warn$1(
      `Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`,
      `
Component that was made reactive: `,
      type
    );
  }
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props) return null;
  return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(props) || isInternalObject(props) ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props, ref, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children:  true && patchFlag === -1 && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children) ? children.map(deepCloneVNode) : children,
    target: vnode.target,
    targetStart: vnode.targetStart,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
function deepCloneVNode(vnode) {
  const cloned = cloneVNode(vnode);
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(vnode.children)) {
    cloned.children = vnode.children.map(deepCloneVNode);
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (isVNode(child)) {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !isInternalObject(children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)([ret.style, toMerge.style]);
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}

const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    ids: parent ? parent.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    data: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    props: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    attrs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    slots: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    refs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    setupState: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  if (true) {
    instance.ctx = createDevRenderContext(instance);
  } else {}
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g[key])) setters = g[key] = [];
    setters.push(setter);
    return (v) => {
      if (setters.length > 1) setters.forEach((set) => set(v));
      else setters[0](v);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v) => currentInstance = v
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v) => isInSSRComponentSetup = v
  );
}
const setCurrentInstance = (instance) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
const isBuiltInTag = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)("slot,component");
function validateComponentName(name, { isNativeTag }) {
  if (isBuiltInTag(name) || isNativeTag(name)) {
    warn$1(
      "Do not use built-in or reserved HTML elements as component id: " + name
    );
  }
}
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false, optimized = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children, optimized);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  var _a;
  const Component = instance.type;
  if (true) {
    if (Component.name) {
      validateComponentName(Component.name, instance.appContext.config);
    }
    if (Component.components) {
      const names = Object.keys(Component.components);
      for (let i = 0; i < names.length; i++) {
        validateComponentName(names[i], instance.appContext.config);
      }
    }
    if (Component.directives) {
      const names = Object.keys(Component.directives);
      for (let i = 0; i < names.length; i++) {
        validateDirectiveName(names[i]);
      }
    }
    if (Component.compilerOptions && isRuntimeOnly()) {
      warn$1(
        `"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`
      );
    }
  }
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
  if (true) {
    exposePropsOnRenderContext(instance);
  }
  const { setup } = Component;
  if (setup) {
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [
         true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.props) : 0,
        setupContext
      ]
    );
    const isAsyncSetup = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(setupResult);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
    reset();
    if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
      markAsyncBoundary(instance);
    }
    if (isAsyncSetup) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
        if ( true && !instance.suspense) {
          const name = (_a = Component.name) != null ? _a : "Anonymous";
          warn$1(
            `Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
          );
        }
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(setupResult)) {
    if ( true && isVNode(setupResult)) {
      warn$1(
        `setup() should not return VNodes directly - return a render function instead.`
      );
    }
    if (true) {
      instance.devtoolsRawSetupState = setupResult;
    }
    instance.setupState = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)(setupResult);
    if (true) {
      exposeSetupStateOnRenderContext(instance);
    }
  } else if ( true && setupResult !== void 0) {
    warn$1(
      `setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`
    );
  }
  finishComponentSetup(instance, isSSR);
}
let compile;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
  compile = _compile;
  installWithProxy = (i) => {
    if (i.render._rc) {
      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  };
}
const isRuntimeOnly = () => !compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template || __VUE_OPTIONS_API__ && resolveMergedOptions(instance).template;
      if (template) {
        if (true) {
          startMeasure(instance, `compile`);
        }
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile(template, finalCompilerOptions);
        if (true) {
          endMeasure(instance, `compile`);
        }
      }
    }
    instance.render = Component.render || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  if (__VUE_OPTIONS_API__ && true) {
    const reset = setCurrentInstance(instance);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
    try {
      applyOptions(instance);
    } finally {
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
      reset();
    }
  }
  if ( true && !Component.render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP && !isSSR) {
    if (!compile && Component.template) {
      warn$1(
        `Component provided template option but runtime compilation is not supported in this build of Vue.` + (` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".` )
      );
    } else {
      warn$1(`Component is missing template or render function: `, Component);
    }
  }
}
const attrsProxyHandlers =  true ? {
  get(target, key) {
    markAttrsAccessed();
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(target, "get", "");
    return target[key];
  },
  set() {
    warn$1(`setupContext.attrs is readonly.`);
    return false;
  },
  deleteProperty() {
    warn$1(`setupContext.attrs is readonly.`);
    return false;
  }
} : 0;
function getSlotsProxy(instance) {
  return new Proxy(instance.slots, {
    get(target, key) {
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, "get", "$slots");
      return target[key];
    }
  });
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    if (true) {
      if (instance.exposed) {
        warn$1(`expose() should be called only once per setup().`);
      }
      if (exposed != null) {
        let exposedType = typeof exposed;
        if (exposedType === "object") {
          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(exposed)) {
            exposedType = "array";
          } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(exposed)) {
            exposedType = "ref";
          }
        }
        if (exposedType !== "object") {
          warn$1(
            `expose() should be passed a plain object, received ${exposedType}.`
          );
        }
      }
    }
    instance.exposed = exposed || {};
  };
  if (true) {
    let attrsProxy;
    let slotsProxy;
    return Object.freeze({
      get attrs() {
        return attrsProxy || (attrsProxy = new Proxy(instance.attrs, attrsProxyHandlers));
      },
      get slots() {
        return slotsProxy || (slotsProxy = getSlotsProxy(instance));
      },
      get emit() {
        return (event, ...args) => instance.emit(event, ...args);
      },
      expose
    });
  } else {}
}
function getComponentPublicInstance(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw)(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  } else {
    return instance.proxy;
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value) && "__vccOpts" in value;
}

const computed = (getterOrOptions, debugOptions) => {
  const c = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.computed)(getterOrOptions, debugOptions, isInSSRComponentSetup);
  if (true) {
    const i = getCurrentInstance();
    if (i && i.appContext.config.warnRecursiveComputed) {
      c._warnRecursive = true;
    }
  }
  return c;
};

function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(propsOrChildren) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}

function initCustomFormatter() {
  if ( false || typeof window === "undefined") {
    return;
  }
  const vueStyle = { style: "color:#3ba776" };
  const numberStyle = { style: "color:#1677ff" };
  const stringStyle = { style: "color:#f5222d" };
  const keywordStyle = { style: "color:#eb2f96" };
  const formatter = {
    __vue_custom_formatter: true,
    header(obj) {
      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
        return null;
      }
      if (obj.__isVue) {
        return ["div", vueStyle, `VueInstance`];
      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, genRefFlag(obj)],
          "<",
          // avoid debugger accessing value affecting behavior
          formatValue("_value" in obj ? obj._value : obj),
          `>`
        ];
      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow)(obj) ? "ShallowReactive" : "Reactive"],
          "<",
          formatValue(obj),
          `>${(0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj) ? ` (readonly)` : ``}`
        ];
      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow)(obj) ? "ShallowReadonly" : "Readonly"],
          "<",
          formatValue(obj),
          ">"
        ];
      }
      return null;
    },
    hasBody(obj) {
      return obj && obj.__isVue;
    },
    body(obj) {
      if (obj && obj.__isVue) {
        return [
          "div",
          {},
          ...formatInstance(obj.$)
        ];
      }
    }
  };
  function formatInstance(instance) {
    const blocks = [];
    if (instance.type.props && instance.props) {
      blocks.push(createInstanceBlock("props", (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.props)));
    }
    if (instance.setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
      blocks.push(createInstanceBlock("setup", instance.setupState));
    }
    if (instance.data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
      blocks.push(createInstanceBlock("data", (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.data)));
    }
    const computed = extractKeys(instance, "computed");
    if (computed) {
      blocks.push(createInstanceBlock("computed", computed));
    }
    const injected = extractKeys(instance, "inject");
    if (injected) {
      blocks.push(createInstanceBlock("injected", injected));
    }
    blocks.push([
      "div",
      {},
      [
        "span",
        {
          style: keywordStyle.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: instance }]
    ]);
    return blocks;
  }
  function createInstanceBlock(type, target) {
    target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, target);
    if (!Object.keys(target).length) {
      return ["span", {}];
    }
    return [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        type
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(target).map((key) => {
          return [
            "div",
            {},
            ["span", keywordStyle, key + ": "],
            formatValue(target[key], false)
          ];
        })
      ]
    ];
  }
  function formatValue(v, asRaw = true) {
    if (typeof v === "number") {
      return ["span", numberStyle, v];
    } else if (typeof v === "string") {
      return ["span", stringStyle, JSON.stringify(v)];
    } else if (typeof v === "boolean") {
      return ["span", keywordStyle, v];
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(v)) {
      return ["object", { object: asRaw ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(v) : v }];
    } else {
      return ["span", stringStyle, String(v)];
    }
  }
  function extractKeys(instance, type) {
    const Comp = instance.type;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Comp)) {
      return;
    }
    const extracted = {};
    for (const key in instance.ctx) {
      if (isKeyOfType(Comp, key, type)) {
        extracted[key] = instance.ctx[key];
      }
    }
    return extracted;
  }
  function isKeyOfType(Comp, key, type) {
    const opts = Comp[type];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opts) && opts.includes(key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opts) && key in opts) {
      return true;
    }
    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
      return true;
    }
    if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type))) {
      return true;
    }
  }
  function genRefFlag(v) {
    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow)(v)) {
      return `ShallowRef`;
    }
    if (v.effect) {
      return `ComputedRef`;
    }
    return `Ref`;
  }
  if (window.devtoolsFormatters) {
    window.devtoolsFormatters.push(formatter);
  } else {
    window.devtoolsFormatters = [formatter];
  }
}

function withMemo(memo, render, cache, index) {
  const cached = cache[index];
  if (cached && isMemoSame(cached, memo)) {
    return cached;
  }
  const ret = render();
  ret.memo = memo.slice();
  ret.cacheIndex = index;
  return cache[index] = ret;
}
function isMemoSame(cached, memo) {
  const prev = cached.memo;
  if (prev.length != memo.length) {
    return false;
  }
  for (let i = 0; i < prev.length; i++) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(prev[i], memo[i])) {
      return false;
    }
  }
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }
  return true;
}

const version = "3.5.13";
const warn =  true ? warn$1 : 0;
const ErrorTypeStrings = ErrorTypeStrings$1 ;
const devtools =  true ? devtools$1 : 0;
const setDevtoolsHook =  true ? setDevtoolsHook$1 : 0;
const _ssrUtils = {
  createComponentInstance,
  setupComponent,
  renderComponentRoot,
  setCurrentRenderingInstance,
  isVNode: isVNode,
  normalizeVNode,
  getComponentPublicInstance,
  ensureValidVNode,
  pushWarningContext,
  popWarningContext
};
const ssrUtils = _ssrUtils ;
const resolveFilter = null;
const compatUtils = null;
const DeprecationTypes = null;




/***/ }),

/***/ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseTransition: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   BaseTransitionPropsValidators: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransitionPropsValidators),
/* harmony export */   Comment: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   DeprecationTypes: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.DeprecationTypes),
/* harmony export */   EffectScope: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.EffectScope),
/* harmony export */   ErrorCodes: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ErrorCodes),
/* harmony export */   ErrorTypeStrings: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ErrorTypeStrings),
/* harmony export */   Fragment: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   KeepAlive: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   ReactiveEffect: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),
/* harmony export */   Static: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   Suspense: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   Teleport: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   Text: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   TrackOpTypes: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.TrackOpTypes),
/* harmony export */   Transition: () => (/* binding */ Transition),
/* harmony export */   TransitionGroup: () => (/* binding */ TransitionGroup),
/* harmony export */   TriggerOpTypes: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.TriggerOpTypes),
/* harmony export */   VueElement: () => (/* binding */ VueElement),
/* harmony export */   assertNumber: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.assertNumber),
/* harmony export */   callWithAsyncErrorHandling: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   callWithErrorHandling: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   camelize: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   capitalize: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   cloneVNode: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   compatUtils: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.compatUtils),
/* harmony export */   computed: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   createApp: () => (/* binding */ createApp),
/* harmony export */   createBlock: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   createCommentVNode: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   createElementBlock: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createElementBlock),
/* harmony export */   createElementVNode: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createElementVNode),
/* harmony export */   createHydrationRenderer: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   createPropsRestProxy: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy),
/* harmony export */   createRenderer: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   createSSRApp: () => (/* binding */ createSSRApp),
/* harmony export */   createSlots: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   createStaticVNode: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   createTextVNode: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   createVNode: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   customRef: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   defineAsyncComponent: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   defineComponent: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement),
/* harmony export */   defineEmits: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineEmits),
/* harmony export */   defineExpose: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineExpose),
/* harmony export */   defineModel: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineModel),
/* harmony export */   defineOptions: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineOptions),
/* harmony export */   defineProps: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   defineSSRCustomElement: () => (/* binding */ defineSSRCustomElement),
/* harmony export */   defineSlots: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineSlots),
/* harmony export */   devtools: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   effect: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   effectScope: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.effectScope),
/* harmony export */   getCurrentInstance: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   getCurrentScope: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),
/* harmony export */   getCurrentWatcher: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentWatcher),
/* harmony export */   getTransitionRawChildren: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   guardReactiveProps: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps),
/* harmony export */   h: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   handleError: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   hasInjectionContext: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.hasInjectionContext),
/* harmony export */   hydrate: () => (/* binding */ hydrate),
/* harmony export */   hydrateOnIdle: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.hydrateOnIdle),
/* harmony export */   hydrateOnInteraction: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.hydrateOnInteraction),
/* harmony export */   hydrateOnMediaQuery: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.hydrateOnMediaQuery),
/* harmony export */   hydrateOnVisible: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.hydrateOnVisible),
/* harmony export */   initCustomFormatter: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   initDirectivesForSSR: () => (/* binding */ initDirectivesForSSR),
/* harmony export */   inject: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   isMemoSame: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isMemoSame),
/* harmony export */   isProxy: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   isReactive: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   isReadonly: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   isRef: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   isRuntimeOnly: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   isShallow: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isShallow),
/* harmony export */   isVNode: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   markRaw: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   mergeDefaults: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults),
/* harmony export */   mergeModels: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeModels),
/* harmony export */   mergeProps: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   nextTick: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   normalizeClass: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeClass),
/* harmony export */   normalizeProps: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeProps),
/* harmony export */   normalizeStyle: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle),
/* harmony export */   onActivated: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   onBeforeMount: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   onBeforeUnmount: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   onBeforeUpdate: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   onDeactivated: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   onErrorCaptured: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   onMounted: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   onRenderTracked: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   onRenderTriggered: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   onScopeDispose: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),
/* harmony export */   onServerPrefetch: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),
/* harmony export */   onUnmounted: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   onUpdated: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   onWatcherCleanup: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onWatcherCleanup),
/* harmony export */   openBlock: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   popScopeId: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   provide: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   proxyRefs: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   pushScopeId: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   queuePostFlushCb: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   reactive: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   readonly: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   ref: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   registerRuntimeCompiler: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   render: () => (/* binding */ render),
/* harmony export */   renderList: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   renderSlot: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   resolveComponent: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   resolveDirective: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   resolveDynamicComponent: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   resolveFilter: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),
/* harmony export */   resolveTransitionHooks: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   setBlockTracking: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   setDevtoolsHook: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   setTransitionHooks: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   shallowReactive: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   shallowReadonly: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   shallowRef: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   ssrContextKey: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   ssrUtils: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   stop: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.stop),
/* harmony export */   toDisplayString: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   toHandlerKey: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   toHandlers: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   toRaw: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   toRef: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   toRefs: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   toValue: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toValue),
/* harmony export */   transformVNodeArgs: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   triggerRef: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   unref: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   useAttrs: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useAttrs),
/* harmony export */   useCssModule: () => (/* binding */ useCssModule),
/* harmony export */   useCssVars: () => (/* binding */ useCssVars),
/* harmony export */   useHost: () => (/* binding */ useHost),
/* harmony export */   useId: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useId),
/* harmony export */   useModel: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useModel),
/* harmony export */   useSSRContext: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   useShadowRoot: () => (/* binding */ useShadowRoot),
/* harmony export */   useSlots: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSlots),
/* harmony export */   useTemplateRef: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTemplateRef),
/* harmony export */   useTransitionState: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   vModelCheckbox: () => (/* binding */ vModelCheckbox),
/* harmony export */   vModelDynamic: () => (/* binding */ vModelDynamic),
/* harmony export */   vModelRadio: () => (/* binding */ vModelRadio),
/* harmony export */   vModelSelect: () => (/* binding */ vModelSelect),
/* harmony export */   vModelText: () => (/* binding */ vModelText),
/* harmony export */   vShow: () => (/* binding */ vShow),
/* harmony export */   version: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   warn: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   watch: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   watchEffect: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   watchPostEffect: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect),
/* harmony export */   watchSyncEffect: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect),
/* harmony export */   withAsyncContext: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext),
/* harmony export */   withCtx: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   withDefaults: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDefaults),
/* harmony export */   withDirectives: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   withKeys: () => (/* binding */ withKeys),
/* harmony export */   withMemo: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withMemo),
/* harmony export */   withModifiers: () => (/* binding */ withModifiers),
/* harmony export */   withScopeId: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withScopeId)
/* harmony export */ });
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");
/**
* @vue/runtime-dom v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/




let policy = void 0;
const tt = typeof window !== "undefined" && window.trustedTypes;
if (tt) {
  try {
    policy = /* @__PURE__ */ tt.createPolicy("vue", {
      createHTML: (val) => val
    });
  } catch (e) {
     true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Error creating trusted types policy: ${e}`);
  }
}
const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, namespace, is, props) => {
    const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, namespace, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling)) break;
      }
    } else {
      templateContainer.innerHTML = unsafeToTrustedHTML(
        namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
      );
      const template = templateContainer.content;
      if (namespace === "svg" || namespace === "mathml") {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};

const TRANSITION = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
  {},
  _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const decorate$1 = (t) => {
  t.displayName = "Transition";
  t.props = TransitionPropsValidators;
  return t;
};
const Transition = /* @__PURE__ */ decorate$1(
  (props, { slots }) => (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h)(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition, resolveTransitionProps(props), slots)
);
const callHook = (hook, args = []) => {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done, isCancelled) => {
    el._enterCancelled = isCancelled;
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve);
        }
      });
    };
  };
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      if (!el._enterCancelled) {
        forceReflow();
        addTransitionClass(el, leaveActiveClass);
      } else {
        addTransitionClass(el, leaveActiveClass);
        forceReflow();
      }
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve);
        }
      });
      callHook(onLeave, [el, resolve]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false, void 0, true);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true, void 0, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(val);
  if (true) {
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.assertNumber)(res, "<transition> explicit duration");
  }
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve();
    }
  };
  if (explicitTimeout != null) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  if (s === "auto") return 0;
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}

function patchClass(el, value, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}

const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const vShow = {
  beforeMount(el, { value }, { transition }) {
    el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue) return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
if (true) {
  vShow.name = "show";
}
function setDisplay(el, value) {
  el.style.display = value ? el[vShowOriginalDisplay] : "none";
  el[vShowHidden] = !value;
}
function initVShowForSSR() {
  vShow.getSSRProps = ({ value }) => {
    if (!value) {
      return { style: { display: "none" } };
    }
  };
}

const CSS_VAR_TEXT = Symbol( true ? "CSS_VAR_TEXT" : 0);
function useCssVars(getter) {
  const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
  if (!instance) {
     true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`useCssVars is called without current active component instance.`);
    return;
  }
  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
    ).forEach((node) => setVarsOnNode(node, vars));
  };
  if (true) {
    instance.getCssVars = () => getter(instance.proxy);
  }
  const setVars = () => {
    const vars = getter(instance.proxy);
    if (instance.ce) {
      setVarsOnNode(instance.ce, vars);
    } else {
      setVarsOnVNode(instance.subTree, vars);
    }
    updateTeleports(vars);
  };
  (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate)(() => {
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb)(setVars);
  });
  (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watch)(setVars, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP, { flush: "post" });
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment) {
    vnode.children.forEach((c) => setVarsOnVNode(c, vars));
  } else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor) break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style = el.style;
    let cssText = "";
    for (const key in vars) {
      style.setProperty(`--${key}`, vars[key]);
      cssText += `--${key}: ${vars[key]};`;
    }
    style[CSS_VAR_TEXT] = cssText;
  }
}

const displayRE = /(^|;)\s*display\s*:/;
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(next);
  let hasControlledDisplay = false;
  if (next && !isCssString) {
    if (prev) {
      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      } else {
        for (const prevStyle of prev.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
    }
    for (const key in next) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style, key, next[key]);
    }
  } else {
    if (isCssString) {
      if (prev !== next) {
        const cssVarText = style[CSS_VAR_TEXT];
        if (cssVarText) {
          next += ";" + cssVarText;
        }
        style.cssText = next;
        hasControlledDisplay = displayRE.test(next);
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el) {
    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
    if (el[vShowHidden]) {
      style.display = "none";
    }
  }
}
const semicolonRE = /[^\\];\s*$/;
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(val)) {
    val.forEach((v) => setStyle(style, name, v));
  } else {
    if (val == null) val = "";
    if (true) {
      if (semicolonRE.test(val)) {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
          `Unexpected semicolon at the end of '${name}' style value: '${val}'`
        );
      }
    }
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}

const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance, isBoolean = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSpecialBooleanAttr)(key)) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (value == null || isBoolean && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.includeBooleanAttr)(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(
        key,
        isBoolean ? "" : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSymbol)(value) ? String(value) : value
      );
    }
  }
}

function patchDOMProp(el, key, value, parentComponent, attrName) {
  if (key === "innerHTML" || key === "textContent") {
    if (value != null) {
      el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
    }
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
    const newValue = value == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      el.type === "checkbox" ? "on" : ""
    ) : String(value);
    if (oldValue !== newValue || !("_value" in el)) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    el._value = value;
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.includeBooleanAttr)(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
    if ( true && !needRemove) {
      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
        `Failed setting prop "${key}" on <${tag.toLowerCase()}>: value ${value} is invalid.`,
        e
      );
    }
  }
  needRemove && el.removeAttribute(attrName || key);
}

function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value =  true ? sanitizeEventValue(nextValue, rawName) : 0;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(
         true ? sanitizeEventValue(nextValue, rawName) : 0,
        instance
      );
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling)(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function sanitizeEventValue(value, propName) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
    return value;
  }
  (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
    `Wrong type passed as event handler to ${propName} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof value}.`
  );
  return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
}
function patchStopImmediatePropagation(e, value) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map(
      (fn) => (e2) => !e2._stopped && fn && fn(e2)
    );
  } else {
    return value;
  }
}

const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
  const isSVG = namespace === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue);
    if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
      patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
    }
  } else if (
    // #11081 force set props for possible async custom element
    el._isVueCE && (/[A-Z]/.test(key) || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(nextValue))
  ) {
    patchDOMProp(el, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key), nextValue, parentComponent, key);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag = el.tagName;
    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
    return false;
  }
  return key in el;
}

const REMOVAL = {};
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineCustomElement(options, extraOptions, _createApp) {
  const Comp = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent)(options, extraOptions);
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(Comp)) (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Comp, extraOptions);
  class VueCustomElement extends VueElement {
    constructor(initialProps) {
      super(Comp, initialProps, _createApp);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
/*! #__NO_SIDE_EFFECTS__ */
const defineSSRCustomElement = /* @__NO_SIDE_EFFECTS__ */ (options, extraOptions) => {
  return /* @__PURE__ */ defineCustomElement(options, extraOptions, createSSRApp);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
  constructor(_def, _props = {}, _createApp = createApp) {
    super();
    this._def = _def;
    this._props = _props;
    this._createApp = _createApp;
    this._isVueCE = true;
    /**
     * @internal
     */
    this._instance = null;
    /**
     * @internal
     */
    this._app = null;
    /**
     * @internal
     */
    this._nonce = this._def.nonce;
    this._connected = false;
    this._resolved = false;
    this._numberProps = null;
    this._styleChildren = /* @__PURE__ */ new WeakSet();
    this._ob = null;
    if (this.shadowRoot && _createApp !== createApp) {
      this._root = this.shadowRoot;
    } else {
      if ( true && this.shadowRoot) {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
          `Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use \`defineSSRCustomElement\`.`
        );
      }
      if (_def.shadowRoot !== false) {
        this.attachShadow({ mode: "open" });
        this._root = this.shadowRoot;
      } else {
        this._root = this;
      }
    }
    if (!this._def.__asyncLoader) {
      this._resolveProps(this._def);
    }
  }
  connectedCallback() {
    if (!this.isConnected) return;
    if (!this.shadowRoot) {
      this._parseSlots();
    }
    this._connected = true;
    let parent = this;
    while (parent = parent && (parent.parentNode || parent.host)) {
      if (parent instanceof VueElement) {
        this._parent = parent;
        break;
      }
    }
    if (!this._instance) {
      if (this._resolved) {
        this._setParent();
        this._update();
      } else {
        if (parent && parent._pendingResolve) {
          this._pendingResolve = parent._pendingResolve.then(() => {
            this._pendingResolve = void 0;
            this._resolveDef();
          });
        } else {
          this._resolveDef();
        }
      }
    }
  }
  _setParent(parent = this._parent) {
    if (parent) {
      this._instance.parent = parent._instance;
      this._instance.provides = parent._instance.provides;
    }
  }
  disconnectedCallback() {
    this._connected = false;
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {
      if (!this._connected) {
        if (this._ob) {
          this._ob.disconnect();
          this._ob = null;
        }
        this._app && this._app.unmount();
        if (this._instance) this._instance.ce = void 0;
        this._app = this._instance = null;
      }
    });
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    if (this._pendingResolve) {
      return;
    }
    for (let i = 0; i < this.attributes.length; i++) {
      this._setAttr(this.attributes[i].name);
    }
    this._ob = new MutationObserver((mutations) => {
      for (const m of mutations) {
        this._setAttr(m.attributeName);
      }
    });
    this._ob.observe(this, { attributes: true });
    const resolve = (def, isAsync = false) => {
      this._resolved = true;
      this._pendingResolve = void 0;
      const { props, styles } = def;
      let numberProps;
      if (props && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(props)) {
        for (const key in props) {
          const opt = props[key];
          if (opt === Number || opt && opt.type === Number) {
            if (key in this._props) {
              this._props[key] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(this._props[key]);
            }
            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key)] = true;
          }
        }
      }
      this._numberProps = numberProps;
      if (isAsync) {
        this._resolveProps(def);
      }
      if (this.shadowRoot) {
        this._applyStyles(styles);
      } else if ( true && styles) {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
          "Custom element style injection is not supported when using shadowRoot: false"
        );
      }
      this._mount(def);
    };
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      this._pendingResolve = asyncDef().then(
        (def) => resolve(this._def = def, true)
      );
    } else {
      resolve(this._def);
    }
  }
  _mount(def) {
    if (( true) && !def.name) {
      def.name = "VueElement";
    }
    this._app = this._createApp(def);
    if (def.configureApp) {
      def.configureApp(this._app);
    }
    this._app._ceVNode = this._createVNode();
    this._app.mount(this._root);
    const exposed = this._instance && this._instance.exposed;
    if (!exposed) return;
    for (const key in exposed) {
      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(this, key)) {
        Object.defineProperty(this, key, {
          // unwrap ref to be consistent with public instance behavior
          get: () => (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.unref)(exposed[key])
        });
      } else if (true) {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Exposed property "${key}" already exists on custom element.`);
      }
    }
  }
  _resolveProps(def) {
    const { props } = def;
    const declaredPropKeys = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(props) ? props : Object.keys(props || {});
    for (const key of Object.keys(this)) {
      if (key[0] !== "_" && declaredPropKeys.includes(key)) {
        this._setProp(key, this[key]);
      }
    }
    for (const key of declaredPropKeys.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)) {
      Object.defineProperty(this, key, {
        get() {
          return this._getProp(key);
        },
        set(val) {
          this._setProp(key, val, true, true);
        }
      });
    }
  }
  _setAttr(key) {
    if (key.startsWith("data-v-")) return;
    const has = this.hasAttribute(key);
    let value = has ? this.getAttribute(key) : REMOVAL;
    const camelKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
    if (has && this._numberProps && this._numberProps[camelKey]) {
      value = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(value);
    }
    this._setProp(camelKey, value, false, true);
  }
  /**
   * @internal
   */
  _getProp(key) {
    return this._props[key];
  }
  /**
   * @internal
   */
  _setProp(key, val, shouldReflect = true, shouldUpdate = false) {
    if (val !== this._props[key]) {
      if (val === REMOVAL) {
        delete this._props[key];
      } else {
        this._props[key] = val;
        if (key === "key" && this._app) {
          this._app._ceVNode.key = val;
        }
      }
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        const ob = this._ob;
        ob && ob.disconnect();
        if (val === true) {
          this.setAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key), val + "");
        } else if (!val) {
          this.removeAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key));
        }
        ob && ob.observe(this, { attributes: true });
      }
    }
  }
  _update() {
    render(this._createVNode(), this._root);
  }
  _createVNode() {
    const baseProps = {};
    if (!this.shadowRoot) {
      baseProps.onVnodeMounted = baseProps.onVnodeUpdated = this._renderSlots.bind(this);
    }
    const vnode = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(this._def, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(baseProps, this._props));
    if (!this._instance) {
      vnode.ce = (instance) => {
        this._instance = instance;
        instance.ce = this;
        instance.isCE = true;
        if (true) {
          instance.ceReload = (newStyles) => {
            if (this._styles) {
              this._styles.forEach((s) => this._root.removeChild(s));
              this._styles.length = 0;
            }
            this._applyStyles(newStyles);
            this._instance = null;
            this._update();
          };
        }
        const dispatch = (event, args) => {
          this.dispatchEvent(
            new CustomEvent(
              event,
              (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(args[0]) ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({ detail: args }, args[0]) : { detail: args }
            )
          );
        };
        instance.emit = (event, ...args) => {
          dispatch(event, args);
          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event) !== event) {
            dispatch((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event), args);
          }
        };
        this._setParent();
      };
    }
    return vnode;
  }
  _applyStyles(styles, owner) {
    if (!styles) return;
    if (owner) {
      if (owner === this._def || this._styleChildren.has(owner)) {
        return;
      }
      this._styleChildren.add(owner);
    }
    const nonce = this._nonce;
    for (let i = styles.length - 1; i >= 0; i--) {
      const s = document.createElement("style");
      if (nonce) s.setAttribute("nonce", nonce);
      s.textContent = styles[i];
      this.shadowRoot.prepend(s);
      if (true) {
        if (owner) {
          if (owner.__hmrId) {
            if (!this._childStyles) this._childStyles = /* @__PURE__ */ new Map();
            let entry = this._childStyles.get(owner.__hmrId);
            if (!entry) {
              this._childStyles.set(owner.__hmrId, entry = []);
            }
            entry.push(s);
          }
        } else {
          (this._styles || (this._styles = [])).push(s);
        }
      }
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _parseSlots() {
    const slots = this._slots = {};
    let n;
    while (n = this.firstChild) {
      const slotName = n.nodeType === 1 && n.getAttribute("slot") || "default";
      (slots[slotName] || (slots[slotName] = [])).push(n);
      this.removeChild(n);
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _renderSlots() {
    const outlets = (this._teleportTarget || this).querySelectorAll("slot");
    const scopeId = this._instance.type.__scopeId;
    for (let i = 0; i < outlets.length; i++) {
      const o = outlets[i];
      const slotName = o.getAttribute("name") || "default";
      const content = this._slots[slotName];
      const parent = o.parentNode;
      if (content) {
        for (const n of content) {
          if (scopeId && n.nodeType === 1) {
            const id = scopeId + "-s";
            const walker = document.createTreeWalker(n, 1);
            n.setAttribute(id, "");
            let child;
            while (child = walker.nextNode()) {
              child.setAttribute(id, "");
            }
          }
          parent.insertBefore(n, o);
        }
      } else {
        while (o.firstChild) parent.insertBefore(o.firstChild, o);
      }
      parent.removeChild(o);
    }
  }
  /**
   * @internal
   */
  _injectChildStyle(comp) {
    this._applyStyles(comp.styles, comp);
  }
  /**
   * @internal
   */
  _removeChildStyle(comp) {
    if (true) {
      this._styleChildren.delete(comp);
      if (this._childStyles && comp.__hmrId) {
        const oldStyles = this._childStyles.get(comp.__hmrId);
        if (oldStyles) {
          oldStyles.forEach((s) => this._root.removeChild(s));
          oldStyles.length = 0;
        }
      }
    }
  }
}
function useHost(caller) {
  const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
  const el = instance && instance.ce;
  if (el) {
    return el;
  } else if (true) {
    if (!instance) {
      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
        `${caller || "useHost"} called without an active component instance.`
      );
    } else {
      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
        `${caller || "useHost"} can only be used in components defined via defineCustomElement.`
      );
    }
  }
  return null;
}
function useShadowRoot() {
  const el =  true ? useHost("useShadowRoot") : 0;
  return el && el.shadowRoot;
}

function useCssModule(name = "$style") {
  {
    const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
    if (!instance) {
       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`useCssModule must be called inside setup()`);
      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    }
    const modules = instance.type.__cssModules;
    if (!modules) {
       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Current instance does not have CSS modules injected.`);
      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    }
    const mod = modules[name];
    if (!mod) {
       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Current instance does not have CSS module named "${name}".`);
      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    }
    return mod;
  }
}

const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const moveCbKey = Symbol("_moveCb");
const enterCbKey = Symbol("_enterCb");
const decorate = (t) => {
  delete t.props.mode;
  return t;
};
const TransitionGroupImpl = /* @__PURE__ */ decorate({
  name: "TransitionGroup",
  props: /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
    const state = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState)();
    let prevChildren;
    let children;
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated)(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(
        prevChildren[0].el,
        instance.vnode.el,
        moveClass
      )) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c) => {
        const el = c.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el[moveCbKey] = (e) => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el[moveCbKey] = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.toRaw)(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment;
      prevChildren = [];
      if (children) {
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child.el && child.el instanceof Element) {
            prevChildren.push(child);
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(
              child,
              (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(
                child,
                cssTransitionProps,
                state,
                instance
              )
            );
            positionMap.set(
              child,
              child.el.getBoundingClientRect()
            );
          }
        }
      }
      children = slots.default ? (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren)(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(
            child,
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(child, cssTransitionProps, state, instance)
          );
        } else if ( true && child.type !== _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Text) {
          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<TransitionGroup> children must be keyed.`);
        }
      }
      return (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(tag, null, children);
    };
  }
});
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
  const el = c.el;
  if (el[moveCbKey]) {
    el[moveCbKey]();
  }
  if (el[enterCbKey]) {
    el[enterCbKey]();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el, root, moveClass) {
  const clone = el.cloneNode();
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c));
  clone.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);
  const { hasTransform } = getTransitionInfo(clone);
  container.removeChild(clone);
  return hasTransform;
}

const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn) ? (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(fn, value) : fn;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const assignKey = Symbol("_assign");
const vModelText = {
  created(el, { modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener(el, lazy ? "change" : "input", (e) => {
      if (e.target.composing) return;
      let domValue = el.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseToNumber)(domValue);
      }
      el[assignKey](domValue);
    });
    if (trim) {
      addEventListener(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (el.composing) return;
    const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseToNumber)(el.value) : el.value;
    const newValue = value == null ? "" : value;
    if (elValue === newValue) {
      return;
    }
    if (document.activeElement === el && el.type !== "range") {
      if (lazy && value === oldValue) {
        return;
      }
      if (trim && el.value.trim() === newValue) {
        return;
      }
    }
    el.value = newValue;
  }
};
const vModelCheckbox = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(el, _, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue(el);
      const checked = el.checked;
      const assign = el[assignKey];
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(modelValue)) {
        const index = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(modelValue, elementValue);
        const found = index !== -1;
        if (checked && !found) {
          assign(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index, 1);
          assign(filtered);
        }
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign(cloned);
      } else {
        assign(getCheckboxValue(el, checked));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value, oldValue }, vnode) {
  el._modelValue = value;
  let checked;
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
    checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, vnode.props.value) > -1;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
    checked = value.has(vnode.props.value);
  } else {
    if (value === oldValue) return;
    checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, getCheckboxValue(el, true));
  }
  if (el.checked !== checked) {
    el.checked = checked;
  }
}
const vModelRadio = {
  created(el, { value }, vnode) {
    el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      el[assignKey](getValue(el));
    });
  },
  beforeUpdate(el, { value, oldValue }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (value !== oldValue) {
      el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, { value, modifiers: { number } }, vnode) {
    const isSetModel = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
        (o) => number ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseToNumber)(getValue(o)) : getValue(o)
      );
      el[assignKey](
        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
      );
      el._assigning = true;
      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {
        el._assigning = false;
      });
    });
    el[assignKey] = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, { value }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
  },
  updated(el, { value }) {
    if (!el._assigning) {
      setSelected(el, value);
    }
  }
};
function setSelected(el, value) {
  const isMultiple = el.multiple;
  const isArrayValue = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value);
  if (isMultiple && !isArrayValue && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
     true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
      `<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(value).slice(8, -1)}.`
    );
    return;
  }
  for (let i = 0, l = el.options.length; i < l; i++) {
    const option = el.options[i];
    const optionValue = getValue(option);
    if (isMultiple) {
      if (isArrayValue) {
        const optionType = typeof optionValue;
        if (optionType === "string" || optionType === "number") {
          option.selected = value.some((v) => String(v) === String(optionValue));
        } else {
          option.selected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, optionValue) > -1;
        }
      } else {
        option.selected = value.has(optionValue);
      }
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(getValue(option), value)) {
      if (el.selectedIndex !== i) el.selectedIndex = i;
      return;
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked;
}
const vModelDynamic = {
  created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "created");
  },
  mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "mounted");
  },
  beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "updated");
  }
};
function resolveDynamicModel(tagName, type) {
  switch (tagName) {
    case "SELECT":
      return vModelSelect;
    case "TEXTAREA":
      return vModelText;
    default:
      switch (type) {
        case "checkbox":
          return vModelCheckbox;
        case "radio":
          return vModelRadio;
        default:
          return vModelText;
      }
  }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
  const modelToUse = resolveDynamicModel(
    el.tagName,
    vnode.props && vnode.props.type
  );
  const fn = modelToUse[hook];
  fn && fn(el, binding, vnode, prevVNode);
}
function initVModelForSSR() {
  vModelText.getSSRProps = ({ value }) => ({ value });
  vModelRadio.getSSRProps = ({ value }, vnode) => {
    if (vnode.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(vnode.props.value, value)) {
      return { checked: true };
    }
  };
  vModelCheckbox.getSSRProps = ({ value }, vnode) => {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
      if (vnode.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, vnode.props.value) > -1) {
        return { checked: true };
      }
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
      if (vnode.props && value.has(vnode.props.value)) {
        return { checked: true };
      }
    } else if (value) {
      return { checked: true };
    }
  };
  vModelDynamic.getSSRProps = (binding, vnode) => {
    if (typeof vnode.type !== "string") {
      return;
    }
    const modelToUse = resolveDynamicModel(
      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
      vnode.type.toUpperCase(),
      vnode.props && vnode.props.type
    );
    if (modelToUse.getSSRProps) {
      return modelToUse.getSSRProps(binding, vnode);
    }
  };
}

const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers) => {
  const cache = fn._withMods || (fn._withMods = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers)) return;
    }
    return fn(event, ...args);
  });
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  const cache = fn._withKeys || (fn._withKeys = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event.key);
    if (modifiers.some(
      (k) => k === eventKey || keyNames[k] === eventKey
    )) {
      return fn(event);
    }
  });
};

const rendererOptions = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({ patchProp }, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
  return renderer || (renderer = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer)(rendererOptions));
}
function ensureHydrationRenderer() {
  renderer = enabledHydration ? renderer : (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer)(rendererOptions);
  enabledHydration = true;
  return renderer;
}
const render = (...args) => {
  ensureRenderer().render(...args);
};
const hydrate = (...args) => {
  ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  if (true) {
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
  }
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container) return;
    const component = app._component;
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    if (container.nodeType === 1) {
      container.textContent = "";
    }
    const proxy = mount(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
const createSSRApp = (...args) => {
  const app = ensureHydrationRenderer().createApp(...args);
  if (true) {
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
  }
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (container) {
      return mount(container, true, resolveRootNamespace(container));
    }
  };
  return app;
};
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
function injectNativeTagCheck(app) {
  Object.defineProperty(app.config, "isNativeTag", {
    value: (tag) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isMathMLTag)(tag),
    writable: false
  });
}
function injectCompilerOptionsCheck(app) {
  if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly)()) {
    const isCustomElement = app.config.isCustomElement;
    Object.defineProperty(app.config, "isCustomElement", {
      get() {
        return isCustomElement;
      },
      set() {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
          `The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`
        );
      }
    });
    const compilerOptions = app.config.compilerOptions;
    const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
    Object.defineProperty(app.config, "compilerOptions", {
      get() {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);
        return compilerOptions;
      },
      set() {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);
      }
    });
  }
}
function normalizeContainer(container) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(container)) {
    const res = document.querySelector(container);
    if ( true && !res) {
      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
        `Failed to mount app: mount target selector "${container}" returned null.`
      );
    }
    return res;
  }
  if ( true && window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
      `mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`
    );
  }
  return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = () => {
  if (!ssrDirectiveInitialized) {
    ssrDirectiveInitialized = true;
    initVModelForSSR();
    initVShowForSSR();
  }
} ;




/***/ }),

/***/ "./node_modules/@vue/shared/dist/shared.esm-bundler.js":
/*!*************************************************************!*\
  !*** ./node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EMPTY_ARR: () => (/* binding */ EMPTY_ARR),
/* harmony export */   EMPTY_OBJ: () => (/* binding */ EMPTY_OBJ),
/* harmony export */   NO: () => (/* binding */ NO),
/* harmony export */   NOOP: () => (/* binding */ NOOP),
/* harmony export */   PatchFlagNames: () => (/* binding */ PatchFlagNames),
/* harmony export */   PatchFlags: () => (/* binding */ PatchFlags),
/* harmony export */   ShapeFlags: () => (/* binding */ ShapeFlags),
/* harmony export */   SlotFlags: () => (/* binding */ SlotFlags),
/* harmony export */   camelize: () => (/* binding */ camelize),
/* harmony export */   capitalize: () => (/* binding */ capitalize),
/* harmony export */   cssVarNameEscapeSymbolsRE: () => (/* binding */ cssVarNameEscapeSymbolsRE),
/* harmony export */   def: () => (/* binding */ def),
/* harmony export */   escapeHtml: () => (/* binding */ escapeHtml),
/* harmony export */   escapeHtmlComment: () => (/* binding */ escapeHtmlComment),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   genCacheKey: () => (/* binding */ genCacheKey),
/* harmony export */   genPropsAccessExp: () => (/* binding */ genPropsAccessExp),
/* harmony export */   generateCodeFrame: () => (/* binding */ generateCodeFrame),
/* harmony export */   getEscapedCssVarName: () => (/* binding */ getEscapedCssVarName),
/* harmony export */   getGlobalThis: () => (/* binding */ getGlobalThis),
/* harmony export */   hasChanged: () => (/* binding */ hasChanged),
/* harmony export */   hasOwn: () => (/* binding */ hasOwn),
/* harmony export */   hyphenate: () => (/* binding */ hyphenate),
/* harmony export */   includeBooleanAttr: () => (/* binding */ includeBooleanAttr),
/* harmony export */   invokeArrayFns: () => (/* binding */ invokeArrayFns),
/* harmony export */   isArray: () => (/* binding */ isArray),
/* harmony export */   isBooleanAttr: () => (/* binding */ isBooleanAttr),
/* harmony export */   isBuiltInDirective: () => (/* binding */ isBuiltInDirective),
/* harmony export */   isDate: () => (/* binding */ isDate),
/* harmony export */   isFunction: () => (/* binding */ isFunction),
/* harmony export */   isGloballyAllowed: () => (/* binding */ isGloballyAllowed),
/* harmony export */   isGloballyWhitelisted: () => (/* binding */ isGloballyWhitelisted),
/* harmony export */   isHTMLTag: () => (/* binding */ isHTMLTag),
/* harmony export */   isIntegerKey: () => (/* binding */ isIntegerKey),
/* harmony export */   isKnownHtmlAttr: () => (/* binding */ isKnownHtmlAttr),
/* harmony export */   isKnownMathMLAttr: () => (/* binding */ isKnownMathMLAttr),
/* harmony export */   isKnownSvgAttr: () => (/* binding */ isKnownSvgAttr),
/* harmony export */   isMap: () => (/* binding */ isMap),
/* harmony export */   isMathMLTag: () => (/* binding */ isMathMLTag),
/* harmony export */   isModelListener: () => (/* binding */ isModelListener),
/* harmony export */   isObject: () => (/* binding */ isObject),
/* harmony export */   isOn: () => (/* binding */ isOn),
/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),
/* harmony export */   isPromise: () => (/* binding */ isPromise),
/* harmony export */   isRegExp: () => (/* binding */ isRegExp),
/* harmony export */   isRenderableAttrValue: () => (/* binding */ isRenderableAttrValue),
/* harmony export */   isReservedProp: () => (/* binding */ isReservedProp),
/* harmony export */   isSSRSafeAttrName: () => (/* binding */ isSSRSafeAttrName),
/* harmony export */   isSVGTag: () => (/* binding */ isSVGTag),
/* harmony export */   isSet: () => (/* binding */ isSet),
/* harmony export */   isSpecialBooleanAttr: () => (/* binding */ isSpecialBooleanAttr),
/* harmony export */   isString: () => (/* binding */ isString),
/* harmony export */   isSymbol: () => (/* binding */ isSymbol),
/* harmony export */   isVoidTag: () => (/* binding */ isVoidTag),
/* harmony export */   looseEqual: () => (/* binding */ looseEqual),
/* harmony export */   looseIndexOf: () => (/* binding */ looseIndexOf),
/* harmony export */   looseToNumber: () => (/* binding */ looseToNumber),
/* harmony export */   makeMap: () => (/* binding */ makeMap),
/* harmony export */   normalizeClass: () => (/* binding */ normalizeClass),
/* harmony export */   normalizeProps: () => (/* binding */ normalizeProps),
/* harmony export */   normalizeStyle: () => (/* binding */ normalizeStyle),
/* harmony export */   objectToString: () => (/* binding */ objectToString),
/* harmony export */   parseStringStyle: () => (/* binding */ parseStringStyle),
/* harmony export */   propsToAttrMap: () => (/* binding */ propsToAttrMap),
/* harmony export */   remove: () => (/* binding */ remove),
/* harmony export */   slotFlagsText: () => (/* binding */ slotFlagsText),
/* harmony export */   stringifyStyle: () => (/* binding */ stringifyStyle),
/* harmony export */   toDisplayString: () => (/* binding */ toDisplayString),
/* harmony export */   toHandlerKey: () => (/* binding */ toHandlerKey),
/* harmony export */   toNumber: () => (/* binding */ toNumber),
/* harmony export */   toRawType: () => (/* binding */ toRawType),
/* harmony export */   toTypeString: () => (/* binding */ toTypeString)
/* harmony export */ });
/**
* @vue/shared v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function makeMap(str) {
  const map = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(",")) map[key] = 1;
  return (val) => val in map;
}

const EMPTY_OBJ =  true ? Object.freeze({}) : 0;
const EMPTY_ARR =  true ? Object.freeze([]) : 0;
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate = (val) => toTypeString(val) === "[object Date]";
const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const isBuiltInDirective = /* @__PURE__ */ makeMap(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction(
  (str) => {
    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
  }
);
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction(
  (str) => {
    const s = str ? `on${capitalize(str)}` : ``;
    return s;
  }
);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, ...arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](...arg);
  }
};
const def = (obj, key, value, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : {});
};
const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function genPropsAccessExp(name) {
  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
}
function genCacheKey(source, options) {
  return source + JSON.stringify(
    options,
    (_, val) => typeof val === "function" ? val.toString() : val
  );
}

const PatchFlags = {
  "TEXT": 1,
  "1": "TEXT",
  "CLASS": 2,
  "2": "CLASS",
  "STYLE": 4,
  "4": "STYLE",
  "PROPS": 8,
  "8": "PROPS",
  "FULL_PROPS": 16,
  "16": "FULL_PROPS",
  "NEED_HYDRATION": 32,
  "32": "NEED_HYDRATION",
  "STABLE_FRAGMENT": 64,
  "64": "STABLE_FRAGMENT",
  "KEYED_FRAGMENT": 128,
  "128": "KEYED_FRAGMENT",
  "UNKEYED_FRAGMENT": 256,
  "256": "UNKEYED_FRAGMENT",
  "NEED_PATCH": 512,
  "512": "NEED_PATCH",
  "DYNAMIC_SLOTS": 1024,
  "1024": "DYNAMIC_SLOTS",
  "DEV_ROOT_FRAGMENT": 2048,
  "2048": "DEV_ROOT_FRAGMENT",
  "CACHED": -1,
  "-1": "CACHED",
  "BAIL": -2,
  "-2": "BAIL"
};
const PatchFlagNames = {
  [1]: `TEXT`,
  [2]: `CLASS`,
  [4]: `STYLE`,
  [8]: `PROPS`,
  [16]: `FULL_PROPS`,
  [32]: `NEED_HYDRATION`,
  [64]: `STABLE_FRAGMENT`,
  [128]: `KEYED_FRAGMENT`,
  [256]: `UNKEYED_FRAGMENT`,
  [512]: `NEED_PATCH`,
  [1024]: `DYNAMIC_SLOTS`,
  [2048]: `DEV_ROOT_FRAGMENT`,
  [-1]: `HOISTED`,
  [-2]: `BAIL`
};

const ShapeFlags = {
  "ELEMENT": 1,
  "1": "ELEMENT",
  "FUNCTIONAL_COMPONENT": 2,
  "2": "FUNCTIONAL_COMPONENT",
  "STATEFUL_COMPONENT": 4,
  "4": "STATEFUL_COMPONENT",
  "TEXT_CHILDREN": 8,
  "8": "TEXT_CHILDREN",
  "ARRAY_CHILDREN": 16,
  "16": "ARRAY_CHILDREN",
  "SLOTS_CHILDREN": 32,
  "32": "SLOTS_CHILDREN",
  "TELEPORT": 64,
  "64": "TELEPORT",
  "SUSPENSE": 128,
  "128": "SUSPENSE",
  "COMPONENT_SHOULD_KEEP_ALIVE": 256,
  "256": "COMPONENT_SHOULD_KEEP_ALIVE",
  "COMPONENT_KEPT_ALIVE": 512,
  "512": "COMPONENT_KEPT_ALIVE",
  "COMPONENT": 6,
  "6": "COMPONENT"
};

const SlotFlags = {
  "STABLE": 1,
  "1": "STABLE",
  "DYNAMIC": 2,
  "2": "DYNAMIC",
  "FORWARDED": 3,
  "3": "FORWARDED"
};
const slotFlagsText = {
  [1]: "STABLE",
  [2]: "DYNAMIC",
  [3]: "FORWARDED"
};

const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol";
const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
const isGloballyWhitelisted = isGloballyAllowed;

const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
  start = Math.max(0, Math.min(start, source.length));
  end = Math.max(0, Math.min(end, source.length));
  if (start > end) return "";
  let lines = source.split(/(\r?\n)/);
  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
  lines = lines.filter((_, idx) => idx % 2 === 0);
  let count = 0;
  const res = [];
  for (let i = 0; i < lines.length; i++) {
    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
    if (count >= start) {
      for (let j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) continue;
        const line = j + 1;
        res.push(
          `${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`
        );
        const lineLength = lines[j].length;
        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
        if (j === i) {
          const pad = start - (count - (lineLength + newLineSeqLength));
          const length = Math.max(
            1,
            end > count ? lineLength - pad : end - start
          );
          res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
        } else if (j > i) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + newLineSeqLength;
        }
      }
      break;
    }
  }
  return res.join("\n");
}

function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value) || isObject(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function stringifyStyle(styles) {
  if (!styles) return "";
  if (isString(styles)) return styles;
  let ret = "";
  for (const key in styles) {
    const value = styles[key];
    if (isString(value) || typeof value === "number") {
      const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
      ret += `${normalizedKey}:${value};`;
    }
  }
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props) return null;
  let { class: klass, style } = props;
  if (klass && !isString(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}

const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);

const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
const isBooleanAttr = /* @__PURE__ */ makeMap(
  specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`
);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
  if (attrValidationCache.hasOwnProperty(name)) {
    return attrValidationCache[name];
  }
  const isUnsafe = unsafeAttrCharRE.test(name);
  if (isUnsafe) {
    console.error(`unsafe attribute name: ${name}`);
  }
  return attrValidationCache[name] = !isUnsafe;
}
const propsToAttrMap = {
  acceptCharset: "accept-charset",
  className: "class",
  htmlFor: "for",
  httpEquiv: "http-equiv"
};
const isKnownHtmlAttr = /* @__PURE__ */ makeMap(
  `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`
);
const isKnownSvgAttr = /* @__PURE__ */ makeMap(
  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`
);
const isKnownMathMLAttr = /* @__PURE__ */ makeMap(
  `accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns`
);
function isRenderableAttrValue(value) {
  if (value == null) {
    return false;
  }
  const type = typeof value;
  return type === "string" || type === "number" || type === "boolean";
}

const escapeRE = /["'&<>]/;
function escapeHtml(string) {
  const str = "" + string;
  const match = escapeRE.exec(str);
  if (!match) {
    return str;
  }
  let html = "";
  let escaped;
  let index;
  let lastIndex = 0;
  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        escaped = "&quot;";
        break;
      case 38:
        escaped = "&amp;";
        break;
      case 39:
        escaped = "&#39;";
        break;
      case 60:
        escaped = "&lt;";
        break;
      case 62:
        escaped = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index) {
      html += str.slice(lastIndex, index);
    }
    lastIndex = index + 1;
    html += escaped;
  }
  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
  return src.replace(commentStripRE, "");
}
const cssVarNameEscapeSymbolsRE = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g;
function getEscapedCssVarName(key, doubleEscape) {
  return key.replace(
    cssVarNameEscapeSymbolsRE,
    (s) => doubleEscape ? s === '"' ? '\\\\\\"' : `\\\\${s}` : `\\${s}`
  );
}

function looseCompareArrays(a, b) {
  if (a.length !== b.length) return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b) return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray(a);
  bValidType = isArray(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject(a);
  bValidType = isObject(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}

const isRef = (val) => {
  return !!(val && val["__v_isRef"] === true);
};
const toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (isRef(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i) => {
          entries[stringifySymbol(key, i) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
    };
  } else if (isSymbol(val)) {
    return stringifySymbol(val);
  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v, i = "") => {
  var _a;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v
  );
};




/***/ }),

/***/ "./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-4.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/layout/DashboardLayout.vue?vue&type=style&index=0&id=4977e71c&scoped=true&lang=css":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-4.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/layout/DashboardLayout.vue?vue&type=style&index=0&id=4977e71c&scoped=true&lang=css ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/vue-loader/dist/exportHelper.js":
/*!******************************************************!*\
  !*** ./node_modules/vue-loader/dist/exportHelper.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
// runtime helper for setting properties on components
// in a tree-shakable way
exports["default"] = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
        target[key] = val;
    }
    return target;
};


/***/ }),

/***/ "./node_modules/vue/dist/vue.esm-bundler.js":
/*!**************************************************!*\
  !*** ./node_modules/vue/dist/vue.esm-bundler.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseTransition: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   BaseTransitionPropsValidators: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.BaseTransitionPropsValidators),
/* harmony export */   Comment: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   DeprecationTypes: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.DeprecationTypes),
/* harmony export */   EffectScope: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.EffectScope),
/* harmony export */   ErrorCodes: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ErrorCodes),
/* harmony export */   ErrorTypeStrings: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ErrorTypeStrings),
/* harmony export */   Fragment: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   KeepAlive: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   ReactiveEffect: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),
/* harmony export */   Static: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   Suspense: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   Teleport: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   Text: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   TrackOpTypes: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.TrackOpTypes),
/* harmony export */   Transition: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Transition),
/* harmony export */   TransitionGroup: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.TransitionGroup),
/* harmony export */   TriggerOpTypes: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.TriggerOpTypes),
/* harmony export */   VueElement: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.VueElement),
/* harmony export */   assertNumber: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.assertNumber),
/* harmony export */   callWithAsyncErrorHandling: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   callWithErrorHandling: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   camelize: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   capitalize: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   cloneVNode: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   compatUtils: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.compatUtils),
/* harmony export */   compile: () => (/* binding */ compileToFunction),
/* harmony export */   computed: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   createApp: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createApp),
/* harmony export */   createBlock: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   createCommentVNode: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   createElementBlock: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createElementBlock),
/* harmony export */   createElementVNode: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createElementVNode),
/* harmony export */   createHydrationRenderer: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   createPropsRestProxy: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy),
/* harmony export */   createRenderer: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   createSSRApp: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSSRApp),
/* harmony export */   createSlots: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   createStaticVNode: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   createTextVNode: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   createVNode: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   customRef: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   defineAsyncComponent: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   defineComponent: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   defineCustomElement: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineCustomElement),
/* harmony export */   defineEmits: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineEmits),
/* harmony export */   defineExpose: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineExpose),
/* harmony export */   defineModel: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineModel),
/* harmony export */   defineOptions: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineOptions),
/* harmony export */   defineProps: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   defineSSRCustomElement: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineSSRCustomElement),
/* harmony export */   defineSlots: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineSlots),
/* harmony export */   devtools: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   effect: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   effectScope: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.effectScope),
/* harmony export */   getCurrentInstance: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   getCurrentScope: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),
/* harmony export */   getCurrentWatcher: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentWatcher),
/* harmony export */   getTransitionRawChildren: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   guardReactiveProps: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps),
/* harmony export */   h: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   handleError: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   hasInjectionContext: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hasInjectionContext),
/* harmony export */   hydrate: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hydrate),
/* harmony export */   hydrateOnIdle: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hydrateOnIdle),
/* harmony export */   hydrateOnInteraction: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hydrateOnInteraction),
/* harmony export */   hydrateOnMediaQuery: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hydrateOnMediaQuery),
/* harmony export */   hydrateOnVisible: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hydrateOnVisible),
/* harmony export */   initCustomFormatter: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   initDirectivesForSSR: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initDirectivesForSSR),
/* harmony export */   inject: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   isMemoSame: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isMemoSame),
/* harmony export */   isProxy: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   isReactive: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   isReadonly: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   isRef: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   isRuntimeOnly: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   isShallow: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isShallow),
/* harmony export */   isVNode: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   markRaw: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   mergeDefaults: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults),
/* harmony export */   mergeModels: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeModels),
/* harmony export */   mergeProps: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   nextTick: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   normalizeClass: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeClass),
/* harmony export */   normalizeProps: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeProps),
/* harmony export */   normalizeStyle: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle),
/* harmony export */   onActivated: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   onBeforeMount: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   onBeforeUnmount: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   onBeforeUpdate: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   onDeactivated: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   onErrorCaptured: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   onMounted: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   onRenderTracked: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   onRenderTriggered: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   onScopeDispose: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),
/* harmony export */   onServerPrefetch: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),
/* harmony export */   onUnmounted: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   onUpdated: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   onWatcherCleanup: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onWatcherCleanup),
/* harmony export */   openBlock: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   popScopeId: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   provide: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   proxyRefs: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   pushScopeId: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   queuePostFlushCb: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   reactive: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   readonly: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   ref: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   registerRuntimeCompiler: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   render: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   renderList: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   renderSlot: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   resolveComponent: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   resolveDirective: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   resolveDynamicComponent: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   resolveFilter: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),
/* harmony export */   resolveTransitionHooks: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   setBlockTracking: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   setDevtoolsHook: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   setTransitionHooks: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   shallowReactive: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   shallowReadonly: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   shallowRef: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   ssrContextKey: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   ssrUtils: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   stop: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.stop),
/* harmony export */   toDisplayString: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   toHandlerKey: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   toHandlers: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   toRaw: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   toRef: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   toRefs: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   toValue: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toValue),
/* harmony export */   transformVNodeArgs: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   triggerRef: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   unref: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   useAttrs: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useAttrs),
/* harmony export */   useCssModule: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssModule),
/* harmony export */   useCssVars: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssVars),
/* harmony export */   useHost: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useHost),
/* harmony export */   useId: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useId),
/* harmony export */   useModel: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useModel),
/* harmony export */   useSSRContext: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   useShadowRoot: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useShadowRoot),
/* harmony export */   useSlots: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSlots),
/* harmony export */   useTemplateRef: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useTemplateRef),
/* harmony export */   useTransitionState: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   vModelCheckbox: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelCheckbox),
/* harmony export */   vModelDynamic: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelDynamic),
/* harmony export */   vModelRadio: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelRadio),
/* harmony export */   vModelSelect: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelSelect),
/* harmony export */   vModelText: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelText),
/* harmony export */   vShow: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vShow),
/* harmony export */   version: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   warn: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   watch: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   watchEffect: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   watchPostEffect: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect),
/* harmony export */   watchSyncEffect: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect),
/* harmony export */   withAsyncContext: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext),
/* harmony export */   withCtx: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   withDefaults: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDefaults),
/* harmony export */   withDirectives: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   withKeys: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withKeys),
/* harmony export */   withMemo: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withMemo),
/* harmony export */   withModifiers: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withModifiers),
/* harmony export */   withScopeId: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withScopeId)
/* harmony export */ });
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-dom */ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js");
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/runtime-dom */ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js");
/* harmony import */ var _vue_compiler_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vue/compiler-dom */ "./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
/**
* vue v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/






function initDev() {
  {
    (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.initCustomFormatter)();
  }
}

if (true) {
  initDev();
}
const compileCache = /* @__PURE__ */ Object.create(null);
function compileToFunction(template, options) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isString)(template)) {
    if (template.nodeType) {
      template = template.innerHTML;
    } else {
       true && (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.warn)(`invalid template option: `, template);
      return _vue_shared__WEBPACK_IMPORTED_MODULE_2__.NOOP;
    }
  }
  const key = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.genCacheKey)(template, options);
  const cached = compileCache[key];
  if (cached) {
    return cached;
  }
  if (template[0] === "#") {
    const el = document.querySelector(template);
    if ( true && !el) {
      (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.warn)(`Template element not found or is empty: ${template}`);
    }
    template = el ? el.innerHTML : ``;
  }
  const opts = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)(
    {
      hoistStatic: true,
      onError:  true ? onError : 0,
      onWarn:  true ? (e) => onError(e, true) : 0
    },
    options
  );
  if (!opts.isCustomElement && typeof customElements !== "undefined") {
    opts.isCustomElement = (tag) => !!customElements.get(tag);
  }
  const { code } = (0,_vue_compiler_dom__WEBPACK_IMPORTED_MODULE_3__.compile)(template, opts);
  function onError(err, asWarning = false) {
    const message = asWarning ? err.message : `Template compilation error: ${err.message}`;
    const codeFrame = err.loc && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.generateCodeFrame)(
      template,
      err.loc.start.offset,
      err.loc.end.offset
    );
    (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.warn)(codeFrame ? `${message}
${codeFrame}` : message);
  }
  const render = new Function("Vue", code)(_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__);
  render._rc = true;
  return compileCache[key] = render;
}
(0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.registerRuntimeCompiler)(compileToFunction);




/***/ }),

/***/ "./src/components/App.vue":
/*!********************************!*\
  !*** ./src/components/App.vue ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _App_vue_vue_type_template_id_617ab0be__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App.vue?vue&type=template&id=617ab0be */ "./src/components/App.vue?vue&type=template&id=617ab0be");
/* harmony import */ var _App_vue_vue_type_script_setup_true_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./App.vue?vue&type=script&setup=true&lang=js */ "./src/components/App.vue?vue&type=script&setup=true&lang=js");
/* harmony import */ var _node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;
const __exports__ = /*#__PURE__*/(0,_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_App_vue_vue_type_script_setup_true_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_App_vue_vue_type_template_id_617ab0be__WEBPACK_IMPORTED_MODULE_0__.render],['__file',"src/components/App.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./src/components/App.vue?vue&type=script&setup=true&lang=js":
/*!*******************************************************************!*\
  !*** ./src/components/App.vue?vue&type=script&setup=true&lang=js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_symfony_webpack_encore_node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_App_vue_vue_type_script_setup_true_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _node_modules_symfony_webpack_encore_node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_App_vue_vue_type_script_setup_true_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/@symfony/webpack-encore/node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./App.vue?vue&type=script&setup=true&lang=js */ "./node_modules/@symfony/webpack-encore/node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/App.vue?vue&type=script&setup=true&lang=js");
 

/***/ }),

/***/ "./src/components/App.vue?vue&type=template&id=617ab0be":
/*!**************************************************************!*\
  !*** ./src/components/App.vue?vue&type=template&id=617ab0be ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* reexport safe */ _node_modules_symfony_webpack_encore_node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_App_vue_vue_type_template_id_617ab0be__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_symfony_webpack_encore_node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_App_vue_vue_type_template_id_617ab0be__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/@symfony/webpack-encore/node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./App.vue?vue&type=template&id=617ab0be */ "./node_modules/@symfony/webpack-encore/node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/App.vue?vue&type=template&id=617ab0be");


/***/ }),

/***/ "./src/layout/DashboardLayout.vue":
/*!****************************************!*\
  !*** ./src/layout/DashboardLayout.vue ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DashboardLayout_vue_vue_type_template_id_4977e71c_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DashboardLayout.vue?vue&type=template&id=4977e71c&scoped=true */ "./src/layout/DashboardLayout.vue?vue&type=template&id=4977e71c&scoped=true");
/* harmony import */ var _DashboardLayout_vue_vue_type_style_index_0_id_4977e71c_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DashboardLayout.vue?vue&type=style&index=0&id=4977e71c&scoped=true&lang=css */ "./src/layout/DashboardLayout.vue?vue&type=style&index=0&id=4977e71c&scoped=true&lang=css");
/* harmony import */ var _node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");

const script = {}

;


const __exports__ = /*#__PURE__*/(0,_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__["default"])(script, [['render',_DashboardLayout_vue_vue_type_template_id_4977e71c_scoped_true__WEBPACK_IMPORTED_MODULE_0__.render],['__scopeId',"data-v-4977e71c"],['__file',"src/layout/DashboardLayout.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./src/layout/DashboardLayout.vue?vue&type=style&index=0&id=4977e71c&scoped=true&lang=css":
/*!************************************************************************************************!*\
  !*** ./src/layout/DashboardLayout.vue?vue&type=style&index=0&id=4977e71c&scoped=true&lang=css ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_clonedRuleSet_4_use_0_node_modules_css_loader_dist_cjs_js_clonedRuleSet_4_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_DashboardLayout_vue_vue_type_style_index_0_id_4977e71c_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-4.use[0]!../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[1]!../../node_modules/vue-loader/dist/stylePostLoader.js!../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./DashboardLayout.vue?vue&type=style&index=0&id=4977e71c&scoped=true&lang=css */ "./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-4.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/layout/DashboardLayout.vue?vue&type=style&index=0&id=4977e71c&scoped=true&lang=css");


/***/ }),

/***/ "./src/layout/DashboardLayout.vue?vue&type=template&id=4977e71c&scoped=true":
/*!**********************************************************************************!*\
  !*** ./src/layout/DashboardLayout.vue?vue&type=template&id=4977e71c&scoped=true ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* reexport safe */ _node_modules_symfony_webpack_encore_node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_DashboardLayout_vue_vue_type_template_id_4977e71c_scoped_true__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_symfony_webpack_encore_node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_DashboardLayout_vue_vue_type_template_id_4977e71c_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/@symfony/webpack-encore/node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./DashboardLayout.vue?vue&type=template&id=4977e71c&scoped=true */ "./node_modules/@symfony/webpack-encore/node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/layout/DashboardLayout.vue?vue&type=template&id=4977e71c&scoped=true");


/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");
/* harmony import */ var _components_App_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/App.vue */ "./src/components/App.vue");


var app = (0,vue__WEBPACK_IMPORTED_MODULE_0__.createApp)(_components_App_vue__WEBPACK_IMPORTED_MODULE_1__["default"]);
app.mount('#vue-app');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ var __webpack_exports__ = (__webpack_exec__("./src/main.js"));
/******/ }
]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFVeUI7QUFDbUM7Ozs7OztJQUU1RCxJQUFNRSxPQUFPLEdBQUdGLHdDQUFHLENBQUMsS0FBSyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyREFaeEJHLGdEQUFBLENBSWtCQyxNQUFBO0lBTHBCLFdBQUFDLDRDQUFBLENBRUk7TUFBQSxPQUVJLENBRkpDLHVEQUFBLENBRUksY0FESkEsdURBQUEsQ0FBc0IsWUFBQUMsb0RBQUEsQ0FBZkgsTUFBQSxDQUFBRixPQUFPOztJQUhsQk0sQ0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQ0NTLFNBQU07QUFBWTs7RUFDZCxTQUFNO0FBQVM7O0VBRWYsU0FBTTtBQUFNOztFQXdDYixTQUFNO0FBQWdCOzs7OzJEQTNDOUJDLHVEQUFBLENBOENNLE9BOUNOQyxVQThDTSxHQTdDSkosdURBQUEsQ0F3Q1EsU0F4Q1JLLFVBd0NRLDZCQXZDTkwsdURBQUEsQ0FBdUM7SUFBbEMsU0FBTTtFQUFNLEdBQUMsaUJBQWUsc0JBQ2pDQSx1REFBQSxDQXFDTSxPQXJDTk0sVUFxQ00sR0FwQ0pDLGdEQUFBLENBS2NDLHNCQUFBO0lBTERDLEVBQUUsRUFBQyxHQUFHO0lBQUNDLEtBQUssRUFBTCxFQUFLO0lBQUMsY0FBWSxFQUFDOztJQUxqRCxXQUFBWCw0Q0FBQSxDQU1ZO01BQUEsT0FHTVksTUFBQSxRQUFBQSxNQUFBLE9BSE5YLHVEQUFBLENBR007UUFIRCxTQUFNO01BQVcsSUFDcEJBLHVEQUFBLENBQXVCO1FBQWxCWSxHQUFHLEVBQUMsRUFBRTtRQUFDQyxHQUFHLEVBQUM7VUFDaEJiLHVEQUFBLENBQWlCLGNBQVgsTUFBSTs7SUFSeEJFLENBQUE7TUFXVUssZ0RBQUEsQ0FLY0Msc0JBQUE7SUFMREMsRUFBRSxFQUFDLGdCQUFnQjtJQUFDLGNBQVksRUFBQzs7SUFYeEQsV0FBQVYsNENBQUEsQ0FZWTtNQUFBLE9BR01ZLE1BQUEsUUFBQUEsTUFBQSxPQUhOWCx1REFBQSxDQUdNO1FBSEQsU0FBTTtNQUFXLElBQ3BCQSx1REFBQSxDQUFnQztRQUEzQlksR0FBRyxFQUFDLEVBQUU7UUFBQ0MsR0FBRyxFQUFDO1VBQ2hCYix1REFBQSxDQUEwQixjQUFwQixlQUFhOztJQWRqQ0UsQ0FBQTtNQWlCVUssZ0RBQUEsQ0FLY0Msc0JBQUE7SUFMREMsRUFBRSxFQUFDLGdCQUFnQjtJQUFDLGNBQVksRUFBQzs7SUFqQnhELFdBQUFWLDRDQUFBLENBa0JZO01BQUEsT0FHTVksTUFBQSxRQUFBQSxNQUFBLE9BSE5YLHVEQUFBLENBR007UUFIRCxTQUFNO01BQVcsSUFDcEJBLHVEQUFBLENBQWdDO1FBQTNCWSxHQUFHLEVBQUMsRUFBRTtRQUFDQyxHQUFHLEVBQUM7VUFDaEJiLHVEQUFBLENBQTBCLGNBQXBCLGVBQWE7O0lBcEJqQ0UsQ0FBQTtNQXVCVUssZ0RBQUEsQ0FLY0Msc0JBQUE7SUFMREMsRUFBRSxFQUFDLFdBQVc7SUFBQyxjQUFZLEVBQUM7O0lBdkJuRCxXQUFBViw0Q0FBQSxDQXdCWTtNQUFBLE9BR01ZLE1BQUEsUUFBQUEsTUFBQSxPQUhOWCx1REFBQSxDQUdNO1FBSEQsU0FBTTtNQUFXLElBQ3BCQSx1REFBQSxDQUEyQjtRQUF0QlksR0FBRyxFQUFDLEVBQUU7UUFBQ0MsR0FBRyxFQUFDO1VBQ2hCYix1REFBQSxDQUFxQixjQUFmLFVBQVE7O0lBMUI1QkUsQ0FBQTtNQTZCVUssZ0RBQUEsQ0FLY0Msc0JBQUE7SUFMREMsRUFBRSxFQUFDLFlBQVk7SUFBQyxjQUFZLEVBQUM7O0lBN0JwRCxXQUFBViw0Q0FBQSxDQThCWTtNQUFBLE9BR01ZLE1BQUEsUUFBQUEsTUFBQSxPQUhOWCx1REFBQSxDQUdNO1FBSEQsU0FBTTtNQUFXLElBQ3BCQSx1REFBQSxDQUE0QjtRQUF2QlksR0FBRyxFQUFDLEVBQUU7UUFBQ0MsR0FBRyxFQUFDO1VBQ2hCYix1REFBQSxDQUFzQixjQUFoQixXQUFTOztJQWhDN0JFLENBQUE7TUFtQ1VLLGdEQUFBLENBS2NDLHNCQUFBO0lBTERDLEVBQUUsRUFBQyxZQUFZO0lBQUMsY0FBWSxFQUFDOztJQW5DcEQsV0FBQVYsNENBQUEsQ0FvQ1k7TUFBQSxPQUdNWSxNQUFBLFFBQUFBLE1BQUEsT0FITlgsdURBQUEsQ0FHTTtRQUhELFNBQU07TUFBVyxJQUNwQkEsdURBQUEsQ0FBNEI7UUFBdkJZLEdBQUcsRUFBQyxFQUFFO1FBQUNDLEdBQUcsRUFBQztVQUNoQmIsdURBQUEsQ0FBc0IsY0FBaEIsV0FBUzs7SUF0QzdCRSxDQUFBO1VBNENNRix1REFBQSxDQUVPLFFBRlBjLFVBRU8sR0FETFAsZ0RBQUEsQ0FBMkJRLHNCQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0NuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzhNO0FBQzlKO0FBQ2hEO0FBQ0Esd0JBQXdCLEtBQXlDLGdCQUFnQixDQUFFO0FBQ25GLHdCQUF3QixLQUF5QyxnQkFBZ0IsQ0FBRTtBQUNuRix3QkFBd0IsS0FBeUMsZ0JBQWdCLENBQUU7QUFDbkYsMEJBQTBCLEtBQXlDLGlCQUFpQixDQUFFO0FBQ3RGO0FBQ0EsRUFBRSxLQUF5QyxzQkFBc0IsQ0FBRTtBQUNuRTtBQUNBLDBCQUEwQixLQUF5QyxpQkFBaUIsQ0FBRTtBQUN0Riw0QkFBNEIsS0FBeUMsbUJBQW1CLENBQUU7QUFDMUY7QUFDQSxFQUFFLEtBQXlDLDBCQUEwQixDQUFFO0FBQ3ZFO0FBQ0EsNEJBQTRCLEtBQXlDLG1CQUFtQixDQUFFO0FBQzFGO0FBQ0EsRUFBRSxLQUF5QywwQkFBMEIsQ0FBRTtBQUN2RTtBQUNBO0FBQ0EsRUFBRSxLQUF5QywwQkFBMEIsQ0FBRTtBQUN2RTtBQUNBO0FBQ0EsRUFBRSxLQUF5Qyx1QkFBdUIsQ0FBRTtBQUNwRTtBQUNBO0FBQ0EsRUFBRSxLQUF5Qyx5QkFBeUIsQ0FBRTtBQUN0RTtBQUNBO0FBQ0EsRUFBRSxLQUF5Qyx3QkFBd0IsQ0FBRTtBQUNyRTtBQUNBO0FBQ0EsRUFBRSxLQUF5QywrQkFBK0IsQ0FBRTtBQUM1RTtBQUNBO0FBQ0EsRUFBRSxLQUF5Qyx3QkFBd0IsQ0FBRTtBQUNyRTtBQUNBO0FBQ0EsRUFBRSxLQUF5QyxxQkFBcUIsQ0FBRTtBQUNsRTtBQUNBO0FBQ0EsRUFBRSxLQUF5QyxzQkFBc0IsQ0FBRTtBQUNuRTtBQUNBLDJCQUEyQixLQUF5QyxrQkFBa0IsQ0FBRTtBQUN4RiwyQkFBMkIsS0FBeUMsa0JBQWtCLENBQUU7QUFDeEYsNEJBQTRCLEtBQXlDLG1CQUFtQixDQUFFO0FBQzFGO0FBQ0EsRUFBRSxLQUF5Qyx1QkFBdUIsQ0FBRTtBQUNwRTtBQUNBLDJCQUEyQixLQUF5QyxrQkFBa0IsQ0FBRTtBQUN4RjtBQUNBLEVBQUUsS0FBeUMsc0JBQXNCLENBQUU7QUFDbkU7QUFDQTtBQUNBLEVBQUUsS0FBeUMsc0JBQXNCLENBQUU7QUFDbkU7QUFDQTtBQUNBLEVBQUUsS0FBeUMsc0JBQXNCLENBQUU7QUFDbkU7QUFDQTtBQUNBLEVBQUUsS0FBeUMsMEJBQTBCLENBQUU7QUFDdkU7QUFDQSwyQkFBMkIsS0FBeUMsa0JBQWtCLENBQUU7QUFDeEYsd0JBQXdCLEtBQXlDLGdCQUFnQixDQUFFO0FBQ25GLDBCQUEwQixLQUF5QyxrQkFBa0IsQ0FBRTtBQUN2RjtBQUNBLEVBQUUsS0FBeUMsb0JBQW9CLENBQUU7QUFDakU7QUFDQTtBQUNBLEVBQUUsS0FBeUMsd0JBQXdCLENBQUU7QUFDckU7QUFDQSw2QkFBNkIsS0FBeUMsbUJBQW1CLENBQUU7QUFDM0YsNEJBQTRCLEtBQXlDLGtCQUFrQixDQUFFO0FBQ3pGLHdCQUF3QixLQUF5QyxlQUFlLENBQUU7QUFDbEYscUJBQXFCLEtBQXlDLGFBQWEsQ0FBRTtBQUM3RSxzQkFBc0IsS0FBeUMsYUFBYSxDQUFFO0FBQzlFLHlCQUF5QixLQUF5QyxnQkFBZ0IsQ0FBRTtBQUNwRiw0QkFBNEIsS0FBeUMsa0JBQWtCLENBQUU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtCQUErQjtBQUMxQyxTQUFTLCtCQUErQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFEQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxREFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNkJBQTZCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLFVBQVUsSUFBa0Q7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxXQUFXLEtBQWtEO0FBQzdEO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFdBQVcsS0FBa0Q7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxVQUFVLEtBQWtEO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsVUFBVSxJQUFrRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxVQUFVLEtBQWtEO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTSx3UkFBd1I7QUFDOVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUhBQWlILElBQUkseUNBQXlDLElBQUk7QUFDbEs7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixjQUFjO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBeUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUIsOEJBQThCLElBQUksSUFBSSwyREFBMkQsRUFBRTtBQUNuRyxhQUFhLEtBQUssT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsS0FBeUMsK0JBQStCLFlBQVk7QUFDdEY7QUFDQTtBQUNBLGNBQWMsS0FBa0QsbUVBQW1FLENBQXFEO0FBQ3hMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FB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O0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxTQUFTLEtBQWtEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw4QkFBOEIsZUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1EQUFNLEdBQUc7QUFDakMsTUFBTTtBQUNOLHdCQUF3QixtREFBTSxHQUFHO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXlDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXlDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsWUFBWTtBQUMxQztBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1EQUFNLEdBQUc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNENBQTRDO0FBQ3RELFVBQVUsNEJBQTRCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQWlEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEMsY0FBYyxvQ0FBb0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVDQUF1QztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsS0FBeUMsVUFBVSxzREFBYSxZQUFZLE1BQU0sQ0FBRTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0EsMkVBQTJFLElBQUk7QUFDL0UsK0JBQStCLHFEQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUF5QztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLE1BQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUNBQWlDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsWUFBWTtBQUMxQztBQUNBO0FBQ0EsNkJBQTZCLGlEQUFJO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTywyREFBYztBQUNyQjtBQUNBO0FBQ0EsNEJBQTRCLDJEQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGNBQWMsaUNBQWlDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVMsd0JBQXdCLG1CQUFtQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxLQUF5QyxnREFBZ0QsQ0FBRTtBQUNoRztBQUNBO0FBQ0EsU0FBUyxzRUFBc0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxTQUFTLCtEQUFXO0FBQ3BCO0FBQ0EsSUFBSSxtREFBTSxHQUFHO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtREFBTTtBQUNqQyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxTQUFTLDZEQUFTLFdBQVcsbURBQU0sR0FBRztBQUN0QztBQUNBO0FBQ3dUOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlxQnhUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMk07QUFDM007QUFDQTtBQUNBLDZCQUE2QixJQUFJO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNLFNBQVMsSUFBeUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFNBQVMsS0FBeUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sVUFBVSxLQUF5QztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1REFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0JBQXdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXlDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0RBQUs7QUFDckI7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0RBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0RBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx5QkFBeUIsb0RBQU87QUFDaEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHlEQUF5RDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxL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SUFBSSxLQUFVLEVBQUUsRUFZZjs7O0FBR0QsaUVBQWU7Ozs7Ozs7Ozs7Ozs7OztBQ3RCbU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FFQTFKO0FBQ3hGOztBQUVBLENBQXNGOztBQUVOO0FBQ2hGLGlDQUFpQyx5RkFBZSxvQkFBb0Isa0dBQU07QUFDMUU7QUFDQSxJQUFJLEtBQVUsRUFBRSxFQVlmOzs7QUFHRCxpRUFBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBR3ZCZ0I7QUFDTztBQUV0QyxJQUFNRyxHQUFHLEdBQUdGLDhDQUFTLENBQUNDLDJEQUFHLENBQUM7QUFDMUJDLEdBQUcsQ0FBQ0MsS0FBSyxDQUFDLFVBQVUsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL251c2VyeS1tYW4tZnJvbnRlbmQvLi9zcmMvY29tcG9uZW50cy9BcHAudnVlIiwid2VicGFjazovL251c2VyeS1tYW4tZnJvbnRlbmQvLi9zcmMvbGF5b3V0L0Rhc2hib2FyZExheW91dC52dWUiLCJ3ZWJwYWNrOi8vbnVzZXJ5LW1hbi1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdnVlL2NvbXBpbGVyLWNvcmUvZGlzdC9jb21waWxlci1jb3JlLmVzbS1idW5kbGVyLmpzIiwid2VicGFjazovL251c2VyeS1tYW4tZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZ1ZS9jb21waWxlci1kb20vZGlzdC9jb21waWxlci1kb20uZXNtLWJ1bmRsZXIuanMiLCJ3ZWJwYWNrOi8vbnVzZXJ5LW1hbi1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdnVlL3JlYWN0aXZpdHkvZGlzdC9yZWFjdGl2aXR5LmVzbS1idW5kbGVyLmpzIiwid2VicGFjazovL251c2VyeS1tYW4tZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZ1ZS9ydW50aW1lLWNvcmUvZGlzdC9ydW50aW1lLWNvcmUuZXNtLWJ1bmRsZXIuanMiLCJ3ZWJwYWNrOi8vbnVzZXJ5LW1hbi1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtZG9tL2Rpc3QvcnVudGltZS1kb20uZXNtLWJ1bmRsZXIuanMiLCJ3ZWJwYWNrOi8vbnVzZXJ5LW1hbi1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdnVlL3NoYXJlZC9kaXN0L3NoYXJlZC5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly9udXNlcnktbWFuLWZyb250ZW5kLy4vc3JjL2xheW91dC9EYXNoYm9hcmRMYXlvdXQudnVlP2U2NWYiLCJ3ZWJwYWNrOi8vbnVzZXJ5LW1hbi1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvZXhwb3J0SGVscGVyLmpzIiwid2VicGFjazovL251c2VyeS1tYW4tZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS1idW5kbGVyLmpzIiwid2VicGFjazovL251c2VyeS1tYW4tZnJvbnRlbmQvLi9zcmMvY29tcG9uZW50cy9BcHAudnVlP2Y2NDciLCJ3ZWJwYWNrOi8vbnVzZXJ5LW1hbi1mcm9udGVuZC8uL3NyYy9jb21wb25lbnRzL0FwcC52dWU/ZmJlYyIsIndlYnBhY2s6Ly9udXNlcnktbWFuLWZyb250ZW5kLy4vc3JjL2NvbXBvbmVudHMvQXBwLnZ1ZT9mMjhiIiwid2VicGFjazovL251c2VyeS1tYW4tZnJvbnRlbmQvLi9zcmMvbGF5b3V0L0Rhc2hib2FyZExheW91dC52dWU/MmYwZiIsIndlYnBhY2s6Ly9udXNlcnktbWFuLWZyb250ZW5kLy4vc3JjL2xheW91dC9EYXNoYm9hcmRMYXlvdXQudnVlP2U2YWYiLCJ3ZWJwYWNrOi8vbnVzZXJ5LW1hbi1mcm9udGVuZC8uL3NyYy9sYXlvdXQvRGFzaGJvYXJkTGF5b3V0LnZ1ZT9mMzZmIiwid2VicGFjazovL251c2VyeS1tYW4tZnJvbnRlbmQvLi9zcmMvbWFpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XHJcbiAgPERhc2hib2FyZExheW91dD5cclxuICAgIDxkaXY+XHJcbiAgICA8aDE+e3sgbWVzc2FnZSB9fTwvaDE+XHJcbiAgPC9kaXY+XHJcbiAgPC9EYXNoYm9hcmRMYXlvdXQ+XHJcblxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdCBzZXR1cD5cclxuaW1wb3J0IHsgcmVmIH0gZnJvbSAndnVlJ1xyXG5pbXBvcnQgIERhc2hib2FyZExheW91dCBmcm9tICcuLi9sYXlvdXQvRGFzaGJvYXJkTGF5b3V0LnZ1ZSdcclxuXHJcbmNvbnN0IG1lc3NhZ2UgPSByZWYoJ0hvbycpXHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlPlxyXG5cclxuPC9zdHlsZT4iLCI8dGVtcGxhdGU+XHJcbiAgICA8ZGl2IGNsYXNzPVwiYXBwLWxheW91dFwiPlxyXG4gICAgICA8YXNpZGUgY2xhc3M9XCJzaWRlYmFyXCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImxvZ29cIj5OdXJzZXJ5IE1hbmFnZXI8L2Rpdj5cclxuICAgICAgICA8bmF2IGNsYXNzPVwibWVudVwiPlxyXG4gICAgICAgICAgPHJvdXRlci1saW5rIHRvPVwiL1wiIGV4YWN0IGFjdGl2ZS1jbGFzcz1cImFjdGl2ZVwiPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwibWVudS1pdGVtXCI+XHJcbiAgICAgICAgICAgICAgPGltZyBzcmM9XCJcIiBhbHQ9XCJIb21lXCI+XHJcbiAgICAgICAgICAgICAgPHNwYW4+SG9tZTwvc3Bhbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8L3JvdXRlci1saW5rPlxyXG4gICAgICAgICAgPHJvdXRlci1saW5rIHRvPVwiL2VzcGFjZS1lbmZhbnRcIiBhY3RpdmUtY2xhc3M9XCJhY3RpdmVcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1lbnUtaXRlbVwiPlxyXG4gICAgICAgICAgICAgIDxpbWcgc3JjPVwiXCIgYWx0PVwiRXNwYWNlIGVuZmFudFwiPlxyXG4gICAgICAgICAgICAgIDxzcGFuPkVzcGFjZSBlbmZhbnQ8L3NwYW4+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPC9yb3V0ZXItbGluaz5cclxuICAgICAgICAgIDxyb3V0ZXItbGluayB0bz1cIi9lc3BhY2UtcGFyZW50XCIgYWN0aXZlLWNsYXNzPVwiYWN0aXZlXCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtZW51LWl0ZW1cIj5cclxuICAgICAgICAgICAgICA8aW1nIHNyYz1cIlwiIGFsdD1cIkVzcGFjZSBwYXJlbnRcIj5cclxuICAgICAgICAgICAgICA8c3Bhbj5Fc3BhY2UgcGFyZW50PC9zcGFuPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIDwvcm91dGVyLWxpbms+XHJcbiAgICAgICAgICA8cm91dGVyLWxpbmsgdG89XCIvcGxhbm5pbmdcIiBhY3RpdmUtY2xhc3M9XCJhY3RpdmVcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1lbnUtaXRlbVwiPlxyXG4gICAgICAgICAgICAgIDxpbWcgc3JjPVwiXCIgYWx0PVwiUGxhbm5pbmdcIj5cclxuICAgICAgICAgICAgICA8c3Bhbj5QbGFubmluZzwvc3Bhbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8L3JvdXRlci1saW5rPlxyXG4gICAgICAgICAgPHJvdXRlci1saW5rIHRvPVwiL3BlcnNvbm5lbFwiIGFjdGl2ZS1jbGFzcz1cImFjdGl2ZVwiPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwibWVudS1pdGVtXCI+XHJcbiAgICAgICAgICAgICAgPGltZyBzcmM9XCJcIiBhbHQ9XCJQZXJzb25uZWxcIj5cclxuICAgICAgICAgICAgICA8c3Bhbj5QZXJzb25uZWw8L3NwYW4+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPC9yb3V0ZXItbGluaz5cclxuICAgICAgICAgIDxyb3V0ZXItbGluayB0bz1cIi9wYXJhbWV0cmVcIiBhY3RpdmUtY2xhc3M9XCJhY3RpdmVcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1lbnUtaXRlbVwiPlxyXG4gICAgICAgICAgICAgIDxpbWcgc3JjPVwiXCIgYWx0PVwiUGFyYW3DqHRyZVwiPlxyXG4gICAgICAgICAgICAgIDxzcGFuPlBhcmFtw6h0cmU8L3NwYW4+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPC9yb3V0ZXItbGluaz5cclxuICAgICAgICA8L25hdj5cclxuICAgICAgPC9hc2lkZT5cclxuICBcclxuICAgICAgPG1haW4gY2xhc3M9XCJtYWluLWNvbnRhaW5lclwiPlxyXG4gICAgICAgIDxyb3V0ZXItdmlldz48L3JvdXRlci12aWV3PlxyXG4gICAgICA8L21haW4+XHJcbiAgICA8L2Rpdj5cclxuICA8L3RlbXBsYXRlPlxyXG4gIFxyXG4gIDxzY3JpcHQgc2V0dXA+XHJcblxyXG4gIDwvc2NyaXB0PlxyXG4gIFxyXG4gIDxzdHlsZSBzY29wZWQ+XHJcbiAgLmFwcC1sYXlvdXQge1xyXG4gICAgZGlzcGxheTogZmxleDtcclxuICAgIGhlaWdodDogMTAwdmg7XHJcbiAgfVxyXG4gIFxyXG4gIC5zaWRlYmFyIHtcclxuICAgIGJhY2tncm91bmQtY29sb3I6ICMyMjI7IC8qIENvdWxldXIgZGUgZm9uZCBkZSBsYSBzaWRlYmFyICovXHJcbiAgICBjb2xvcjogI2VlZTtcclxuICAgIHdpZHRoOiAyNTBweDtcclxuICAgIHBhZGRpbmc6IDIwcHg7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuICB9XHJcbiAgXHJcbiAgLmxvZ28ge1xyXG4gICAgZm9udC1zaXplOiAxLjVlbTtcclxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xyXG4gICAgbWFyZ2luLWJvdHRvbTogMzBweDtcclxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcclxuICB9XHJcbiAgXHJcbiAgLm1lbnUge1xyXG4gICAgZmxleC1ncm93OiAxO1xyXG4gIH1cclxuICBcclxuICAubWVudS1pdGVtIHtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gICAgcGFkZGluZzogMTBweDtcclxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcclxuICAgIGNvbG9yOiAjZWVlO1xyXG4gICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjNzIGVhc2U7XHJcbiAgICBib3JkZXItcmFkaXVzOiA1cHg7XHJcbiAgICBtYXJnaW4tYm90dG9tOiA1cHg7XHJcbiAgfVxyXG4gIFxyXG4gIC5tZW51LWl0ZW0gaW1nIHtcclxuICAgIHdpZHRoOiAyMHB4O1xyXG4gICAgaGVpZ2h0OiAyMHB4O1xyXG4gICAgbWFyZ2luLXJpZ2h0OiAxMHB4O1xyXG4gICAgZmlsdGVyOiBpbnZlcnQoMSk7IC8qIEludmVyc2VyIGxhIGNvdWxldXIgcG91ciBxdWUgbGVzIGljw7RuZXMgc29pZW50IGJsYW5jaGVzICovXHJcbiAgfVxyXG4gIFxyXG4gIC5tZW51LWl0ZW0gc3BhbiB7XHJcbiAgICBmbGV4LWdyb3c6IDE7XHJcbiAgfVxyXG4gIFxyXG4gIC5tZW51LWl0ZW0uYWN0aXZlLFxyXG4gIC5tZW51LWl0ZW06aG92ZXIge1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzMzMztcclxuICB9XHJcbiAgXHJcbiAgLm1haW4tY29udGFpbmVyIHtcclxuICAgIGZsZXgtZ3JvdzogMTtcclxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmNGY0ZjQ7IC8qIENvdWxldXIgZGUgZm9uZCBkdSBjb250ZW5ldXIgcHJpbmNpcGFsIChmYWN1bHRhdGlmKSAqL1xyXG4gICAgcGFkZGluZzogMjBweDsgLyogQWpvdXQgZGUgcGFkZGluZyBwb3VyIGxlIGNvbnRlbnUgcHJpbmNpcGFsICovXHJcbiAgfVxyXG4gIDwvc3R5bGU+IiwiLyoqXHJcbiogQHZ1ZS9jb21waWxlci1jb3JlIHYzLjUuMTNcclxuKiAoYykgMjAxOC1wcmVzZW50IFl1eGkgKEV2YW4pIFlvdSBhbmQgVnVlIGNvbnRyaWJ1dG9yc1xyXG4qIEBsaWNlbnNlIE1JVFxyXG4qKi9cclxuaW1wb3J0IHsgaXNTdHJpbmcsIE5PT1AsIGlzT2JqZWN0LCBOTywgZXh0ZW5kLCBpc1N5bWJvbCwgaXNBcnJheSwgY2FwaXRhbGl6ZSwgY2FtZWxpemUsIEVNUFRZX09CSiwgUGF0Y2hGbGFnTmFtZXMsIHNsb3RGbGFnc1RleHQsIGlzT24sIGlzQnVpbHRJbkRpcmVjdGl2ZSwgaXNSZXNlcnZlZFByb3AsIHRvSGFuZGxlcktleSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcclxuZXhwb3J0IHsgZ2VuZXJhdGVDb2RlRnJhbWUgfSBmcm9tICdAdnVlL3NoYXJlZCc7XHJcblxyXG5jb25zdCBGUkFHTUVOVCA9IFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYEZyYWdtZW50YCA6IGBgKTtcclxuY29uc3QgVEVMRVBPUlQgPSBTeW1ib2woISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGBUZWxlcG9ydGAgOiBgYCk7XHJcbmNvbnN0IFNVU1BFTlNFID0gU3ltYm9sKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgU3VzcGVuc2VgIDogYGApO1xyXG5jb25zdCBLRUVQX0FMSVZFID0gU3ltYm9sKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgS2VlcEFsaXZlYCA6IGBgKTtcclxuY29uc3QgQkFTRV9UUkFOU0lUSU9OID0gU3ltYm9sKFxyXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgQmFzZVRyYW5zaXRpb25gIDogYGBcclxuKTtcclxuY29uc3QgT1BFTl9CTE9DSyA9IFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYG9wZW5CbG9ja2AgOiBgYCk7XHJcbmNvbnN0IENSRUFURV9CTE9DSyA9IFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYGNyZWF0ZUJsb2NrYCA6IGBgKTtcclxuY29uc3QgQ1JFQVRFX0VMRU1FTlRfQkxPQ0sgPSBTeW1ib2woXHJcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGBjcmVhdGVFbGVtZW50QmxvY2tgIDogYGBcclxuKTtcclxuY29uc3QgQ1JFQVRFX1ZOT0RFID0gU3ltYm9sKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgY3JlYXRlVk5vZGVgIDogYGApO1xyXG5jb25zdCBDUkVBVEVfRUxFTUVOVF9WTk9ERSA9IFN5bWJvbChcclxuICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYGNyZWF0ZUVsZW1lbnRWTm9kZWAgOiBgYFxyXG4pO1xyXG5jb25zdCBDUkVBVEVfQ09NTUVOVCA9IFN5bWJvbChcclxuICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYGNyZWF0ZUNvbW1lbnRWTm9kZWAgOiBgYFxyXG4pO1xyXG5jb25zdCBDUkVBVEVfVEVYVCA9IFN5bWJvbChcclxuICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYGNyZWF0ZVRleHRWTm9kZWAgOiBgYFxyXG4pO1xyXG5jb25zdCBDUkVBVEVfU1RBVElDID0gU3ltYm9sKFxyXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgY3JlYXRlU3RhdGljVk5vZGVgIDogYGBcclxuKTtcclxuY29uc3QgUkVTT0xWRV9DT01QT05FTlQgPSBTeW1ib2woXHJcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGByZXNvbHZlQ29tcG9uZW50YCA6IGBgXHJcbik7XHJcbmNvbnN0IFJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQgPSBTeW1ib2woXHJcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGByZXNvbHZlRHluYW1pY0NvbXBvbmVudGAgOiBgYFxyXG4pO1xyXG5jb25zdCBSRVNPTFZFX0RJUkVDVElWRSA9IFN5bWJvbChcclxuICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYHJlc29sdmVEaXJlY3RpdmVgIDogYGBcclxuKTtcclxuY29uc3QgUkVTT0xWRV9GSUxURVIgPSBTeW1ib2woXHJcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGByZXNvbHZlRmlsdGVyYCA6IGBgXHJcbik7XHJcbmNvbnN0IFdJVEhfRElSRUNUSVZFUyA9IFN5bWJvbChcclxuICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYHdpdGhEaXJlY3RpdmVzYCA6IGBgXHJcbik7XHJcbmNvbnN0IFJFTkRFUl9MSVNUID0gU3ltYm9sKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgcmVuZGVyTGlzdGAgOiBgYCk7XHJcbmNvbnN0IFJFTkRFUl9TTE9UID0gU3ltYm9sKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgcmVuZGVyU2xvdGAgOiBgYCk7XHJcbmNvbnN0IENSRUFURV9TTE9UUyA9IFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYGNyZWF0ZVNsb3RzYCA6IGBgKTtcclxuY29uc3QgVE9fRElTUExBWV9TVFJJTkcgPSBTeW1ib2woXHJcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGB0b0Rpc3BsYXlTdHJpbmdgIDogYGBcclxuKTtcclxuY29uc3QgTUVSR0VfUFJPUFMgPSBTeW1ib2woISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGBtZXJnZVByb3BzYCA6IGBgKTtcclxuY29uc3QgTk9STUFMSVpFX0NMQVNTID0gU3ltYm9sKFxyXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgbm9ybWFsaXplQ2xhc3NgIDogYGBcclxuKTtcclxuY29uc3QgTk9STUFMSVpFX1NUWUxFID0gU3ltYm9sKFxyXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgbm9ybWFsaXplU3R5bGVgIDogYGBcclxuKTtcclxuY29uc3QgTk9STUFMSVpFX1BST1BTID0gU3ltYm9sKFxyXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgbm9ybWFsaXplUHJvcHNgIDogYGBcclxuKTtcclxuY29uc3QgR1VBUkRfUkVBQ1RJVkVfUFJPUFMgPSBTeW1ib2woXHJcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGBndWFyZFJlYWN0aXZlUHJvcHNgIDogYGBcclxuKTtcclxuY29uc3QgVE9fSEFORExFUlMgPSBTeW1ib2woISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGB0b0hhbmRsZXJzYCA6IGBgKTtcclxuY29uc3QgQ0FNRUxJWkUgPSBTeW1ib2woISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGBjYW1lbGl6ZWAgOiBgYCk7XHJcbmNvbnN0IENBUElUQUxJWkUgPSBTeW1ib2woISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGBjYXBpdGFsaXplYCA6IGBgKTtcclxuY29uc3QgVE9fSEFORExFUl9LRVkgPSBTeW1ib2woXHJcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGB0b0hhbmRsZXJLZXlgIDogYGBcclxuKTtcclxuY29uc3QgU0VUX0JMT0NLX1RSQUNLSU5HID0gU3ltYm9sKFxyXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgc2V0QmxvY2tUcmFja2luZ2AgOiBgYFxyXG4pO1xyXG5jb25zdCBQVVNIX1NDT1BFX0lEID0gU3ltYm9sKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgcHVzaFNjb3BlSWRgIDogYGApO1xyXG5jb25zdCBQT1BfU0NPUEVfSUQgPSBTeW1ib2woISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGBwb3BTY29wZUlkYCA6IGBgKTtcclxuY29uc3QgV0lUSF9DVFggPSBTeW1ib2woISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGB3aXRoQ3R4YCA6IGBgKTtcclxuY29uc3QgVU5SRUYgPSBTeW1ib2woISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGB1bnJlZmAgOiBgYCk7XHJcbmNvbnN0IElTX1JFRiA9IFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYGlzUmVmYCA6IGBgKTtcclxuY29uc3QgV0lUSF9NRU1PID0gU3ltYm9sKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgd2l0aE1lbW9gIDogYGApO1xyXG5jb25zdCBJU19NRU1PX1NBTUUgPSBTeW1ib2woISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGBpc01lbW9TYW1lYCA6IGBgKTtcclxuY29uc3QgaGVscGVyTmFtZU1hcCA9IHtcclxuICBbRlJBR01FTlRdOiBgRnJhZ21lbnRgLFxyXG4gIFtURUxFUE9SVF06IGBUZWxlcG9ydGAsXHJcbiAgW1NVU1BFTlNFXTogYFN1c3BlbnNlYCxcclxuICBbS0VFUF9BTElWRV06IGBLZWVwQWxpdmVgLFxyXG4gIFtCQVNFX1RSQU5TSVRJT05dOiBgQmFzZVRyYW5zaXRpb25gLFxyXG4gIFtPUEVOX0JMT0NLXTogYG9wZW5CbG9ja2AsXHJcbiAgW0NSRUFURV9CTE9DS106IGBjcmVhdGVCbG9ja2AsXHJcbiAgW0NSRUFURV9FTEVNRU5UX0JMT0NLXTogYGNyZWF0ZUVsZW1lbnRCbG9ja2AsXHJcbiAgW0NSRUFURV9WTk9ERV06IGBjcmVhdGVWTm9kZWAsXHJcbiAgW0NSRUFURV9FTEVNRU5UX1ZOT0RFXTogYGNyZWF0ZUVsZW1lbnRWTm9kZWAsXHJcbiAgW0NSRUFURV9DT01NRU5UXTogYGNyZWF0ZUNvbW1lbnRWTm9kZWAsXHJcbiAgW0NSRUFURV9URVhUXTogYGNyZWF0ZVRleHRWTm9kZWAsXHJcbiAgW0NSRUFURV9TVEFUSUNdOiBgY3JlYXRlU3RhdGljVk5vZGVgLFxyXG4gIFtSRVNPTFZFX0NPTVBPTkVOVF06IGByZXNvbHZlQ29tcG9uZW50YCxcclxuICBbUkVTT0xWRV9EWU5BTUlDX0NPTVBPTkVOVF06IGByZXNvbHZlRHluYW1pY0NvbXBvbmVudGAsXHJcbiAgW1JFU09MVkVfRElSRUNUSVZFXTogYHJlc29sdmVEaXJlY3RpdmVgLFxyXG4gIFtSRVNPTFZFX0ZJTFRFUl06IGByZXNvbHZlRmlsdGVyYCxcclxuICBbV0lUSF9ESVJFQ1RJVkVTXTogYHdpdGhEaXJlY3RpdmVzYCxcclxuICBbUkVOREVSX0xJU1RdOiBgcmVuZGVyTGlzdGAsXHJcbiAgW1JFTkRFUl9TTE9UXTogYHJlbmRlclNsb3RgLFxyXG4gIFtDUkVBVEVfU0xPVFNdOiBgY3JlYXRlU2xvdHNgLFxyXG4gIFtUT19ESVNQTEFZX1NUUklOR106IGB0b0Rpc3BsYXlTdHJpbmdgLFxyXG4gIFtNRVJHRV9QUk9QU106IGBtZXJnZVByb3BzYCxcclxuICBbTk9STUFMSVpFX0NMQVNTXTogYG5vcm1hbGl6ZUNsYXNzYCxcclxuICBbTk9STUFMSVpFX1NUWUxFXTogYG5vcm1hbGl6ZVN0eWxlYCxcclxuICBbTk9STUFMSVpFX1BST1BTXTogYG5vcm1hbGl6ZVByb3BzYCxcclxuICBbR1VBUkRfUkVBQ1RJVkVfUFJPUFNdOiBgZ3VhcmRSZWFjdGl2ZVByb3BzYCxcclxuICBbVE9fSEFORExFUlNdOiBgdG9IYW5kbGVyc2AsXHJcbiAgW0NBTUVMSVpFXTogYGNhbWVsaXplYCxcclxuICBbQ0FQSVRBTElaRV06IGBjYXBpdGFsaXplYCxcclxuICBbVE9fSEFORExFUl9LRVldOiBgdG9IYW5kbGVyS2V5YCxcclxuICBbU0VUX0JMT0NLX1RSQUNLSU5HXTogYHNldEJsb2NrVHJhY2tpbmdgLFxyXG4gIFtQVVNIX1NDT1BFX0lEXTogYHB1c2hTY29wZUlkYCxcclxuICBbUE9QX1NDT1BFX0lEXTogYHBvcFNjb3BlSWRgLFxyXG4gIFtXSVRIX0NUWF06IGB3aXRoQ3R4YCxcclxuICBbVU5SRUZdOiBgdW5yZWZgLFxyXG4gIFtJU19SRUZdOiBgaXNSZWZgLFxyXG4gIFtXSVRIX01FTU9dOiBgd2l0aE1lbW9gLFxyXG4gIFtJU19NRU1PX1NBTUVdOiBgaXNNZW1vU2FtZWBcclxufTtcclxuZnVuY3Rpb24gcmVnaXN0ZXJSdW50aW1lSGVscGVycyhoZWxwZXJzKSB7XHJcbiAgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhoZWxwZXJzKS5mb3JFYWNoKChzKSA9PiB7XHJcbiAgICBoZWxwZXJOYW1lTWFwW3NdID0gaGVscGVyc1tzXTtcclxuICB9KTtcclxufVxyXG5cclxuY29uc3QgTmFtZXNwYWNlcyA9IHtcclxuICBcIkhUTUxcIjogMCxcclxuICBcIjBcIjogXCJIVE1MXCIsXHJcbiAgXCJTVkdcIjogMSxcclxuICBcIjFcIjogXCJTVkdcIixcclxuICBcIk1BVEhfTUxcIjogMixcclxuICBcIjJcIjogXCJNQVRIX01MXCJcclxufTtcclxuY29uc3QgTm9kZVR5cGVzID0ge1xyXG4gIFwiUk9PVFwiOiAwLFxyXG4gIFwiMFwiOiBcIlJPT1RcIixcclxuICBcIkVMRU1FTlRcIjogMSxcclxuICBcIjFcIjogXCJFTEVNRU5UXCIsXHJcbiAgXCJURVhUXCI6IDIsXHJcbiAgXCIyXCI6IFwiVEVYVFwiLFxyXG4gIFwiQ09NTUVOVFwiOiAzLFxyXG4gIFwiM1wiOiBcIkNPTU1FTlRcIixcclxuICBcIlNJTVBMRV9FWFBSRVNTSU9OXCI6IDQsXHJcbiAgXCI0XCI6IFwiU0lNUExFX0VYUFJFU1NJT05cIixcclxuICBcIklOVEVSUE9MQVRJT05cIjogNSxcclxuICBcIjVcIjogXCJJTlRFUlBPTEFUSU9OXCIsXHJcbiAgXCJBVFRSSUJVVEVcIjogNixcclxuICBcIjZcIjogXCJBVFRSSUJVVEVcIixcclxuICBcIkRJUkVDVElWRVwiOiA3LFxyXG4gIFwiN1wiOiBcIkRJUkVDVElWRVwiLFxyXG4gIFwiQ09NUE9VTkRfRVhQUkVTU0lPTlwiOiA4LFxyXG4gIFwiOFwiOiBcIkNPTVBPVU5EX0VYUFJFU1NJT05cIixcclxuICBcIklGXCI6IDksXHJcbiAgXCI5XCI6IFwiSUZcIixcclxuICBcIklGX0JSQU5DSFwiOiAxMCxcclxuICBcIjEwXCI6IFwiSUZfQlJBTkNIXCIsXHJcbiAgXCJGT1JcIjogMTEsXHJcbiAgXCIxMVwiOiBcIkZPUlwiLFxyXG4gIFwiVEVYVF9DQUxMXCI6IDEyLFxyXG4gIFwiMTJcIjogXCJURVhUX0NBTExcIixcclxuICBcIlZOT0RFX0NBTExcIjogMTMsXHJcbiAgXCIxM1wiOiBcIlZOT0RFX0NBTExcIixcclxuICBcIkpTX0NBTExfRVhQUkVTU0lPTlwiOiAxNCxcclxuICBcIjE0XCI6IFwiSlNfQ0FMTF9FWFBSRVNTSU9OXCIsXHJcbiAgXCJKU19PQkpFQ1RfRVhQUkVTU0lPTlwiOiAxNSxcclxuICBcIjE1XCI6IFwiSlNfT0JKRUNUX0VYUFJFU1NJT05cIixcclxuICBcIkpTX1BST1BFUlRZXCI6IDE2LFxyXG4gIFwiMTZcIjogXCJKU19QUk9QRVJUWVwiLFxyXG4gIFwiSlNfQVJSQVlfRVhQUkVTU0lPTlwiOiAxNyxcclxuICBcIjE3XCI6IFwiSlNfQVJSQVlfRVhQUkVTU0lPTlwiLFxyXG4gIFwiSlNfRlVOQ1RJT05fRVhQUkVTU0lPTlwiOiAxOCxcclxuICBcIjE4XCI6IFwiSlNfRlVOQ1RJT05fRVhQUkVTU0lPTlwiLFxyXG4gIFwiSlNfQ09ORElUSU9OQUxfRVhQUkVTU0lPTlwiOiAxOSxcclxuICBcIjE5XCI6IFwiSlNfQ09ORElUSU9OQUxfRVhQUkVTU0lPTlwiLFxyXG4gIFwiSlNfQ0FDSEVfRVhQUkVTU0lPTlwiOiAyMCxcclxuICBcIjIwXCI6IFwiSlNfQ0FDSEVfRVhQUkVTU0lPTlwiLFxyXG4gIFwiSlNfQkxPQ0tfU1RBVEVNRU5UXCI6IDIxLFxyXG4gIFwiMjFcIjogXCJKU19CTE9DS19TVEFURU1FTlRcIixcclxuICBcIkpTX1RFTVBMQVRFX0xJVEVSQUxcIjogMjIsXHJcbiAgXCIyMlwiOiBcIkpTX1RFTVBMQVRFX0xJVEVSQUxcIixcclxuICBcIkpTX0lGX1NUQVRFTUVOVFwiOiAyMyxcclxuICBcIjIzXCI6IFwiSlNfSUZfU1RBVEVNRU5UXCIsXHJcbiAgXCJKU19BU1NJR05NRU5UX0VYUFJFU1NJT05cIjogMjQsXHJcbiAgXCIyNFwiOiBcIkpTX0FTU0lHTk1FTlRfRVhQUkVTU0lPTlwiLFxyXG4gIFwiSlNfU0VRVUVOQ0VfRVhQUkVTU0lPTlwiOiAyNSxcclxuICBcIjI1XCI6IFwiSlNfU0VRVUVOQ0VfRVhQUkVTU0lPTlwiLFxyXG4gIFwiSlNfUkVUVVJOX1NUQVRFTUVOVFwiOiAyNixcclxuICBcIjI2XCI6IFwiSlNfUkVUVVJOX1NUQVRFTUVOVFwiXHJcbn07XHJcbmNvbnN0IEVsZW1lbnRUeXBlcyA9IHtcclxuICBcIkVMRU1FTlRcIjogMCxcclxuICBcIjBcIjogXCJFTEVNRU5UXCIsXHJcbiAgXCJDT01QT05FTlRcIjogMSxcclxuICBcIjFcIjogXCJDT01QT05FTlRcIixcclxuICBcIlNMT1RcIjogMixcclxuICBcIjJcIjogXCJTTE9UXCIsXHJcbiAgXCJURU1QTEFURVwiOiAzLFxyXG4gIFwiM1wiOiBcIlRFTVBMQVRFXCJcclxufTtcclxuY29uc3QgQ29uc3RhbnRUeXBlcyA9IHtcclxuICBcIk5PVF9DT05TVEFOVFwiOiAwLFxyXG4gIFwiMFwiOiBcIk5PVF9DT05TVEFOVFwiLFxyXG4gIFwiQ0FOX1NLSVBfUEFUQ0hcIjogMSxcclxuICBcIjFcIjogXCJDQU5fU0tJUF9QQVRDSFwiLFxyXG4gIFwiQ0FOX0NBQ0hFXCI6IDIsXHJcbiAgXCIyXCI6IFwiQ0FOX0NBQ0hFXCIsXHJcbiAgXCJDQU5fU1RSSU5HSUZZXCI6IDMsXHJcbiAgXCIzXCI6IFwiQ0FOX1NUUklOR0lGWVwiXHJcbn07XHJcbmNvbnN0IGxvY1N0dWIgPSB7XHJcbiAgc3RhcnQ6IHsgbGluZTogMSwgY29sdW1uOiAxLCBvZmZzZXQ6IDAgfSxcclxuICBlbmQ6IHsgbGluZTogMSwgY29sdW1uOiAxLCBvZmZzZXQ6IDAgfSxcclxuICBzb3VyY2U6IFwiXCJcclxufTtcclxuZnVuY3Rpb24gY3JlYXRlUm9vdChjaGlsZHJlbiwgc291cmNlID0gXCJcIikge1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiAwLFxyXG4gICAgc291cmNlLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICBoZWxwZXJzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxyXG4gICAgY29tcG9uZW50czogW10sXHJcbiAgICBkaXJlY3RpdmVzOiBbXSxcclxuICAgIGhvaXN0czogW10sXHJcbiAgICBpbXBvcnRzOiBbXSxcclxuICAgIGNhY2hlZDogW10sXHJcbiAgICB0ZW1wczogMCxcclxuICAgIGNvZGVnZW5Ob2RlOiB2b2lkIDAsXHJcbiAgICBsb2M6IGxvY1N0dWJcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVZOb2RlQ2FsbChjb250ZXh0LCB0YWcsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIGRpcmVjdGl2ZXMsIGlzQmxvY2sgPSBmYWxzZSwgZGlzYWJsZVRyYWNraW5nID0gZmFsc2UsIGlzQ29tcG9uZW50ID0gZmFsc2UsIGxvYyA9IGxvY1N0dWIpIHtcclxuICBpZiAoY29udGV4dCkge1xyXG4gICAgaWYgKGlzQmxvY2spIHtcclxuICAgICAgY29udGV4dC5oZWxwZXIoT1BFTl9CTE9DSyk7XHJcbiAgICAgIGNvbnRleHQuaGVscGVyKGdldFZOb2RlQmxvY2tIZWxwZXIoY29udGV4dC5pblNTUiwgaXNDb21wb25lbnQpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnRleHQuaGVscGVyKGdldFZOb2RlSGVscGVyKGNvbnRleHQuaW5TU1IsIGlzQ29tcG9uZW50KSk7XHJcbiAgICB9XHJcbiAgICBpZiAoZGlyZWN0aXZlcykge1xyXG4gICAgICBjb250ZXh0LmhlbHBlcihXSVRIX0RJUkVDVElWRVMpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogMTMsXHJcbiAgICB0YWcsXHJcbiAgICBwcm9wcyxcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgcGF0Y2hGbGFnLFxyXG4gICAgZHluYW1pY1Byb3BzLFxyXG4gICAgZGlyZWN0aXZlcyxcclxuICAgIGlzQmxvY2ssXHJcbiAgICBkaXNhYmxlVHJhY2tpbmcsXHJcbiAgICBpc0NvbXBvbmVudCxcclxuICAgIGxvY1xyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQXJyYXlFeHByZXNzaW9uKGVsZW1lbnRzLCBsb2MgPSBsb2NTdHViKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGU6IDE3LFxyXG4gICAgbG9jLFxyXG4gICAgZWxlbWVudHNcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdEV4cHJlc3Npb24ocHJvcGVydGllcywgbG9jID0gbG9jU3R1Yikge1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiAxNSxcclxuICAgIGxvYyxcclxuICAgIHByb3BlcnRpZXNcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdFByb3BlcnR5KGtleSwgdmFsdWUpIHtcclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogMTYsXHJcbiAgICBsb2M6IGxvY1N0dWIsXHJcbiAgICBrZXk6IGlzU3RyaW5nKGtleSkgPyBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGtleSwgdHJ1ZSkgOiBrZXksXHJcbiAgICB2YWx1ZVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihjb250ZW50LCBpc1N0YXRpYyA9IGZhbHNlLCBsb2MgPSBsb2NTdHViLCBjb25zdFR5cGUgPSAwKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGU6IDQsXHJcbiAgICBsb2MsXHJcbiAgICBjb250ZW50LFxyXG4gICAgaXNTdGF0aWMsXHJcbiAgICBjb25zdFR5cGU6IGlzU3RhdGljID8gMyA6IGNvbnN0VHlwZVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSW50ZXJwb2xhdGlvbihjb250ZW50LCBsb2MpIHtcclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogNSxcclxuICAgIGxvYyxcclxuICAgIGNvbnRlbnQ6IGlzU3RyaW5nKGNvbnRlbnQpID8gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihjb250ZW50LCBmYWxzZSwgbG9jKSA6IGNvbnRlbnRcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihjaGlsZHJlbiwgbG9jID0gbG9jU3R1Yikge1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiA4LFxyXG4gICAgbG9jLFxyXG4gICAgY2hpbGRyZW5cclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNhbGxlZSwgYXJncyA9IFtdLCBsb2MgPSBsb2NTdHViKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGU6IDE0LFxyXG4gICAgbG9jLFxyXG4gICAgY2FsbGVlLFxyXG4gICAgYXJndW1lbnRzOiBhcmdzXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24ocGFyYW1zLCByZXR1cm5zID0gdm9pZCAwLCBuZXdsaW5lID0gZmFsc2UsIGlzU2xvdCA9IGZhbHNlLCBsb2MgPSBsb2NTdHViKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGU6IDE4LFxyXG4gICAgcGFyYW1zLFxyXG4gICAgcmV0dXJucyxcclxuICAgIG5ld2xpbmUsXHJcbiAgICBpc1Nsb3QsXHJcbiAgICBsb2NcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbih0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUsIG5ld2xpbmUgPSB0cnVlKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGU6IDE5LFxyXG4gICAgdGVzdCxcclxuICAgIGNvbnNlcXVlbnQsXHJcbiAgICBhbHRlcm5hdGUsXHJcbiAgICBuZXdsaW5lLFxyXG4gICAgbG9jOiBsb2NTdHViXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDYWNoZUV4cHJlc3Npb24oaW5kZXgsIHZhbHVlLCBuZWVkUGF1c2VUcmFja2luZyA9IGZhbHNlLCBpblZPbmNlID0gZmFsc2UpIHtcclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogMjAsXHJcbiAgICBpbmRleCxcclxuICAgIHZhbHVlLFxyXG4gICAgbmVlZFBhdXNlVHJhY2tpbmcsXHJcbiAgICBpblZPbmNlLFxyXG4gICAgbmVlZEFycmF5U3ByZWFkOiBmYWxzZSxcclxuICAgIGxvYzogbG9jU3R1YlxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQmxvY2tTdGF0ZW1lbnQoYm9keSkge1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiAyMSxcclxuICAgIGJvZHksXHJcbiAgICBsb2M6IGxvY1N0dWJcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVRlbXBsYXRlTGl0ZXJhbChlbGVtZW50cykge1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiAyMixcclxuICAgIGVsZW1lbnRzLFxyXG4gICAgbG9jOiBsb2NTdHViXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJZlN0YXRlbWVudCh0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpIHtcclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogMjMsXHJcbiAgICB0ZXN0LFxyXG4gICAgY29uc2VxdWVudCxcclxuICAgIGFsdGVybmF0ZSxcclxuICAgIGxvYzogbG9jU3R1YlxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24obGVmdCwgcmlnaHQpIHtcclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogMjQsXHJcbiAgICBsZWZ0LFxyXG4gICAgcmlnaHQsXHJcbiAgICBsb2M6IGxvY1N0dWJcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNlcXVlbmNlRXhwcmVzc2lvbihleHByZXNzaW9ucykge1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiAyNSxcclxuICAgIGV4cHJlc3Npb25zLFxyXG4gICAgbG9jOiBsb2NTdHViXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSZXR1cm5TdGF0ZW1lbnQocmV0dXJucykge1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiAyNixcclxuICAgIHJldHVybnMsXHJcbiAgICBsb2M6IGxvY1N0dWJcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldFZOb2RlSGVscGVyKHNzciwgaXNDb21wb25lbnQpIHtcclxuICByZXR1cm4gc3NyIHx8IGlzQ29tcG9uZW50ID8gQ1JFQVRFX1ZOT0RFIDogQ1JFQVRFX0VMRU1FTlRfVk5PREU7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Vk5vZGVCbG9ja0hlbHBlcihzc3IsIGlzQ29tcG9uZW50KSB7XHJcbiAgcmV0dXJuIHNzciB8fCBpc0NvbXBvbmVudCA/IENSRUFURV9CTE9DSyA6IENSRUFURV9FTEVNRU5UX0JMT0NLO1xyXG59XHJcbmZ1bmN0aW9uIGNvbnZlcnRUb0Jsb2NrKG5vZGUsIHsgaGVscGVyLCByZW1vdmVIZWxwZXIsIGluU1NSIH0pIHtcclxuICBpZiAoIW5vZGUuaXNCbG9jaykge1xyXG4gICAgbm9kZS5pc0Jsb2NrID0gdHJ1ZTtcclxuICAgIHJlbW92ZUhlbHBlcihnZXRWTm9kZUhlbHBlcihpblNTUiwgbm9kZS5pc0NvbXBvbmVudCkpO1xyXG4gICAgaGVscGVyKE9QRU5fQkxPQ0spO1xyXG4gICAgaGVscGVyKGdldFZOb2RlQmxvY2tIZWxwZXIoaW5TU1IsIG5vZGUuaXNDb21wb25lbnQpKTtcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IGRlZmF1bHREZWxpbWl0ZXJzT3BlbiA9IG5ldyBVaW50OEFycmF5KFsxMjMsIDEyM10pO1xyXG5jb25zdCBkZWZhdWx0RGVsaW1pdGVyc0Nsb3NlID0gbmV3IFVpbnQ4QXJyYXkoWzEyNSwgMTI1XSk7XHJcbmZ1bmN0aW9uIGlzVGFnU3RhcnRDaGFyKGMpIHtcclxuICByZXR1cm4gYyA+PSA5NyAmJiBjIDw9IDEyMiB8fCBjID49IDY1ICYmIGMgPD0gOTA7XHJcbn1cclxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGMpIHtcclxuICByZXR1cm4gYyA9PT0gMzIgfHwgYyA9PT0gMTAgfHwgYyA9PT0gOSB8fCBjID09PSAxMiB8fCBjID09PSAxMztcclxufVxyXG5mdW5jdGlvbiBpc0VuZE9mVGFnU2VjdGlvbihjKSB7XHJcbiAgcmV0dXJuIGMgPT09IDQ3IHx8IGMgPT09IDYyIHx8IGlzV2hpdGVzcGFjZShjKTtcclxufVxyXG5mdW5jdGlvbiB0b0NoYXJDb2RlcyhzdHIpIHtcclxuICBjb25zdCByZXQgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xyXG4gICAgcmV0W2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgfVxyXG4gIHJldHVybiByZXQ7XHJcbn1cclxuY29uc3QgU2VxdWVuY2VzID0ge1xyXG4gIENkYXRhOiBuZXcgVWludDhBcnJheShbNjcsIDY4LCA2NSwgODQsIDY1LCA5MV0pLFxyXG4gIC8vIENEQVRBW1xyXG4gIENkYXRhRW5kOiBuZXcgVWludDhBcnJheShbOTMsIDkzLCA2Ml0pLFxyXG4gIC8vIF1dPlxyXG4gIENvbW1lbnRFbmQ6IG5ldyBVaW50OEFycmF5KFs0NSwgNDUsIDYyXSksXHJcbiAgLy8gYC0tPmBcclxuICBTY3JpcHRFbmQ6IG5ldyBVaW50OEFycmF5KFs2MCwgNDcsIDExNSwgOTksIDExNCwgMTA1LCAxMTIsIDExNl0pLFxyXG4gIC8vIGA8XFwvc2NyaXB0YFxyXG4gIFN0eWxlRW5kOiBuZXcgVWludDhBcnJheShbNjAsIDQ3LCAxMTUsIDExNiwgMTIxLCAxMDgsIDEwMV0pLFxyXG4gIC8vIGA8L3N0eWxlYFxyXG4gIFRpdGxlRW5kOiBuZXcgVWludDhBcnJheShbNjAsIDQ3LCAxMTYsIDEwNSwgMTE2LCAxMDgsIDEwMV0pLFxyXG4gIC8vIGA8L3RpdGxlYFxyXG4gIFRleHRhcmVhRW5kOiBuZXcgVWludDhBcnJheShbXHJcbiAgICA2MCxcclxuICAgIDQ3LFxyXG4gICAgMTE2LFxyXG4gICAgMTAxLFxyXG4gICAgMTIwLFxyXG4gICAgMTE2LFxyXG4gICAgOTcsXHJcbiAgICAxMTQsXHJcbiAgICAxMDEsXHJcbiAgICA5N1xyXG4gIF0pXHJcbiAgLy8gYDwvdGV4dGFyZWFcclxufTtcclxuY2xhc3MgVG9rZW5pemVyIHtcclxuICBjb25zdHJ1Y3RvcihzdGFjaywgY2JzKSB7XHJcbiAgICB0aGlzLnN0YWNrID0gc3RhY2s7XHJcbiAgICB0aGlzLmNicyA9IGNicztcclxuICAgIC8qKiBUaGUgY3VycmVudCBzdGF0ZSB0aGUgdG9rZW5pemVyIGlzIGluLiAqL1xyXG4gICAgdGhpcy5zdGF0ZSA9IDE7XHJcbiAgICAvKiogVGhlIHJlYWQgYnVmZmVyLiAqL1xyXG4gICAgdGhpcy5idWZmZXIgPSBcIlwiO1xyXG4gICAgLyoqIFRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlY3Rpb24gdGhhdCBpcyBjdXJyZW50bHkgYmVpbmcgcmVhZC4gKi9cclxuICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gMDtcclxuICAgIC8qKiBUaGUgaW5kZXggd2l0aGluIHRoZSBidWZmZXIgdGhhdCB3ZSBhcmUgY3VycmVudGx5IGxvb2tpbmcgYXQuICovXHJcbiAgICB0aGlzLmluZGV4ID0gMDtcclxuICAgIC8qKiBUaGUgc3RhcnQgb2YgdGhlIGxhc3QgZW50aXR5LiAqL1xyXG4gICAgdGhpcy5lbnRpdHlTdGFydCA9IDA7XHJcbiAgICAvKiogU29tZSBiZWhhdmlvciwgZWcuIHdoZW4gZGVjb2RpbmcgZW50aXRpZXMsIGlzIGRvbmUgd2hpbGUgd2UgYXJlIGluIGFub3RoZXIgc3RhdGUuIFRoaXMga2VlcHMgdHJhY2sgb2YgdGhlIG90aGVyIHN0YXRlIHR5cGUuICovXHJcbiAgICB0aGlzLmJhc2VTdGF0ZSA9IDE7XHJcbiAgICAvKiogRm9yIHNwZWNpYWwgcGFyc2luZyBiZWhhdmlvciBpbnNpZGUgb2Ygc2NyaXB0IGFuZCBzdHlsZSB0YWdzLiAqL1xyXG4gICAgdGhpcy5pblJDREFUQSA9IGZhbHNlO1xyXG4gICAgLyoqIEZvciBkaXNhYmxpbmcgUkNEQVRBIHRhZ3MgaGFuZGxpbmcgKi9cclxuICAgIHRoaXMuaW5YTUwgPSBmYWxzZTtcclxuICAgIC8qKiBGb3IgZGlzYWJsaW5nIGludGVycG9sYXRpb24gcGFyc2luZyBpbiB2LXByZSAqL1xyXG4gICAgdGhpcy5pblZQcmUgPSBmYWxzZTtcclxuICAgIC8qKiBSZWNvcmQgbmV3bGluZSBwb3NpdGlvbnMgZm9yIGZhc3QgbGluZSAvIGNvbHVtbiBjYWxjdWxhdGlvbiAqL1xyXG4gICAgdGhpcy5uZXdsaW5lcyA9IFtdO1xyXG4gICAgdGhpcy5tb2RlID0gMDtcclxuICAgIHRoaXMuZGVsaW1pdGVyT3BlbiA9IGRlZmF1bHREZWxpbWl0ZXJzT3BlbjtcclxuICAgIHRoaXMuZGVsaW1pdGVyQ2xvc2UgPSBkZWZhdWx0RGVsaW1pdGVyc0Nsb3NlO1xyXG4gICAgdGhpcy5kZWxpbWl0ZXJJbmRleCA9IC0xO1xyXG4gICAgdGhpcy5jdXJyZW50U2VxdWVuY2UgPSB2b2lkIDA7XHJcbiAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAwO1xyXG4gIH1cclxuICBnZXQgaW5TRkNSb290KCkge1xyXG4gICAgcmV0dXJuIHRoaXMubW9kZSA9PT0gMiAmJiB0aGlzLnN0YWNrLmxlbmd0aCA9PT0gMDtcclxuICB9XHJcbiAgcmVzZXQoKSB7XHJcbiAgICB0aGlzLnN0YXRlID0gMTtcclxuICAgIHRoaXMubW9kZSA9IDA7XHJcbiAgICB0aGlzLmJ1ZmZlciA9IFwiXCI7XHJcbiAgICB0aGlzLnNlY3Rpb25TdGFydCA9IDA7XHJcbiAgICB0aGlzLmluZGV4ID0gMDtcclxuICAgIHRoaXMuYmFzZVN0YXRlID0gMTtcclxuICAgIHRoaXMuaW5SQ0RBVEEgPSBmYWxzZTtcclxuICAgIHRoaXMuY3VycmVudFNlcXVlbmNlID0gdm9pZCAwO1xyXG4gICAgdGhpcy5uZXdsaW5lcy5sZW5ndGggPSAwO1xyXG4gICAgdGhpcy5kZWxpbWl0ZXJPcGVuID0gZGVmYXVsdERlbGltaXRlcnNPcGVuO1xyXG4gICAgdGhpcy5kZWxpbWl0ZXJDbG9zZSA9IGRlZmF1bHREZWxpbWl0ZXJzQ2xvc2U7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlIFBvc2l0aW9uIG9iamVjdCB3aXRoIGxpbmUgLyBjb2x1bW4gaW5mb3JtYXRpb24gdXNpbmcgcmVjb3JkZWRcclxuICAgKiBuZXdsaW5lIHBvc2l0aW9ucy4gV2Uga25vdyB0aGUgaW5kZXggaXMgYWx3YXlzIGdvaW5nIHRvIGJlIGFuIGFscmVhZHlcclxuICAgKiBwcm9jZXNzZWQgaW5kZXgsIHNvIGFsbCB0aGUgbmV3bGluZXMgdXAgdG8gdGhpcyBpbmRleCBzaG91bGQgaGF2ZSBiZWVuXHJcbiAgICogcmVjb3JkZWQuXHJcbiAgICovXHJcbiAgZ2V0UG9zKGluZGV4KSB7XHJcbiAgICBsZXQgbGluZSA9IDE7XHJcbiAgICBsZXQgY29sdW1uID0gaW5kZXggKyAxO1xyXG4gICAgZm9yIChsZXQgaSA9IHRoaXMubmV3bGluZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgY29uc3QgbmV3bGluZUluZGV4ID0gdGhpcy5uZXdsaW5lc1tpXTtcclxuICAgICAgaWYgKGluZGV4ID4gbmV3bGluZUluZGV4KSB7XHJcbiAgICAgICAgbGluZSA9IGkgKyAyO1xyXG4gICAgICAgIGNvbHVtbiA9IGluZGV4IC0gbmV3bGluZUluZGV4O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjb2x1bW4sXHJcbiAgICAgIGxpbmUsXHJcbiAgICAgIG9mZnNldDogaW5kZXhcclxuICAgIH07XHJcbiAgfVxyXG4gIHBlZWsoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5idWZmZXIuY2hhckNvZGVBdCh0aGlzLmluZGV4ICsgMSk7XHJcbiAgfVxyXG4gIHN0YXRlVGV4dChjKSB7XHJcbiAgICBpZiAoYyA9PT0gNjApIHtcclxuICAgICAgaWYgKHRoaXMuaW5kZXggPiB0aGlzLnNlY3Rpb25TdGFydCkge1xyXG4gICAgICAgIHRoaXMuY2JzLm9udGV4dCh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zdGF0ZSA9IDU7XHJcbiAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleDtcclxuICAgIH0gZWxzZSBpZiAoIXRoaXMuaW5WUHJlICYmIGMgPT09IHRoaXMuZGVsaW1pdGVyT3BlblswXSkge1xyXG4gICAgICB0aGlzLnN0YXRlID0gMjtcclxuICAgICAgdGhpcy5kZWxpbWl0ZXJJbmRleCA9IDA7XHJcbiAgICAgIHRoaXMuc3RhdGVJbnRlcnBvbGF0aW9uT3BlbihjKTtcclxuICAgIH1cclxuICB9XHJcbiAgc3RhdGVJbnRlcnBvbGF0aW9uT3BlbihjKSB7XHJcbiAgICBpZiAoYyA9PT0gdGhpcy5kZWxpbWl0ZXJPcGVuW3RoaXMuZGVsaW1pdGVySW5kZXhdKSB7XHJcbiAgICAgIGlmICh0aGlzLmRlbGltaXRlckluZGV4ID09PSB0aGlzLmRlbGltaXRlck9wZW4ubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5pbmRleCArIDEgLSB0aGlzLmRlbGltaXRlck9wZW4ubGVuZ3RoO1xyXG4gICAgICAgIGlmIChzdGFydCA+IHRoaXMuc2VjdGlvblN0YXJ0KSB7XHJcbiAgICAgICAgICB0aGlzLmNicy5vbnRleHQodGhpcy5zZWN0aW9uU3RhcnQsIHN0YXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDM7XHJcbiAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSBzdGFydDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmRlbGltaXRlckluZGV4Kys7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodGhpcy5pblJDREFUQSkge1xyXG4gICAgICB0aGlzLnN0YXRlID0gMzI7XHJcbiAgICAgIHRoaXMuc3RhdGVJblJDREFUQShjKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSAxO1xyXG4gICAgICB0aGlzLnN0YXRlVGV4dChjKTtcclxuICAgIH1cclxuICB9XHJcbiAgc3RhdGVJbnRlcnBvbGF0aW9uKGMpIHtcclxuICAgIGlmIChjID09PSB0aGlzLmRlbGltaXRlckNsb3NlWzBdKSB7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSA0O1xyXG4gICAgICB0aGlzLmRlbGltaXRlckluZGV4ID0gMDtcclxuICAgICAgdGhpcy5zdGF0ZUludGVycG9sYXRpb25DbG9zZShjKTtcclxuICAgIH1cclxuICB9XHJcbiAgc3RhdGVJbnRlcnBvbGF0aW9uQ2xvc2UoYykge1xyXG4gICAgaWYgKGMgPT09IHRoaXMuZGVsaW1pdGVyQ2xvc2VbdGhpcy5kZWxpbWl0ZXJJbmRleF0pIHtcclxuICAgICAgaWYgKHRoaXMuZGVsaW1pdGVySW5kZXggPT09IHRoaXMuZGVsaW1pdGVyQ2xvc2UubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgIHRoaXMuY2JzLm9uaW50ZXJwb2xhdGlvbih0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCArIDEpO1xyXG4gICAgICAgIGlmICh0aGlzLmluUkNEQVRBKSB7XHJcbiAgICAgICAgICB0aGlzLnN0YXRlID0gMzI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuc3RhdGUgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZGVsaW1pdGVySW5kZXgrKztcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5zdGF0ZSA9IDM7XHJcbiAgICAgIHRoaXMuc3RhdGVJbnRlcnBvbGF0aW9uKGMpO1xyXG4gICAgfVxyXG4gIH1cclxuICBzdGF0ZVNwZWNpYWxTdGFydFNlcXVlbmNlKGMpIHtcclxuICAgIGNvbnN0IGlzRW5kID0gdGhpcy5zZXF1ZW5jZUluZGV4ID09PSB0aGlzLmN1cnJlbnRTZXF1ZW5jZS5sZW5ndGg7XHJcbiAgICBjb25zdCBpc01hdGNoID0gaXNFbmQgPyAoXHJcbiAgICAgIC8vIElmIHdlIGFyZSBhdCB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZSwgbWFrZSBzdXJlIHRoZSB0YWcgbmFtZSBoYXMgZW5kZWRcclxuICAgICAgaXNFbmRPZlRhZ1NlY3Rpb24oYylcclxuICAgICkgOiAoXHJcbiAgICAgIC8vIE90aGVyd2lzZSwgZG8gYSBjYXNlLWluc2Vuc2l0aXZlIGNvbXBhcmlzb25cclxuICAgICAgKGMgfCAzMikgPT09IHRoaXMuY3VycmVudFNlcXVlbmNlW3RoaXMuc2VxdWVuY2VJbmRleF1cclxuICAgICk7XHJcbiAgICBpZiAoIWlzTWF0Y2gpIHtcclxuICAgICAgdGhpcy5pblJDREFUQSA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIGlmICghaXNFbmQpIHtcclxuICAgICAgdGhpcy5zZXF1ZW5jZUluZGV4Kys7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IDA7XHJcbiAgICB0aGlzLnN0YXRlID0gNjtcclxuICAgIHRoaXMuc3RhdGVJblRhZ05hbWUoYyk7XHJcbiAgfVxyXG4gIC8qKiBMb29rIGZvciBhbiBlbmQgdGFnLiBGb3IgPHRpdGxlPiBhbmQgPHRleHRhcmVhPiwgYWxzbyBkZWNvZGUgZW50aXRpZXMuICovXHJcbiAgc3RhdGVJblJDREFUQShjKSB7XHJcbiAgICBpZiAodGhpcy5zZXF1ZW5jZUluZGV4ID09PSB0aGlzLmN1cnJlbnRTZXF1ZW5jZS5sZW5ndGgpIHtcclxuICAgICAgaWYgKGMgPT09IDYyIHx8IGlzV2hpdGVzcGFjZShjKSkge1xyXG4gICAgICAgIGNvbnN0IGVuZE9mVGV4dCA9IHRoaXMuaW5kZXggLSB0aGlzLmN1cnJlbnRTZXF1ZW5jZS5sZW5ndGg7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VjdGlvblN0YXJ0IDwgZW5kT2ZUZXh0KSB7XHJcbiAgICAgICAgICBjb25zdCBhY3R1YWxJbmRleCA9IHRoaXMuaW5kZXg7XHJcbiAgICAgICAgICB0aGlzLmluZGV4ID0gZW5kT2ZUZXh0O1xyXG4gICAgICAgICAgdGhpcy5jYnMub250ZXh0KHRoaXMuc2VjdGlvblN0YXJ0LCBlbmRPZlRleHQpO1xyXG4gICAgICAgICAgdGhpcy5pbmRleCA9IGFjdHVhbEluZGV4O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IGVuZE9mVGV4dCArIDI7XHJcbiAgICAgICAgdGhpcy5zdGF0ZUluQ2xvc2luZ1RhZ05hbWUoYyk7XHJcbiAgICAgICAgdGhpcy5pblJDREFUQSA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAwO1xyXG4gICAgfVxyXG4gICAgaWYgKChjIHwgMzIpID09PSB0aGlzLmN1cnJlbnRTZXF1ZW5jZVt0aGlzLnNlcXVlbmNlSW5kZXhdKSB7XHJcbiAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCArPSAxO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLnNlcXVlbmNlSW5kZXggPT09IDApIHtcclxuICAgICAgaWYgKHRoaXMuY3VycmVudFNlcXVlbmNlID09PSBTZXF1ZW5jZXMuVGl0bGVFbmQgfHwgdGhpcy5jdXJyZW50U2VxdWVuY2UgPT09IFNlcXVlbmNlcy5UZXh0YXJlYUVuZCAmJiAhdGhpcy5pblNGQ1Jvb3QpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW5WUHJlICYmIGMgPT09IHRoaXMuZGVsaW1pdGVyT3BlblswXSkge1xyXG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IDI7XHJcbiAgICAgICAgICB0aGlzLmRlbGltaXRlckluZGV4ID0gMDtcclxuICAgICAgICAgIHRoaXMuc3RhdGVJbnRlcnBvbGF0aW9uT3BlbihjKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5mYXN0Rm9yd2FyZFRvKDYwKSkge1xyXG4gICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IDE7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IE51bWJlcihjID09PSA2MCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHN0YXRlQ0RBVEFTZXF1ZW5jZShjKSB7XHJcbiAgICBpZiAoYyA9PT0gU2VxdWVuY2VzLkNkYXRhW3RoaXMuc2VxdWVuY2VJbmRleF0pIHtcclxuICAgICAgaWYgKCsrdGhpcy5zZXF1ZW5jZUluZGV4ID09PSBTZXF1ZW5jZXMuQ2RhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDI4O1xyXG4gICAgICAgIHRoaXMuY3VycmVudFNlcXVlbmNlID0gU2VxdWVuY2VzLkNkYXRhRW5kO1xyXG4gICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IDA7XHJcbiAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5zZXF1ZW5jZUluZGV4ID0gMDtcclxuICAgICAgdGhpcy5zdGF0ZSA9IDIzO1xyXG4gICAgICB0aGlzLnN0YXRlSW5EZWNsYXJhdGlvbihjKTtcclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgICogV2hlbiB3ZSB3YWl0IGZvciBvbmUgc3BlY2lmaWMgY2hhcmFjdGVyLCB3ZSBjYW4gc3BlZWQgdGhpbmdzIHVwXHJcbiAgICogYnkgc2tpcHBpbmcgdGhyb3VnaCB0aGUgYnVmZmVyIHVudGlsIHdlIGZpbmQgaXQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBjaGFyYWN0ZXIgd2FzIGZvdW5kLlxyXG4gICAqL1xyXG4gIGZhc3RGb3J3YXJkVG8oYykge1xyXG4gICAgd2hpbGUgKCsrdGhpcy5pbmRleCA8IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xyXG4gICAgICBjb25zdCBjYyA9IHRoaXMuYnVmZmVyLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XHJcbiAgICAgIGlmIChjYyA9PT0gMTApIHtcclxuICAgICAgICB0aGlzLm5ld2xpbmVzLnB1c2godGhpcy5pbmRleCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNjID09PSBjKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuaW5kZXggPSB0aGlzLmJ1ZmZlci5sZW5ndGggLSAxO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBDb21tZW50cyBhbmQgQ0RBVEEgZW5kIHdpdGggYC0tPmAgYW5kIGBdXT5gLlxyXG4gICAqXHJcbiAgICogVGhlaXIgY29tbW9uIHF1YWxpdGllcyBhcmU6XHJcbiAgICogLSBUaGVpciBlbmQgc2VxdWVuY2VzIGhhdmUgYSBkaXN0aW5jdCBjaGFyYWN0ZXIgdGhleSBzdGFydCB3aXRoLlxyXG4gICAqIC0gVGhhdCBjaGFyYWN0ZXIgaXMgdGhlbiByZXBlYXRlZCwgc28gd2UgaGF2ZSB0byBjaGVjayBtdWx0aXBsZSByZXBlYXRzLlxyXG4gICAqIC0gQWxsIGNoYXJhY3RlcnMgYnV0IHRoZSBzdGFydCBjaGFyYWN0ZXIgb2YgdGhlIHNlcXVlbmNlIGNhbiBiZSBza2lwcGVkLlxyXG4gICAqL1xyXG4gIHN0YXRlSW5Db21tZW50TGlrZShjKSB7XHJcbiAgICBpZiAoYyA9PT0gdGhpcy5jdXJyZW50U2VxdWVuY2VbdGhpcy5zZXF1ZW5jZUluZGV4XSkge1xyXG4gICAgICBpZiAoKyt0aGlzLnNlcXVlbmNlSW5kZXggPT09IHRoaXMuY3VycmVudFNlcXVlbmNlLmxlbmd0aCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRTZXF1ZW5jZSA9PT0gU2VxdWVuY2VzLkNkYXRhRW5kKSB7XHJcbiAgICAgICAgICB0aGlzLmNicy5vbmNkYXRhKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4IC0gMik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuY2JzLm9uY29tbWVudCh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCAtIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAwO1xyXG4gICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDE7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodGhpcy5zZXF1ZW5jZUluZGV4ID09PSAwKSB7XHJcbiAgICAgIGlmICh0aGlzLmZhc3RGb3J3YXJkVG8odGhpcy5jdXJyZW50U2VxdWVuY2VbMF0pKSB7XHJcbiAgICAgICAgdGhpcy5zZXF1ZW5jZUluZGV4ID0gMTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChjICE9PSB0aGlzLmN1cnJlbnRTZXF1ZW5jZVt0aGlzLnNlcXVlbmNlSW5kZXggLSAxXSkge1xyXG4gICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAwO1xyXG4gICAgfVxyXG4gIH1cclxuICBzdGFydFNwZWNpYWwoc2VxdWVuY2UsIG9mZnNldCkge1xyXG4gICAgdGhpcy5lbnRlclJDREFUQShzZXF1ZW5jZSwgb2Zmc2V0KTtcclxuICAgIHRoaXMuc3RhdGUgPSAzMTtcclxuICB9XHJcbiAgZW50ZXJSQ0RBVEEoc2VxdWVuY2UsIG9mZnNldCkge1xyXG4gICAgdGhpcy5pblJDREFUQSA9IHRydWU7XHJcbiAgICB0aGlzLmN1cnJlbnRTZXF1ZW5jZSA9IHNlcXVlbmNlO1xyXG4gICAgdGhpcy5zZXF1ZW5jZUluZGV4ID0gb2Zmc2V0O1xyXG4gIH1cclxuICBzdGF0ZUJlZm9yZVRhZ05hbWUoYykge1xyXG4gICAgaWYgKGMgPT09IDMzKSB7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSAyMjtcclxuICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcclxuICAgIH0gZWxzZSBpZiAoYyA9PT0gNjMpIHtcclxuICAgICAgdGhpcy5zdGF0ZSA9IDI0O1xyXG4gICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxO1xyXG4gICAgfSBlbHNlIGlmIChpc1RhZ1N0YXJ0Q2hhcihjKSkge1xyXG4gICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXg7XHJcbiAgICAgIGlmICh0aGlzLm1vZGUgPT09IDApIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gNjtcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLmluU0ZDUm9vdCkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAzNDtcclxuICAgICAgfSBlbHNlIGlmICghdGhpcy5pblhNTCkge1xyXG4gICAgICAgIGlmIChjID09PSAxMTYpIHtcclxuICAgICAgICAgIHRoaXMuc3RhdGUgPSAzMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IGMgPT09IDExNSA/IDI5IDogNjtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDY7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoYyA9PT0gNDcpIHtcclxuICAgICAgdGhpcy5zdGF0ZSA9IDg7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnN0YXRlID0gMTtcclxuICAgICAgdGhpcy5zdGF0ZVRleHQoYyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHN0YXRlSW5UYWdOYW1lKGMpIHtcclxuICAgIGlmIChpc0VuZE9mVGFnU2VjdGlvbihjKSkge1xyXG4gICAgICB0aGlzLmhhbmRsZVRhZ05hbWUoYyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHN0YXRlSW5TRkNSb290VGFnTmFtZShjKSB7XHJcbiAgICBpZiAoaXNFbmRPZlRhZ1NlY3Rpb24oYykpIHtcclxuICAgICAgY29uc3QgdGFnID0gdGhpcy5idWZmZXIuc2xpY2UodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpO1xyXG4gICAgICBpZiAodGFnICE9PSBcInRlbXBsYXRlXCIpIHtcclxuICAgICAgICB0aGlzLmVudGVyUkNEQVRBKHRvQ2hhckNvZGVzKGA8L2AgKyB0YWcpLCAwKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmhhbmRsZVRhZ05hbWUoYyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGhhbmRsZVRhZ05hbWUoYykge1xyXG4gICAgdGhpcy5jYnMub25vcGVudGFnbmFtZSh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XHJcbiAgICB0aGlzLnNlY3Rpb25TdGFydCA9IC0xO1xyXG4gICAgdGhpcy5zdGF0ZSA9IDExO1xyXG4gICAgdGhpcy5zdGF0ZUJlZm9yZUF0dHJOYW1lKGMpO1xyXG4gIH1cclxuICBzdGF0ZUJlZm9yZUNsb3NpbmdUYWdOYW1lKGMpIHtcclxuICAgIGlmIChpc1doaXRlc3BhY2UoYykpIDsgZWxzZSBpZiAoYyA9PT0gNjIpIHtcclxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgZmFsc2UpIHtcclxuICAgICAgICB0aGlzLmNicy5vbmVycigxNCwgdGhpcy5pbmRleCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zdGF0ZSA9IDE7XHJcbiAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnN0YXRlID0gaXNUYWdTdGFydENoYXIoYykgPyA5IDogMjc7XHJcbiAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleDtcclxuICAgIH1cclxuICB9XHJcbiAgc3RhdGVJbkNsb3NpbmdUYWdOYW1lKGMpIHtcclxuICAgIGlmIChjID09PSA2MiB8fCBpc1doaXRlc3BhY2UoYykpIHtcclxuICAgICAgdGhpcy5jYnMub25jbG9zZXRhZyh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XHJcbiAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gLTE7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSAxMDtcclxuICAgICAgdGhpcy5zdGF0ZUFmdGVyQ2xvc2luZ1RhZ05hbWUoYyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHN0YXRlQWZ0ZXJDbG9zaW5nVGFnTmFtZShjKSB7XHJcbiAgICBpZiAoYyA9PT0gNjIpIHtcclxuICAgICAgdGhpcy5zdGF0ZSA9IDE7XHJcbiAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHN0YXRlQmVmb3JlQXR0ck5hbWUoYykge1xyXG4gICAgaWYgKGMgPT09IDYyKSB7XHJcbiAgICAgIHRoaXMuY2JzLm9ub3BlbnRhZ2VuZCh0aGlzLmluZGV4KTtcclxuICAgICAgaWYgKHRoaXMuaW5SQ0RBVEEpIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMzI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDE7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcclxuICAgIH0gZWxzZSBpZiAoYyA9PT0gNDcpIHtcclxuICAgICAgdGhpcy5zdGF0ZSA9IDc7XHJcbiAgICAgIGlmICgoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBmYWxzZSkgJiYgdGhpcy5wZWVrKCkgIT09IDYyKSB7XHJcbiAgICAgICAgdGhpcy5jYnMub25lcnIoMjIsIHRoaXMuaW5kZXgpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGMgPT09IDYwICYmIHRoaXMucGVlaygpID09PSA0Nykge1xyXG4gICAgICB0aGlzLmNicy5vbm9wZW50YWdlbmQodGhpcy5pbmRleCk7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSA1O1xyXG4gICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXg7XHJcbiAgICB9IGVsc2UgaWYgKCFpc1doaXRlc3BhY2UoYykpIHtcclxuICAgICAgaWYgKCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IGZhbHNlKSAmJiBjID09PSA2MSkge1xyXG4gICAgICAgIHRoaXMuY2JzLm9uZXJyKFxyXG4gICAgICAgICAgMTksXHJcbiAgICAgICAgICB0aGlzLmluZGV4XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmhhbmRsZUF0dHJTdGFydChjKTtcclxuICAgIH1cclxuICB9XHJcbiAgaGFuZGxlQXR0clN0YXJ0KGMpIHtcclxuICAgIGlmIChjID09PSAxMTggJiYgdGhpcy5wZWVrKCkgPT09IDQ1KSB7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSAxMztcclxuICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4O1xyXG4gICAgfSBlbHNlIGlmIChjID09PSA0NiB8fCBjID09PSA1OCB8fCBjID09PSA2NCB8fCBjID09PSAzNSkge1xyXG4gICAgICB0aGlzLmNicy5vbmRpcm5hbWUodGhpcy5pbmRleCwgdGhpcy5pbmRleCArIDEpO1xyXG4gICAgICB0aGlzLnN0YXRlID0gMTQ7XHJcbiAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnN0YXRlID0gMTI7XHJcbiAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleDtcclxuICAgIH1cclxuICB9XHJcbiAgc3RhdGVJblNlbGZDbG9zaW5nVGFnKGMpIHtcclxuICAgIGlmIChjID09PSA2Mikge1xyXG4gICAgICB0aGlzLmNicy5vbnNlbGZjbG9zaW5ndGFnKHRoaXMuaW5kZXgpO1xyXG4gICAgICB0aGlzLnN0YXRlID0gMTtcclxuICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcclxuICAgICAgdGhpcy5pblJDREFUQSA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSAxMTtcclxuICAgICAgdGhpcy5zdGF0ZUJlZm9yZUF0dHJOYW1lKGMpO1xyXG4gICAgfVxyXG4gIH1cclxuICBzdGF0ZUluQXR0ck5hbWUoYykge1xyXG4gICAgaWYgKGMgPT09IDYxIHx8IGlzRW5kT2ZUYWdTZWN0aW9uKGMpKSB7XHJcbiAgICAgIHRoaXMuY2JzLm9uYXR0cmlibmFtZSh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XHJcbiAgICAgIHRoaXMuaGFuZGxlQXR0ck5hbWVFbmQoYyk7XHJcbiAgICB9IGVsc2UgaWYgKCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IGZhbHNlKSAmJiAoYyA9PT0gMzQgfHwgYyA9PT0gMzkgfHwgYyA9PT0gNjApKSB7XHJcbiAgICAgIHRoaXMuY2JzLm9uZXJyKFxyXG4gICAgICAgIDE3LFxyXG4gICAgICAgIHRoaXMuaW5kZXhcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcbiAgc3RhdGVJbkRpck5hbWUoYykge1xyXG4gICAgaWYgKGMgPT09IDYxIHx8IGlzRW5kT2ZUYWdTZWN0aW9uKGMpKSB7XHJcbiAgICAgIHRoaXMuY2JzLm9uZGlybmFtZSh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XHJcbiAgICAgIHRoaXMuaGFuZGxlQXR0ck5hbWVFbmQoYyk7XHJcbiAgICB9IGVsc2UgaWYgKGMgPT09IDU4KSB7XHJcbiAgICAgIHRoaXMuY2JzLm9uZGlybmFtZSh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSAxNDtcclxuICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcclxuICAgIH0gZWxzZSBpZiAoYyA9PT0gNDYpIHtcclxuICAgICAgdGhpcy5jYnMub25kaXJuYW1lKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcclxuICAgICAgdGhpcy5zdGF0ZSA9IDE2O1xyXG4gICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxO1xyXG4gICAgfVxyXG4gIH1cclxuICBzdGF0ZUluRGlyQXJnKGMpIHtcclxuICAgIGlmIChjID09PSA2MSB8fCBpc0VuZE9mVGFnU2VjdGlvbihjKSkge1xyXG4gICAgICB0aGlzLmNicy5vbmRpcmFyZyh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XHJcbiAgICAgIHRoaXMuaGFuZGxlQXR0ck5hbWVFbmQoYyk7XHJcbiAgICB9IGVsc2UgaWYgKGMgPT09IDkxKSB7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSAxNTtcclxuICAgIH0gZWxzZSBpZiAoYyA9PT0gNDYpIHtcclxuICAgICAgdGhpcy5jYnMub25kaXJhcmcodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpO1xyXG4gICAgICB0aGlzLnN0YXRlID0gMTY7XHJcbiAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHN0YXRlSW5EeW5hbWljRGlyQXJnKGMpIHtcclxuICAgIGlmIChjID09PSA5Mykge1xyXG4gICAgICB0aGlzLnN0YXRlID0gMTQ7XHJcbiAgICB9IGVsc2UgaWYgKGMgPT09IDYxIHx8IGlzRW5kT2ZUYWdTZWN0aW9uKGMpKSB7XHJcbiAgICAgIHRoaXMuY2JzLm9uZGlyYXJnKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4ICsgMSk7XHJcbiAgICAgIHRoaXMuaGFuZGxlQXR0ck5hbWVFbmQoYyk7XHJcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IGZhbHNlKSB7XHJcbiAgICAgICAgdGhpcy5jYnMub25lcnIoXHJcbiAgICAgICAgICAyNyxcclxuICAgICAgICAgIHRoaXMuaW5kZXhcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHN0YXRlSW5EaXJNb2RpZmllcihjKSB7XHJcbiAgICBpZiAoYyA9PT0gNjEgfHwgaXNFbmRPZlRhZ1NlY3Rpb24oYykpIHtcclxuICAgICAgdGhpcy5jYnMub25kaXJtb2RpZmllcih0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XHJcbiAgICAgIHRoaXMuaGFuZGxlQXR0ck5hbWVFbmQoYyk7XHJcbiAgICB9IGVsc2UgaWYgKGMgPT09IDQ2KSB7XHJcbiAgICAgIHRoaXMuY2JzLm9uZGlybW9kaWZpZXIodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpO1xyXG4gICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxO1xyXG4gICAgfVxyXG4gIH1cclxuICBoYW5kbGVBdHRyTmFtZUVuZChjKSB7XHJcbiAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXg7XHJcbiAgICB0aGlzLnN0YXRlID0gMTc7XHJcbiAgICB0aGlzLmNicy5vbmF0dHJpYm5hbWVlbmQodGhpcy5pbmRleCk7XHJcbiAgICB0aGlzLnN0YXRlQWZ0ZXJBdHRyTmFtZShjKTtcclxuICB9XHJcbiAgc3RhdGVBZnRlckF0dHJOYW1lKGMpIHtcclxuICAgIGlmIChjID09PSA2MSkge1xyXG4gICAgICB0aGlzLnN0YXRlID0gMTg7XHJcbiAgICB9IGVsc2UgaWYgKGMgPT09IDQ3IHx8IGMgPT09IDYyKSB7XHJcbiAgICAgIHRoaXMuY2JzLm9uYXR0cmliZW5kKDAsIHRoaXMuc2VjdGlvblN0YXJ0KTtcclxuICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSAtMTtcclxuICAgICAgdGhpcy5zdGF0ZSA9IDExO1xyXG4gICAgICB0aGlzLnN0YXRlQmVmb3JlQXR0ck5hbWUoYyk7XHJcbiAgICB9IGVsc2UgaWYgKCFpc1doaXRlc3BhY2UoYykpIHtcclxuICAgICAgdGhpcy5jYnMub25hdHRyaWJlbmQoMCwgdGhpcy5zZWN0aW9uU3RhcnQpO1xyXG4gICAgICB0aGlzLmhhbmRsZUF0dHJTdGFydChjKTtcclxuICAgIH1cclxuICB9XHJcbiAgc3RhdGVCZWZvcmVBdHRyVmFsdWUoYykge1xyXG4gICAgaWYgKGMgPT09IDM0KSB7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSAxOTtcclxuICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcclxuICAgIH0gZWxzZSBpZiAoYyA9PT0gMzkpIHtcclxuICAgICAgdGhpcy5zdGF0ZSA9IDIwO1xyXG4gICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxO1xyXG4gICAgfSBlbHNlIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XHJcbiAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleDtcclxuICAgICAgdGhpcy5zdGF0ZSA9IDIxO1xyXG4gICAgICB0aGlzLnN0YXRlSW5BdHRyVmFsdWVOb1F1b3RlcyhjKTtcclxuICAgIH1cclxuICB9XHJcbiAgaGFuZGxlSW5BdHRyVmFsdWUoYywgcXVvdGUpIHtcclxuICAgIGlmIChjID09PSBxdW90ZSB8fCB0aGlzLmZhc3RGb3J3YXJkVG8ocXVvdGUpKSB7XHJcbiAgICAgIHRoaXMuY2JzLm9uYXR0cmliZGF0YSh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XHJcbiAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gLTE7XHJcbiAgICAgIHRoaXMuY2JzLm9uYXR0cmliZW5kKFxyXG4gICAgICAgIHF1b3RlID09PSAzNCA/IDMgOiAyLFxyXG4gICAgICAgIHRoaXMuaW5kZXggKyAxXHJcbiAgICAgICk7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSAxMTtcclxuICAgIH1cclxuICB9XHJcbiAgc3RhdGVJbkF0dHJWYWx1ZURvdWJsZVF1b3RlcyhjKSB7XHJcbiAgICB0aGlzLmhhbmRsZUluQXR0clZhbHVlKGMsIDM0KTtcclxuICB9XHJcbiAgc3RhdGVJbkF0dHJWYWx1ZVNpbmdsZVF1b3RlcyhjKSB7XHJcbiAgICB0aGlzLmhhbmRsZUluQXR0clZhbHVlKGMsIDM5KTtcclxuICB9XHJcbiAgc3RhdGVJbkF0dHJWYWx1ZU5vUXVvdGVzKGMpIHtcclxuICAgIGlmIChpc1doaXRlc3BhY2UoYykgfHwgYyA9PT0gNjIpIHtcclxuICAgICAgdGhpcy5jYnMub25hdHRyaWJkYXRhKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcclxuICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSAtMTtcclxuICAgICAgdGhpcy5jYnMub25hdHRyaWJlbmQoMSwgdGhpcy5pbmRleCk7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSAxMTtcclxuICAgICAgdGhpcy5zdGF0ZUJlZm9yZUF0dHJOYW1lKGMpO1xyXG4gICAgfSBlbHNlIGlmICgoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBmYWxzZSkgJiYgYyA9PT0gMzQgfHwgYyA9PT0gMzkgfHwgYyA9PT0gNjAgfHwgYyA9PT0gNjEgfHwgYyA9PT0gOTYpIHtcclxuICAgICAgdGhpcy5jYnMub25lcnIoXHJcbiAgICAgICAgMTgsXHJcbiAgICAgICAgdGhpcy5pbmRleFxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIDtcclxuICB9XHJcbiAgc3RhdGVCZWZvcmVEZWNsYXJhdGlvbihjKSB7XHJcbiAgICBpZiAoYyA9PT0gOTEpIHtcclxuICAgICAgdGhpcy5zdGF0ZSA9IDI2O1xyXG4gICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAwO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5zdGF0ZSA9IGMgPT09IDQ1ID8gMjUgOiAyMztcclxuICAgIH1cclxuICB9XHJcbiAgc3RhdGVJbkRlY2xhcmF0aW9uKGMpIHtcclxuICAgIGlmIChjID09PSA2MiB8fCB0aGlzLmZhc3RGb3J3YXJkVG8oNjIpKSB7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSAxO1xyXG4gICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxO1xyXG4gICAgfVxyXG4gIH1cclxuICBzdGF0ZUluUHJvY2Vzc2luZ0luc3RydWN0aW9uKGMpIHtcclxuICAgIGlmIChjID09PSA2MiB8fCB0aGlzLmZhc3RGb3J3YXJkVG8oNjIpKSB7XHJcbiAgICAgIHRoaXMuY2JzLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcclxuICAgICAgdGhpcy5zdGF0ZSA9IDE7XHJcbiAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHN0YXRlQmVmb3JlQ29tbWVudChjKSB7XHJcbiAgICBpZiAoYyA9PT0gNDUpIHtcclxuICAgICAgdGhpcy5zdGF0ZSA9IDI4O1xyXG4gICAgICB0aGlzLmN1cnJlbnRTZXF1ZW5jZSA9IFNlcXVlbmNlcy5Db21tZW50RW5kO1xyXG4gICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAyO1xyXG4gICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5zdGF0ZSA9IDIzO1xyXG4gICAgfVxyXG4gIH1cclxuICBzdGF0ZUluU3BlY2lhbENvbW1lbnQoYykge1xyXG4gICAgaWYgKGMgPT09IDYyIHx8IHRoaXMuZmFzdEZvcndhcmRUbyg2MikpIHtcclxuICAgICAgdGhpcy5jYnMub25jb21tZW50KHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcclxuICAgICAgdGhpcy5zdGF0ZSA9IDE7XHJcbiAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHN0YXRlQmVmb3JlU3BlY2lhbFMoYykge1xyXG4gICAgaWYgKGMgPT09IFNlcXVlbmNlcy5TY3JpcHRFbmRbM10pIHtcclxuICAgICAgdGhpcy5zdGFydFNwZWNpYWwoU2VxdWVuY2VzLlNjcmlwdEVuZCwgNCk7XHJcbiAgICB9IGVsc2UgaWYgKGMgPT09IFNlcXVlbmNlcy5TdHlsZUVuZFszXSkge1xyXG4gICAgICB0aGlzLnN0YXJ0U3BlY2lhbChTZXF1ZW5jZXMuU3R5bGVFbmQsIDQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5zdGF0ZSA9IDY7XHJcbiAgICAgIHRoaXMuc3RhdGVJblRhZ05hbWUoYyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHN0YXRlQmVmb3JlU3BlY2lhbFQoYykge1xyXG4gICAgaWYgKGMgPT09IFNlcXVlbmNlcy5UaXRsZUVuZFszXSkge1xyXG4gICAgICB0aGlzLnN0YXJ0U3BlY2lhbChTZXF1ZW5jZXMuVGl0bGVFbmQsIDQpO1xyXG4gICAgfSBlbHNlIGlmIChjID09PSBTZXF1ZW5jZXMuVGV4dGFyZWFFbmRbM10pIHtcclxuICAgICAgdGhpcy5zdGFydFNwZWNpYWwoU2VxdWVuY2VzLlRleHRhcmVhRW5kLCA0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSA2O1xyXG4gICAgICB0aGlzLnN0YXRlSW5UYWdOYW1lKGMpO1xyXG4gICAgfVxyXG4gIH1cclxuICBzdGFydEVudGl0eSgpIHtcclxuICB9XHJcbiAgc3RhdGVJbkVudGl0eSgpIHtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogSXRlcmF0ZXMgdGhyb3VnaCB0aGUgYnVmZmVyLCBjYWxsaW5nIHRoZSBmdW5jdGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBjdXJyZW50IHN0YXRlLlxyXG4gICAqXHJcbiAgICogU3RhdGVzIHRoYXQgYXJlIG1vcmUgbGlrZWx5IHRvIGJlIGhpdCBhcmUgaGlnaGVyIHVwLCBhcyBhIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50LlxyXG4gICAqL1xyXG4gIHBhcnNlKGlucHV0KSB7XHJcbiAgICB0aGlzLmJ1ZmZlciA9IGlucHV0O1xyXG4gICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcclxuICAgICAgY29uc3QgYyA9IHRoaXMuYnVmZmVyLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XHJcbiAgICAgIGlmIChjID09PSAxMCkge1xyXG4gICAgICAgIHRoaXMubmV3bGluZXMucHVzaCh0aGlzLmluZGV4KTtcclxuICAgICAgfVxyXG4gICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcclxuICAgICAgICBjYXNlIDE6IHtcclxuICAgICAgICAgIHRoaXMuc3RhdGVUZXh0KGMpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgMjoge1xyXG4gICAgICAgICAgdGhpcy5zdGF0ZUludGVycG9sYXRpb25PcGVuKGMpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgMzoge1xyXG4gICAgICAgICAgdGhpcy5zdGF0ZUludGVycG9sYXRpb24oYyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSA0OiB7XHJcbiAgICAgICAgICB0aGlzLnN0YXRlSW50ZXJwb2xhdGlvbkNsb3NlKGMpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgMzE6IHtcclxuICAgICAgICAgIHRoaXMuc3RhdGVTcGVjaWFsU3RhcnRTZXF1ZW5jZShjKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIDMyOiB7XHJcbiAgICAgICAgICB0aGlzLnN0YXRlSW5SQ0RBVEEoYyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAyNjoge1xyXG4gICAgICAgICAgdGhpcy5zdGF0ZUNEQVRBU2VxdWVuY2UoYyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAxOToge1xyXG4gICAgICAgICAgdGhpcy5zdGF0ZUluQXR0clZhbHVlRG91YmxlUXVvdGVzKGMpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgMTI6IHtcclxuICAgICAgICAgIHRoaXMuc3RhdGVJbkF0dHJOYW1lKGMpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgMTM6IHtcclxuICAgICAgICAgIHRoaXMuc3RhdGVJbkRpck5hbWUoYyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAxNDoge1xyXG4gICAgICAgICAgdGhpcy5zdGF0ZUluRGlyQXJnKGMpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgMTU6IHtcclxuICAgICAgICAgIHRoaXMuc3RhdGVJbkR5bmFtaWNEaXJBcmcoYyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAxNjoge1xyXG4gICAgICAgICAgdGhpcy5zdGF0ZUluRGlyTW9kaWZpZXIoYyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAyODoge1xyXG4gICAgICAgICAgdGhpcy5zdGF0ZUluQ29tbWVudExpa2UoYyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAyNzoge1xyXG4gICAgICAgICAgdGhpcy5zdGF0ZUluU3BlY2lhbENvbW1lbnQoYyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAxMToge1xyXG4gICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZUF0dHJOYW1lKGMpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgNjoge1xyXG4gICAgICAgICAgdGhpcy5zdGF0ZUluVGFnTmFtZShjKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIDM0OiB7XHJcbiAgICAgICAgICB0aGlzLnN0YXRlSW5TRkNSb290VGFnTmFtZShjKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIDk6IHtcclxuICAgICAgICAgIHRoaXMuc3RhdGVJbkNsb3NpbmdUYWdOYW1lKGMpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgNToge1xyXG4gICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZVRhZ05hbWUoYyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAxNzoge1xyXG4gICAgICAgICAgdGhpcy5zdGF0ZUFmdGVyQXR0ck5hbWUoYyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAyMDoge1xyXG4gICAgICAgICAgdGhpcy5zdGF0ZUluQXR0clZhbHVlU2luZ2xlUXVvdGVzKGMpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgMTg6IHtcclxuICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVBdHRyVmFsdWUoYyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSA4OiB7XHJcbiAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlQ2xvc2luZ1RhZ05hbWUoYyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAxMDoge1xyXG4gICAgICAgICAgdGhpcy5zdGF0ZUFmdGVyQ2xvc2luZ1RhZ05hbWUoYyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAyOToge1xyXG4gICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZVNwZWNpYWxTKGMpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgMzA6IHtcclxuICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVTcGVjaWFsVChjKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIDIxOiB7XHJcbiAgICAgICAgICB0aGlzLnN0YXRlSW5BdHRyVmFsdWVOb1F1b3RlcyhjKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIDc6IHtcclxuICAgICAgICAgIHRoaXMuc3RhdGVJblNlbGZDbG9zaW5nVGFnKGMpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgMjM6IHtcclxuICAgICAgICAgIHRoaXMuc3RhdGVJbkRlY2xhcmF0aW9uKGMpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgMjI6IHtcclxuICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVEZWNsYXJhdGlvbihjKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIDI1OiB7XHJcbiAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlQ29tbWVudChjKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIDI0OiB7XHJcbiAgICAgICAgICB0aGlzLnN0YXRlSW5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oYyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAzMzoge1xyXG4gICAgICAgICAgdGhpcy5zdGF0ZUluRW50aXR5KCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5pbmRleCsrO1xyXG4gICAgfVxyXG4gICAgdGhpcy5jbGVhbnVwKCk7XHJcbiAgICB0aGlzLmZpbmlzaCgpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBSZW1vdmUgZGF0YSB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gY29uc3VtZWQgZnJvbSB0aGUgYnVmZmVyLlxyXG4gICAqL1xyXG4gIGNsZWFudXAoKSB7XHJcbiAgICBpZiAodGhpcy5zZWN0aW9uU3RhcnQgIT09IHRoaXMuaW5kZXgpIHtcclxuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IDEgfHwgdGhpcy5zdGF0ZSA9PT0gMzIgJiYgdGhpcy5zZXF1ZW5jZUluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgdGhpcy5jYnMub250ZXh0KHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcclxuICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXg7XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gMTkgfHwgdGhpcy5zdGF0ZSA9PT0gMjAgfHwgdGhpcy5zdGF0ZSA9PT0gMjEpIHtcclxuICAgICAgICB0aGlzLmNicy5vbmF0dHJpYmRhdGEodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpO1xyXG4gICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBmaW5pc2goKSB7XHJcbiAgICB0aGlzLmhhbmRsZVRyYWlsaW5nRGF0YSgpO1xyXG4gICAgdGhpcy5jYnMub25lbmQoKTtcclxuICB9XHJcbiAgLyoqIEhhbmRsZSBhbnkgdHJhaWxpbmcgZGF0YS4gKi9cclxuICBoYW5kbGVUcmFpbGluZ0RhdGEoKSB7XHJcbiAgICBjb25zdCBlbmRJbmRleCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcclxuICAgIGlmICh0aGlzLnNlY3Rpb25TdGFydCA+PSBlbmRJbmRleCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gMjgpIHtcclxuICAgICAgaWYgKHRoaXMuY3VycmVudFNlcXVlbmNlID09PSBTZXF1ZW5jZXMuQ2RhdGFFbmQpIHtcclxuICAgICAgICB0aGlzLmNicy5vbmNkYXRhKHRoaXMuc2VjdGlvblN0YXJ0LCBlbmRJbmRleCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5jYnMub25jb21tZW50KHRoaXMuc2VjdGlvblN0YXJ0LCBlbmRJbmRleCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gNiB8fCB0aGlzLnN0YXRlID09PSAxMSB8fCB0aGlzLnN0YXRlID09PSAxOCB8fCB0aGlzLnN0YXRlID09PSAxNyB8fCB0aGlzLnN0YXRlID09PSAxMiB8fCB0aGlzLnN0YXRlID09PSAxMyB8fCB0aGlzLnN0YXRlID09PSAxNCB8fCB0aGlzLnN0YXRlID09PSAxNSB8fCB0aGlzLnN0YXRlID09PSAxNiB8fCB0aGlzLnN0YXRlID09PSAyMCB8fCB0aGlzLnN0YXRlID09PSAxOSB8fCB0aGlzLnN0YXRlID09PSAyMSB8fCB0aGlzLnN0YXRlID09PSA5KSA7IGVsc2Uge1xyXG4gICAgICB0aGlzLmNicy5vbnRleHQodGhpcy5zZWN0aW9uU3RhcnQsIGVuZEluZGV4KTtcclxuICAgIH1cclxuICB9XHJcbiAgZW1pdENvZGVQb2ludChjcCwgY29uc3VtZWQpIHtcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IENvbXBpbGVyRGVwcmVjYXRpb25UeXBlcyA9IHtcclxuICBcIkNPTVBJTEVSX0lTX09OX0VMRU1FTlRcIjogXCJDT01QSUxFUl9JU19PTl9FTEVNRU5UXCIsXHJcbiAgXCJDT01QSUxFUl9WX0JJTkRfU1lOQ1wiOiBcIkNPTVBJTEVSX1ZfQklORF9TWU5DXCIsXHJcbiAgXCJDT01QSUxFUl9WX0JJTkRfT0JKRUNUX09SREVSXCI6IFwiQ09NUElMRVJfVl9CSU5EX09CSkVDVF9PUkRFUlwiLFxyXG4gIFwiQ09NUElMRVJfVl9PTl9OQVRJVkVcIjogXCJDT01QSUxFUl9WX09OX05BVElWRVwiLFxyXG4gIFwiQ09NUElMRVJfVl9JRl9WX0ZPUl9QUkVDRURFTkNFXCI6IFwiQ09NUElMRVJfVl9JRl9WX0ZPUl9QUkVDRURFTkNFXCIsXHJcbiAgXCJDT01QSUxFUl9OQVRJVkVfVEVNUExBVEVcIjogXCJDT01QSUxFUl9OQVRJVkVfVEVNUExBVEVcIixcclxuICBcIkNPTVBJTEVSX0lOTElORV9URU1QTEFURVwiOiBcIkNPTVBJTEVSX0lOTElORV9URU1QTEFURVwiLFxyXG4gIFwiQ09NUElMRVJfRklMVEVSU1wiOiBcIkNPTVBJTEVSX0ZJTFRFUlNcIlxyXG59O1xyXG5jb25zdCBkZXByZWNhdGlvbkRhdGEgPSB7XHJcbiAgW1wiQ09NUElMRVJfSVNfT05fRUxFTUVOVFwiXToge1xyXG4gICAgbWVzc2FnZTogYFBsYXRmb3JtLW5hdGl2ZSBlbGVtZW50cyB3aXRoIFwiaXNcIiBwcm9wIHdpbGwgbm8gbG9uZ2VyIGJlIHRyZWF0ZWQgYXMgY29tcG9uZW50cyBpbiBWdWUgMyB1bmxlc3MgdGhlIFwiaXNcIiB2YWx1ZSBpcyBleHBsaWNpdGx5IHByZWZpeGVkIHdpdGggXCJ2dWU6XCIuYCxcclxuICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy9jdXN0b20tZWxlbWVudHMtaW50ZXJvcC5odG1sYFxyXG4gIH0sXHJcbiAgW1wiQ09NUElMRVJfVl9CSU5EX1NZTkNcIl06IHtcclxuICAgIG1lc3NhZ2U6IChrZXkpID0+IGAuc3luYyBtb2RpZmllciBmb3Igdi1iaW5kIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2LW1vZGVsIHdpdGggYXJndW1lbnQgaW5zdGVhZC4gXFxgdi1iaW5kOiR7a2V5fS5zeW5jXFxgIHNob3VsZCBiZSBjaGFuZ2VkIHRvIFxcYHYtbW9kZWw6JHtrZXl9XFxgLmAsXHJcbiAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvdi1tb2RlbC5odG1sYFxyXG4gIH0sXHJcbiAgW1wiQ09NUElMRVJfVl9CSU5EX09CSkVDVF9PUkRFUlwiXToge1xyXG4gICAgbWVzc2FnZTogYHYtYmluZD1cIm9ialwiIHVzYWdlIGlzIG5vdyBvcmRlciBzZW5zaXRpdmUgYW5kIGJlaGF2ZXMgbGlrZSBKYXZhU2NyaXB0IG9iamVjdCBzcHJlYWQ6IGl0IHdpbGwgbm93IG92ZXJ3cml0ZSBhbiBleGlzdGluZyBub24tbWVyZ2VhYmxlIGF0dHJpYnV0ZSB0aGF0IGFwcGVhcnMgYmVmb3JlIHYtYmluZCBpbiB0aGUgY2FzZSBvZiBjb25mbGljdC4gVG8gcmV0YWluIDIueCBiZWhhdmlvciwgbW92ZSB2LWJpbmQgdG8gbWFrZSBpdCB0aGUgZmlyc3QgYXR0cmlidXRlLiBZb3UgY2FuIGFsc28gc3VwcHJlc3MgdGhpcyB3YXJuaW5nIGlmIHRoZSB1c2FnZSBpcyBpbnRlbmRlZC5gLFxyXG4gICAgbGluazogYGh0dHBzOi8vdjMtbWlncmF0aW9uLnZ1ZWpzLm9yZy9icmVha2luZy1jaGFuZ2VzL3YtYmluZC5odG1sYFxyXG4gIH0sXHJcbiAgW1wiQ09NUElMRVJfVl9PTl9OQVRJVkVcIl06IHtcclxuICAgIG1lc3NhZ2U6IGAubmF0aXZlIG1vZGlmaWVyIGZvciB2LW9uIGhhcyBiZWVuIHJlbW92ZWQgYXMgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeS5gLFxyXG4gICAgbGluazogYGh0dHBzOi8vdjMtbWlncmF0aW9uLnZ1ZWpzLm9yZy9icmVha2luZy1jaGFuZ2VzL3Ytb24tbmF0aXZlLW1vZGlmaWVyLXJlbW92ZWQuaHRtbGBcclxuICB9LFxyXG4gIFtcIkNPTVBJTEVSX1ZfSUZfVl9GT1JfUFJFQ0VERU5DRVwiXToge1xyXG4gICAgbWVzc2FnZTogYHYtaWYgLyB2LWZvciBwcmVjZWRlbmNlIHdoZW4gdXNlZCBvbiB0aGUgc2FtZSBlbGVtZW50IGhhcyBjaGFuZ2VkIGluIFZ1ZSAzOiB2LWlmIG5vdyB0YWtlcyBoaWdoZXIgcHJlY2VkZW5jZSBhbmQgd2lsbCBubyBsb25nZXIgaGF2ZSBhY2Nlc3MgdG8gdi1mb3Igc2NvcGUgdmFyaWFibGVzLiBJdCBpcyBiZXN0IHRvIGF2b2lkIHRoZSBhbWJpZ3VpdHkgd2l0aCA8dGVtcGxhdGU+IHRhZ3Mgb3IgdXNlIGEgY29tcHV0ZWQgcHJvcGVydHkgdGhhdCBmaWx0ZXJzIHYtZm9yIGRhdGEgc291cmNlLmAsXHJcbiAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvdi1pZi12LWZvci5odG1sYFxyXG4gIH0sXHJcbiAgW1wiQ09NUElMRVJfTkFUSVZFX1RFTVBMQVRFXCJdOiB7XHJcbiAgICBtZXNzYWdlOiBgPHRlbXBsYXRlPiB3aXRoIG5vIHNwZWNpYWwgZGlyZWN0aXZlcyB3aWxsIHJlbmRlciBhcyBhIG5hdGl2ZSB0ZW1wbGF0ZSBlbGVtZW50IGluc3RlYWQgb2YgaXRzIGlubmVyIGNvbnRlbnQgaW4gVnVlIDMuYFxyXG4gIH0sXHJcbiAgW1wiQ09NUElMRVJfSU5MSU5FX1RFTVBMQVRFXCJdOiB7XHJcbiAgICBtZXNzYWdlOiBgXCJpbmxpbmUtdGVtcGxhdGVcIiBoYXMgYmVlbiByZW1vdmVkIGluIFZ1ZSAzLmAsXHJcbiAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvaW5saW5lLXRlbXBsYXRlLWF0dHJpYnV0ZS5odG1sYFxyXG4gIH0sXHJcbiAgW1wiQ09NUElMRVJfRklMVEVSU1wiXToge1xyXG4gICAgbWVzc2FnZTogYGZpbHRlcnMgaGF2ZSBiZWVuIHJlbW92ZWQgaW4gVnVlIDMuIFRoZSBcInxcIiBzeW1ib2wgd2lsbCBiZSB0cmVhdGVkIGFzIG5hdGl2ZSBKYXZhU2NyaXB0IGJpdHdpc2UgT1Igb3BlcmF0b3IuIFVzZSBtZXRob2QgY2FsbHMgb3IgY29tcHV0ZWQgcHJvcGVydGllcyBpbnN0ZWFkLmAsXHJcbiAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvZmlsdGVycy5odG1sYFxyXG4gIH1cclxufTtcclxuZnVuY3Rpb24gZ2V0Q29tcGF0VmFsdWUoa2V5LCB7IGNvbXBhdENvbmZpZyB9KSB7XHJcbiAgY29uc3QgdmFsdWUgPSBjb21wYXRDb25maWcgJiYgY29tcGF0Q29uZmlnW2tleV07XHJcbiAgaWYgKGtleSA9PT0gXCJNT0RFXCIpIHtcclxuICAgIHJldHVybiB2YWx1ZSB8fCAzO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzQ29tcGF0RW5hYmxlZChrZXksIGNvbnRleHQpIHtcclxuICBjb25zdCBtb2RlID0gZ2V0Q29tcGF0VmFsdWUoXCJNT0RFXCIsIGNvbnRleHQpO1xyXG4gIGNvbnN0IHZhbHVlID0gZ2V0Q29tcGF0VmFsdWUoa2V5LCBjb250ZXh0KTtcclxuICByZXR1cm4gbW9kZSA9PT0gMyA/IHZhbHVlID09PSB0cnVlIDogdmFsdWUgIT09IGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrQ29tcGF0RW5hYmxlZChrZXksIGNvbnRleHQsIGxvYywgLi4uYXJncykge1xyXG4gIGNvbnN0IGVuYWJsZWQgPSBpc0NvbXBhdEVuYWJsZWQoa2V5LCBjb250ZXh0KTtcclxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBlbmFibGVkKSB7XHJcbiAgICB3YXJuRGVwcmVjYXRpb24oa2V5LCBjb250ZXh0LCBsb2MsIC4uLmFyZ3MpO1xyXG4gIH1cclxuICByZXR1cm4gZW5hYmxlZDtcclxufVxyXG5mdW5jdGlvbiB3YXJuRGVwcmVjYXRpb24oa2V5LCBjb250ZXh0LCBsb2MsIC4uLmFyZ3MpIHtcclxuICBjb25zdCB2YWwgPSBnZXRDb21wYXRWYWx1ZShrZXksIGNvbnRleHQpO1xyXG4gIGlmICh2YWwgPT09IFwic3VwcHJlc3Mtd2FybmluZ1wiKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGNvbnN0IHsgbWVzc2FnZSwgbGluayB9ID0gZGVwcmVjYXRpb25EYXRhW2tleV07XHJcbiAgY29uc3QgbXNnID0gYChkZXByZWNhdGlvbiAke2tleX0pICR7dHlwZW9mIG1lc3NhZ2UgPT09IFwiZnVuY3Rpb25cIiA/IG1lc3NhZ2UoLi4uYXJncykgOiBtZXNzYWdlfSR7bGluayA/IGBcclxuICBEZXRhaWxzOiAke2xpbmt9YCA6IGBgfWA7XHJcbiAgY29uc3QgZXJyID0gbmV3IFN5bnRheEVycm9yKG1zZyk7XHJcbiAgZXJyLmNvZGUgPSBrZXk7XHJcbiAgaWYgKGxvYykgZXJyLmxvYyA9IGxvYztcclxuICBjb250ZXh0Lm9uV2FybihlcnIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZhdWx0T25FcnJvcihlcnJvcikge1xyXG4gIHRocm93IGVycm9yO1xyXG59XHJcbmZ1bmN0aW9uIGRlZmF1bHRPbldhcm4obXNnKSB7XHJcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjb25zb2xlLndhcm4oYFtWdWUgd2Fybl0gJHttc2cubWVzc2FnZX1gKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlckVycm9yKGNvZGUsIGxvYywgbWVzc2FnZXMsIGFkZGl0aW9uYWxNZXNzYWdlKSB7XHJcbiAgY29uc3QgbXNnID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBmYWxzZSA/IChtZXNzYWdlcyB8fCBlcnJvck1lc3NhZ2VzKVtjb2RlXSArIChhZGRpdGlvbmFsTWVzc2FnZSB8fCBgYCkgOiBgaHR0cHM6Ly92dWVqcy5vcmcvZXJyb3ItcmVmZXJlbmNlLyNjb21waWxlci0ke2NvZGV9YDtcclxuICBjb25zdCBlcnJvciA9IG5ldyBTeW50YXhFcnJvcihTdHJpbmcobXNnKSk7XHJcbiAgZXJyb3IuY29kZSA9IGNvZGU7XHJcbiAgZXJyb3IubG9jID0gbG9jO1xyXG4gIHJldHVybiBlcnJvcjtcclxufVxyXG5jb25zdCBFcnJvckNvZGVzID0ge1xyXG4gIFwiQUJSVVBUX0NMT1NJTkdfT0ZfRU1QVFlfQ09NTUVOVFwiOiAwLFxyXG4gIFwiMFwiOiBcIkFCUlVQVF9DTE9TSU5HX09GX0VNUFRZX0NPTU1FTlRcIixcclxuICBcIkNEQVRBX0lOX0hUTUxfQ09OVEVOVFwiOiAxLFxyXG4gIFwiMVwiOiBcIkNEQVRBX0lOX0hUTUxfQ09OVEVOVFwiLFxyXG4gIFwiRFVQTElDQVRFX0FUVFJJQlVURVwiOiAyLFxyXG4gIFwiMlwiOiBcIkRVUExJQ0FURV9BVFRSSUJVVEVcIixcclxuICBcIkVORF9UQUdfV0lUSF9BVFRSSUJVVEVTXCI6IDMsXHJcbiAgXCIzXCI6IFwiRU5EX1RBR19XSVRIX0FUVFJJQlVURVNcIixcclxuICBcIkVORF9UQUdfV0lUSF9UUkFJTElOR19TT0xJRFVTXCI6IDQsXHJcbiAgXCI0XCI6IFwiRU5EX1RBR19XSVRIX1RSQUlMSU5HX1NPTElEVVNcIixcclxuICBcIkVPRl9CRUZPUkVfVEFHX05BTUVcIjogNSxcclxuICBcIjVcIjogXCJFT0ZfQkVGT1JFX1RBR19OQU1FXCIsXHJcbiAgXCJFT0ZfSU5fQ0RBVEFcIjogNixcclxuICBcIjZcIjogXCJFT0ZfSU5fQ0RBVEFcIixcclxuICBcIkVPRl9JTl9DT01NRU5UXCI6IDcsXHJcbiAgXCI3XCI6IFwiRU9GX0lOX0NPTU1FTlRcIixcclxuICBcIkVPRl9JTl9TQ1JJUFRfSFRNTF9DT01NRU5UX0xJS0VfVEVYVFwiOiA4LFxyXG4gIFwiOFwiOiBcIkVPRl9JTl9TQ1JJUFRfSFRNTF9DT01NRU5UX0xJS0VfVEVYVFwiLFxyXG4gIFwiRU9GX0lOX1RBR1wiOiA5LFxyXG4gIFwiOVwiOiBcIkVPRl9JTl9UQUdcIixcclxuICBcIklOQ09SUkVDVExZX0NMT1NFRF9DT01NRU5UXCI6IDEwLFxyXG4gIFwiMTBcIjogXCJJTkNPUlJFQ1RMWV9DTE9TRURfQ09NTUVOVFwiLFxyXG4gIFwiSU5DT1JSRUNUTFlfT1BFTkVEX0NPTU1FTlRcIjogMTEsXHJcbiAgXCIxMVwiOiBcIklOQ09SUkVDVExZX09QRU5FRF9DT01NRU5UXCIsXHJcbiAgXCJJTlZBTElEX0ZJUlNUX0NIQVJBQ1RFUl9PRl9UQUdfTkFNRVwiOiAxMixcclxuICBcIjEyXCI6IFwiSU5WQUxJRF9GSVJTVF9DSEFSQUNURVJfT0ZfVEFHX05BTUVcIixcclxuICBcIk1JU1NJTkdfQVRUUklCVVRFX1ZBTFVFXCI6IDEzLFxyXG4gIFwiMTNcIjogXCJNSVNTSU5HX0FUVFJJQlVURV9WQUxVRVwiLFxyXG4gIFwiTUlTU0lOR19FTkRfVEFHX05BTUVcIjogMTQsXHJcbiAgXCIxNFwiOiBcIk1JU1NJTkdfRU5EX1RBR19OQU1FXCIsXHJcbiAgXCJNSVNTSU5HX1dISVRFU1BBQ0VfQkVUV0VFTl9BVFRSSUJVVEVTXCI6IDE1LFxyXG4gIFwiMTVcIjogXCJNSVNTSU5HX1dISVRFU1BBQ0VfQkVUV0VFTl9BVFRSSUJVVEVTXCIsXHJcbiAgXCJORVNURURfQ09NTUVOVFwiOiAxNixcclxuICBcIjE2XCI6IFwiTkVTVEVEX0NPTU1FTlRcIixcclxuICBcIlVORVhQRUNURURfQ0hBUkFDVEVSX0lOX0FUVFJJQlVURV9OQU1FXCI6IDE3LFxyXG4gIFwiMTdcIjogXCJVTkVYUEVDVEVEX0NIQVJBQ1RFUl9JTl9BVFRSSUJVVEVfTkFNRVwiLFxyXG4gIFwiVU5FWFBFQ1RFRF9DSEFSQUNURVJfSU5fVU5RVU9URURfQVRUUklCVVRFX1ZBTFVFXCI6IDE4LFxyXG4gIFwiMThcIjogXCJVTkVYUEVDVEVEX0NIQVJBQ1RFUl9JTl9VTlFVT1RFRF9BVFRSSUJVVEVfVkFMVUVcIixcclxuICBcIlVORVhQRUNURURfRVFVQUxTX1NJR05fQkVGT1JFX0FUVFJJQlVURV9OQU1FXCI6IDE5LFxyXG4gIFwiMTlcIjogXCJVTkVYUEVDVEVEX0VRVUFMU19TSUdOX0JFRk9SRV9BVFRSSUJVVEVfTkFNRVwiLFxyXG4gIFwiVU5FWFBFQ1RFRF9OVUxMX0NIQVJBQ1RFUlwiOiAyMCxcclxuICBcIjIwXCI6IFwiVU5FWFBFQ1RFRF9OVUxMX0NIQVJBQ1RFUlwiLFxyXG4gIFwiVU5FWFBFQ1RFRF9RVUVTVElPTl9NQVJLX0lOU1RFQURfT0ZfVEFHX05BTUVcIjogMjEsXHJcbiAgXCIyMVwiOiBcIlVORVhQRUNURURfUVVFU1RJT05fTUFSS19JTlNURUFEX09GX1RBR19OQU1FXCIsXHJcbiAgXCJVTkVYUEVDVEVEX1NPTElEVVNfSU5fVEFHXCI6IDIyLFxyXG4gIFwiMjJcIjogXCJVTkVYUEVDVEVEX1NPTElEVVNfSU5fVEFHXCIsXHJcbiAgXCJYX0lOVkFMSURfRU5EX1RBR1wiOiAyMyxcclxuICBcIjIzXCI6IFwiWF9JTlZBTElEX0VORF9UQUdcIixcclxuICBcIlhfTUlTU0lOR19FTkRfVEFHXCI6IDI0LFxyXG4gIFwiMjRcIjogXCJYX01JU1NJTkdfRU5EX1RBR1wiLFxyXG4gIFwiWF9NSVNTSU5HX0lOVEVSUE9MQVRJT05fRU5EXCI6IDI1LFxyXG4gIFwiMjVcIjogXCJYX01JU1NJTkdfSU5URVJQT0xBVElPTl9FTkRcIixcclxuICBcIlhfTUlTU0lOR19ESVJFQ1RJVkVfTkFNRVwiOiAyNixcclxuICBcIjI2XCI6IFwiWF9NSVNTSU5HX0RJUkVDVElWRV9OQU1FXCIsXHJcbiAgXCJYX01JU1NJTkdfRFlOQU1JQ19ESVJFQ1RJVkVfQVJHVU1FTlRfRU5EXCI6IDI3LFxyXG4gIFwiMjdcIjogXCJYX01JU1NJTkdfRFlOQU1JQ19ESVJFQ1RJVkVfQVJHVU1FTlRfRU5EXCIsXHJcbiAgXCJYX1ZfSUZfTk9fRVhQUkVTU0lPTlwiOiAyOCxcclxuICBcIjI4XCI6IFwiWF9WX0lGX05PX0VYUFJFU1NJT05cIixcclxuICBcIlhfVl9JRl9TQU1FX0tFWVwiOiAyOSxcclxuICBcIjI5XCI6IFwiWF9WX0lGX1NBTUVfS0VZXCIsXHJcbiAgXCJYX1ZfRUxTRV9OT19BREpBQ0VOVF9JRlwiOiAzMCxcclxuICBcIjMwXCI6IFwiWF9WX0VMU0VfTk9fQURKQUNFTlRfSUZcIixcclxuICBcIlhfVl9GT1JfTk9fRVhQUkVTU0lPTlwiOiAzMSxcclxuICBcIjMxXCI6IFwiWF9WX0ZPUl9OT19FWFBSRVNTSU9OXCIsXHJcbiAgXCJYX1ZfRk9SX01BTEZPUk1FRF9FWFBSRVNTSU9OXCI6IDMyLFxyXG4gIFwiMzJcIjogXCJYX1ZfRk9SX01BTEZPUk1FRF9FWFBSRVNTSU9OXCIsXHJcbiAgXCJYX1ZfRk9SX1RFTVBMQVRFX0tFWV9QTEFDRU1FTlRcIjogMzMsXHJcbiAgXCIzM1wiOiBcIlhfVl9GT1JfVEVNUExBVEVfS0VZX1BMQUNFTUVOVFwiLFxyXG4gIFwiWF9WX0JJTkRfTk9fRVhQUkVTU0lPTlwiOiAzNCxcclxuICBcIjM0XCI6IFwiWF9WX0JJTkRfTk9fRVhQUkVTU0lPTlwiLFxyXG4gIFwiWF9WX09OX05PX0VYUFJFU1NJT05cIjogMzUsXHJcbiAgXCIzNVwiOiBcIlhfVl9PTl9OT19FWFBSRVNTSU9OXCIsXHJcbiAgXCJYX1ZfU0xPVF9VTkVYUEVDVEVEX0RJUkVDVElWRV9PTl9TTE9UX09VVExFVFwiOiAzNixcclxuICBcIjM2XCI6IFwiWF9WX1NMT1RfVU5FWFBFQ1RFRF9ESVJFQ1RJVkVfT05fU0xPVF9PVVRMRVRcIixcclxuICBcIlhfVl9TTE9UX01JWEVEX1NMT1RfVVNBR0VcIjogMzcsXHJcbiAgXCIzN1wiOiBcIlhfVl9TTE9UX01JWEVEX1NMT1RfVVNBR0VcIixcclxuICBcIlhfVl9TTE9UX0RVUExJQ0FURV9TTE9UX05BTUVTXCI6IDM4LFxyXG4gIFwiMzhcIjogXCJYX1ZfU0xPVF9EVVBMSUNBVEVfU0xPVF9OQU1FU1wiLFxyXG4gIFwiWF9WX1NMT1RfRVhUUkFORU9VU19ERUZBVUxUX1NMT1RfQ0hJTERSRU5cIjogMzksXHJcbiAgXCIzOVwiOiBcIlhfVl9TTE9UX0VYVFJBTkVPVVNfREVGQVVMVF9TTE9UX0NISUxEUkVOXCIsXHJcbiAgXCJYX1ZfU0xPVF9NSVNQTEFDRURcIjogNDAsXHJcbiAgXCI0MFwiOiBcIlhfVl9TTE9UX01JU1BMQUNFRFwiLFxyXG4gIFwiWF9WX01PREVMX05PX0VYUFJFU1NJT05cIjogNDEsXHJcbiAgXCI0MVwiOiBcIlhfVl9NT0RFTF9OT19FWFBSRVNTSU9OXCIsXHJcbiAgXCJYX1ZfTU9ERUxfTUFMRk9STUVEX0VYUFJFU1NJT05cIjogNDIsXHJcbiAgXCI0MlwiOiBcIlhfVl9NT0RFTF9NQUxGT1JNRURfRVhQUkVTU0lPTlwiLFxyXG4gIFwiWF9WX01PREVMX09OX1NDT1BFX1ZBUklBQkxFXCI6IDQzLFxyXG4gIFwiNDNcIjogXCJYX1ZfTU9ERUxfT05fU0NPUEVfVkFSSUFCTEVcIixcclxuICBcIlhfVl9NT0RFTF9PTl9QUk9QU1wiOiA0NCxcclxuICBcIjQ0XCI6IFwiWF9WX01PREVMX09OX1BST1BTXCIsXHJcbiAgXCJYX0lOVkFMSURfRVhQUkVTU0lPTlwiOiA0NSxcclxuICBcIjQ1XCI6IFwiWF9JTlZBTElEX0VYUFJFU1NJT05cIixcclxuICBcIlhfS0VFUF9BTElWRV9JTlZBTElEX0NISUxEUkVOXCI6IDQ2LFxyXG4gIFwiNDZcIjogXCJYX0tFRVBfQUxJVkVfSU5WQUxJRF9DSElMRFJFTlwiLFxyXG4gIFwiWF9QUkVGSVhfSURfTk9UX1NVUFBPUlRFRFwiOiA0NyxcclxuICBcIjQ3XCI6IFwiWF9QUkVGSVhfSURfTk9UX1NVUFBPUlRFRFwiLFxyXG4gIFwiWF9NT0RVTEVfTU9ERV9OT1RfU1VQUE9SVEVEXCI6IDQ4LFxyXG4gIFwiNDhcIjogXCJYX01PRFVMRV9NT0RFX05PVF9TVVBQT1JURURcIixcclxuICBcIlhfQ0FDSEVfSEFORExFUl9OT1RfU1VQUE9SVEVEXCI6IDQ5LFxyXG4gIFwiNDlcIjogXCJYX0NBQ0hFX0hBTkRMRVJfTk9UX1NVUFBPUlRFRFwiLFxyXG4gIFwiWF9TQ09QRV9JRF9OT1RfU1VQUE9SVEVEXCI6IDUwLFxyXG4gIFwiNTBcIjogXCJYX1NDT1BFX0lEX05PVF9TVVBQT1JURURcIixcclxuICBcIlhfVk5PREVfSE9PS1NcIjogNTEsXHJcbiAgXCI1MVwiOiBcIlhfVk5PREVfSE9PS1NcIixcclxuICBcIlhfVl9CSU5EX0lOVkFMSURfU0FNRV9OQU1FX0FSR1VNRU5UXCI6IDUyLFxyXG4gIFwiNTJcIjogXCJYX1ZfQklORF9JTlZBTElEX1NBTUVfTkFNRV9BUkdVTUVOVFwiLFxyXG4gIFwiX19FWFRFTkRfUE9JTlRfX1wiOiA1MyxcclxuICBcIjUzXCI6IFwiX19FWFRFTkRfUE9JTlRfX1wiXHJcbn07XHJcbmNvbnN0IGVycm9yTWVzc2FnZXMgPSB7XHJcbiAgLy8gcGFyc2UgZXJyb3JzXHJcbiAgWzBdOiBcIklsbGVnYWwgY29tbWVudC5cIixcclxuICBbMV06IFwiQ0RBVEEgc2VjdGlvbiBpcyBhbGxvd2VkIG9ubHkgaW4gWE1MIGNvbnRleHQuXCIsXHJcbiAgWzJdOiBcIkR1cGxpY2F0ZSBhdHRyaWJ1dGUuXCIsXHJcbiAgWzNdOiBcIkVuZCB0YWcgY2Fubm90IGhhdmUgYXR0cmlidXRlcy5cIixcclxuICBbNF06IFwiSWxsZWdhbCAnLycgaW4gdGFncy5cIixcclxuICBbNV06IFwiVW5leHBlY3RlZCBFT0YgaW4gdGFnLlwiLFxyXG4gIFs2XTogXCJVbmV4cGVjdGVkIEVPRiBpbiBDREFUQSBzZWN0aW9uLlwiLFxyXG4gIFs3XTogXCJVbmV4cGVjdGVkIEVPRiBpbiBjb21tZW50LlwiLFxyXG4gIFs4XTogXCJVbmV4cGVjdGVkIEVPRiBpbiBzY3JpcHQuXCIsXHJcbiAgWzldOiBcIlVuZXhwZWN0ZWQgRU9GIGluIHRhZy5cIixcclxuICBbMTBdOiBcIkluY29ycmVjdGx5IGNsb3NlZCBjb21tZW50LlwiLFxyXG4gIFsxMV06IFwiSW5jb3JyZWN0bHkgb3BlbmVkIGNvbW1lbnQuXCIsXHJcbiAgWzEyXTogXCJJbGxlZ2FsIHRhZyBuYW1lLiBVc2UgJyZsdDsnIHRvIHByaW50ICc8Jy5cIixcclxuICBbMTNdOiBcIkF0dHJpYnV0ZSB2YWx1ZSB3YXMgZXhwZWN0ZWQuXCIsXHJcbiAgWzE0XTogXCJFbmQgdGFnIG5hbWUgd2FzIGV4cGVjdGVkLlwiLFxyXG4gIFsxNV06IFwiV2hpdGVzcGFjZSB3YXMgZXhwZWN0ZWQuXCIsXHJcbiAgWzE2XTogXCJVbmV4cGVjdGVkICc8IS0tJyBpbiBjb21tZW50LlwiLFxyXG4gIFsxN106IGBBdHRyaWJ1dGUgbmFtZSBjYW5ub3QgY29udGFpbiBVKzAwMjIgKFwiKSwgVSswMDI3ICgnKSwgYW5kIFUrMDAzQyAoPCkuYCxcclxuICBbMThdOiBcIlVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZSBjYW5ub3QgY29udGFpbiBVKzAwMjIgKFxcXCIpLCBVKzAwMjcgKCcpLCBVKzAwM0MgKDwpLCBVKzAwM0QgKD0pLCBhbmQgVSswMDYwIChgKS5cIixcclxuICBbMTldOiBcIkF0dHJpYnV0ZSBuYW1lIGNhbm5vdCBzdGFydCB3aXRoICc9Jy5cIixcclxuICBbMjFdOiBcIic8PycgaXMgYWxsb3dlZCBvbmx5IGluIFhNTCBjb250ZXh0LlwiLFxyXG4gIFsyMF06IGBVbmV4cGVjdGVkIG51bGwgY2hhcmFjdGVyLmAsXHJcbiAgWzIyXTogXCJJbGxlZ2FsICcvJyBpbiB0YWdzLlwiLFxyXG4gIC8vIFZ1ZS1zcGVjaWZpYyBwYXJzZSBlcnJvcnNcclxuICBbMjNdOiBcIkludmFsaWQgZW5kIHRhZy5cIixcclxuICBbMjRdOiBcIkVsZW1lbnQgaXMgbWlzc2luZyBlbmQgdGFnLlwiLFxyXG4gIFsyNV06IFwiSW50ZXJwb2xhdGlvbiBlbmQgc2lnbiB3YXMgbm90IGZvdW5kLlwiLFxyXG4gIFsyN106IFwiRW5kIGJyYWNrZXQgZm9yIGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IHdhcyBub3QgZm91bmQuIE5vdGUgdGhhdCBkeW5hbWljIGRpcmVjdGl2ZSBhcmd1bWVudCBjYW5ub3QgY29udGFpbiBzcGFjZXMuXCIsXHJcbiAgWzI2XTogXCJMZWdhbCBkaXJlY3RpdmUgbmFtZSB3YXMgZXhwZWN0ZWQuXCIsXHJcbiAgLy8gdHJhbnNmb3JtIGVycm9yc1xyXG4gIFsyOF06IGB2LWlmL3YtZWxzZS1pZiBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICBbMjldOiBgdi1pZi9lbHNlIGJyYW5jaGVzIG11c3QgdXNlIHVuaXF1ZSBrZXlzLmAsXHJcbiAgWzMwXTogYHYtZWxzZS92LWVsc2UtaWYgaGFzIG5vIGFkamFjZW50IHYtaWYgb3Igdi1lbHNlLWlmLmAsXHJcbiAgWzMxXTogYHYtZm9yIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxyXG4gIFszMl06IGB2LWZvciBoYXMgaW52YWxpZCBleHByZXNzaW9uLmAsXHJcbiAgWzMzXTogYDx0ZW1wbGF0ZSB2LWZvcj4ga2V5IHNob3VsZCBiZSBwbGFjZWQgb24gdGhlIDx0ZW1wbGF0ZT4gdGFnLmAsXHJcbiAgWzM0XTogYHYtYmluZCBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICBbNTJdOiBgdi1iaW5kIHdpdGggc2FtZS1uYW1lIHNob3J0aGFuZCBvbmx5IGFsbG93cyBzdGF0aWMgYXJndW1lbnQuYCxcclxuICBbMzVdOiBgdi1vbiBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICBbMzZdOiBgVW5leHBlY3RlZCBjdXN0b20gZGlyZWN0aXZlIG9uIDxzbG90PiBvdXRsZXQuYCxcclxuICBbMzddOiBgTWl4ZWQgdi1zbG90IHVzYWdlIG9uIGJvdGggdGhlIGNvbXBvbmVudCBhbmQgbmVzdGVkIDx0ZW1wbGF0ZT4uIFdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIG5hbWVkIHNsb3RzLCBhbGwgc2xvdHMgc2hvdWxkIHVzZSA8dGVtcGxhdGU+IHN5bnRheCB0byBhdm9pZCBzY29wZSBhbWJpZ3VpdHkuYCxcclxuICBbMzhdOiBgRHVwbGljYXRlIHNsb3QgbmFtZXMgZm91bmQuIGAsXHJcbiAgWzM5XTogYEV4dHJhbmVvdXMgY2hpbGRyZW4gZm91bmQgd2hlbiBjb21wb25lbnQgYWxyZWFkeSBoYXMgZXhwbGljaXRseSBuYW1lZCBkZWZhdWx0IHNsb3QuIFRoZXNlIGNoaWxkcmVuIHdpbGwgYmUgaWdub3JlZC5gLFxyXG4gIFs0MF06IGB2LXNsb3QgY2FuIG9ubHkgYmUgdXNlZCBvbiBjb21wb25lbnRzIG9yIDx0ZW1wbGF0ZT4gdGFncy5gLFxyXG4gIFs0MV06IGB2LW1vZGVsIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxyXG4gIFs0Ml06IGB2LW1vZGVsIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBKYXZhU2NyaXB0IG1lbWJlciBleHByZXNzaW9uLmAsXHJcbiAgWzQzXTogYHYtbW9kZWwgY2Fubm90IGJlIHVzZWQgb24gdi1mb3Igb3Igdi1zbG90IHNjb3BlIHZhcmlhYmxlcyBiZWNhdXNlIHRoZXkgYXJlIG5vdCB3cml0YWJsZS5gLFxyXG4gIFs0NF06IGB2LW1vZGVsIGNhbm5vdCBiZSB1c2VkIG9uIGEgcHJvcCwgYmVjYXVzZSBsb2NhbCBwcm9wIGJpbmRpbmdzIGFyZSBub3Qgd3JpdGFibGUuXHJcblVzZSBhIHYtYmluZCBiaW5kaW5nIGNvbWJpbmVkIHdpdGggYSB2LW9uIGxpc3RlbmVyIHRoYXQgZW1pdHMgdXBkYXRlOnggZXZlbnQgaW5zdGVhZC5gLFxyXG4gIFs0NV06IGBFcnJvciBwYXJzaW5nIEphdmFTY3JpcHQgZXhwcmVzc2lvbjogYCxcclxuICBbNDZdOiBgPEtlZXBBbGl2ZT4gZXhwZWN0cyBleGFjdGx5IG9uZSBjaGlsZCBjb21wb25lbnQuYCxcclxuICBbNTFdOiBgQHZub2RlLSogaG9va3MgaW4gdGVtcGxhdGVzIGFyZSBubyBsb25nZXIgc3VwcG9ydGVkLiBVc2UgdGhlIHZ1ZTogcHJlZml4IGluc3RlYWQuIEZvciBleGFtcGxlLCBAdm5vZGUtbW91bnRlZCBzaG91bGQgYmUgY2hhbmdlZCB0byBAdnVlOm1vdW50ZWQuIEB2bm9kZS0qIGhvb2tzIHN1cHBvcnQgaGFzIGJlZW4gcmVtb3ZlZCBpbiAzLjQuYCxcclxuICAvLyBnZW5lcmljIGVycm9yc1xyXG4gIFs0N106IGBcInByZWZpeElkZW50aWZpZXJzXCIgb3B0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBjb21waWxlci5gLFxyXG4gIFs0OF06IGBFUyBtb2R1bGUgbW9kZSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnVpbGQgb2YgY29tcGlsZXIuYCxcclxuICBbNDldOiBgXCJjYWNoZUhhbmRsZXJzXCIgb3B0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIHdoZW4gdGhlIFwicHJlZml4SWRlbnRpZmllcnNcIiBvcHRpb24gaXMgZW5hYmxlZC5gLFxyXG4gIFs1MF06IGBcInNjb3BlSWRcIiBvcHRpb24gaXMgb25seSBzdXBwb3J0ZWQgaW4gbW9kdWxlIG1vZGUuYCxcclxuICAvLyBqdXN0IHRvIGZ1bGZpbGwgdHlwZXNcclxuICBbNTNdOiBgYFxyXG59O1xyXG5cclxuZnVuY3Rpb24gd2Fsa0lkZW50aWZpZXJzKHJvb3QsIG9uSWRlbnRpZmllciwgaW5jbHVkZUFsbCA9IGZhbHNlLCBwYXJlbnRTdGFjayA9IFtdLCBrbm93bklkcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpKSB7XHJcbiAge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBpc1JlZmVyZW5jZWRJZGVudGlmaWVyKGlkLCBwYXJlbnQsIHBhcmVudFN0YWNrKSB7XHJcbiAge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBpc0luRGVzdHJ1Y3R1cmVBc3NpZ25tZW50KHBhcmVudCwgcGFyZW50U3RhY2spIHtcclxuICBpZiAocGFyZW50ICYmIChwYXJlbnQudHlwZSA9PT0gXCJPYmplY3RQcm9wZXJ0eVwiIHx8IHBhcmVudC50eXBlID09PSBcIkFycmF5UGF0dGVyblwiKSkge1xyXG4gICAgbGV0IGkgPSBwYXJlbnRTdGFjay5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgIGNvbnN0IHAgPSBwYXJlbnRTdGFja1tpXTtcclxuICAgICAgaWYgKHAudHlwZSA9PT0gXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH0gZWxzZSBpZiAocC50eXBlICE9PSBcIk9iamVjdFByb3BlcnR5XCIgJiYgIXAudHlwZS5lbmRzV2l0aChcIlBhdHRlcm5cIikpIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaXNJbk5ld0V4cHJlc3Npb24ocGFyZW50U3RhY2spIHtcclxuICBsZXQgaSA9IHBhcmVudFN0YWNrLmxlbmd0aDtcclxuICB3aGlsZSAoaS0tKSB7XHJcbiAgICBjb25zdCBwID0gcGFyZW50U3RhY2tbaV07XHJcbiAgICBpZiAocC50eXBlID09PSBcIk5ld0V4cHJlc3Npb25cIikge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gZWxzZSBpZiAocC50eXBlICE9PSBcIk1lbWJlckV4cHJlc3Npb25cIikge1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIHdhbGtGdW5jdGlvblBhcmFtcyhub2RlLCBvbklkZW50KSB7XHJcbiAgZm9yIChjb25zdCBwIG9mIG5vZGUucGFyYW1zKSB7XHJcbiAgICBmb3IgKGNvbnN0IGlkIG9mIGV4dHJhY3RJZGVudGlmaWVycyhwKSkge1xyXG4gICAgICBvbklkZW50KGlkKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZnVuY3Rpb24gd2Fsa0Jsb2NrRGVjbGFyYXRpb25zKGJsb2NrLCBvbklkZW50KSB7XHJcbiAgZm9yIChjb25zdCBzdG10IG9mIGJsb2NrLmJvZHkpIHtcclxuICAgIGlmIChzdG10LnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKSB7XHJcbiAgICAgIGlmIChzdG10LmRlY2xhcmUpIGNvbnRpbnVlO1xyXG4gICAgICBmb3IgKGNvbnN0IGRlY2wgb2Ygc3RtdC5kZWNsYXJhdGlvbnMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGV4dHJhY3RJZGVudGlmaWVycyhkZWNsLmlkKSkge1xyXG4gICAgICAgICAgb25JZGVudChpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHN0bXQudHlwZSA9PT0gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgfHwgc3RtdC50eXBlID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIikge1xyXG4gICAgICBpZiAoc3RtdC5kZWNsYXJlIHx8ICFzdG10LmlkKSBjb250aW51ZTtcclxuICAgICAgb25JZGVudChzdG10LmlkKTtcclxuICAgIH0gZWxzZSBpZiAoaXNGb3JTdGF0ZW1lbnQoc3RtdCkpIHtcclxuICAgICAgd2Fsa0ZvclN0YXRlbWVudChzdG10LCB0cnVlLCBvbklkZW50KTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZnVuY3Rpb24gaXNGb3JTdGF0ZW1lbnQoc3RtdCkge1xyXG4gIHJldHVybiBzdG10LnR5cGUgPT09IFwiRm9yT2ZTdGF0ZW1lbnRcIiB8fCBzdG10LnR5cGUgPT09IFwiRm9ySW5TdGF0ZW1lbnRcIiB8fCBzdG10LnR5cGUgPT09IFwiRm9yU3RhdGVtZW50XCI7XHJcbn1cclxuZnVuY3Rpb24gd2Fsa0ZvclN0YXRlbWVudChzdG10LCBpc1Zhciwgb25JZGVudCkge1xyXG4gIGNvbnN0IHZhcmlhYmxlID0gc3RtdC50eXBlID09PSBcIkZvclN0YXRlbWVudFwiID8gc3RtdC5pbml0IDogc3RtdC5sZWZ0O1xyXG4gIGlmICh2YXJpYWJsZSAmJiB2YXJpYWJsZS50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiAmJiAodmFyaWFibGUua2luZCA9PT0gXCJ2YXJcIiA/IGlzVmFyIDogIWlzVmFyKSkge1xyXG4gICAgZm9yIChjb25zdCBkZWNsIG9mIHZhcmlhYmxlLmRlY2xhcmF0aW9ucykge1xyXG4gICAgICBmb3IgKGNvbnN0IGlkIG9mIGV4dHJhY3RJZGVudGlmaWVycyhkZWNsLmlkKSkge1xyXG4gICAgICAgIG9uSWRlbnQoaWQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGV4dHJhY3RJZGVudGlmaWVycyhwYXJhbSwgbm9kZXMgPSBbXSkge1xyXG4gIHN3aXRjaCAocGFyYW0udHlwZSkge1xyXG4gICAgY2FzZSBcIklkZW50aWZpZXJcIjpcclxuICAgICAgbm9kZXMucHVzaChwYXJhbSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcclxuICAgICAgbGV0IG9iamVjdCA9IHBhcmFtO1xyXG4gICAgICB3aGlsZSAob2JqZWN0LnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XHJcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0Lm9iamVjdDtcclxuICAgICAgfVxyXG4gICAgICBub2Rlcy5wdXNoKG9iamVjdCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcclxuICAgICAgZm9yIChjb25zdCBwcm9wIG9mIHBhcmFtLnByb3BlcnRpZXMpIHtcclxuICAgICAgICBpZiAocHJvcC50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpIHtcclxuICAgICAgICAgIGV4dHJhY3RJZGVudGlmaWVycyhwcm9wLmFyZ3VtZW50LCBub2Rlcyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGV4dHJhY3RJZGVudGlmaWVycyhwcm9wLnZhbHVlLCBub2Rlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxyXG4gICAgICBwYXJhbS5lbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQpIGV4dHJhY3RJZGVudGlmaWVycyhlbGVtZW50LCBub2Rlcyk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxyXG4gICAgICBleHRyYWN0SWRlbnRpZmllcnMocGFyYW0uYXJndW1lbnQsIG5vZGVzKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcclxuICAgICAgZXh0cmFjdElkZW50aWZpZXJzKHBhcmFtLmxlZnQsIG5vZGVzKTtcclxuICAgICAgYnJlYWs7XHJcbiAgfVxyXG4gIHJldHVybiBub2RlcztcclxufVxyXG5jb25zdCBpc0Z1bmN0aW9uVHlwZSA9IChub2RlKSA9PiB7XHJcbiAgcmV0dXJuIC9GdW5jdGlvbig/OkV4cHJlc3Npb258RGVjbGFyYXRpb24pJHxNZXRob2QkLy50ZXN0KG5vZGUudHlwZSk7XHJcbn07XHJcbmNvbnN0IGlzU3RhdGljUHJvcGVydHkgPSAobm9kZSkgPT4gbm9kZSAmJiAobm9kZS50eXBlID09PSBcIk9iamVjdFByb3BlcnR5XCIgfHwgbm9kZS50eXBlID09PSBcIk9iamVjdE1ldGhvZFwiKSAmJiAhbm9kZS5jb21wdXRlZDtcclxuY29uc3QgaXNTdGF0aWNQcm9wZXJ0eUtleSA9IChub2RlLCBwYXJlbnQpID0+IGlzU3RhdGljUHJvcGVydHkocGFyZW50KSAmJiBwYXJlbnQua2V5ID09PSBub2RlO1xyXG5jb25zdCBUU19OT0RFX1RZUEVTID0gW1xyXG4gIFwiVFNBc0V4cHJlc3Npb25cIixcclxuICAvLyBmb28gYXMgbnVtYmVyXHJcbiAgXCJUU1R5cGVBc3NlcnRpb25cIixcclxuICAvLyAoPG51bWJlcj5mb28pXHJcbiAgXCJUU05vbk51bGxFeHByZXNzaW9uXCIsXHJcbiAgLy8gZm9vIVxyXG4gIFwiVFNJbnN0YW50aWF0aW9uRXhwcmVzc2lvblwiLFxyXG4gIC8vIGZvbzxzdHJpbmc+XHJcbiAgXCJUU1NhdGlzZmllc0V4cHJlc3Npb25cIlxyXG4gIC8vIGZvbyBzYXRpc2ZpZXMgVFxyXG5dO1xyXG5mdW5jdGlvbiB1bndyYXBUU05vZGUobm9kZSkge1xyXG4gIGlmIChUU19OT0RFX1RZUEVTLmluY2x1ZGVzKG5vZGUudHlwZSkpIHtcclxuICAgIHJldHVybiB1bndyYXBUU05vZGUobm9kZS5leHByZXNzaW9uKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIG5vZGU7XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBpc1N0YXRpY0V4cCA9IChwKSA9PiBwLnR5cGUgPT09IDQgJiYgcC5pc1N0YXRpYztcclxuZnVuY3Rpb24gaXNDb3JlQ29tcG9uZW50KHRhZykge1xyXG4gIHN3aXRjaCAodGFnKSB7XHJcbiAgICBjYXNlIFwiVGVsZXBvcnRcIjpcclxuICAgIGNhc2UgXCJ0ZWxlcG9ydFwiOlxyXG4gICAgICByZXR1cm4gVEVMRVBPUlQ7XHJcbiAgICBjYXNlIFwiU3VzcGVuc2VcIjpcclxuICAgIGNhc2UgXCJzdXNwZW5zZVwiOlxyXG4gICAgICByZXR1cm4gU1VTUEVOU0U7XHJcbiAgICBjYXNlIFwiS2VlcEFsaXZlXCI6XHJcbiAgICBjYXNlIFwia2VlcC1hbGl2ZVwiOlxyXG4gICAgICByZXR1cm4gS0VFUF9BTElWRTtcclxuICAgIGNhc2UgXCJCYXNlVHJhbnNpdGlvblwiOlxyXG4gICAgY2FzZSBcImJhc2UtdHJhbnNpdGlvblwiOlxyXG4gICAgICByZXR1cm4gQkFTRV9UUkFOU0lUSU9OO1xyXG4gIH1cclxufVxyXG5jb25zdCBub25JZGVudGlmaWVyUkUgPSAvXlxcZHxbXlxcJFxcd1xceEEwLVxcdUZGRkZdLztcclxuY29uc3QgaXNTaW1wbGVJZGVudGlmaWVyID0gKG5hbWUpID0+ICFub25JZGVudGlmaWVyUkUudGVzdChuYW1lKTtcclxuY29uc3QgdmFsaWRGaXJzdElkZW50Q2hhclJFID0gL1tBLVphLXpfJFxceEEwLVxcdUZGRkZdLztcclxuY29uc3QgdmFsaWRJZGVudENoYXJSRSA9IC9bXFwuXFw/XFx3JFxceEEwLVxcdUZGRkZdLztcclxuY29uc3Qgd2hpdGVzcGFjZVJFID0gL1xccytbLltdXFxzKnxcXHMqWy5bXVxccysvZztcclxuY29uc3QgZ2V0RXhwU291cmNlID0gKGV4cCkgPT4gZXhwLnR5cGUgPT09IDQgPyBleHAuY29udGVudCA6IGV4cC5sb2Muc291cmNlO1xyXG5jb25zdCBpc01lbWJlckV4cHJlc3Npb25Ccm93c2VyID0gKGV4cCkgPT4ge1xyXG4gIGNvbnN0IHBhdGggPSBnZXRFeHBTb3VyY2UoZXhwKS50cmltKCkucmVwbGFjZSh3aGl0ZXNwYWNlUkUsIChzKSA9PiBzLnRyaW0oKSk7XHJcbiAgbGV0IHN0YXRlID0gMCAvKiBpbk1lbWJlckV4cCAqLztcclxuICBsZXQgc3RhdGVTdGFjayA9IFtdO1xyXG4gIGxldCBjdXJyZW50T3BlbkJyYWNrZXRDb3VudCA9IDA7XHJcbiAgbGV0IGN1cnJlbnRPcGVuUGFyZW5zQ291bnQgPSAwO1xyXG4gIGxldCBjdXJyZW50U3RyaW5nVHlwZSA9IG51bGw7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBjaGFyID0gcGF0aC5jaGFyQXQoaSk7XHJcbiAgICBzd2l0Y2ggKHN0YXRlKSB7XHJcbiAgICAgIGNhc2UgMCAvKiBpbk1lbWJlckV4cCAqLzpcclxuICAgICAgICBpZiAoY2hhciA9PT0gXCJbXCIpIHtcclxuICAgICAgICAgIHN0YXRlU3RhY2sucHVzaChzdGF0ZSk7XHJcbiAgICAgICAgICBzdGF0ZSA9IDEgLyogaW5CcmFja2V0cyAqLztcclxuICAgICAgICAgIGN1cnJlbnRPcGVuQnJhY2tldENvdW50Kys7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSBcIihcIikge1xyXG4gICAgICAgICAgc3RhdGVTdGFjay5wdXNoKHN0YXRlKTtcclxuICAgICAgICAgIHN0YXRlID0gMiAvKiBpblBhcmVucyAqLztcclxuICAgICAgICAgIGN1cnJlbnRPcGVuUGFyZW5zQ291bnQrKztcclxuICAgICAgICB9IGVsc2UgaWYgKCEoaSA9PT0gMCA/IHZhbGlkRmlyc3RJZGVudENoYXJSRSA6IHZhbGlkSWRlbnRDaGFyUkUpLnRlc3QoY2hhcikpIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMSAvKiBpbkJyYWNrZXRzICovOlxyXG4gICAgICAgIGlmIChjaGFyID09PSBgJ2AgfHwgY2hhciA9PT0gYFwiYCB8fCBjaGFyID09PSBcImBcIikge1xyXG4gICAgICAgICAgc3RhdGVTdGFjay5wdXNoKHN0YXRlKTtcclxuICAgICAgICAgIHN0YXRlID0gMyAvKiBpblN0cmluZyAqLztcclxuICAgICAgICAgIGN1cnJlbnRTdHJpbmdUeXBlID0gY2hhcjtcclxuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09IGBbYCkge1xyXG4gICAgICAgICAgY3VycmVudE9wZW5CcmFja2V0Q291bnQrKztcclxuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09IGBdYCkge1xyXG4gICAgICAgICAgaWYgKCEtLWN1cnJlbnRPcGVuQnJhY2tldENvdW50KSB7XHJcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGVTdGFjay5wb3AoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMiAvKiBpblBhcmVucyAqLzpcclxuICAgICAgICBpZiAoY2hhciA9PT0gYCdgIHx8IGNoYXIgPT09IGBcImAgfHwgY2hhciA9PT0gXCJgXCIpIHtcclxuICAgICAgICAgIHN0YXRlU3RhY2sucHVzaChzdGF0ZSk7XHJcbiAgICAgICAgICBzdGF0ZSA9IDMgLyogaW5TdHJpbmcgKi87XHJcbiAgICAgICAgICBjdXJyZW50U3RyaW5nVHlwZSA9IGNoYXI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSBgKGApIHtcclxuICAgICAgICAgIGN1cnJlbnRPcGVuUGFyZW5zQ291bnQrKztcclxuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09IGApYCkge1xyXG4gICAgICAgICAgaWYgKGkgPT09IHBhdGgubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoIS0tY3VycmVudE9wZW5QYXJlbnNDb3VudCkge1xyXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlU3RhY2sucG9wKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDMgLyogaW5TdHJpbmcgKi86XHJcbiAgICAgICAgaWYgKGNoYXIgPT09IGN1cnJlbnRTdHJpbmdUeXBlKSB7XHJcbiAgICAgICAgICBzdGF0ZSA9IHN0YXRlU3RhY2sucG9wKCk7XHJcbiAgICAgICAgICBjdXJyZW50U3RyaW5nVHlwZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gIWN1cnJlbnRPcGVuQnJhY2tldENvdW50ICYmICFjdXJyZW50T3BlblBhcmVuc0NvdW50O1xyXG59O1xyXG5jb25zdCBpc01lbWJlckV4cHJlc3Npb25Ob2RlID0gTk9PUCA7XHJcbmNvbnN0IGlzTWVtYmVyRXhwcmVzc2lvbiA9IGlzTWVtYmVyRXhwcmVzc2lvbkJyb3dzZXIgO1xyXG5jb25zdCBmbkV4cFJFID0gL15cXHMqKGFzeW5jXFxzKik/KFxcKFteKV0qP1xcKXxbXFx3JF9dKylcXHMqKDpbXj1dKyk/PT58XlxccyooYXN5bmNcXHMrKT9mdW5jdGlvbig/OlxccytbXFx3JF0rKT9cXHMqXFwoLztcclxuY29uc3QgaXNGbkV4cHJlc3Npb25Ccm93c2VyID0gKGV4cCkgPT4gZm5FeHBSRS50ZXN0KGdldEV4cFNvdXJjZShleHApKTtcclxuY29uc3QgaXNGbkV4cHJlc3Npb25Ob2RlID0gTk9PUCA7XHJcbmNvbnN0IGlzRm5FeHByZXNzaW9uID0gaXNGbkV4cHJlc3Npb25Ccm93c2VyIDtcclxuZnVuY3Rpb24gYWR2YW5jZVBvc2l0aW9uV2l0aENsb25lKHBvcywgc291cmNlLCBudW1iZXJPZkNoYXJhY3RlcnMgPSBzb3VyY2UubGVuZ3RoKSB7XHJcbiAgcmV0dXJuIGFkdmFuY2VQb3NpdGlvbldpdGhNdXRhdGlvbihcclxuICAgIHtcclxuICAgICAgb2Zmc2V0OiBwb3Mub2Zmc2V0LFxyXG4gICAgICBsaW5lOiBwb3MubGluZSxcclxuICAgICAgY29sdW1uOiBwb3MuY29sdW1uXHJcbiAgICB9LFxyXG4gICAgc291cmNlLFxyXG4gICAgbnVtYmVyT2ZDaGFyYWN0ZXJzXHJcbiAgKTtcclxufVxyXG5mdW5jdGlvbiBhZHZhbmNlUG9zaXRpb25XaXRoTXV0YXRpb24ocG9zLCBzb3VyY2UsIG51bWJlck9mQ2hhcmFjdGVycyA9IHNvdXJjZS5sZW5ndGgpIHtcclxuICBsZXQgbGluZXNDb3VudCA9IDA7XHJcbiAgbGV0IGxhc3ROZXdMaW5lUG9zID0gLTE7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkNoYXJhY3RlcnM7IGkrKykge1xyXG4gICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGkpID09PSAxMCkge1xyXG4gICAgICBsaW5lc0NvdW50Kys7XHJcbiAgICAgIGxhc3ROZXdMaW5lUG9zID0gaTtcclxuICAgIH1cclxuICB9XHJcbiAgcG9zLm9mZnNldCArPSBudW1iZXJPZkNoYXJhY3RlcnM7XHJcbiAgcG9zLmxpbmUgKz0gbGluZXNDb3VudDtcclxuICBwb3MuY29sdW1uID0gbGFzdE5ld0xpbmVQb3MgPT09IC0xID8gcG9zLmNvbHVtbiArIG51bWJlck9mQ2hhcmFjdGVycyA6IG51bWJlck9mQ2hhcmFjdGVycyAtIGxhc3ROZXdMaW5lUG9zO1xyXG4gIHJldHVybiBwb3M7XHJcbn1cclxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbXNnKSB7XHJcbiAgaWYgKCFjb25kaXRpb24pIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgYHVuZXhwZWN0ZWQgY29tcGlsZXIgY29uZGl0aW9uYCk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGZpbmREaXIobm9kZSwgbmFtZSwgYWxsb3dFbXB0eSA9IGZhbHNlKSB7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBwID0gbm9kZS5wcm9wc1tpXTtcclxuICAgIGlmIChwLnR5cGUgPT09IDcgJiYgKGFsbG93RW1wdHkgfHwgcC5leHApICYmIChpc1N0cmluZyhuYW1lKSA/IHAubmFtZSA9PT0gbmFtZSA6IG5hbWUudGVzdChwLm5hbWUpKSkge1xyXG4gICAgICByZXR1cm4gcDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZmluZFByb3Aobm9kZSwgbmFtZSwgZHluYW1pY09ubHkgPSBmYWxzZSwgYWxsb3dFbXB0eSA9IGZhbHNlKSB7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBwID0gbm9kZS5wcm9wc1tpXTtcclxuICAgIGlmIChwLnR5cGUgPT09IDYpIHtcclxuICAgICAgaWYgKGR5bmFtaWNPbmx5KSBjb250aW51ZTtcclxuICAgICAgaWYgKHAubmFtZSA9PT0gbmFtZSAmJiAocC52YWx1ZSB8fCBhbGxvd0VtcHR5KSkge1xyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHAubmFtZSA9PT0gXCJiaW5kXCIgJiYgKHAuZXhwIHx8IGFsbG93RW1wdHkpICYmIGlzU3RhdGljQXJnT2YocC5hcmcsIG5hbWUpKSB7XHJcbiAgICAgIHJldHVybiBwO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBpc1N0YXRpY0FyZ09mKGFyZywgbmFtZSkge1xyXG4gIHJldHVybiAhIShhcmcgJiYgaXNTdGF0aWNFeHAoYXJnKSAmJiBhcmcuY29udGVudCA9PT0gbmFtZSk7XHJcbn1cclxuZnVuY3Rpb24gaGFzRHluYW1pY0tleVZCaW5kKG5vZGUpIHtcclxuICByZXR1cm4gbm9kZS5wcm9wcy5zb21lKFxyXG4gICAgKHApID0+IHAudHlwZSA9PT0gNyAmJiBwLm5hbWUgPT09IFwiYmluZFwiICYmICghcC5hcmcgfHwgLy8gdi1iaW5kPVwib2JqXCJcclxuICAgIHAuYXJnLnR5cGUgIT09IDQgfHwgLy8gdi1iaW5kOltfY3R4LmZvb11cclxuICAgICFwLmFyZy5pc1N0YXRpYylcclxuICAgIC8vIHYtYmluZDpbZm9vXVxyXG4gICk7XHJcbn1cclxuZnVuY3Rpb24gaXNUZXh0JDEobm9kZSkge1xyXG4gIHJldHVybiBub2RlLnR5cGUgPT09IDUgfHwgbm9kZS50eXBlID09PSAyO1xyXG59XHJcbmZ1bmN0aW9uIGlzVlNsb3QocCkge1xyXG4gIHJldHVybiBwLnR5cGUgPT09IDcgJiYgcC5uYW1lID09PSBcInNsb3RcIjtcclxufVxyXG5mdW5jdGlvbiBpc1RlbXBsYXRlTm9kZShub2RlKSB7XHJcbiAgcmV0dXJuIG5vZGUudHlwZSA9PT0gMSAmJiBub2RlLnRhZ1R5cGUgPT09IDM7XHJcbn1cclxuZnVuY3Rpb24gaXNTbG90T3V0bGV0KG5vZGUpIHtcclxuICByZXR1cm4gbm9kZS50eXBlID09PSAxICYmIG5vZGUudGFnVHlwZSA9PT0gMjtcclxufVxyXG5jb25zdCBwcm9wc0hlbHBlclNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtOT1JNQUxJWkVfUFJPUFMsIEdVQVJEX1JFQUNUSVZFX1BST1BTXSk7XHJcbmZ1bmN0aW9uIGdldFVubm9ybWFsaXplZFByb3BzKHByb3BzLCBjYWxsUGF0aCA9IFtdKSB7XHJcbiAgaWYgKHByb3BzICYmICFpc1N0cmluZyhwcm9wcykgJiYgcHJvcHMudHlwZSA9PT0gMTQpIHtcclxuICAgIGNvbnN0IGNhbGxlZSA9IHByb3BzLmNhbGxlZTtcclxuICAgIGlmICghaXNTdHJpbmcoY2FsbGVlKSAmJiBwcm9wc0hlbHBlclNldC5oYXMoY2FsbGVlKSkge1xyXG4gICAgICByZXR1cm4gZ2V0VW5ub3JtYWxpemVkUHJvcHMoXHJcbiAgICAgICAgcHJvcHMuYXJndW1lbnRzWzBdLFxyXG4gICAgICAgIGNhbGxQYXRoLmNvbmNhdChwcm9wcylcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIFtwcm9wcywgY2FsbFBhdGhdO1xyXG59XHJcbmZ1bmN0aW9uIGluamVjdFByb3Aobm9kZSwgcHJvcCwgY29udGV4dCkge1xyXG4gIGxldCBwcm9wc1dpdGhJbmplY3Rpb247XHJcbiAgbGV0IHByb3BzID0gbm9kZS50eXBlID09PSAxMyA/IG5vZGUucHJvcHMgOiBub2RlLmFyZ3VtZW50c1syXTtcclxuICBsZXQgY2FsbFBhdGggPSBbXTtcclxuICBsZXQgcGFyZW50Q2FsbDtcclxuICBpZiAocHJvcHMgJiYgIWlzU3RyaW5nKHByb3BzKSAmJiBwcm9wcy50eXBlID09PSAxNCkge1xyXG4gICAgY29uc3QgcmV0ID0gZ2V0VW5ub3JtYWxpemVkUHJvcHMocHJvcHMpO1xyXG4gICAgcHJvcHMgPSByZXRbMF07XHJcbiAgICBjYWxsUGF0aCA9IHJldFsxXTtcclxuICAgIHBhcmVudENhbGwgPSBjYWxsUGF0aFtjYWxsUGF0aC5sZW5ndGggLSAxXTtcclxuICB9XHJcbiAgaWYgKHByb3BzID09IG51bGwgfHwgaXNTdHJpbmcocHJvcHMpKSB7XHJcbiAgICBwcm9wc1dpdGhJbmplY3Rpb24gPSBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtwcm9wXSk7XHJcbiAgfSBlbHNlIGlmIChwcm9wcy50eXBlID09PSAxNCkge1xyXG4gICAgY29uc3QgZmlyc3QgPSBwcm9wcy5hcmd1bWVudHNbMF07XHJcbiAgICBpZiAoIWlzU3RyaW5nKGZpcnN0KSAmJiBmaXJzdC50eXBlID09PSAxNSkge1xyXG4gICAgICBpZiAoIWhhc1Byb3AocHJvcCwgZmlyc3QpKSB7XHJcbiAgICAgICAgZmlyc3QucHJvcGVydGllcy51bnNoaWZ0KHByb3ApO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAocHJvcHMuY2FsbGVlID09PSBUT19IQU5ETEVSUykge1xyXG4gICAgICAgIHByb3BzV2l0aEluamVjdGlvbiA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKE1FUkdFX1BST1BTKSwgW1xyXG4gICAgICAgICAgY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihbcHJvcF0pLFxyXG4gICAgICAgICAgcHJvcHNcclxuICAgICAgICBdKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwcm9wcy5hcmd1bWVudHMudW5zaGlmdChjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtwcm9wXSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAhcHJvcHNXaXRoSW5qZWN0aW9uICYmIChwcm9wc1dpdGhJbmplY3Rpb24gPSBwcm9wcyk7XHJcbiAgfSBlbHNlIGlmIChwcm9wcy50eXBlID09PSAxNSkge1xyXG4gICAgaWYgKCFoYXNQcm9wKHByb3AsIHByb3BzKSkge1xyXG4gICAgICBwcm9wcy5wcm9wZXJ0aWVzLnVuc2hpZnQocHJvcCk7XHJcbiAgICB9XHJcbiAgICBwcm9wc1dpdGhJbmplY3Rpb24gPSBwcm9wcztcclxuICB9IGVsc2Uge1xyXG4gICAgcHJvcHNXaXRoSW5qZWN0aW9uID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoTUVSR0VfUFJPUFMpLCBbXHJcbiAgICAgIGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oW3Byb3BdKSxcclxuICAgICAgcHJvcHNcclxuICAgIF0pO1xyXG4gICAgaWYgKHBhcmVudENhbGwgJiYgcGFyZW50Q2FsbC5jYWxsZWUgPT09IEdVQVJEX1JFQUNUSVZFX1BST1BTKSB7XHJcbiAgICAgIHBhcmVudENhbGwgPSBjYWxsUGF0aFtjYWxsUGF0aC5sZW5ndGggLSAyXTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKG5vZGUudHlwZSA9PT0gMTMpIHtcclxuICAgIGlmIChwYXJlbnRDYWxsKSB7XHJcbiAgICAgIHBhcmVudENhbGwuYXJndW1lbnRzWzBdID0gcHJvcHNXaXRoSW5qZWN0aW9uO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbm9kZS5wcm9wcyA9IHByb3BzV2l0aEluamVjdGlvbjtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKHBhcmVudENhbGwpIHtcclxuICAgICAgcGFyZW50Q2FsbC5hcmd1bWVudHNbMF0gPSBwcm9wc1dpdGhJbmplY3Rpb247XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBub2RlLmFyZ3VtZW50c1syXSA9IHByb3BzV2l0aEluamVjdGlvbjtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZnVuY3Rpb24gaGFzUHJvcChwcm9wLCBwcm9wcykge1xyXG4gIGxldCByZXN1bHQgPSBmYWxzZTtcclxuICBpZiAocHJvcC5rZXkudHlwZSA9PT0gNCkge1xyXG4gICAgY29uc3QgcHJvcEtleU5hbWUgPSBwcm9wLmtleS5jb250ZW50O1xyXG4gICAgcmVzdWx0ID0gcHJvcHMucHJvcGVydGllcy5zb21lKFxyXG4gICAgICAocCkgPT4gcC5rZXkudHlwZSA9PT0gNCAmJiBwLmtleS5jb250ZW50ID09PSBwcm9wS2V5TmFtZVxyXG4gICAgKTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiB0b1ZhbGlkQXNzZXRJZChuYW1lLCB0eXBlKSB7XHJcbiAgcmV0dXJuIGBfJHt0eXBlfV8ke25hbWUucmVwbGFjZSgvW15cXHddL2csIChzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKSA9PiB7XHJcbiAgICByZXR1cm4gc2VhcmNoVmFsdWUgPT09IFwiLVwiID8gXCJfXCIgOiBuYW1lLmNoYXJDb2RlQXQocmVwbGFjZVZhbHVlKS50b1N0cmluZygpO1xyXG4gIH0pfWA7XHJcbn1cclxuZnVuY3Rpb24gaGFzU2NvcGVSZWYobm9kZSwgaWRzKSB7XHJcbiAgaWYgKCFub2RlIHx8IE9iamVjdC5rZXlzKGlkcykubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XHJcbiAgICBjYXNlIDE6XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHAgPSBub2RlLnByb3BzW2ldO1xyXG4gICAgICAgIGlmIChwLnR5cGUgPT09IDcgJiYgKGhhc1Njb3BlUmVmKHAuYXJnLCBpZHMpIHx8IGhhc1Njb3BlUmVmKHAuZXhwLCBpZHMpKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLnNvbWUoKGMpID0+IGhhc1Njb3BlUmVmKGMsIGlkcykpO1xyXG4gICAgY2FzZSAxMTpcclxuICAgICAgaWYgKGhhc1Njb3BlUmVmKG5vZGUuc291cmNlLCBpZHMpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4uc29tZSgoYykgPT4gaGFzU2NvcGVSZWYoYywgaWRzKSk7XHJcbiAgICBjYXNlIDk6XHJcbiAgICAgIHJldHVybiBub2RlLmJyYW5jaGVzLnNvbWUoKGIpID0+IGhhc1Njb3BlUmVmKGIsIGlkcykpO1xyXG4gICAgY2FzZSAxMDpcclxuICAgICAgaWYgKGhhc1Njb3BlUmVmKG5vZGUuY29uZGl0aW9uLCBpZHMpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4uc29tZSgoYykgPT4gaGFzU2NvcGVSZWYoYywgaWRzKSk7XHJcbiAgICBjYXNlIDQ6XHJcbiAgICAgIHJldHVybiAhbm9kZS5pc1N0YXRpYyAmJiBpc1NpbXBsZUlkZW50aWZpZXIobm9kZS5jb250ZW50KSAmJiAhIWlkc1tub2RlLmNvbnRlbnRdO1xyXG4gICAgY2FzZSA4OlxyXG4gICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5zb21lKChjKSA9PiBpc09iamVjdChjKSAmJiBoYXNTY29wZVJlZihjLCBpZHMpKTtcclxuICAgIGNhc2UgNTpcclxuICAgIGNhc2UgMTI6XHJcbiAgICAgIHJldHVybiBoYXNTY29wZVJlZihub2RlLmNvbnRlbnQsIGlkcyk7XHJcbiAgICBjYXNlIDI6XHJcbiAgICBjYXNlIDM6XHJcbiAgICBjYXNlIDIwOlxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkgO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldE1lbW9lZFZOb2RlQ2FsbChub2RlKSB7XHJcbiAgaWYgKG5vZGUudHlwZSA9PT0gMTQgJiYgbm9kZS5jYWxsZWUgPT09IFdJVEhfTUVNTykge1xyXG4gICAgcmV0dXJuIG5vZGUuYXJndW1lbnRzWzFdLnJldHVybnM7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBub2RlO1xyXG4gIH1cclxufVxyXG5jb25zdCBmb3JBbGlhc1JFID0gLyhbXFxzXFxTXSo/KVxccysoPzppbnxvZilcXHMrKFxcU1tcXHNcXFNdKikvO1xyXG5cclxuY29uc3QgZGVmYXVsdFBhcnNlck9wdGlvbnMgPSB7XHJcbiAgcGFyc2VNb2RlOiBcImJhc2VcIixcclxuICBuczogMCxcclxuICBkZWxpbWl0ZXJzOiBbYHt7YCwgYH19YF0sXHJcbiAgZ2V0TmFtZXNwYWNlOiAoKSA9PiAwLFxyXG4gIGlzVm9pZFRhZzogTk8sXHJcbiAgaXNQcmVUYWc6IE5PLFxyXG4gIGlzSWdub3JlTmV3bGluZVRhZzogTk8sXHJcbiAgaXNDdXN0b21FbGVtZW50OiBOTyxcclxuICBvbkVycm9yOiBkZWZhdWx0T25FcnJvcixcclxuICBvbldhcm46IGRlZmF1bHRPbldhcm4sXHJcbiAgY29tbWVudHM6ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiksXHJcbiAgcHJlZml4SWRlbnRpZmllcnM6IGZhbHNlXHJcbn07XHJcbmxldCBjdXJyZW50T3B0aW9ucyA9IGRlZmF1bHRQYXJzZXJPcHRpb25zO1xyXG5sZXQgY3VycmVudFJvb3QgPSBudWxsO1xyXG5sZXQgY3VycmVudElucHV0ID0gXCJcIjtcclxubGV0IGN1cnJlbnRPcGVuVGFnID0gbnVsbDtcclxubGV0IGN1cnJlbnRQcm9wID0gbnVsbDtcclxubGV0IGN1cnJlbnRBdHRyVmFsdWUgPSBcIlwiO1xyXG5sZXQgY3VycmVudEF0dHJTdGFydEluZGV4ID0gLTE7XHJcbmxldCBjdXJyZW50QXR0ckVuZEluZGV4ID0gLTE7XHJcbmxldCBpblByZSA9IDA7XHJcbmxldCBpblZQcmUgPSBmYWxzZTtcclxubGV0IGN1cnJlbnRWUHJlQm91bmRhcnkgPSBudWxsO1xyXG5jb25zdCBzdGFjayA9IFtdO1xyXG5jb25zdCB0b2tlbml6ZXIgPSBuZXcgVG9rZW5pemVyKHN0YWNrLCB7XHJcbiAgb25lcnI6IGVtaXRFcnJvcixcclxuICBvbnRleHQoc3RhcnQsIGVuZCkge1xyXG4gICAgb25UZXh0KGdldFNsaWNlKHN0YXJ0LCBlbmQpLCBzdGFydCwgZW5kKTtcclxuICB9LFxyXG4gIG9udGV4dGVudGl0eShjaGFyLCBzdGFydCwgZW5kKSB7XHJcbiAgICBvblRleHQoY2hhciwgc3RhcnQsIGVuZCk7XHJcbiAgfSxcclxuICBvbmludGVycG9sYXRpb24oc3RhcnQsIGVuZCkge1xyXG4gICAgaWYgKGluVlByZSkge1xyXG4gICAgICByZXR1cm4gb25UZXh0KGdldFNsaWNlKHN0YXJ0LCBlbmQpLCBzdGFydCwgZW5kKTtcclxuICAgIH1cclxuICAgIGxldCBpbm5lclN0YXJ0ID0gc3RhcnQgKyB0b2tlbml6ZXIuZGVsaW1pdGVyT3Blbi5sZW5ndGg7XHJcbiAgICBsZXQgaW5uZXJFbmQgPSBlbmQgLSB0b2tlbml6ZXIuZGVsaW1pdGVyQ2xvc2UubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGlzV2hpdGVzcGFjZShjdXJyZW50SW5wdXQuY2hhckNvZGVBdChpbm5lclN0YXJ0KSkpIHtcclxuICAgICAgaW5uZXJTdGFydCsrO1xyXG4gICAgfVxyXG4gICAgd2hpbGUgKGlzV2hpdGVzcGFjZShjdXJyZW50SW5wdXQuY2hhckNvZGVBdChpbm5lckVuZCAtIDEpKSkge1xyXG4gICAgICBpbm5lckVuZC0tO1xyXG4gICAgfVxyXG4gICAgbGV0IGV4cCA9IGdldFNsaWNlKGlubmVyU3RhcnQsIGlubmVyRW5kKTtcclxuICAgIGlmIChleHAuaW5jbHVkZXMoXCImXCIpKSB7XHJcbiAgICAgIHtcclxuICAgICAgICBleHAgPSBjdXJyZW50T3B0aW9ucy5kZWNvZGVFbnRpdGllcyhleHAsIGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgYWRkTm9kZSh7XHJcbiAgICAgIHR5cGU6IDUsXHJcbiAgICAgIGNvbnRlbnQ6IGNyZWF0ZUV4cChleHAsIGZhbHNlLCBnZXRMb2MoaW5uZXJTdGFydCwgaW5uZXJFbmQpKSxcclxuICAgICAgbG9jOiBnZXRMb2Moc3RhcnQsIGVuZClcclxuICAgIH0pO1xyXG4gIH0sXHJcbiAgb25vcGVudGFnbmFtZShzdGFydCwgZW5kKSB7XHJcbiAgICBjb25zdCBuYW1lID0gZ2V0U2xpY2Uoc3RhcnQsIGVuZCk7XHJcbiAgICBjdXJyZW50T3BlblRhZyA9IHtcclxuICAgICAgdHlwZTogMSxcclxuICAgICAgdGFnOiBuYW1lLFxyXG4gICAgICBuczogY3VycmVudE9wdGlvbnMuZ2V0TmFtZXNwYWNlKG5hbWUsIHN0YWNrWzBdLCBjdXJyZW50T3B0aW9ucy5ucyksXHJcbiAgICAgIHRhZ1R5cGU6IDAsXHJcbiAgICAgIC8vIHdpbGwgYmUgcmVmaW5lZCBvbiB0YWcgY2xvc2VcclxuICAgICAgcHJvcHM6IFtdLFxyXG4gICAgICBjaGlsZHJlbjogW10sXHJcbiAgICAgIGxvYzogZ2V0TG9jKHN0YXJ0IC0gMSwgZW5kKSxcclxuICAgICAgY29kZWdlbk5vZGU6IHZvaWQgMFxyXG4gICAgfTtcclxuICB9LFxyXG4gIG9ub3BlbnRhZ2VuZChlbmQpIHtcclxuICAgIGVuZE9wZW5UYWcoZW5kKTtcclxuICB9LFxyXG4gIG9uY2xvc2V0YWcoc3RhcnQsIGVuZCkge1xyXG4gICAgY29uc3QgbmFtZSA9IGdldFNsaWNlKHN0YXJ0LCBlbmQpO1xyXG4gICAgaWYgKCFjdXJyZW50T3B0aW9ucy5pc1ZvaWRUYWcobmFtZSkpIHtcclxuICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBlID0gc3RhY2tbaV07XHJcbiAgICAgICAgaWYgKGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcigyNCwgc3RhY2tbMF0ubG9jLnN0YXJ0Lm9mZnNldCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8PSBpOyBqKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZWwgPSBzdGFjay5zaGlmdCgpO1xyXG4gICAgICAgICAgICBvbkNsb3NlVGFnKGVsLCBlbmQsIGogPCBpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoIWZvdW5kKSB7XHJcbiAgICAgICAgZW1pdEVycm9yKDIzLCBiYWNrVHJhY2soc3RhcnQsIDYwKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG4gIG9uc2VsZmNsb3Npbmd0YWcoZW5kKSB7XHJcbiAgICBjb25zdCBuYW1lID0gY3VycmVudE9wZW5UYWcudGFnO1xyXG4gICAgY3VycmVudE9wZW5UYWcuaXNTZWxmQ2xvc2luZyA9IHRydWU7XHJcbiAgICBlbmRPcGVuVGFnKGVuZCk7XHJcbiAgICBpZiAoc3RhY2tbMF0gJiYgc3RhY2tbMF0udGFnID09PSBuYW1lKSB7XHJcbiAgICAgIG9uQ2xvc2VUYWcoc3RhY2suc2hpZnQoKSwgZW5kKTtcclxuICAgIH1cclxuICB9LFxyXG4gIG9uYXR0cmlibmFtZShzdGFydCwgZW5kKSB7XHJcbiAgICBjdXJyZW50UHJvcCA9IHtcclxuICAgICAgdHlwZTogNixcclxuICAgICAgbmFtZTogZ2V0U2xpY2Uoc3RhcnQsIGVuZCksXHJcbiAgICAgIG5hbWVMb2M6IGdldExvYyhzdGFydCwgZW5kKSxcclxuICAgICAgdmFsdWU6IHZvaWQgMCxcclxuICAgICAgbG9jOiBnZXRMb2Moc3RhcnQpXHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgb25kaXJuYW1lKHN0YXJ0LCBlbmQpIHtcclxuICAgIGNvbnN0IHJhdyA9IGdldFNsaWNlKHN0YXJ0LCBlbmQpO1xyXG4gICAgY29uc3QgbmFtZSA9IHJhdyA9PT0gXCIuXCIgfHwgcmF3ID09PSBcIjpcIiA/IFwiYmluZFwiIDogcmF3ID09PSBcIkBcIiA/IFwib25cIiA6IHJhdyA9PT0gXCIjXCIgPyBcInNsb3RcIiA6IHJhdy5zbGljZSgyKTtcclxuICAgIGlmICghaW5WUHJlICYmIG5hbWUgPT09IFwiXCIpIHtcclxuICAgICAgZW1pdEVycm9yKDI2LCBzdGFydCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaW5WUHJlIHx8IG5hbWUgPT09IFwiXCIpIHtcclxuICAgICAgY3VycmVudFByb3AgPSB7XHJcbiAgICAgICAgdHlwZTogNixcclxuICAgICAgICBuYW1lOiByYXcsXHJcbiAgICAgICAgbmFtZUxvYzogZ2V0TG9jKHN0YXJ0LCBlbmQpLFxyXG4gICAgICAgIHZhbHVlOiB2b2lkIDAsXHJcbiAgICAgICAgbG9jOiBnZXRMb2Moc3RhcnQpXHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjdXJyZW50UHJvcCA9IHtcclxuICAgICAgICB0eXBlOiA3LFxyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgcmF3TmFtZTogcmF3LFxyXG4gICAgICAgIGV4cDogdm9pZCAwLFxyXG4gICAgICAgIGFyZzogdm9pZCAwLFxyXG4gICAgICAgIG1vZGlmaWVyczogcmF3ID09PSBcIi5cIiA/IFtjcmVhdGVTaW1wbGVFeHByZXNzaW9uKFwicHJvcFwiKV0gOiBbXSxcclxuICAgICAgICBsb2M6IGdldExvYyhzdGFydClcclxuICAgICAgfTtcclxuICAgICAgaWYgKG5hbWUgPT09IFwicHJlXCIpIHtcclxuICAgICAgICBpblZQcmUgPSB0b2tlbml6ZXIuaW5WUHJlID0gdHJ1ZTtcclxuICAgICAgICBjdXJyZW50VlByZUJvdW5kYXJ5ID0gY3VycmVudE9wZW5UYWc7XHJcbiAgICAgICAgY29uc3QgcHJvcHMgPSBjdXJyZW50T3BlblRhZy5wcm9wcztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAocHJvcHNbaV0udHlwZSA9PT0gNykge1xyXG4gICAgICAgICAgICBwcm9wc1tpXSA9IGRpclRvQXR0cihwcm9wc1tpXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuICBvbmRpcmFyZyhzdGFydCwgZW5kKSB7XHJcbiAgICBpZiAoc3RhcnQgPT09IGVuZCkgcmV0dXJuO1xyXG4gICAgY29uc3QgYXJnID0gZ2V0U2xpY2Uoc3RhcnQsIGVuZCk7XHJcbiAgICBpZiAoaW5WUHJlKSB7XHJcbiAgICAgIGN1cnJlbnRQcm9wLm5hbWUgKz0gYXJnO1xyXG4gICAgICBzZXRMb2NFbmQoY3VycmVudFByb3AubmFtZUxvYywgZW5kKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IGlzU3RhdGljID0gYXJnWzBdICE9PSBgW2A7XHJcbiAgICAgIGN1cnJlbnRQcm9wLmFyZyA9IGNyZWF0ZUV4cChcclxuICAgICAgICBpc1N0YXRpYyA/IGFyZyA6IGFyZy5zbGljZSgxLCAtMSksXHJcbiAgICAgICAgaXNTdGF0aWMsXHJcbiAgICAgICAgZ2V0TG9jKHN0YXJ0LCBlbmQpLFxyXG4gICAgICAgIGlzU3RhdGljID8gMyA6IDBcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9LFxyXG4gIG9uZGlybW9kaWZpZXIoc3RhcnQsIGVuZCkge1xyXG4gICAgY29uc3QgbW9kID0gZ2V0U2xpY2Uoc3RhcnQsIGVuZCk7XHJcbiAgICBpZiAoaW5WUHJlKSB7XHJcbiAgICAgIGN1cnJlbnRQcm9wLm5hbWUgKz0gXCIuXCIgKyBtb2Q7XHJcbiAgICAgIHNldExvY0VuZChjdXJyZW50UHJvcC5uYW1lTG9jLCBlbmQpO1xyXG4gICAgfSBlbHNlIGlmIChjdXJyZW50UHJvcC5uYW1lID09PSBcInNsb3RcIikge1xyXG4gICAgICBjb25zdCBhcmcgPSBjdXJyZW50UHJvcC5hcmc7XHJcbiAgICAgIGlmIChhcmcpIHtcclxuICAgICAgICBhcmcuY29udGVudCArPSBcIi5cIiArIG1vZDtcclxuICAgICAgICBzZXRMb2NFbmQoYXJnLmxvYywgZW5kKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgZXhwID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihtb2QsIHRydWUsIGdldExvYyhzdGFydCwgZW5kKSk7XHJcbiAgICAgIGN1cnJlbnRQcm9wLm1vZGlmaWVycy5wdXNoKGV4cCk7XHJcbiAgICB9XHJcbiAgfSxcclxuICBvbmF0dHJpYmRhdGEoc3RhcnQsIGVuZCkge1xyXG4gICAgY3VycmVudEF0dHJWYWx1ZSArPSBnZXRTbGljZShzdGFydCwgZW5kKTtcclxuICAgIGlmIChjdXJyZW50QXR0clN0YXJ0SW5kZXggPCAwKSBjdXJyZW50QXR0clN0YXJ0SW5kZXggPSBzdGFydDtcclxuICAgIGN1cnJlbnRBdHRyRW5kSW5kZXggPSBlbmQ7XHJcbiAgfSxcclxuICBvbmF0dHJpYmVudGl0eShjaGFyLCBzdGFydCwgZW5kKSB7XHJcbiAgICBjdXJyZW50QXR0clZhbHVlICs9IGNoYXI7XHJcbiAgICBpZiAoY3VycmVudEF0dHJTdGFydEluZGV4IDwgMCkgY3VycmVudEF0dHJTdGFydEluZGV4ID0gc3RhcnQ7XHJcbiAgICBjdXJyZW50QXR0ckVuZEluZGV4ID0gZW5kO1xyXG4gIH0sXHJcbiAgb25hdHRyaWJuYW1lZW5kKGVuZCkge1xyXG4gICAgY29uc3Qgc3RhcnQgPSBjdXJyZW50UHJvcC5sb2Muc3RhcnQub2Zmc2V0O1xyXG4gICAgY29uc3QgbmFtZSA9IGdldFNsaWNlKHN0YXJ0LCBlbmQpO1xyXG4gICAgaWYgKGN1cnJlbnRQcm9wLnR5cGUgPT09IDcpIHtcclxuICAgICAgY3VycmVudFByb3AucmF3TmFtZSA9IG5hbWU7XHJcbiAgICB9XHJcbiAgICBpZiAoY3VycmVudE9wZW5UYWcucHJvcHMuc29tZShcclxuICAgICAgKHApID0+IChwLnR5cGUgPT09IDcgPyBwLnJhd05hbWUgOiBwLm5hbWUpID09PSBuYW1lXHJcbiAgICApKSB7XHJcbiAgICAgIGVtaXRFcnJvcigyLCBzdGFydCk7XHJcbiAgICB9XHJcbiAgfSxcclxuICBvbmF0dHJpYmVuZChxdW90ZSwgZW5kKSB7XHJcbiAgICBpZiAoY3VycmVudE9wZW5UYWcgJiYgY3VycmVudFByb3ApIHtcclxuICAgICAgc2V0TG9jRW5kKGN1cnJlbnRQcm9wLmxvYywgZW5kKTtcclxuICAgICAgaWYgKHF1b3RlICE9PSAwKSB7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRBdHRyVmFsdWUuaW5jbHVkZXMoXCImXCIpKSB7XHJcbiAgICAgICAgICBjdXJyZW50QXR0clZhbHVlID0gY3VycmVudE9wdGlvbnMuZGVjb2RlRW50aXRpZXMoXHJcbiAgICAgICAgICAgIGN1cnJlbnRBdHRyVmFsdWUsXHJcbiAgICAgICAgICAgIHRydWVcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjdXJyZW50UHJvcC50eXBlID09PSA2KSB7XHJcbiAgICAgICAgICBpZiAoY3VycmVudFByb3AubmFtZSA9PT0gXCJjbGFzc1wiKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBdHRyVmFsdWUgPSBjb25kZW5zZShjdXJyZW50QXR0clZhbHVlKS50cmltKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAocXVvdGUgPT09IDEgJiYgIWN1cnJlbnRBdHRyVmFsdWUpIHtcclxuICAgICAgICAgICAgZW1pdEVycm9yKDEzLCBlbmQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY3VycmVudFByb3AudmFsdWUgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6IDIsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IGN1cnJlbnRBdHRyVmFsdWUsXHJcbiAgICAgICAgICAgIGxvYzogcXVvdGUgPT09IDEgPyBnZXRMb2MoY3VycmVudEF0dHJTdGFydEluZGV4LCBjdXJyZW50QXR0ckVuZEluZGV4KSA6IGdldExvYyhjdXJyZW50QXR0clN0YXJ0SW5kZXggLSAxLCBjdXJyZW50QXR0ckVuZEluZGV4ICsgMSlcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICBpZiAodG9rZW5pemVyLmluU0ZDUm9vdCAmJiBjdXJyZW50T3BlblRhZy50YWcgPT09IFwidGVtcGxhdGVcIiAmJiBjdXJyZW50UHJvcC5uYW1lID09PSBcImxhbmdcIiAmJiBjdXJyZW50QXR0clZhbHVlICYmIGN1cnJlbnRBdHRyVmFsdWUgIT09IFwiaHRtbFwiKSB7XHJcbiAgICAgICAgICAgIHRva2VuaXplci5lbnRlclJDREFUQSh0b0NoYXJDb2RlcyhgPC90ZW1wbGF0ZWApLCAwKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbGV0IGV4cFBhcnNlTW9kZSA9IDAgLyogTm9ybWFsICovO1xyXG4gICAgICAgICAgY3VycmVudFByb3AuZXhwID0gY3JlYXRlRXhwKFxyXG4gICAgICAgICAgICBjdXJyZW50QXR0clZhbHVlLFxyXG4gICAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgICAgZ2V0TG9jKGN1cnJlbnRBdHRyU3RhcnRJbmRleCwgY3VycmVudEF0dHJFbmRJbmRleCksXHJcbiAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgIGV4cFBhcnNlTW9kZVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGlmIChjdXJyZW50UHJvcC5uYW1lID09PSBcImZvclwiKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQcm9wLmZvclBhcnNlUmVzdWx0ID0gcGFyc2VGb3JFeHByZXNzaW9uKGN1cnJlbnRQcm9wLmV4cCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBsZXQgc3luY0luZGV4ID0gLTE7XHJcbiAgICAgICAgICBpZiAoY3VycmVudFByb3AubmFtZSA9PT0gXCJiaW5kXCIgJiYgKHN5bmNJbmRleCA9IGN1cnJlbnRQcm9wLm1vZGlmaWVycy5maW5kSW5kZXgoXHJcbiAgICAgICAgICAgIChtb2QpID0+IG1vZC5jb250ZW50ID09PSBcInN5bmNcIlxyXG4gICAgICAgICAgKSkgPiAtMSAmJiBjaGVja0NvbXBhdEVuYWJsZWQoXHJcbiAgICAgICAgICAgIFwiQ09NUElMRVJfVl9CSU5EX1NZTkNcIixcclxuICAgICAgICAgICAgY3VycmVudE9wdGlvbnMsXHJcbiAgICAgICAgICAgIGN1cnJlbnRQcm9wLmxvYyxcclxuICAgICAgICAgICAgY3VycmVudFByb3AucmF3TmFtZVxyXG4gICAgICAgICAgKSkge1xyXG4gICAgICAgICAgICBjdXJyZW50UHJvcC5uYW1lID0gXCJtb2RlbFwiO1xyXG4gICAgICAgICAgICBjdXJyZW50UHJvcC5tb2RpZmllcnMuc3BsaWNlKHN5bmNJbmRleCwgMSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChjdXJyZW50UHJvcC50eXBlICE9PSA3IHx8IGN1cnJlbnRQcm9wLm5hbWUgIT09IFwicHJlXCIpIHtcclxuICAgICAgICBjdXJyZW50T3BlblRhZy5wcm9wcy5wdXNoKGN1cnJlbnRQcm9wKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY3VycmVudEF0dHJWYWx1ZSA9IFwiXCI7XHJcbiAgICBjdXJyZW50QXR0clN0YXJ0SW5kZXggPSBjdXJyZW50QXR0ckVuZEluZGV4ID0gLTE7XHJcbiAgfSxcclxuICBvbmNvbW1lbnQoc3RhcnQsIGVuZCkge1xyXG4gICAgaWYgKGN1cnJlbnRPcHRpb25zLmNvbW1lbnRzKSB7XHJcbiAgICAgIGFkZE5vZGUoe1xyXG4gICAgICAgIHR5cGU6IDMsXHJcbiAgICAgICAgY29udGVudDogZ2V0U2xpY2Uoc3RhcnQsIGVuZCksXHJcbiAgICAgICAgbG9jOiBnZXRMb2Moc3RhcnQgLSA0LCBlbmQgKyAzKVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LFxyXG4gIG9uZW5kKCkge1xyXG4gICAgY29uc3QgZW5kID0gY3VycmVudElucHV0Lmxlbmd0aDtcclxuICAgIGlmICgoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBmYWxzZSkgJiYgdG9rZW5pemVyLnN0YXRlICE9PSAxKSB7XHJcbiAgICAgIHN3aXRjaCAodG9rZW5pemVyLnN0YXRlKSB7XHJcbiAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgIGNhc2UgODpcclxuICAgICAgICAgIGVtaXRFcnJvcig1LCBlbmQpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgIGVtaXRFcnJvcihcclxuICAgICAgICAgICAgMjUsXHJcbiAgICAgICAgICAgIHRva2VuaXplci5zZWN0aW9uU3RhcnRcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDI4OlxyXG4gICAgICAgICAgaWYgKHRva2VuaXplci5jdXJyZW50U2VxdWVuY2UgPT09IFNlcXVlbmNlcy5DZGF0YUVuZCkge1xyXG4gICAgICAgICAgICBlbWl0RXJyb3IoNiwgZW5kKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcig3LCBlbmQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgIGNhc2UgNzpcclxuICAgICAgICBjYXNlIDk6XHJcbiAgICAgICAgY2FzZSAxMTpcclxuICAgICAgICBjYXNlIDEyOlxyXG4gICAgICAgIGNhc2UgMTM6XHJcbiAgICAgICAgY2FzZSAxNDpcclxuICAgICAgICBjYXNlIDE1OlxyXG4gICAgICAgIGNhc2UgMTY6XHJcbiAgICAgICAgY2FzZSAxNzpcclxuICAgICAgICBjYXNlIDE4OlxyXG4gICAgICAgIGNhc2UgMTk6XHJcbiAgICAgICAgLy8gXCJcclxuICAgICAgICBjYXNlIDIwOlxyXG4gICAgICAgIC8vICdcclxuICAgICAgICBjYXNlIDIxOlxyXG4gICAgICAgICAgZW1pdEVycm9yKDksIGVuZCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHN0YWNrLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICBvbkNsb3NlVGFnKHN0YWNrW2luZGV4XSwgZW5kIC0gMSk7XHJcbiAgICAgIGVtaXRFcnJvcigyNCwgc3RhY2tbaW5kZXhdLmxvYy5zdGFydC5vZmZzZXQpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgb25jZGF0YShzdGFydCwgZW5kKSB7XHJcbiAgICBpZiAoc3RhY2tbMF0ubnMgIT09IDApIHtcclxuICAgICAgb25UZXh0KGdldFNsaWNlKHN0YXJ0LCBlbmQpLCBzdGFydCwgZW5kKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVtaXRFcnJvcigxLCBzdGFydCAtIDkpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgb25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24oc3RhcnQpIHtcclxuICAgIGlmICgoc3RhY2tbMF0gPyBzdGFja1swXS5ucyA6IGN1cnJlbnRPcHRpb25zLm5zKSA9PT0gMCkge1xyXG4gICAgICBlbWl0RXJyb3IoXHJcbiAgICAgICAgMjEsXHJcbiAgICAgICAgc3RhcnQgLSAxXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG59KTtcclxuY29uc3QgZm9ySXRlcmF0b3JSRSA9IC8sKFteLFxcfVxcXV0qKSg/OiwoW14sXFx9XFxdXSopKT8kLztcclxuY29uc3Qgc3RyaXBQYXJlbnNSRSA9IC9eXFwofFxcKSQvZztcclxuZnVuY3Rpb24gcGFyc2VGb3JFeHByZXNzaW9uKGlucHV0KSB7XHJcbiAgY29uc3QgbG9jID0gaW5wdXQubG9jO1xyXG4gIGNvbnN0IGV4cCA9IGlucHV0LmNvbnRlbnQ7XHJcbiAgY29uc3QgaW5NYXRjaCA9IGV4cC5tYXRjaChmb3JBbGlhc1JFKTtcclxuICBpZiAoIWluTWF0Y2gpIHJldHVybjtcclxuICBjb25zdCBbLCBMSFMsIFJIU10gPSBpbk1hdGNoO1xyXG4gIGNvbnN0IGNyZWF0ZUFsaWFzRXhwcmVzc2lvbiA9IChjb250ZW50LCBvZmZzZXQsIGFzUGFyYW0gPSBmYWxzZSkgPT4ge1xyXG4gICAgY29uc3Qgc3RhcnQgPSBsb2Muc3RhcnQub2Zmc2V0ICsgb2Zmc2V0O1xyXG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBjb250ZW50Lmxlbmd0aDtcclxuICAgIHJldHVybiBjcmVhdGVFeHAoXHJcbiAgICAgIGNvbnRlbnQsXHJcbiAgICAgIGZhbHNlLFxyXG4gICAgICBnZXRMb2Moc3RhcnQsIGVuZCksXHJcbiAgICAgIDAsXHJcbiAgICAgIGFzUGFyYW0gPyAxIC8qIFBhcmFtcyAqLyA6IDAgLyogTm9ybWFsICovXHJcbiAgICApO1xyXG4gIH07XHJcbiAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgc291cmNlOiBjcmVhdGVBbGlhc0V4cHJlc3Npb24oUkhTLnRyaW0oKSwgZXhwLmluZGV4T2YoUkhTLCBMSFMubGVuZ3RoKSksXHJcbiAgICB2YWx1ZTogdm9pZCAwLFxyXG4gICAga2V5OiB2b2lkIDAsXHJcbiAgICBpbmRleDogdm9pZCAwLFxyXG4gICAgZmluYWxpemVkOiBmYWxzZVxyXG4gIH07XHJcbiAgbGV0IHZhbHVlQ29udGVudCA9IExIUy50cmltKCkucmVwbGFjZShzdHJpcFBhcmVuc1JFLCBcIlwiKS50cmltKCk7XHJcbiAgY29uc3QgdHJpbW1lZE9mZnNldCA9IExIUy5pbmRleE9mKHZhbHVlQ29udGVudCk7XHJcbiAgY29uc3QgaXRlcmF0b3JNYXRjaCA9IHZhbHVlQ29udGVudC5tYXRjaChmb3JJdGVyYXRvclJFKTtcclxuICBpZiAoaXRlcmF0b3JNYXRjaCkge1xyXG4gICAgdmFsdWVDb250ZW50ID0gdmFsdWVDb250ZW50LnJlcGxhY2UoZm9ySXRlcmF0b3JSRSwgXCJcIikudHJpbSgpO1xyXG4gICAgY29uc3Qga2V5Q29udGVudCA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xyXG4gICAgbGV0IGtleU9mZnNldDtcclxuICAgIGlmIChrZXlDb250ZW50KSB7XHJcbiAgICAgIGtleU9mZnNldCA9IGV4cC5pbmRleE9mKGtleUNvbnRlbnQsIHRyaW1tZWRPZmZzZXQgKyB2YWx1ZUNvbnRlbnQubGVuZ3RoKTtcclxuICAgICAgcmVzdWx0LmtleSA9IGNyZWF0ZUFsaWFzRXhwcmVzc2lvbihrZXlDb250ZW50LCBrZXlPZmZzZXQsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcclxuICAgICAgY29uc3QgaW5kZXhDb250ZW50ID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XHJcbiAgICAgIGlmIChpbmRleENvbnRlbnQpIHtcclxuICAgICAgICByZXN1bHQuaW5kZXggPSBjcmVhdGVBbGlhc0V4cHJlc3Npb24oXHJcbiAgICAgICAgICBpbmRleENvbnRlbnQsXHJcbiAgICAgICAgICBleHAuaW5kZXhPZihcclxuICAgICAgICAgICAgaW5kZXhDb250ZW50LFxyXG4gICAgICAgICAgICByZXN1bHQua2V5ID8ga2V5T2Zmc2V0ICsga2V5Q29udGVudC5sZW5ndGggOiB0cmltbWVkT2Zmc2V0ICsgdmFsdWVDb250ZW50Lmxlbmd0aFxyXG4gICAgICAgICAgKSxcclxuICAgICAgICAgIHRydWVcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmICh2YWx1ZUNvbnRlbnQpIHtcclxuICAgIHJlc3VsdC52YWx1ZSA9IGNyZWF0ZUFsaWFzRXhwcmVzc2lvbih2YWx1ZUNvbnRlbnQsIHRyaW1tZWRPZmZzZXQsIHRydWUpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGdldFNsaWNlKHN0YXJ0LCBlbmQpIHtcclxuICByZXR1cm4gY3VycmVudElucHV0LnNsaWNlKHN0YXJ0LCBlbmQpO1xyXG59XHJcbmZ1bmN0aW9uIGVuZE9wZW5UYWcoZW5kKSB7XHJcbiAgaWYgKHRva2VuaXplci5pblNGQ1Jvb3QpIHtcclxuICAgIGN1cnJlbnRPcGVuVGFnLmlubmVyTG9jID0gZ2V0TG9jKGVuZCArIDEsIGVuZCArIDEpO1xyXG4gIH1cclxuICBhZGROb2RlKGN1cnJlbnRPcGVuVGFnKTtcclxuICBjb25zdCB7IHRhZywgbnMgfSA9IGN1cnJlbnRPcGVuVGFnO1xyXG4gIGlmIChucyA9PT0gMCAmJiBjdXJyZW50T3B0aW9ucy5pc1ByZVRhZyh0YWcpKSB7XHJcbiAgICBpblByZSsrO1xyXG4gIH1cclxuICBpZiAoY3VycmVudE9wdGlvbnMuaXNWb2lkVGFnKHRhZykpIHtcclxuICAgIG9uQ2xvc2VUYWcoY3VycmVudE9wZW5UYWcsIGVuZCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHN0YWNrLnVuc2hpZnQoY3VycmVudE9wZW5UYWcpO1xyXG4gICAgaWYgKG5zID09PSAxIHx8IG5zID09PSAyKSB7XHJcbiAgICAgIHRva2VuaXplci5pblhNTCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGN1cnJlbnRPcGVuVGFnID0gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBvblRleHQoY29udGVudCwgc3RhcnQsIGVuZCkge1xyXG4gIHtcclxuICAgIGNvbnN0IHRhZyA9IHN0YWNrWzBdICYmIHN0YWNrWzBdLnRhZztcclxuICAgIGlmICh0YWcgIT09IFwic2NyaXB0XCIgJiYgdGFnICE9PSBcInN0eWxlXCIgJiYgY29udGVudC5pbmNsdWRlcyhcIiZcIikpIHtcclxuICAgICAgY29udGVudCA9IGN1cnJlbnRPcHRpb25zLmRlY29kZUVudGl0aWVzKGNvbnRlbnQsIGZhbHNlKTtcclxuICAgIH1cclxuICB9XHJcbiAgY29uc3QgcGFyZW50ID0gc3RhY2tbMF0gfHwgY3VycmVudFJvb3Q7XHJcbiAgY29uc3QgbGFzdE5vZGUgPSBwYXJlbnQuY2hpbGRyZW5bcGFyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xyXG4gIGlmIChsYXN0Tm9kZSAmJiBsYXN0Tm9kZS50eXBlID09PSAyKSB7XHJcbiAgICBsYXN0Tm9kZS5jb250ZW50ICs9IGNvbnRlbnQ7XHJcbiAgICBzZXRMb2NFbmQobGFzdE5vZGUubG9jLCBlbmQpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaCh7XHJcbiAgICAgIHR5cGU6IDIsXHJcbiAgICAgIGNvbnRlbnQsXHJcbiAgICAgIGxvYzogZ2V0TG9jKHN0YXJ0LCBlbmQpXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gb25DbG9zZVRhZyhlbCwgZW5kLCBpc0ltcGxpZWQgPSBmYWxzZSkge1xyXG4gIGlmIChpc0ltcGxpZWQpIHtcclxuICAgIHNldExvY0VuZChlbC5sb2MsIGJhY2tUcmFjayhlbmQsIDYwKSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHNldExvY0VuZChlbC5sb2MsIGxvb2tBaGVhZChlbmQsIDYyKSArIDEpO1xyXG4gIH1cclxuICBpZiAodG9rZW5pemVyLmluU0ZDUm9vdCkge1xyXG4gICAgaWYgKGVsLmNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICBlbC5pbm5lckxvYy5lbmQgPSBleHRlbmQoe30sIGVsLmNoaWxkcmVuW2VsLmNoaWxkcmVuLmxlbmd0aCAtIDFdLmxvYy5lbmQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZWwuaW5uZXJMb2MuZW5kID0gZXh0ZW5kKHt9LCBlbC5pbm5lckxvYy5zdGFydCk7XHJcbiAgICB9XHJcbiAgICBlbC5pbm5lckxvYy5zb3VyY2UgPSBnZXRTbGljZShcclxuICAgICAgZWwuaW5uZXJMb2Muc3RhcnQub2Zmc2V0LFxyXG4gICAgICBlbC5pbm5lckxvYy5lbmQub2Zmc2V0XHJcbiAgICApO1xyXG4gIH1cclxuICBjb25zdCB7IHRhZywgbnMsIGNoaWxkcmVuIH0gPSBlbDtcclxuICBpZiAoIWluVlByZSkge1xyXG4gICAgaWYgKHRhZyA9PT0gXCJzbG90XCIpIHtcclxuICAgICAgZWwudGFnVHlwZSA9IDI7XHJcbiAgICB9IGVsc2UgaWYgKGlzRnJhZ21lbnRUZW1wbGF0ZShlbCkpIHtcclxuICAgICAgZWwudGFnVHlwZSA9IDM7XHJcbiAgICB9IGVsc2UgaWYgKGlzQ29tcG9uZW50KGVsKSkge1xyXG4gICAgICBlbC50YWdUeXBlID0gMTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKCF0b2tlbml6ZXIuaW5SQ0RBVEEpIHtcclxuICAgIGVsLmNoaWxkcmVuID0gY29uZGVuc2VXaGl0ZXNwYWNlKGNoaWxkcmVuKTtcclxuICB9XHJcbiAgaWYgKG5zID09PSAwICYmIGN1cnJlbnRPcHRpb25zLmlzSWdub3JlTmV3bGluZVRhZyh0YWcpKSB7XHJcbiAgICBjb25zdCBmaXJzdCA9IGNoaWxkcmVuWzBdO1xyXG4gICAgaWYgKGZpcnN0ICYmIGZpcnN0LnR5cGUgPT09IDIpIHtcclxuICAgICAgZmlyc3QuY29udGVudCA9IGZpcnN0LmNvbnRlbnQucmVwbGFjZSgvXlxccj9cXG4vLCBcIlwiKTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKG5zID09PSAwICYmIGN1cnJlbnRPcHRpb25zLmlzUHJlVGFnKHRhZykpIHtcclxuICAgIGluUHJlLS07XHJcbiAgfVxyXG4gIGlmIChjdXJyZW50VlByZUJvdW5kYXJ5ID09PSBlbCkge1xyXG4gICAgaW5WUHJlID0gdG9rZW5pemVyLmluVlByZSA9IGZhbHNlO1xyXG4gICAgY3VycmVudFZQcmVCb3VuZGFyeSA9IG51bGw7XHJcbiAgfVxyXG4gIGlmICh0b2tlbml6ZXIuaW5YTUwgJiYgKHN0YWNrWzBdID8gc3RhY2tbMF0ubnMgOiBjdXJyZW50T3B0aW9ucy5ucykgPT09IDApIHtcclxuICAgIHRva2VuaXplci5pblhNTCA9IGZhbHNlO1xyXG4gIH1cclxuICB7XHJcbiAgICBjb25zdCBwcm9wcyA9IGVsLnByb3BzO1xyXG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNDb21wYXRFbmFibGVkKFxyXG4gICAgICBcIkNPTVBJTEVSX1ZfSUZfVl9GT1JfUFJFQ0VERU5DRVwiLFxyXG4gICAgICBjdXJyZW50T3B0aW9uc1xyXG4gICAgKSkge1xyXG4gICAgICBsZXQgaGFzSWYgPSBmYWxzZTtcclxuICAgICAgbGV0IGhhc0ZvciA9IGZhbHNlO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcCA9IHByb3BzW2ldO1xyXG4gICAgICAgIGlmIChwLnR5cGUgPT09IDcpIHtcclxuICAgICAgICAgIGlmIChwLm5hbWUgPT09IFwiaWZcIikge1xyXG4gICAgICAgICAgICBoYXNJZiA9IHRydWU7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHAubmFtZSA9PT0gXCJmb3JcIikge1xyXG4gICAgICAgICAgICBoYXNGb3IgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFzSWYgJiYgaGFzRm9yKSB7XHJcbiAgICAgICAgICB3YXJuRGVwcmVjYXRpb24oXHJcbiAgICAgICAgICAgIFwiQ09NUElMRVJfVl9JRl9WX0ZPUl9QUkVDRURFTkNFXCIsXHJcbiAgICAgICAgICAgIGN1cnJlbnRPcHRpb25zLFxyXG4gICAgICAgICAgICBlbC5sb2NcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghdG9rZW5pemVyLmluU0ZDUm9vdCAmJiBpc0NvbXBhdEVuYWJsZWQoXHJcbiAgICAgIFwiQ09NUElMRVJfTkFUSVZFX1RFTVBMQVRFXCIsXHJcbiAgICAgIGN1cnJlbnRPcHRpb25zXHJcbiAgICApICYmIGVsLnRhZyA9PT0gXCJ0ZW1wbGF0ZVwiICYmICFpc0ZyYWdtZW50VGVtcGxhdGUoZWwpKSB7XHJcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybkRlcHJlY2F0aW9uKFxyXG4gICAgICAgIFwiQ09NUElMRVJfTkFUSVZFX1RFTVBMQVRFXCIsXHJcbiAgICAgICAgY3VycmVudE9wdGlvbnMsXHJcbiAgICAgICAgZWwubG9jXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnN0IHBhcmVudCA9IHN0YWNrWzBdIHx8IGN1cnJlbnRSb290O1xyXG4gICAgICBjb25zdCBpbmRleCA9IHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKGVsKTtcclxuICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSwgLi4uZWwuY2hpbGRyZW4pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW5saW5lVGVtcGxhdGVQcm9wID0gcHJvcHMuZmluZChcclxuICAgICAgKHApID0+IHAudHlwZSA9PT0gNiAmJiBwLm5hbWUgPT09IFwiaW5saW5lLXRlbXBsYXRlXCJcclxuICAgICk7XHJcbiAgICBpZiAoaW5saW5lVGVtcGxhdGVQcm9wICYmIGNoZWNrQ29tcGF0RW5hYmxlZChcclxuICAgICAgXCJDT01QSUxFUl9JTkxJTkVfVEVNUExBVEVcIixcclxuICAgICAgY3VycmVudE9wdGlvbnMsXHJcbiAgICAgIGlubGluZVRlbXBsYXRlUHJvcC5sb2NcclxuICAgICkgJiYgZWwuY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgIGlubGluZVRlbXBsYXRlUHJvcC52YWx1ZSA9IHtcclxuICAgICAgICB0eXBlOiAyLFxyXG4gICAgICAgIGNvbnRlbnQ6IGdldFNsaWNlKFxyXG4gICAgICAgICAgZWwuY2hpbGRyZW5bMF0ubG9jLnN0YXJ0Lm9mZnNldCxcclxuICAgICAgICAgIGVsLmNoaWxkcmVuW2VsLmNoaWxkcmVuLmxlbmd0aCAtIDFdLmxvYy5lbmQub2Zmc2V0XHJcbiAgICAgICAgKSxcclxuICAgICAgICBsb2M6IGlubGluZVRlbXBsYXRlUHJvcC5sb2NcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZnVuY3Rpb24gbG9va0FoZWFkKGluZGV4LCBjKSB7XHJcbiAgbGV0IGkgPSBpbmRleDtcclxuICB3aGlsZSAoY3VycmVudElucHV0LmNoYXJDb2RlQXQoaSkgIT09IGMgJiYgaSA8IGN1cnJlbnRJbnB1dC5sZW5ndGggLSAxKSBpKys7XHJcbiAgcmV0dXJuIGk7XHJcbn1cclxuZnVuY3Rpb24gYmFja1RyYWNrKGluZGV4LCBjKSB7XHJcbiAgbGV0IGkgPSBpbmRleDtcclxuICB3aGlsZSAoY3VycmVudElucHV0LmNoYXJDb2RlQXQoaSkgIT09IGMgJiYgaSA+PSAwKSBpLS07XHJcbiAgcmV0dXJuIGk7XHJcbn1cclxuY29uc3Qgc3BlY2lhbFRlbXBsYXRlRGlyID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiaWZcIiwgXCJlbHNlXCIsIFwiZWxzZS1pZlwiLCBcImZvclwiLCBcInNsb3RcIl0pO1xyXG5mdW5jdGlvbiBpc0ZyYWdtZW50VGVtcGxhdGUoeyB0YWcsIHByb3BzIH0pIHtcclxuICBpZiAodGFnID09PSBcInRlbXBsYXRlXCIpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKHByb3BzW2ldLnR5cGUgPT09IDcgJiYgc3BlY2lhbFRlbXBsYXRlRGlyLmhhcyhwcm9wc1tpXS5uYW1lKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBpc0NvbXBvbmVudCh7IHRhZywgcHJvcHMgfSkge1xyXG4gIGlmIChjdXJyZW50T3B0aW9ucy5pc0N1c3RvbUVsZW1lbnQodGFnKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBpZiAodGFnID09PSBcImNvbXBvbmVudFwiIHx8IGlzVXBwZXJDYXNlKHRhZy5jaGFyQ29kZUF0KDApKSB8fCBpc0NvcmVDb21wb25lbnQodGFnKSB8fCBjdXJyZW50T3B0aW9ucy5pc0J1aWx0SW5Db21wb25lbnQgJiYgY3VycmVudE9wdGlvbnMuaXNCdWlsdEluQ29tcG9uZW50KHRhZykgfHwgY3VycmVudE9wdGlvbnMuaXNOYXRpdmVUYWcgJiYgIWN1cnJlbnRPcHRpb25zLmlzTmF0aXZlVGFnKHRhZykpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBwID0gcHJvcHNbaV07XHJcbiAgICBpZiAocC50eXBlID09PSA2KSB7XHJcbiAgICAgIGlmIChwLm5hbWUgPT09IFwiaXNcIiAmJiBwLnZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHAudmFsdWUuY29udGVudC5zdGFydHNXaXRoKFwidnVlOlwiKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjaGVja0NvbXBhdEVuYWJsZWQoXHJcbiAgICAgICAgICBcIkNPTVBJTEVSX0lTX09OX0VMRU1FTlRcIixcclxuICAgICAgICAgIGN1cnJlbnRPcHRpb25zLFxyXG4gICAgICAgICAgcC5sb2NcclxuICAgICAgICApKSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoLy8gOmlzIG9uIHBsYWluIGVsZW1lbnQgLSBvbmx5IHRyZWF0IGFzIGNvbXBvbmVudCBpbiBjb21wYXQgbW9kZVxyXG4gICAgcC5uYW1lID09PSBcImJpbmRcIiAmJiBpc1N0YXRpY0FyZ09mKHAuYXJnLCBcImlzXCIpICYmIGNoZWNrQ29tcGF0RW5hYmxlZChcclxuICAgICAgXCJDT01QSUxFUl9JU19PTl9FTEVNRU5UXCIsXHJcbiAgICAgIGN1cnJlbnRPcHRpb25zLFxyXG4gICAgICBwLmxvY1xyXG4gICAgKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGlzVXBwZXJDYXNlKGMpIHtcclxuICByZXR1cm4gYyA+IDY0ICYmIGMgPCA5MTtcclxufVxyXG5jb25zdCB3aW5kb3dzTmV3bGluZVJFID0gL1xcclxcbi9nO1xyXG5mdW5jdGlvbiBjb25kZW5zZVdoaXRlc3BhY2Uobm9kZXMsIHRhZykge1xyXG4gIGNvbnN0IHNob3VsZENvbmRlbnNlID0gY3VycmVudE9wdGlvbnMud2hpdGVzcGFjZSAhPT0gXCJwcmVzZXJ2ZVwiO1xyXG4gIGxldCByZW1vdmVkV2hpdGVzcGFjZSA9IGZhbHNlO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDIpIHtcclxuICAgICAgaWYgKCFpblByZSkge1xyXG4gICAgICAgIGlmIChpc0FsbFdoaXRlc3BhY2Uobm9kZS5jb250ZW50KSkge1xyXG4gICAgICAgICAgY29uc3QgcHJldiA9IG5vZGVzW2kgLSAxXSAmJiBub2Rlc1tpIC0gMV0udHlwZTtcclxuICAgICAgICAgIGNvbnN0IG5leHQgPSBub2Rlc1tpICsgMV0gJiYgbm9kZXNbaSArIDFdLnR5cGU7XHJcbiAgICAgICAgICBpZiAoIXByZXYgfHwgIW5leHQgfHwgc2hvdWxkQ29uZGVuc2UgJiYgKHByZXYgPT09IDMgJiYgKG5leHQgPT09IDMgfHwgbmV4dCA9PT0gMSkgfHwgcHJldiA9PT0gMSAmJiAobmV4dCA9PT0gMyB8fCBuZXh0ID09PSAxICYmIGhhc05ld2xpbmVDaGFyKG5vZGUuY29udGVudCkpKSkge1xyXG4gICAgICAgICAgICByZW1vdmVkV2hpdGVzcGFjZSA9IHRydWU7XHJcbiAgICAgICAgICAgIG5vZGVzW2ldID0gbnVsbDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5vZGUuY29udGVudCA9IFwiIFwiO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoc2hvdWxkQ29uZGVuc2UpIHtcclxuICAgICAgICAgIG5vZGUuY29udGVudCA9IGNvbmRlbnNlKG5vZGUuY29udGVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG5vZGUuY29udGVudCA9IG5vZGUuY29udGVudC5yZXBsYWNlKHdpbmRvd3NOZXdsaW5lUkUsIFwiXFxuXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZW1vdmVkV2hpdGVzcGFjZSA/IG5vZGVzLmZpbHRlcihCb29sZWFuKSA6IG5vZGVzO1xyXG59XHJcbmZ1bmN0aW9uIGlzQWxsV2hpdGVzcGFjZShzdHIpIHtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKCFpc1doaXRlc3BhY2Uoc3RyLmNoYXJDb2RlQXQoaSkpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gaGFzTmV3bGluZUNoYXIoc3RyKSB7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgIGlmIChjID09PSAxMCB8fCBjID09PSAxMykge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGNvbmRlbnNlKHN0cikge1xyXG4gIGxldCByZXQgPSBcIlwiO1xyXG4gIGxldCBwcmV2Q2hhcklzV2hpdGVzcGFjZSA9IGZhbHNlO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoaXNXaGl0ZXNwYWNlKHN0ci5jaGFyQ29kZUF0KGkpKSkge1xyXG4gICAgICBpZiAoIXByZXZDaGFySXNXaGl0ZXNwYWNlKSB7XHJcbiAgICAgICAgcmV0ICs9IFwiIFwiO1xyXG4gICAgICAgIHByZXZDaGFySXNXaGl0ZXNwYWNlID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0ICs9IHN0cltpXTtcclxuICAgICAgcHJldkNoYXJJc1doaXRlc3BhY2UgPSBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJldDtcclxufVxyXG5mdW5jdGlvbiBhZGROb2RlKG5vZGUpIHtcclxuICAoc3RhY2tbMF0gfHwgY3VycmVudFJvb3QpLmNoaWxkcmVuLnB1c2gobm9kZSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TG9jKHN0YXJ0LCBlbmQpIHtcclxuICByZXR1cm4ge1xyXG4gICAgc3RhcnQ6IHRva2VuaXplci5nZXRQb3Moc3RhcnQpLFxyXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBhbGxvdyBsYXRlIGF0dGFjaG1lbnRcclxuICAgIGVuZDogZW5kID09IG51bGwgPyBlbmQgOiB0b2tlbml6ZXIuZ2V0UG9zKGVuZCksXHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGFsbG93IGxhdGUgYXR0YWNobWVudFxyXG4gICAgc291cmNlOiBlbmQgPT0gbnVsbCA/IGVuZCA6IGdldFNsaWNlKHN0YXJ0LCBlbmQpXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBjbG9uZUxvYyhsb2MpIHtcclxuICByZXR1cm4gZ2V0TG9jKGxvYy5zdGFydC5vZmZzZXQsIGxvYy5lbmQub2Zmc2V0KTtcclxufVxyXG5mdW5jdGlvbiBzZXRMb2NFbmQobG9jLCBlbmQpIHtcclxuICBsb2MuZW5kID0gdG9rZW5pemVyLmdldFBvcyhlbmQpO1xyXG4gIGxvYy5zb3VyY2UgPSBnZXRTbGljZShsb2Muc3RhcnQub2Zmc2V0LCBlbmQpO1xyXG59XHJcbmZ1bmN0aW9uIGRpclRvQXR0cihkaXIpIHtcclxuICBjb25zdCBhdHRyID0ge1xyXG4gICAgdHlwZTogNixcclxuICAgIG5hbWU6IGRpci5yYXdOYW1lLFxyXG4gICAgbmFtZUxvYzogZ2V0TG9jKFxyXG4gICAgICBkaXIubG9jLnN0YXJ0Lm9mZnNldCxcclxuICAgICAgZGlyLmxvYy5zdGFydC5vZmZzZXQgKyBkaXIucmF3TmFtZS5sZW5ndGhcclxuICAgICksXHJcbiAgICB2YWx1ZTogdm9pZCAwLFxyXG4gICAgbG9jOiBkaXIubG9jXHJcbiAgfTtcclxuICBpZiAoZGlyLmV4cCkge1xyXG4gICAgY29uc3QgbG9jID0gZGlyLmV4cC5sb2M7XHJcbiAgICBpZiAobG9jLmVuZC5vZmZzZXQgPCBkaXIubG9jLmVuZC5vZmZzZXQpIHtcclxuICAgICAgbG9jLnN0YXJ0Lm9mZnNldC0tO1xyXG4gICAgICBsb2Muc3RhcnQuY29sdW1uLS07XHJcbiAgICAgIGxvYy5lbmQub2Zmc2V0Kys7XHJcbiAgICAgIGxvYy5lbmQuY29sdW1uKys7XHJcbiAgICB9XHJcbiAgICBhdHRyLnZhbHVlID0ge1xyXG4gICAgICB0eXBlOiAyLFxyXG4gICAgICBjb250ZW50OiBkaXIuZXhwLmNvbnRlbnQsXHJcbiAgICAgIGxvY1xyXG4gICAgfTtcclxuICB9XHJcbiAgcmV0dXJuIGF0dHI7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRXhwKGNvbnRlbnQsIGlzU3RhdGljID0gZmFsc2UsIGxvYywgY29uc3RUeXBlID0gMCwgcGFyc2VNb2RlID0gMCAvKiBOb3JtYWwgKi8pIHtcclxuICBjb25zdCBleHAgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGNvbnRlbnQsIGlzU3RhdGljLCBsb2MsIGNvbnN0VHlwZSk7XHJcbiAgcmV0dXJuIGV4cDtcclxufVxyXG5mdW5jdGlvbiBlbWl0RXJyb3IoY29kZSwgaW5kZXgsIG1lc3NhZ2UpIHtcclxuICBjdXJyZW50T3B0aW9ucy5vbkVycm9yKFxyXG4gICAgY3JlYXRlQ29tcGlsZXJFcnJvcihjb2RlLCBnZXRMb2MoaW5kZXgsIGluZGV4KSwgdm9pZCAwLCBtZXNzYWdlKVxyXG4gICk7XHJcbn1cclxuZnVuY3Rpb24gcmVzZXQoKSB7XHJcbiAgdG9rZW5pemVyLnJlc2V0KCk7XHJcbiAgY3VycmVudE9wZW5UYWcgPSBudWxsO1xyXG4gIGN1cnJlbnRQcm9wID0gbnVsbDtcclxuICBjdXJyZW50QXR0clZhbHVlID0gXCJcIjtcclxuICBjdXJyZW50QXR0clN0YXJ0SW5kZXggPSAtMTtcclxuICBjdXJyZW50QXR0ckVuZEluZGV4ID0gLTE7XHJcbiAgc3RhY2subGVuZ3RoID0gMDtcclxufVxyXG5mdW5jdGlvbiBiYXNlUGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcclxuICByZXNldCgpO1xyXG4gIGN1cnJlbnRJbnB1dCA9IGlucHV0O1xyXG4gIGN1cnJlbnRPcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0UGFyc2VyT3B0aW9ucyk7XHJcbiAgaWYgKG9wdGlvbnMpIHtcclxuICAgIGxldCBrZXk7XHJcbiAgICBmb3IgKGtleSBpbiBvcHRpb25zKSB7XHJcbiAgICAgIGlmIChvcHRpb25zW2tleV0gIT0gbnVsbCkge1xyXG4gICAgICAgIGN1cnJlbnRPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgIGlmICghY3VycmVudE9wdGlvbnMuZGVjb2RlRW50aXRpZXMpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBbQHZ1ZS9jb21waWxlci1jb3JlXSBkZWNvZGVFbnRpdGllcyBvcHRpb24gaXMgcmVxdWlyZWQgaW4gYnJvd3NlciBidWlsZHMuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuICB0b2tlbml6ZXIubW9kZSA9IGN1cnJlbnRPcHRpb25zLnBhcnNlTW9kZSA9PT0gXCJodG1sXCIgPyAxIDogY3VycmVudE9wdGlvbnMucGFyc2VNb2RlID09PSBcInNmY1wiID8gMiA6IDA7XHJcbiAgdG9rZW5pemVyLmluWE1MID0gY3VycmVudE9wdGlvbnMubnMgPT09IDEgfHwgY3VycmVudE9wdGlvbnMubnMgPT09IDI7XHJcbiAgY29uc3QgZGVsaW1pdGVycyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWxpbWl0ZXJzO1xyXG4gIGlmIChkZWxpbWl0ZXJzKSB7XHJcbiAgICB0b2tlbml6ZXIuZGVsaW1pdGVyT3BlbiA9IHRvQ2hhckNvZGVzKGRlbGltaXRlcnNbMF0pO1xyXG4gICAgdG9rZW5pemVyLmRlbGltaXRlckNsb3NlID0gdG9DaGFyQ29kZXMoZGVsaW1pdGVyc1sxXSk7XHJcbiAgfVxyXG4gIGNvbnN0IHJvb3QgPSBjdXJyZW50Um9vdCA9IGNyZWF0ZVJvb3QoW10sIGlucHV0KTtcclxuICB0b2tlbml6ZXIucGFyc2UoY3VycmVudElucHV0KTtcclxuICByb290LmxvYyA9IGdldExvYygwLCBpbnB1dC5sZW5ndGgpO1xyXG4gIHJvb3QuY2hpbGRyZW4gPSBjb25kZW5zZVdoaXRlc3BhY2Uocm9vdC5jaGlsZHJlbik7XHJcbiAgY3VycmVudFJvb3QgPSBudWxsO1xyXG4gIHJldHVybiByb290O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjYWNoZVN0YXRpYyhyb290LCBjb250ZXh0KSB7XHJcbiAgd2FsayhcclxuICAgIHJvb3QsXHJcbiAgICB2b2lkIDAsXHJcbiAgICBjb250ZXh0LFxyXG4gICAgLy8gUm9vdCBub2RlIGlzIHVuZm9ydHVuYXRlbHkgbm9uLWhvaXN0YWJsZSBkdWUgdG8gcG90ZW50aWFsIHBhcmVudFxyXG4gICAgLy8gZmFsbHRocm91Z2ggYXR0cmlidXRlcy5cclxuICAgIGlzU2luZ2xlRWxlbWVudFJvb3Qocm9vdCwgcm9vdC5jaGlsZHJlblswXSlcclxuICApO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2luZ2xlRWxlbWVudFJvb3Qocm9vdCwgY2hpbGQpIHtcclxuICBjb25zdCB7IGNoaWxkcmVuIH0gPSByb290O1xyXG4gIHJldHVybiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGQudHlwZSA9PT0gMSAmJiAhaXNTbG90T3V0bGV0KGNoaWxkKTtcclxufVxyXG5mdW5jdGlvbiB3YWxrKG5vZGUsIHBhcmVudCwgY29udGV4dCwgZG9Ob3RIb2lzdE5vZGUgPSBmYWxzZSwgaW5Gb3IgPSBmYWxzZSkge1xyXG4gIGNvbnN0IHsgY2hpbGRyZW4gfSA9IG5vZGU7XHJcbiAgY29uc3QgdG9DYWNoZSA9IFtdO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gMSAmJiBjaGlsZC50YWdUeXBlID09PSAwKSB7XHJcbiAgICAgIGNvbnN0IGNvbnN0YW50VHlwZSA9IGRvTm90SG9pc3ROb2RlID8gMCA6IGdldENvbnN0YW50VHlwZShjaGlsZCwgY29udGV4dCk7XHJcbiAgICAgIGlmIChjb25zdGFudFR5cGUgPiAwKSB7XHJcbiAgICAgICAgaWYgKGNvbnN0YW50VHlwZSA+PSAyKSB7XHJcbiAgICAgICAgICBjaGlsZC5jb2RlZ2VuTm9kZS5wYXRjaEZsYWcgPSAtMTtcclxuICAgICAgICAgIHRvQ2FjaGUucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY29kZWdlbk5vZGUgPSBjaGlsZC5jb2RlZ2VuTm9kZTtcclxuICAgICAgICBpZiAoY29kZWdlbk5vZGUudHlwZSA9PT0gMTMpIHtcclxuICAgICAgICAgIGNvbnN0IGZsYWcgPSBjb2RlZ2VuTm9kZS5wYXRjaEZsYWc7XHJcbiAgICAgICAgICBpZiAoKGZsYWcgPT09IHZvaWQgMCB8fCBmbGFnID09PSA1MTIgfHwgZmxhZyA9PT0gMSkgJiYgZ2V0R2VuZXJhdGVkUHJvcHNDb25zdGFudFR5cGUoY2hpbGQsIGNvbnRleHQpID49IDIpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBnZXROb2RlUHJvcHMoY2hpbGQpO1xyXG4gICAgICAgICAgICBpZiAocHJvcHMpIHtcclxuICAgICAgICAgICAgICBjb2RlZ2VuTm9kZS5wcm9wcyA9IGNvbnRleHQuaG9pc3QocHJvcHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoY29kZWdlbk5vZGUuZHluYW1pY1Byb3BzKSB7XHJcbiAgICAgICAgICAgIGNvZGVnZW5Ob2RlLmR5bmFtaWNQcm9wcyA9IGNvbnRleHQuaG9pc3QoY29kZWdlbk5vZGUuZHluYW1pY1Byb3BzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoY2hpbGQudHlwZSA9PT0gMTIpIHtcclxuICAgICAgY29uc3QgY29uc3RhbnRUeXBlID0gZG9Ob3RIb2lzdE5vZGUgPyAwIDogZ2V0Q29uc3RhbnRUeXBlKGNoaWxkLCBjb250ZXh0KTtcclxuICAgICAgaWYgKGNvbnN0YW50VHlwZSA+PSAyKSB7XHJcbiAgICAgICAgdG9DYWNoZS5wdXNoKGNoaWxkKTtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IDEpIHtcclxuICAgICAgY29uc3QgaXNDb21wb25lbnQgPSBjaGlsZC50YWdUeXBlID09PSAxO1xyXG4gICAgICBpZiAoaXNDb21wb25lbnQpIHtcclxuICAgICAgICBjb250ZXh0LnNjb3Blcy52U2xvdCsrO1xyXG4gICAgICB9XHJcbiAgICAgIHdhbGsoY2hpbGQsIG5vZGUsIGNvbnRleHQsIGZhbHNlLCBpbkZvcik7XHJcbiAgICAgIGlmIChpc0NvbXBvbmVudCkge1xyXG4gICAgICAgIGNvbnRleHQuc2NvcGVzLnZTbG90LS07XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoY2hpbGQudHlwZSA9PT0gMTEpIHtcclxuICAgICAgd2FsayhjaGlsZCwgbm9kZSwgY29udGV4dCwgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoID09PSAxLCB0cnVlKTtcclxuICAgIH0gZWxzZSBpZiAoY2hpbGQudHlwZSA9PT0gOSkge1xyXG4gICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgY2hpbGQuYnJhbmNoZXMubGVuZ3RoOyBpMisrKSB7XHJcbiAgICAgICAgd2FsayhcclxuICAgICAgICAgIGNoaWxkLmJyYW5jaGVzW2kyXSxcclxuICAgICAgICAgIG5vZGUsXHJcbiAgICAgICAgICBjb250ZXh0LFxyXG4gICAgICAgICAgY2hpbGQuYnJhbmNoZXNbaTJdLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSxcclxuICAgICAgICAgIGluRm9yXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBsZXQgY2FjaGVkQXNBcnJheSA9IGZhbHNlO1xyXG4gIGlmICh0b0NhY2hlLmxlbmd0aCA9PT0gY2hpbGRyZW4ubGVuZ3RoICYmIG5vZGUudHlwZSA9PT0gMSkge1xyXG4gICAgaWYgKG5vZGUudGFnVHlwZSA9PT0gMCAmJiBub2RlLmNvZGVnZW5Ob2RlICYmIG5vZGUuY29kZWdlbk5vZGUudHlwZSA9PT0gMTMgJiYgaXNBcnJheShub2RlLmNvZGVnZW5Ob2RlLmNoaWxkcmVuKSkge1xyXG4gICAgICBub2RlLmNvZGVnZW5Ob2RlLmNoaWxkcmVuID0gZ2V0Q2FjaGVFeHByZXNzaW9uKFxyXG4gICAgICAgIGNyZWF0ZUFycmF5RXhwcmVzc2lvbihub2RlLmNvZGVnZW5Ob2RlLmNoaWxkcmVuKVxyXG4gICAgICApO1xyXG4gICAgICBjYWNoZWRBc0FycmF5ID0gdHJ1ZTtcclxuICAgIH0gZWxzZSBpZiAobm9kZS50YWdUeXBlID09PSAxICYmIG5vZGUuY29kZWdlbk5vZGUgJiYgbm9kZS5jb2RlZ2VuTm9kZS50eXBlID09PSAxMyAmJiBub2RlLmNvZGVnZW5Ob2RlLmNoaWxkcmVuICYmICFpc0FycmF5KG5vZGUuY29kZWdlbk5vZGUuY2hpbGRyZW4pICYmIG5vZGUuY29kZWdlbk5vZGUuY2hpbGRyZW4udHlwZSA9PT0gMTUpIHtcclxuICAgICAgY29uc3Qgc2xvdCA9IGdldFNsb3ROb2RlKG5vZGUuY29kZWdlbk5vZGUsIFwiZGVmYXVsdFwiKTtcclxuICAgICAgaWYgKHNsb3QpIHtcclxuICAgICAgICBzbG90LnJldHVybnMgPSBnZXRDYWNoZUV4cHJlc3Npb24oXHJcbiAgICAgICAgICBjcmVhdGVBcnJheUV4cHJlc3Npb24oc2xvdC5yZXR1cm5zKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY2FjaGVkQXNBcnJheSA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobm9kZS50YWdUeXBlID09PSAzICYmIHBhcmVudCAmJiBwYXJlbnQudHlwZSA9PT0gMSAmJiBwYXJlbnQudGFnVHlwZSA9PT0gMSAmJiBwYXJlbnQuY29kZWdlbk5vZGUgJiYgcGFyZW50LmNvZGVnZW5Ob2RlLnR5cGUgPT09IDEzICYmIHBhcmVudC5jb2RlZ2VuTm9kZS5jaGlsZHJlbiAmJiAhaXNBcnJheShwYXJlbnQuY29kZWdlbk5vZGUuY2hpbGRyZW4pICYmIHBhcmVudC5jb2RlZ2VuTm9kZS5jaGlsZHJlbi50eXBlID09PSAxNSkge1xyXG4gICAgICBjb25zdCBzbG90TmFtZSA9IGZpbmREaXIobm9kZSwgXCJzbG90XCIsIHRydWUpO1xyXG4gICAgICBjb25zdCBzbG90ID0gc2xvdE5hbWUgJiYgc2xvdE5hbWUuYXJnICYmIGdldFNsb3ROb2RlKHBhcmVudC5jb2RlZ2VuTm9kZSwgc2xvdE5hbWUuYXJnKTtcclxuICAgICAgaWYgKHNsb3QpIHtcclxuICAgICAgICBzbG90LnJldHVybnMgPSBnZXRDYWNoZUV4cHJlc3Npb24oXHJcbiAgICAgICAgICBjcmVhdGVBcnJheUV4cHJlc3Npb24oc2xvdC5yZXR1cm5zKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY2FjaGVkQXNBcnJheSA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgaWYgKCFjYWNoZWRBc0FycmF5KSB7XHJcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRvQ2FjaGUpIHtcclxuICAgICAgY2hpbGQuY29kZWdlbk5vZGUgPSBjb250ZXh0LmNhY2hlKGNoaWxkLmNvZGVnZW5Ob2RlKTtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gZ2V0Q2FjaGVFeHByZXNzaW9uKHZhbHVlKSB7XHJcbiAgICBjb25zdCBleHAgPSBjb250ZXh0LmNhY2hlKHZhbHVlKTtcclxuICAgIGlmIChpbkZvciAmJiBjb250ZXh0Lmhtcikge1xyXG4gICAgICBleHAubmVlZEFycmF5U3ByZWFkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBleHA7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGdldFNsb3ROb2RlKG5vZGUyLCBuYW1lKSB7XHJcbiAgICBpZiAobm9kZTIuY2hpbGRyZW4gJiYgIWlzQXJyYXkobm9kZTIuY2hpbGRyZW4pICYmIG5vZGUyLmNoaWxkcmVuLnR5cGUgPT09IDE1KSB7XHJcbiAgICAgIGNvbnN0IHNsb3QgPSBub2RlMi5jaGlsZHJlbi5wcm9wZXJ0aWVzLmZpbmQoXHJcbiAgICAgICAgKHApID0+IHAua2V5ID09PSBuYW1lIHx8IHAua2V5LmNvbnRlbnQgPT09IG5hbWVcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHNsb3QgJiYgc2xvdC52YWx1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKHRvQ2FjaGUubGVuZ3RoICYmIGNvbnRleHQudHJhbnNmb3JtSG9pc3QpIHtcclxuICAgIGNvbnRleHQudHJhbnNmb3JtSG9pc3QoY2hpbGRyZW4sIGNvbnRleHQsIG5vZGUpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBnZXRDb25zdGFudFR5cGUobm9kZSwgY29udGV4dCkge1xyXG4gIGNvbnN0IHsgY29uc3RhbnRDYWNoZSB9ID0gY29udGV4dDtcclxuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xyXG4gICAgY2FzZSAxOlxyXG4gICAgICBpZiAobm9kZS50YWdUeXBlICE9PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgY2FjaGVkID0gY29uc3RhbnRDYWNoZS5nZXQobm9kZSk7XHJcbiAgICAgIGlmIChjYWNoZWQgIT09IHZvaWQgMCkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgY29kZWdlbk5vZGUgPSBub2RlLmNvZGVnZW5Ob2RlO1xyXG4gICAgICBpZiAoY29kZWdlbk5vZGUudHlwZSAhPT0gMTMpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY29kZWdlbk5vZGUuaXNCbG9jayAmJiBub2RlLnRhZyAhPT0gXCJzdmdcIiAmJiBub2RlLnRhZyAhPT0gXCJmb3JlaWduT2JqZWN0XCIgJiYgbm9kZS50YWcgIT09IFwibWF0aFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNvZGVnZW5Ob2RlLnBhdGNoRmxhZyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgbGV0IHJldHVyblR5cGUyID0gMztcclxuICAgICAgICBjb25zdCBnZW5lcmF0ZWRQcm9wc1R5cGUgPSBnZXRHZW5lcmF0ZWRQcm9wc0NvbnN0YW50VHlwZShub2RlLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAoZ2VuZXJhdGVkUHJvcHNUeXBlID09PSAwKSB7XHJcbiAgICAgICAgICBjb25zdGFudENhY2hlLnNldChub2RlLCAwKTtcclxuICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZ2VuZXJhdGVkUHJvcHNUeXBlIDwgcmV0dXJuVHlwZTIpIHtcclxuICAgICAgICAgIHJldHVyblR5cGUyID0gZ2VuZXJhdGVkUHJvcHNUeXBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGNvbnN0IGNoaWxkVHlwZSA9IGdldENvbnN0YW50VHlwZShub2RlLmNoaWxkcmVuW2ldLCBjb250ZXh0KTtcclxuICAgICAgICAgIGlmIChjaGlsZFR5cGUgPT09IDApIHtcclxuICAgICAgICAgICAgY29uc3RhbnRDYWNoZS5zZXQobm9kZSwgMCk7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGNoaWxkVHlwZSA8IHJldHVyblR5cGUyKSB7XHJcbiAgICAgICAgICAgIHJldHVyblR5cGUyID0gY2hpbGRUeXBlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmV0dXJuVHlwZTIgPiAxKSB7XHJcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgcCA9IG5vZGUucHJvcHNbaV07XHJcbiAgICAgICAgICAgIGlmIChwLnR5cGUgPT09IDcgJiYgcC5uYW1lID09PSBcImJpbmRcIiAmJiBwLmV4cCkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGV4cFR5cGUgPSBnZXRDb25zdGFudFR5cGUocC5leHAsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgIGlmIChleHBUeXBlID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdGFudENhY2hlLnNldChub2RlLCAwKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoZXhwVHlwZSA8IHJldHVyblR5cGUyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5UeXBlMiA9IGV4cFR5cGU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb2RlZ2VuTm9kZS5pc0Jsb2NrKSB7XHJcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgcCA9IG5vZGUucHJvcHNbaV07XHJcbiAgICAgICAgICAgIGlmIChwLnR5cGUgPT09IDcpIHtcclxuICAgICAgICAgICAgICBjb25zdGFudENhY2hlLnNldChub2RlLCAwKTtcclxuICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY29udGV4dC5yZW1vdmVIZWxwZXIoT1BFTl9CTE9DSyk7XHJcbiAgICAgICAgICBjb250ZXh0LnJlbW92ZUhlbHBlcihcclxuICAgICAgICAgICAgZ2V0Vk5vZGVCbG9ja0hlbHBlcihjb250ZXh0LmluU1NSLCBjb2RlZ2VuTm9kZS5pc0NvbXBvbmVudClcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBjb2RlZ2VuTm9kZS5pc0Jsb2NrID0gZmFsc2U7XHJcbiAgICAgICAgICBjb250ZXh0LmhlbHBlcihnZXRWTm9kZUhlbHBlcihjb250ZXh0LmluU1NSLCBjb2RlZ2VuTm9kZS5pc0NvbXBvbmVudCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdGFudENhY2hlLnNldChub2RlLCByZXR1cm5UeXBlMik7XHJcbiAgICAgICAgcmV0dXJuIHJldHVyblR5cGUyO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0YW50Q2FjaGUuc2V0KG5vZGUsIDApO1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgICB9XHJcbiAgICBjYXNlIDI6XHJcbiAgICBjYXNlIDM6XHJcbiAgICAgIHJldHVybiAzO1xyXG4gICAgY2FzZSA5OlxyXG4gICAgY2FzZSAxMTpcclxuICAgIGNhc2UgMTA6XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgY2FzZSA1OlxyXG4gICAgY2FzZSAxMjpcclxuICAgICAgcmV0dXJuIGdldENvbnN0YW50VHlwZShub2RlLmNvbnRlbnQsIGNvbnRleHQpO1xyXG4gICAgY2FzZSA0OlxyXG4gICAgICByZXR1cm4gbm9kZS5jb25zdFR5cGU7XHJcbiAgICBjYXNlIDg6XHJcbiAgICAgIGxldCByZXR1cm5UeXBlID0gMztcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgIGlmIChpc1N0cmluZyhjaGlsZCkgfHwgaXNTeW1ib2woY2hpbGQpKSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2hpbGRUeXBlID0gZ2V0Q29uc3RhbnRUeXBlKGNoaWxkLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAoY2hpbGRUeXBlID09PSAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkVHlwZSA8IHJldHVyblR5cGUpIHtcclxuICAgICAgICAgIHJldHVyblR5cGUgPSBjaGlsZFR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXR1cm5UeXBlO1xyXG4gICAgY2FzZSAyMDpcclxuICAgICAgcmV0dXJuIDI7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkgO1xyXG4gICAgICByZXR1cm4gMDtcclxuICB9XHJcbn1cclxuY29uc3QgYWxsb3dIb2lzdGVkSGVscGVyU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xyXG4gIE5PUk1BTElaRV9DTEFTUyxcclxuICBOT1JNQUxJWkVfU1RZTEUsXHJcbiAgTk9STUFMSVpFX1BST1BTLFxyXG4gIEdVQVJEX1JFQUNUSVZFX1BST1BTXHJcbl0pO1xyXG5mdW5jdGlvbiBnZXRDb25zdGFudFR5cGVPZkhlbHBlckNhbGwodmFsdWUsIGNvbnRleHQpIHtcclxuICBpZiAodmFsdWUudHlwZSA9PT0gMTQgJiYgIWlzU3RyaW5nKHZhbHVlLmNhbGxlZSkgJiYgYWxsb3dIb2lzdGVkSGVscGVyU2V0Lmhhcyh2YWx1ZS5jYWxsZWUpKSB7XHJcbiAgICBjb25zdCBhcmcgPSB2YWx1ZS5hcmd1bWVudHNbMF07XHJcbiAgICBpZiAoYXJnLnR5cGUgPT09IDQpIHtcclxuICAgICAgcmV0dXJuIGdldENvbnN0YW50VHlwZShhcmcsIGNvbnRleHQpO1xyXG4gICAgfSBlbHNlIGlmIChhcmcudHlwZSA9PT0gMTQpIHtcclxuICAgICAgcmV0dXJuIGdldENvbnN0YW50VHlwZU9mSGVscGVyQ2FsbChhcmcsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gMDtcclxufVxyXG5mdW5jdGlvbiBnZXRHZW5lcmF0ZWRQcm9wc0NvbnN0YW50VHlwZShub2RlLCBjb250ZXh0KSB7XHJcbiAgbGV0IHJldHVyblR5cGUgPSAzO1xyXG4gIGNvbnN0IHByb3BzID0gZ2V0Tm9kZVByb3BzKG5vZGUpO1xyXG4gIGlmIChwcm9wcyAmJiBwcm9wcy50eXBlID09PSAxNSkge1xyXG4gICAgY29uc3QgeyBwcm9wZXJ0aWVzIH0gPSBwcm9wcztcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IHByb3BlcnRpZXNbaV07XHJcbiAgICAgIGNvbnN0IGtleVR5cGUgPSBnZXRDb25zdGFudFR5cGUoa2V5LCBjb250ZXh0KTtcclxuICAgICAgaWYgKGtleVR5cGUgPT09IDApIHtcclxuICAgICAgICByZXR1cm4ga2V5VHlwZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoa2V5VHlwZSA8IHJldHVyblR5cGUpIHtcclxuICAgICAgICByZXR1cm5UeXBlID0ga2V5VHlwZTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgdmFsdWVUeXBlO1xyXG4gICAgICBpZiAodmFsdWUudHlwZSA9PT0gNCkge1xyXG4gICAgICAgIHZhbHVlVHlwZSA9IGdldENvbnN0YW50VHlwZSh2YWx1ZSwgY29udGV4dCk7XHJcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUudHlwZSA9PT0gMTQpIHtcclxuICAgICAgICB2YWx1ZVR5cGUgPSBnZXRDb25zdGFudFR5cGVPZkhlbHBlckNhbGwodmFsdWUsIGNvbnRleHQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhbHVlVHlwZSA9IDA7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHZhbHVlVHlwZSA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZVR5cGU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHZhbHVlVHlwZSA8IHJldHVyblR5cGUpIHtcclxuICAgICAgICByZXR1cm5UeXBlID0gdmFsdWVUeXBlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXR1cm5UeXBlO1xyXG59XHJcbmZ1bmN0aW9uIGdldE5vZGVQcm9wcyhub2RlKSB7XHJcbiAgY29uc3QgY29kZWdlbk5vZGUgPSBub2RlLmNvZGVnZW5Ob2RlO1xyXG4gIGlmIChjb2RlZ2VuTm9kZS50eXBlID09PSAxMykge1xyXG4gICAgcmV0dXJuIGNvZGVnZW5Ob2RlLnByb3BzO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlVHJhbnNmb3JtQ29udGV4dChyb290LCB7XHJcbiAgZmlsZW5hbWUgPSBcIlwiLFxyXG4gIHByZWZpeElkZW50aWZpZXJzID0gZmFsc2UsXHJcbiAgaG9pc3RTdGF0aWMgPSBmYWxzZSxcclxuICBobXIgPSBmYWxzZSxcclxuICBjYWNoZUhhbmRsZXJzID0gZmFsc2UsXHJcbiAgbm9kZVRyYW5zZm9ybXMgPSBbXSxcclxuICBkaXJlY3RpdmVUcmFuc2Zvcm1zID0ge30sXHJcbiAgdHJhbnNmb3JtSG9pc3QgPSBudWxsLFxyXG4gIGlzQnVpbHRJbkNvbXBvbmVudCA9IE5PT1AsXHJcbiAgaXNDdXN0b21FbGVtZW50ID0gTk9PUCxcclxuICBleHByZXNzaW9uUGx1Z2lucyA9IFtdLFxyXG4gIHNjb3BlSWQgPSBudWxsLFxyXG4gIHNsb3R0ZWQgPSB0cnVlLFxyXG4gIHNzciA9IGZhbHNlLFxyXG4gIGluU1NSID0gZmFsc2UsXHJcbiAgc3NyQ3NzVmFycyA9IGBgLFxyXG4gIGJpbmRpbmdNZXRhZGF0YSA9IEVNUFRZX09CSixcclxuICBpbmxpbmUgPSBmYWxzZSxcclxuICBpc1RTID0gZmFsc2UsXHJcbiAgb25FcnJvciA9IGRlZmF1bHRPbkVycm9yLFxyXG4gIG9uV2FybiA9IGRlZmF1bHRPbldhcm4sXHJcbiAgY29tcGF0Q29uZmlnXHJcbn0pIHtcclxuICBjb25zdCBuYW1lTWF0Y2ggPSBmaWxlbmFtZS5yZXBsYWNlKC9cXD8uKiQvLCBcIlwiKS5tYXRjaCgvKFteL1xcXFxdKylcXC5cXHcrJC8pO1xyXG4gIGNvbnN0IGNvbnRleHQgPSB7XHJcbiAgICAvLyBvcHRpb25zXHJcbiAgICBmaWxlbmFtZSxcclxuICAgIHNlbGZOYW1lOiBuYW1lTWF0Y2ggJiYgY2FwaXRhbGl6ZShjYW1lbGl6ZShuYW1lTWF0Y2hbMV0pKSxcclxuICAgIHByZWZpeElkZW50aWZpZXJzLFxyXG4gICAgaG9pc3RTdGF0aWMsXHJcbiAgICBobXIsXHJcbiAgICBjYWNoZUhhbmRsZXJzLFxyXG4gICAgbm9kZVRyYW5zZm9ybXMsXHJcbiAgICBkaXJlY3RpdmVUcmFuc2Zvcm1zLFxyXG4gICAgdHJhbnNmb3JtSG9pc3QsXHJcbiAgICBpc0J1aWx0SW5Db21wb25lbnQsXHJcbiAgICBpc0N1c3RvbUVsZW1lbnQsXHJcbiAgICBleHByZXNzaW9uUGx1Z2lucyxcclxuICAgIHNjb3BlSWQsXHJcbiAgICBzbG90dGVkLFxyXG4gICAgc3NyLFxyXG4gICAgaW5TU1IsXHJcbiAgICBzc3JDc3NWYXJzLFxyXG4gICAgYmluZGluZ01ldGFkYXRhLFxyXG4gICAgaW5saW5lLFxyXG4gICAgaXNUUyxcclxuICAgIG9uRXJyb3IsXHJcbiAgICBvbldhcm4sXHJcbiAgICBjb21wYXRDb25maWcsXHJcbiAgICAvLyBzdGF0ZVxyXG4gICAgcm9vdCxcclxuICAgIGhlbHBlcnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXHJcbiAgICBjb21wb25lbnRzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxyXG4gICAgZGlyZWN0aXZlczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcclxuICAgIGhvaXN0czogW10sXHJcbiAgICBpbXBvcnRzOiBbXSxcclxuICAgIGNhY2hlZDogW10sXHJcbiAgICBjb25zdGFudENhY2hlOiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSxcclxuICAgIHRlbXBzOiAwLFxyXG4gICAgaWRlbnRpZmllcnM6IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG4gICAgc2NvcGVzOiB7XHJcbiAgICAgIHZGb3I6IDAsXHJcbiAgICAgIHZTbG90OiAwLFxyXG4gICAgICB2UHJlOiAwLFxyXG4gICAgICB2T25jZTogMFxyXG4gICAgfSxcclxuICAgIHBhcmVudDogbnVsbCxcclxuICAgIGdyYW5kUGFyZW50OiBudWxsLFxyXG4gICAgY3VycmVudE5vZGU6IHJvb3QsXHJcbiAgICBjaGlsZEluZGV4OiAwLFxyXG4gICAgaW5WT25jZTogZmFsc2UsXHJcbiAgICAvLyBtZXRob2RzXHJcbiAgICBoZWxwZXIobmFtZSkge1xyXG4gICAgICBjb25zdCBjb3VudCA9IGNvbnRleHQuaGVscGVycy5nZXQobmFtZSkgfHwgMDtcclxuICAgICAgY29udGV4dC5oZWxwZXJzLnNldChuYW1lLCBjb3VudCArIDEpO1xyXG4gICAgICByZXR1cm4gbmFtZTtcclxuICAgIH0sXHJcbiAgICByZW1vdmVIZWxwZXIobmFtZSkge1xyXG4gICAgICBjb25zdCBjb3VudCA9IGNvbnRleHQuaGVscGVycy5nZXQobmFtZSk7XHJcbiAgICAgIGlmIChjb3VudCkge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb3VudCA9IGNvdW50IC0gMTtcclxuICAgICAgICBpZiAoIWN1cnJlbnRDb3VudCkge1xyXG4gICAgICAgICAgY29udGV4dC5oZWxwZXJzLmRlbGV0ZShuYW1lKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29udGV4dC5oZWxwZXJzLnNldChuYW1lLCBjdXJyZW50Q291bnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGhlbHBlclN0cmluZyhuYW1lKSB7XHJcbiAgICAgIHJldHVybiBgXyR7aGVscGVyTmFtZU1hcFtjb250ZXh0LmhlbHBlcihuYW1lKV19YDtcclxuICAgIH0sXHJcbiAgICByZXBsYWNlTm9kZShub2RlKSB7XHJcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgICAgaWYgKCFjb250ZXh0LmN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vZGUgYmVpbmcgcmVwbGFjZWQgaXMgYWxyZWFkeSByZW1vdmVkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWNvbnRleHQucGFyZW50KSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZXBsYWNlIHJvb3Qgbm9kZS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgY29udGV4dC5wYXJlbnQuY2hpbGRyZW5bY29udGV4dC5jaGlsZEluZGV4XSA9IGNvbnRleHQuY3VycmVudE5vZGUgPSBub2RlO1xyXG4gICAgfSxcclxuICAgIHJlbW92ZU5vZGUobm9kZSkge1xyXG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhY29udGV4dC5wYXJlbnQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZW1vdmUgcm9vdCBub2RlLmApO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGxpc3QgPSBjb250ZXh0LnBhcmVudC5jaGlsZHJlbjtcclxuICAgICAgY29uc3QgcmVtb3ZhbEluZGV4ID0gbm9kZSA/IGxpc3QuaW5kZXhPZihub2RlKSA6IGNvbnRleHQuY3VycmVudE5vZGUgPyBjb250ZXh0LmNoaWxkSW5kZXggOiAtMTtcclxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgcmVtb3ZhbEluZGV4IDwgMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm9kZSBiZWluZyByZW1vdmVkIGlzIG5vdCBhIGNoaWxkIG9mIGN1cnJlbnQgcGFyZW50YCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFub2RlIHx8IG5vZGUgPT09IGNvbnRleHQuY3VycmVudE5vZGUpIHtcclxuICAgICAgICBjb250ZXh0LmN1cnJlbnROb2RlID0gbnVsbDtcclxuICAgICAgICBjb250ZXh0Lm9uTm9kZVJlbW92ZWQoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoY29udGV4dC5jaGlsZEluZGV4ID4gcmVtb3ZhbEluZGV4KSB7XHJcbiAgICAgICAgICBjb250ZXh0LmNoaWxkSW5kZXgtLTtcclxuICAgICAgICAgIGNvbnRleHQub25Ob2RlUmVtb3ZlZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBjb250ZXh0LnBhcmVudC5jaGlsZHJlbi5zcGxpY2UocmVtb3ZhbEluZGV4LCAxKTtcclxuICAgIH0sXHJcbiAgICBvbk5vZGVSZW1vdmVkOiBOT09QLFxyXG4gICAgYWRkSWRlbnRpZmllcnMoZXhwKSB7XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlSWRlbnRpZmllcnMoZXhwKSB7XHJcbiAgICB9LFxyXG4gICAgaG9pc3QoZXhwKSB7XHJcbiAgICAgIGlmIChpc1N0cmluZyhleHApKSBleHAgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGV4cCk7XHJcbiAgICAgIGNvbnRleHQuaG9pc3RzLnB1c2goZXhwKTtcclxuICAgICAgY29uc3QgaWRlbnRpZmllciA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oXHJcbiAgICAgICAgYF9ob2lzdGVkXyR7Y29udGV4dC5ob2lzdHMubGVuZ3RofWAsXHJcbiAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgZXhwLmxvYyxcclxuICAgICAgICAyXHJcbiAgICAgICk7XHJcbiAgICAgIGlkZW50aWZpZXIuaG9pc3RlZCA9IGV4cDtcclxuICAgICAgcmV0dXJuIGlkZW50aWZpZXI7XHJcbiAgICB9LFxyXG4gICAgY2FjaGUoZXhwLCBpc1ZOb2RlID0gZmFsc2UsIGluVk9uY2UgPSBmYWxzZSkge1xyXG4gICAgICBjb25zdCBjYWNoZUV4cCA9IGNyZWF0ZUNhY2hlRXhwcmVzc2lvbihcclxuICAgICAgICBjb250ZXh0LmNhY2hlZC5sZW5ndGgsXHJcbiAgICAgICAgZXhwLFxyXG4gICAgICAgIGlzVk5vZGUsXHJcbiAgICAgICAgaW5WT25jZVxyXG4gICAgICApO1xyXG4gICAgICBjb250ZXh0LmNhY2hlZC5wdXNoKGNhY2hlRXhwKTtcclxuICAgICAgcmV0dXJuIGNhY2hlRXhwO1xyXG4gICAgfVxyXG4gIH07XHJcbiAge1xyXG4gICAgY29udGV4dC5maWx0ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcclxuICB9XHJcbiAgcmV0dXJuIGNvbnRleHQ7XHJcbn1cclxuZnVuY3Rpb24gdHJhbnNmb3JtKHJvb3QsIG9wdGlvbnMpIHtcclxuICBjb25zdCBjb250ZXh0ID0gY3JlYXRlVHJhbnNmb3JtQ29udGV4dChyb290LCBvcHRpb25zKTtcclxuICB0cmF2ZXJzZU5vZGUocm9vdCwgY29udGV4dCk7XHJcbiAgaWYgKG9wdGlvbnMuaG9pc3RTdGF0aWMpIHtcclxuICAgIGNhY2hlU3RhdGljKHJvb3QsIGNvbnRleHQpO1xyXG4gIH1cclxuICBpZiAoIW9wdGlvbnMuc3NyKSB7XHJcbiAgICBjcmVhdGVSb290Q29kZWdlbihyb290LCBjb250ZXh0KTtcclxuICB9XHJcbiAgcm9vdC5oZWxwZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLmNvbnRleHQuaGVscGVycy5rZXlzKCldKTtcclxuICByb290LmNvbXBvbmVudHMgPSBbLi4uY29udGV4dC5jb21wb25lbnRzXTtcclxuICByb290LmRpcmVjdGl2ZXMgPSBbLi4uY29udGV4dC5kaXJlY3RpdmVzXTtcclxuICByb290LmltcG9ydHMgPSBjb250ZXh0LmltcG9ydHM7XHJcbiAgcm9vdC5ob2lzdHMgPSBjb250ZXh0LmhvaXN0cztcclxuICByb290LnRlbXBzID0gY29udGV4dC50ZW1wcztcclxuICByb290LmNhY2hlZCA9IGNvbnRleHQuY2FjaGVkO1xyXG4gIHJvb3QudHJhbnNmb3JtZWQgPSB0cnVlO1xyXG4gIHtcclxuICAgIHJvb3QuZmlsdGVycyA9IFsuLi5jb250ZXh0LmZpbHRlcnNdO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSb290Q29kZWdlbihyb290LCBjb250ZXh0KSB7XHJcbiAgY29uc3QgeyBoZWxwZXIgfSA9IGNvbnRleHQ7XHJcbiAgY29uc3QgeyBjaGlsZHJlbiB9ID0gcm9vdDtcclxuICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XHJcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xyXG4gICAgaWYgKGlzU2luZ2xlRWxlbWVudFJvb3Qocm9vdCwgY2hpbGQpICYmIGNoaWxkLmNvZGVnZW5Ob2RlKSB7XHJcbiAgICAgIGNvbnN0IGNvZGVnZW5Ob2RlID0gY2hpbGQuY29kZWdlbk5vZGU7XHJcbiAgICAgIGlmIChjb2RlZ2VuTm9kZS50eXBlID09PSAxMykge1xyXG4gICAgICAgIGNvbnZlcnRUb0Jsb2NrKGNvZGVnZW5Ob2RlLCBjb250ZXh0KTtcclxuICAgICAgfVxyXG4gICAgICByb290LmNvZGVnZW5Ob2RlID0gY29kZWdlbk5vZGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByb290LmNvZGVnZW5Ob2RlID0gY2hpbGQ7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XHJcbiAgICBsZXQgcGF0Y2hGbGFnID0gNjQ7XHJcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjaGlsZHJlbi5maWx0ZXIoKGMpID0+IGMudHlwZSAhPT0gMykubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgIHBhdGNoRmxhZyB8PSAyMDQ4O1xyXG4gICAgfVxyXG4gICAgcm9vdC5jb2RlZ2VuTm9kZSA9IGNyZWF0ZVZOb2RlQ2FsbChcclxuICAgICAgY29udGV4dCxcclxuICAgICAgaGVscGVyKEZSQUdNRU5UKSxcclxuICAgICAgdm9pZCAwLFxyXG4gICAgICByb290LmNoaWxkcmVuLFxyXG4gICAgICBwYXRjaEZsYWcsXHJcbiAgICAgIHZvaWQgMCxcclxuICAgICAgdm9pZCAwLFxyXG4gICAgICB0cnVlLFxyXG4gICAgICB2b2lkIDAsXHJcbiAgICAgIGZhbHNlXHJcbiAgICApO1xyXG4gIH0gZWxzZSA7XHJcbn1cclxuZnVuY3Rpb24gdHJhdmVyc2VDaGlsZHJlbihwYXJlbnQsIGNvbnRleHQpIHtcclxuICBsZXQgaSA9IDA7XHJcbiAgY29uc3Qgbm9kZVJlbW92ZWQgPSAoKSA9PiB7XHJcbiAgICBpLS07XHJcbiAgfTtcclxuICBmb3IgKDsgaSA8IHBhcmVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3QgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5baV07XHJcbiAgICBpZiAoaXNTdHJpbmcoY2hpbGQpKSBjb250aW51ZTtcclxuICAgIGNvbnRleHQuZ3JhbmRQYXJlbnQgPSBjb250ZXh0LnBhcmVudDtcclxuICAgIGNvbnRleHQucGFyZW50ID0gcGFyZW50O1xyXG4gICAgY29udGV4dC5jaGlsZEluZGV4ID0gaTtcclxuICAgIGNvbnRleHQub25Ob2RlUmVtb3ZlZCA9IG5vZGVSZW1vdmVkO1xyXG4gICAgdHJhdmVyc2VOb2RlKGNoaWxkLCBjb250ZXh0KTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gdHJhdmVyc2VOb2RlKG5vZGUsIGNvbnRleHQpIHtcclxuICBjb250ZXh0LmN1cnJlbnROb2RlID0gbm9kZTtcclxuICBjb25zdCB7IG5vZGVUcmFuc2Zvcm1zIH0gPSBjb250ZXh0O1xyXG4gIGNvbnN0IGV4aXRGbnMgPSBbXTtcclxuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbm9kZVRyYW5zZm9ybXMubGVuZ3RoOyBpMisrKSB7XHJcbiAgICBjb25zdCBvbkV4aXQgPSBub2RlVHJhbnNmb3Jtc1tpMl0obm9kZSwgY29udGV4dCk7XHJcbiAgICBpZiAob25FeGl0KSB7XHJcbiAgICAgIGlmIChpc0FycmF5KG9uRXhpdCkpIHtcclxuICAgICAgICBleGl0Rm5zLnB1c2goLi4ub25FeGl0KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBleGl0Rm5zLnB1c2gob25FeGl0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFjb250ZXh0LmN1cnJlbnROb2RlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG5vZGUgPSBjb250ZXh0LmN1cnJlbnROb2RlO1xyXG4gICAgfVxyXG4gIH1cclxuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xyXG4gICAgY2FzZSAzOlxyXG4gICAgICBpZiAoIWNvbnRleHQuc3NyKSB7XHJcbiAgICAgICAgY29udGV4dC5oZWxwZXIoQ1JFQVRFX0NPTU1FTlQpO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSA1OlxyXG4gICAgICBpZiAoIWNvbnRleHQuc3NyKSB7XHJcbiAgICAgICAgY29udGV4dC5oZWxwZXIoVE9fRElTUExBWV9TVFJJTkcpO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgLy8gZm9yIGNvbnRhaW5lciB0eXBlcywgZnVydGhlciB0cmF2ZXJzZSBkb3dud2FyZHNcclxuICAgIGNhc2UgOTpcclxuICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG5vZGUuYnJhbmNoZXMubGVuZ3RoOyBpMisrKSB7XHJcbiAgICAgICAgdHJhdmVyc2VOb2RlKG5vZGUuYnJhbmNoZXNbaTJdLCBjb250ZXh0KTtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMTA6XHJcbiAgICBjYXNlIDExOlxyXG4gICAgY2FzZSAxOlxyXG4gICAgY2FzZSAwOlxyXG4gICAgICB0cmF2ZXJzZUNoaWxkcmVuKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICBicmVhaztcclxuICB9XHJcbiAgY29udGV4dC5jdXJyZW50Tm9kZSA9IG5vZGU7XHJcbiAgbGV0IGkgPSBleGl0Rm5zLmxlbmd0aDtcclxuICB3aGlsZSAoaS0tKSB7XHJcbiAgICBleGl0Rm5zW2ldKCk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVN0cnVjdHVyYWxEaXJlY3RpdmVUcmFuc2Zvcm0obmFtZSwgZm4pIHtcclxuICBjb25zdCBtYXRjaGVzID0gaXNTdHJpbmcobmFtZSkgPyAobikgPT4gbiA9PT0gbmFtZSA6IChuKSA9PiBuYW1lLnRlc3Qobik7XHJcbiAgcmV0dXJuIChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAxKSB7XHJcbiAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IG5vZGU7XHJcbiAgICAgIGlmIChub2RlLnRhZ1R5cGUgPT09IDMgJiYgcHJvcHMuc29tZShpc1ZTbG90KSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBleGl0Rm5zID0gW107XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwcm9wID0gcHJvcHNbaV07XHJcbiAgICAgICAgaWYgKHByb3AudHlwZSA9PT0gNyAmJiBtYXRjaGVzKHByb3AubmFtZSkpIHtcclxuICAgICAgICAgIHByb3BzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgIGktLTtcclxuICAgICAgICAgIGNvbnN0IG9uRXhpdCA9IGZuKG5vZGUsIHByb3AsIGNvbnRleHQpO1xyXG4gICAgICAgICAgaWYgKG9uRXhpdCkgZXhpdEZucy5wdXNoKG9uRXhpdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBleGl0Rm5zO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbmNvbnN0IFBVUkVfQU5OT1RBVElPTiA9IGAvKkBfX1BVUkVfXyovYDtcclxuY29uc3QgYWxpYXNIZWxwZXIgPSAocykgPT4gYCR7aGVscGVyTmFtZU1hcFtzXX06IF8ke2hlbHBlck5hbWVNYXBbc119YDtcclxuZnVuY3Rpb24gY3JlYXRlQ29kZWdlbkNvbnRleHQoYXN0LCB7XHJcbiAgbW9kZSA9IFwiZnVuY3Rpb25cIixcclxuICBwcmVmaXhJZGVudGlmaWVycyA9IG1vZGUgPT09IFwibW9kdWxlXCIsXHJcbiAgc291cmNlTWFwID0gZmFsc2UsXHJcbiAgZmlsZW5hbWUgPSBgdGVtcGxhdGUudnVlLmh0bWxgLFxyXG4gIHNjb3BlSWQgPSBudWxsLFxyXG4gIG9wdGltaXplSW1wb3J0cyA9IGZhbHNlLFxyXG4gIHJ1bnRpbWVHbG9iYWxOYW1lID0gYFZ1ZWAsXHJcbiAgcnVudGltZU1vZHVsZU5hbWUgPSBgdnVlYCxcclxuICBzc3JSdW50aW1lTW9kdWxlTmFtZSA9IFwidnVlL3NlcnZlci1yZW5kZXJlclwiLFxyXG4gIHNzciA9IGZhbHNlLFxyXG4gIGlzVFMgPSBmYWxzZSxcclxuICBpblNTUiA9IGZhbHNlXHJcbn0pIHtcclxuICBjb25zdCBjb250ZXh0ID0ge1xyXG4gICAgbW9kZSxcclxuICAgIHByZWZpeElkZW50aWZpZXJzLFxyXG4gICAgc291cmNlTWFwLFxyXG4gICAgZmlsZW5hbWUsXHJcbiAgICBzY29wZUlkLFxyXG4gICAgb3B0aW1pemVJbXBvcnRzLFxyXG4gICAgcnVudGltZUdsb2JhbE5hbWUsXHJcbiAgICBydW50aW1lTW9kdWxlTmFtZSxcclxuICAgIHNzclJ1bnRpbWVNb2R1bGVOYW1lLFxyXG4gICAgc3NyLFxyXG4gICAgaXNUUyxcclxuICAgIGluU1NSLFxyXG4gICAgc291cmNlOiBhc3Quc291cmNlLFxyXG4gICAgY29kZTogYGAsXHJcbiAgICBjb2x1bW46IDEsXHJcbiAgICBsaW5lOiAxLFxyXG4gICAgb2Zmc2V0OiAwLFxyXG4gICAgaW5kZW50TGV2ZWw6IDAsXHJcbiAgICBwdXJlOiBmYWxzZSxcclxuICAgIG1hcDogdm9pZCAwLFxyXG4gICAgaGVscGVyKGtleSkge1xyXG4gICAgICByZXR1cm4gYF8ke2hlbHBlck5hbWVNYXBba2V5XX1gO1xyXG4gICAgfSxcclxuICAgIHB1c2goY29kZSwgbmV3bGluZUluZGV4ID0gLTIgLyogTm9uZSAqLywgbm9kZSkge1xyXG4gICAgICBjb250ZXh0LmNvZGUgKz0gY29kZTtcclxuICAgIH0sXHJcbiAgICBpbmRlbnQoKSB7XHJcbiAgICAgIG5ld2xpbmUoKytjb250ZXh0LmluZGVudExldmVsKTtcclxuICAgIH0sXHJcbiAgICBkZWluZGVudCh3aXRob3V0TmV3TGluZSA9IGZhbHNlKSB7XHJcbiAgICAgIGlmICh3aXRob3V0TmV3TGluZSkge1xyXG4gICAgICAgIC0tY29udGV4dC5pbmRlbnRMZXZlbDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuZXdsaW5lKC0tY29udGV4dC5pbmRlbnRMZXZlbCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBuZXdsaW5lKCkge1xyXG4gICAgICBuZXdsaW5lKGNvbnRleHQuaW5kZW50TGV2ZWwpO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgZnVuY3Rpb24gbmV3bGluZShuKSB7XHJcbiAgICBjb250ZXh0LnB1c2goXCJcXG5cIiArIGAgIGAucmVwZWF0KG4pLCAwIC8qIFN0YXJ0ICovKTtcclxuICB9XHJcbiAgcmV0dXJuIGNvbnRleHQ7XHJcbn1cclxuZnVuY3Rpb24gZ2VuZXJhdGUoYXN0LCBvcHRpb25zID0ge30pIHtcclxuICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ29kZWdlbkNvbnRleHQoYXN0LCBvcHRpb25zKTtcclxuICBpZiAob3B0aW9ucy5vbkNvbnRleHRDcmVhdGVkKSBvcHRpb25zLm9uQ29udGV4dENyZWF0ZWQoY29udGV4dCk7XHJcbiAgY29uc3Qge1xyXG4gICAgbW9kZSxcclxuICAgIHB1c2gsXHJcbiAgICBwcmVmaXhJZGVudGlmaWVycyxcclxuICAgIGluZGVudCxcclxuICAgIGRlaW5kZW50LFxyXG4gICAgbmV3bGluZSxcclxuICAgIHNjb3BlSWQsXHJcbiAgICBzc3JcclxuICB9ID0gY29udGV4dDtcclxuICBjb25zdCBoZWxwZXJzID0gQXJyYXkuZnJvbShhc3QuaGVscGVycyk7XHJcbiAgY29uc3QgaGFzSGVscGVycyA9IGhlbHBlcnMubGVuZ3RoID4gMDtcclxuICBjb25zdCB1c2VXaXRoQmxvY2sgPSAhcHJlZml4SWRlbnRpZmllcnMgJiYgbW9kZSAhPT0gXCJtb2R1bGVcIjtcclxuICBjb25zdCBwcmVhbWJsZUNvbnRleHQgPSBjb250ZXh0O1xyXG4gIHtcclxuICAgIGdlbkZ1bmN0aW9uUHJlYW1ibGUoYXN0LCBwcmVhbWJsZUNvbnRleHQpO1xyXG4gIH1cclxuICBjb25zdCBmdW5jdGlvbk5hbWUgPSBzc3IgPyBgc3NyUmVuZGVyYCA6IGByZW5kZXJgO1xyXG4gIGNvbnN0IGFyZ3MgPSBzc3IgPyBbXCJfY3R4XCIsIFwiX3B1c2hcIiwgXCJfcGFyZW50XCIsIFwiX2F0dHJzXCJdIDogW1wiX2N0eFwiLCBcIl9jYWNoZVwiXTtcclxuICBjb25zdCBzaWduYXR1cmUgPSBhcmdzLmpvaW4oXCIsIFwiKTtcclxuICB7XHJcbiAgICBwdXNoKGBmdW5jdGlvbiAke2Z1bmN0aW9uTmFtZX0oJHtzaWduYXR1cmV9KSB7YCk7XHJcbiAgfVxyXG4gIGluZGVudCgpO1xyXG4gIGlmICh1c2VXaXRoQmxvY2spIHtcclxuICAgIHB1c2goYHdpdGggKF9jdHgpIHtgKTtcclxuICAgIGluZGVudCgpO1xyXG4gICAgaWYgKGhhc0hlbHBlcnMpIHtcclxuICAgICAgcHVzaChcclxuICAgICAgICBgY29uc3QgeyAke2hlbHBlcnMubWFwKGFsaWFzSGVscGVyKS5qb2luKFwiLCBcIil9IH0gPSBfVnVlXHJcbmAsXHJcbiAgICAgICAgLTEgLyogRW5kICovXHJcbiAgICAgICk7XHJcbiAgICAgIG5ld2xpbmUoKTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKGFzdC5jb21wb25lbnRzLmxlbmd0aCkge1xyXG4gICAgZ2VuQXNzZXRzKGFzdC5jb21wb25lbnRzLCBcImNvbXBvbmVudFwiLCBjb250ZXh0KTtcclxuICAgIGlmIChhc3QuZGlyZWN0aXZlcy5sZW5ndGggfHwgYXN0LnRlbXBzID4gMCkge1xyXG4gICAgICBuZXdsaW5lKCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChhc3QuZGlyZWN0aXZlcy5sZW5ndGgpIHtcclxuICAgIGdlbkFzc2V0cyhhc3QuZGlyZWN0aXZlcywgXCJkaXJlY3RpdmVcIiwgY29udGV4dCk7XHJcbiAgICBpZiAoYXN0LnRlbXBzID4gMCkge1xyXG4gICAgICBuZXdsaW5lKCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChhc3QuZmlsdGVycyAmJiBhc3QuZmlsdGVycy5sZW5ndGgpIHtcclxuICAgIG5ld2xpbmUoKTtcclxuICAgIGdlbkFzc2V0cyhhc3QuZmlsdGVycywgXCJmaWx0ZXJcIiwgY29udGV4dCk7XHJcbiAgICBuZXdsaW5lKCk7XHJcbiAgfVxyXG4gIGlmIChhc3QudGVtcHMgPiAwKSB7XHJcbiAgICBwdXNoKGBsZXQgYCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzdC50ZW1wczsgaSsrKSB7XHJcbiAgICAgIHB1c2goYCR7aSA+IDAgPyBgLCBgIDogYGB9X3RlbXAke2l9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChhc3QuY29tcG9uZW50cy5sZW5ndGggfHwgYXN0LmRpcmVjdGl2ZXMubGVuZ3RoIHx8IGFzdC50ZW1wcykge1xyXG4gICAgcHVzaChgXHJcbmAsIDAgLyogU3RhcnQgKi8pO1xyXG4gICAgbmV3bGluZSgpO1xyXG4gIH1cclxuICBpZiAoIXNzcikge1xyXG4gICAgcHVzaChgcmV0dXJuIGApO1xyXG4gIH1cclxuICBpZiAoYXN0LmNvZGVnZW5Ob2RlKSB7XHJcbiAgICBnZW5Ob2RlKGFzdC5jb2RlZ2VuTm9kZSwgY29udGV4dCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHB1c2goYG51bGxgKTtcclxuICB9XHJcbiAgaWYgKHVzZVdpdGhCbG9jaykge1xyXG4gICAgZGVpbmRlbnQoKTtcclxuICAgIHB1c2goYH1gKTtcclxuICB9XHJcbiAgZGVpbmRlbnQoKTtcclxuICBwdXNoKGB9YCk7XHJcbiAgcmV0dXJuIHtcclxuICAgIGFzdCxcclxuICAgIGNvZGU6IGNvbnRleHQuY29kZSxcclxuICAgIHByZWFtYmxlOiBgYCxcclxuICAgIG1hcDogY29udGV4dC5tYXAgPyBjb250ZXh0Lm1hcC50b0pTT04oKSA6IHZvaWQgMFxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gZ2VuRnVuY3Rpb25QcmVhbWJsZShhc3QsIGNvbnRleHQpIHtcclxuICBjb25zdCB7XHJcbiAgICBzc3IsXHJcbiAgICBwcmVmaXhJZGVudGlmaWVycyxcclxuICAgIHB1c2gsXHJcbiAgICBuZXdsaW5lLFxyXG4gICAgcnVudGltZU1vZHVsZU5hbWUsXHJcbiAgICBydW50aW1lR2xvYmFsTmFtZSxcclxuICAgIHNzclJ1bnRpbWVNb2R1bGVOYW1lXHJcbiAgfSA9IGNvbnRleHQ7XHJcbiAgY29uc3QgVnVlQmluZGluZyA9IHJ1bnRpbWVHbG9iYWxOYW1lO1xyXG4gIGNvbnN0IGhlbHBlcnMgPSBBcnJheS5mcm9tKGFzdC5oZWxwZXJzKTtcclxuICBpZiAoaGVscGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICB7XHJcbiAgICAgIHB1c2goYGNvbnN0IF9WdWUgPSAke1Z1ZUJpbmRpbmd9XHJcbmAsIC0xIC8qIEVuZCAqLyk7XHJcbiAgICAgIGlmIChhc3QuaG9pc3RzLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IHN0YXRpY0hlbHBlcnMgPSBbXHJcbiAgICAgICAgICBDUkVBVEVfVk5PREUsXHJcbiAgICAgICAgICBDUkVBVEVfRUxFTUVOVF9WTk9ERSxcclxuICAgICAgICAgIENSRUFURV9DT01NRU5ULFxyXG4gICAgICAgICAgQ1JFQVRFX1RFWFQsXHJcbiAgICAgICAgICBDUkVBVEVfU1RBVElDXHJcbiAgICAgICAgXS5maWx0ZXIoKGhlbHBlcikgPT4gaGVscGVycy5pbmNsdWRlcyhoZWxwZXIpKS5tYXAoYWxpYXNIZWxwZXIpLmpvaW4oXCIsIFwiKTtcclxuICAgICAgICBwdXNoKGBjb25zdCB7ICR7c3RhdGljSGVscGVyc30gfSA9IF9WdWVcclxuYCwgLTEgLyogRW5kICovKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBnZW5Ib2lzdHMoYXN0LmhvaXN0cywgY29udGV4dCk7XHJcbiAgbmV3bGluZSgpO1xyXG4gIHB1c2goYHJldHVybiBgKTtcclxufVxyXG5mdW5jdGlvbiBnZW5Bc3NldHMoYXNzZXRzLCB0eXBlLCB7IGhlbHBlciwgcHVzaCwgbmV3bGluZSwgaXNUUyB9KSB7XHJcbiAgY29uc3QgcmVzb2x2ZXIgPSBoZWxwZXIoXHJcbiAgICB0eXBlID09PSBcImZpbHRlclwiID8gUkVTT0xWRV9GSUxURVIgOiB0eXBlID09PSBcImNvbXBvbmVudFwiID8gUkVTT0xWRV9DT01QT05FTlQgOiBSRVNPTFZFX0RJUkVDVElWRVxyXG4gICk7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3NldHMubGVuZ3RoOyBpKyspIHtcclxuICAgIGxldCBpZCA9IGFzc2V0c1tpXTtcclxuICAgIGNvbnN0IG1heWJlU2VsZlJlZmVyZW5jZSA9IGlkLmVuZHNXaXRoKFwiX19zZWxmXCIpO1xyXG4gICAgaWYgKG1heWJlU2VsZlJlZmVyZW5jZSkge1xyXG4gICAgICBpZCA9IGlkLnNsaWNlKDAsIC02KTtcclxuICAgIH1cclxuICAgIHB1c2goXHJcbiAgICAgIGBjb25zdCAke3RvVmFsaWRBc3NldElkKGlkLCB0eXBlKX0gPSAke3Jlc29sdmVyfSgke0pTT04uc3RyaW5naWZ5KGlkKX0ke21heWJlU2VsZlJlZmVyZW5jZSA/IGAsIHRydWVgIDogYGB9KSR7aXNUUyA/IGAhYCA6IGBgfWBcclxuICAgICk7XHJcbiAgICBpZiAoaSA8IGFzc2V0cy5sZW5ndGggLSAxKSB7XHJcbiAgICAgIG5ld2xpbmUoKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZ2VuSG9pc3RzKGhvaXN0cywgY29udGV4dCkge1xyXG4gIGlmICghaG9pc3RzLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBjb250ZXh0LnB1cmUgPSB0cnVlO1xyXG4gIGNvbnN0IHsgcHVzaCwgbmV3bGluZSB9ID0gY29udGV4dDtcclxuICBuZXdsaW5lKCk7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBob2lzdHMubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGV4cCA9IGhvaXN0c1tpXTtcclxuICAgIGlmIChleHApIHtcclxuICAgICAgcHVzaChgY29uc3QgX2hvaXN0ZWRfJHtpICsgMX0gPSBgKTtcclxuICAgICAgZ2VuTm9kZShleHAsIGNvbnRleHQpO1xyXG4gICAgICBuZXdsaW5lKCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNvbnRleHQucHVyZSA9IGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGlzVGV4dChuKSB7XHJcbiAgcmV0dXJuIGlzU3RyaW5nKG4pIHx8IG4udHlwZSA9PT0gNCB8fCBuLnR5cGUgPT09IDIgfHwgbi50eXBlID09PSA1IHx8IG4udHlwZSA9PT0gODtcclxufVxyXG5mdW5jdGlvbiBnZW5Ob2RlTGlzdEFzQXJyYXkobm9kZXMsIGNvbnRleHQpIHtcclxuICBjb25zdCBtdWx0aWxpbmVzID0gbm9kZXMubGVuZ3RoID4gMyB8fCAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG5vZGVzLnNvbWUoKG4pID0+IGlzQXJyYXkobikgfHwgIWlzVGV4dChuKSk7XHJcbiAgY29udGV4dC5wdXNoKGBbYCk7XHJcbiAgbXVsdGlsaW5lcyAmJiBjb250ZXh0LmluZGVudCgpO1xyXG4gIGdlbk5vZGVMaXN0KG5vZGVzLCBjb250ZXh0LCBtdWx0aWxpbmVzKTtcclxuICBtdWx0aWxpbmVzICYmIGNvbnRleHQuZGVpbmRlbnQoKTtcclxuICBjb250ZXh0LnB1c2goYF1gKTtcclxufVxyXG5mdW5jdGlvbiBnZW5Ob2RlTGlzdChub2RlcywgY29udGV4dCwgbXVsdGlsaW5lcyA9IGZhbHNlLCBjb21tYSA9IHRydWUpIHtcclxuICBjb25zdCB7IHB1c2gsIG5ld2xpbmUgfSA9IGNvbnRleHQ7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xyXG4gICAgaWYgKGlzU3RyaW5nKG5vZGUpKSB7XHJcbiAgICAgIHB1c2gobm9kZSwgLTMgLyogVW5rbm93biAqLyk7XHJcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcclxuICAgICAgZ2VuTm9kZUxpc3RBc0FycmF5KG5vZGUsIGNvbnRleHQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZ2VuTm9kZShub2RlLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGlmIChpIDwgbm9kZXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICBpZiAobXVsdGlsaW5lcykge1xyXG4gICAgICAgIGNvbW1hICYmIHB1c2goXCIsXCIpO1xyXG4gICAgICAgIG5ld2xpbmUoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb21tYSAmJiBwdXNoKFwiLCBcIik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZ2VuTm9kZShub2RlLCBjb250ZXh0KSB7XHJcbiAgaWYgKGlzU3RyaW5nKG5vZGUpKSB7XHJcbiAgICBjb250ZXh0LnB1c2gobm9kZSwgLTMgLyogVW5rbm93biAqLyk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmIChpc1N5bWJvbChub2RlKSkge1xyXG4gICAgY29udGV4dC5wdXNoKGNvbnRleHQuaGVscGVyKG5vZGUpKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcclxuICAgIGNhc2UgMTpcclxuICAgIGNhc2UgOTpcclxuICAgIGNhc2UgMTE6XHJcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgYXNzZXJ0KFxyXG4gICAgICAgIG5vZGUuY29kZWdlbk5vZGUgIT0gbnVsbCxcclxuICAgICAgICBgQ29kZWdlbiBub2RlIGlzIG1pc3NpbmcgZm9yIGVsZW1lbnQvaWYvZm9yIG5vZGUuIEFwcGx5IGFwcHJvcHJpYXRlIHRyYW5zZm9ybXMgZmlyc3QuYFxyXG4gICAgICApO1xyXG4gICAgICBnZW5Ob2RlKG5vZGUuY29kZWdlbk5vZGUsIGNvbnRleHQpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMjpcclxuICAgICAgZ2VuVGV4dChub2RlLCBjb250ZXh0KTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDQ6XHJcbiAgICAgIGdlbkV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSA1OlxyXG4gICAgICBnZW5JbnRlcnBvbGF0aW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMTI6XHJcbiAgICAgIGdlbk5vZGUobm9kZS5jb2RlZ2VuTm9kZSwgY29udGV4dCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSA4OlxyXG4gICAgICBnZW5Db21wb3VuZEV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAzOlxyXG4gICAgICBnZW5Db21tZW50KG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMTM6XHJcbiAgICAgIGdlblZOb2RlQ2FsbChub2RlLCBjb250ZXh0KTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDE0OlxyXG4gICAgICBnZW5DYWxsRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDE1OlxyXG4gICAgICBnZW5PYmplY3RFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMTc6XHJcbiAgICAgIGdlbkFycmF5RXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDE4OlxyXG4gICAgICBnZW5GdW5jdGlvbkV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAxOTpcclxuICAgICAgZ2VuQ29uZGl0aW9uYWxFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMjA6XHJcbiAgICAgIGdlbkNhY2hlRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDIxOlxyXG4gICAgICBnZW5Ob2RlTGlzdChub2RlLmJvZHksIGNvbnRleHQsIHRydWUsIGZhbHNlKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICAvLyBTU1Igb25seSB0eXBlc1xyXG4gICAgY2FzZSAyMjpcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDIzOlxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMjQ6XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAyNTpcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDI2OlxyXG4gICAgICBicmVhaztcclxuICAgIC8qIHY4IGlnbm9yZSBzdGFydCAqL1xyXG4gICAgY2FzZSAxMDpcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICAgIGFzc2VydChmYWxzZSwgYHVuaGFuZGxlZCBjb2RlZ2VuIG5vZGUgdHlwZTogJHtub2RlLnR5cGV9YCk7XHJcbiAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gbm9kZTtcclxuICAgICAgICByZXR1cm4gZXhoYXVzdGl2ZUNoZWNrO1xyXG4gICAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlblRleHQobm9kZSwgY29udGV4dCkge1xyXG4gIGNvbnRleHQucHVzaChKU09OLnN0cmluZ2lmeShub2RlLmNvbnRlbnQpLCAtMyAvKiBVbmtub3duICovLCBub2RlKTtcclxufVxyXG5mdW5jdGlvbiBnZW5FeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICBjb25zdCB7IGNvbnRlbnQsIGlzU3RhdGljIH0gPSBub2RlO1xyXG4gIGNvbnRleHQucHVzaChcclxuICAgIGlzU3RhdGljID8gSlNPTi5zdHJpbmdpZnkoY29udGVudCkgOiBjb250ZW50LFxyXG4gICAgLTMgLyogVW5rbm93biAqLyxcclxuICAgIG5vZGVcclxuICApO1xyXG59XHJcbmZ1bmN0aW9uIGdlbkludGVycG9sYXRpb24obm9kZSwgY29udGV4dCkge1xyXG4gIGNvbnN0IHsgcHVzaCwgaGVscGVyLCBwdXJlIH0gPSBjb250ZXh0O1xyXG4gIGlmIChwdXJlKSBwdXNoKFBVUkVfQU5OT1RBVElPTik7XHJcbiAgcHVzaChgJHtoZWxwZXIoVE9fRElTUExBWV9TVFJJTkcpfShgKTtcclxuICBnZW5Ob2RlKG5vZGUuY29udGVudCwgY29udGV4dCk7XHJcbiAgcHVzaChgKWApO1xyXG59XHJcbmZ1bmN0aW9uIGdlbkNvbXBvdW5kRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XHJcbiAgICBpZiAoaXNTdHJpbmcoY2hpbGQpKSB7XHJcbiAgICAgIGNvbnRleHQucHVzaChjaGlsZCwgLTMgLyogVW5rbm93biAqLyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBnZW5Ob2RlKGNoaWxkLCBjb250ZXh0KTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZ2VuRXhwcmVzc2lvbkFzUHJvcGVydHlLZXkobm9kZSwgY29udGV4dCkge1xyXG4gIGNvbnN0IHsgcHVzaCB9ID0gY29udGV4dDtcclxuICBpZiAobm9kZS50eXBlID09PSA4KSB7XHJcbiAgICBwdXNoKGBbYCk7XHJcbiAgICBnZW5Db21wb3VuZEV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICBwdXNoKGBdYCk7XHJcbiAgfSBlbHNlIGlmIChub2RlLmlzU3RhdGljKSB7XHJcbiAgICBjb25zdCB0ZXh0ID0gaXNTaW1wbGVJZGVudGlmaWVyKG5vZGUuY29udGVudCkgPyBub2RlLmNvbnRlbnQgOiBKU09OLnN0cmluZ2lmeShub2RlLmNvbnRlbnQpO1xyXG4gICAgcHVzaCh0ZXh0LCAtMiAvKiBOb25lICovLCBub2RlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcHVzaChgWyR7bm9kZS5jb250ZW50fV1gLCAtMyAvKiBVbmtub3duICovLCBub2RlKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZ2VuQ29tbWVudChub2RlLCBjb250ZXh0KSB7XHJcbiAgY29uc3QgeyBwdXNoLCBoZWxwZXIsIHB1cmUgfSA9IGNvbnRleHQ7XHJcbiAgaWYgKHB1cmUpIHtcclxuICAgIHB1c2goUFVSRV9BTk5PVEFUSU9OKTtcclxuICB9XHJcbiAgcHVzaChcclxuICAgIGAke2hlbHBlcihDUkVBVEVfQ09NTUVOVCl9KCR7SlNPTi5zdHJpbmdpZnkobm9kZS5jb250ZW50KX0pYCxcclxuICAgIC0zIC8qIFVua25vd24gKi8sXHJcbiAgICBub2RlXHJcbiAgKTtcclxufVxyXG5mdW5jdGlvbiBnZW5WTm9kZUNhbGwobm9kZSwgY29udGV4dCkge1xyXG4gIGNvbnN0IHsgcHVzaCwgaGVscGVyLCBwdXJlIH0gPSBjb250ZXh0O1xyXG4gIGNvbnN0IHtcclxuICAgIHRhZyxcclxuICAgIHByb3BzLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICBwYXRjaEZsYWcsXHJcbiAgICBkeW5hbWljUHJvcHMsXHJcbiAgICBkaXJlY3RpdmVzLFxyXG4gICAgaXNCbG9jayxcclxuICAgIGRpc2FibGVUcmFja2luZyxcclxuICAgIGlzQ29tcG9uZW50XHJcbiAgfSA9IG5vZGU7XHJcbiAgbGV0IHBhdGNoRmxhZ1N0cmluZztcclxuICBpZiAocGF0Y2hGbGFnKSB7XHJcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICBpZiAocGF0Y2hGbGFnIDwgMCkge1xyXG4gICAgICAgIHBhdGNoRmxhZ1N0cmluZyA9IHBhdGNoRmxhZyArIGAgLyogJHtQYXRjaEZsYWdOYW1lc1twYXRjaEZsYWddfSAqL2A7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgZmxhZ05hbWVzID0gT2JqZWN0LmtleXMoUGF0Y2hGbGFnTmFtZXMpLm1hcChOdW1iZXIpLmZpbHRlcigobikgPT4gbiA+IDAgJiYgcGF0Y2hGbGFnICYgbikubWFwKChuKSA9PiBQYXRjaEZsYWdOYW1lc1tuXSkuam9pbihgLCBgKTtcclxuICAgICAgICBwYXRjaEZsYWdTdHJpbmcgPSBwYXRjaEZsYWcgKyBgIC8qICR7ZmxhZ05hbWVzfSAqL2A7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBhdGNoRmxhZ1N0cmluZyA9IFN0cmluZyhwYXRjaEZsYWcpO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoZGlyZWN0aXZlcykge1xyXG4gICAgcHVzaChoZWxwZXIoV0lUSF9ESVJFQ1RJVkVTKSArIGAoYCk7XHJcbiAgfVxyXG4gIGlmIChpc0Jsb2NrKSB7XHJcbiAgICBwdXNoKGAoJHtoZWxwZXIoT1BFTl9CTE9DSyl9KCR7ZGlzYWJsZVRyYWNraW5nID8gYHRydWVgIDogYGB9KSwgYCk7XHJcbiAgfVxyXG4gIGlmIChwdXJlKSB7XHJcbiAgICBwdXNoKFBVUkVfQU5OT1RBVElPTik7XHJcbiAgfVxyXG4gIGNvbnN0IGNhbGxIZWxwZXIgPSBpc0Jsb2NrID8gZ2V0Vk5vZGVCbG9ja0hlbHBlcihjb250ZXh0LmluU1NSLCBpc0NvbXBvbmVudCkgOiBnZXRWTm9kZUhlbHBlcihjb250ZXh0LmluU1NSLCBpc0NvbXBvbmVudCk7XHJcbiAgcHVzaChoZWxwZXIoY2FsbEhlbHBlcikgKyBgKGAsIC0yIC8qIE5vbmUgKi8sIG5vZGUpO1xyXG4gIGdlbk5vZGVMaXN0KFxyXG4gICAgZ2VuTnVsbGFibGVBcmdzKFt0YWcsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnU3RyaW5nLCBkeW5hbWljUHJvcHNdKSxcclxuICAgIGNvbnRleHRcclxuICApO1xyXG4gIHB1c2goYClgKTtcclxuICBpZiAoaXNCbG9jaykge1xyXG4gICAgcHVzaChgKWApO1xyXG4gIH1cclxuICBpZiAoZGlyZWN0aXZlcykge1xyXG4gICAgcHVzaChgLCBgKTtcclxuICAgIGdlbk5vZGUoZGlyZWN0aXZlcywgY29udGV4dCk7XHJcbiAgICBwdXNoKGApYCk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbk51bGxhYmxlQXJncyhhcmdzKSB7XHJcbiAgbGV0IGkgPSBhcmdzLmxlbmd0aDtcclxuICB3aGlsZSAoaS0tKSB7XHJcbiAgICBpZiAoYXJnc1tpXSAhPSBudWxsKSBicmVhaztcclxuICB9XHJcbiAgcmV0dXJuIGFyZ3Muc2xpY2UoMCwgaSArIDEpLm1hcCgoYXJnKSA9PiBhcmcgfHwgYG51bGxgKTtcclxufVxyXG5mdW5jdGlvbiBnZW5DYWxsRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgY29uc3QgeyBwdXNoLCBoZWxwZXIsIHB1cmUgfSA9IGNvbnRleHQ7XHJcbiAgY29uc3QgY2FsbGVlID0gaXNTdHJpbmcobm9kZS5jYWxsZWUpID8gbm9kZS5jYWxsZWUgOiBoZWxwZXIobm9kZS5jYWxsZWUpO1xyXG4gIGlmIChwdXJlKSB7XHJcbiAgICBwdXNoKFBVUkVfQU5OT1RBVElPTik7XHJcbiAgfVxyXG4gIHB1c2goY2FsbGVlICsgYChgLCAtMiAvKiBOb25lICovLCBub2RlKTtcclxuICBnZW5Ob2RlTGlzdChub2RlLmFyZ3VtZW50cywgY29udGV4dCk7XHJcbiAgcHVzaChgKWApO1xyXG59XHJcbmZ1bmN0aW9uIGdlbk9iamVjdEV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xyXG4gIGNvbnN0IHsgcHVzaCwgaW5kZW50LCBkZWluZGVudCwgbmV3bGluZSB9ID0gY29udGV4dDtcclxuICBjb25zdCB7IHByb3BlcnRpZXMgfSA9IG5vZGU7XHJcbiAgaWYgKCFwcm9wZXJ0aWVzLmxlbmd0aCkge1xyXG4gICAgcHVzaChge31gLCAtMiAvKiBOb25lICovLCBub2RlKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgY29uc3QgbXVsdGlsaW5lcyA9IHByb3BlcnRpZXMubGVuZ3RoID4gMSB8fCAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHByb3BlcnRpZXMuc29tZSgocCkgPT4gcC52YWx1ZS50eXBlICE9PSA0KTtcclxuICBwdXNoKG11bHRpbGluZXMgPyBge2AgOiBgeyBgKTtcclxuICBtdWx0aWxpbmVzICYmIGluZGVudCgpO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBwcm9wZXJ0aWVzW2ldO1xyXG4gICAgZ2VuRXhwcmVzc2lvbkFzUHJvcGVydHlLZXkoa2V5LCBjb250ZXh0KTtcclxuICAgIHB1c2goYDogYCk7XHJcbiAgICBnZW5Ob2RlKHZhbHVlLCBjb250ZXh0KTtcclxuICAgIGlmIChpIDwgcHJvcGVydGllcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgIHB1c2goYCxgKTtcclxuICAgICAgbmV3bGluZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuICBtdWx0aWxpbmVzICYmIGRlaW5kZW50KCk7XHJcbiAgcHVzaChtdWx0aWxpbmVzID8gYH1gIDogYCB9YCk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuQXJyYXlFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICBnZW5Ob2RlTGlzdEFzQXJyYXkobm9kZS5lbGVtZW50cywgY29udGV4dCk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuRnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICBjb25zdCB7IHB1c2gsIGluZGVudCwgZGVpbmRlbnQgfSA9IGNvbnRleHQ7XHJcbiAgY29uc3QgeyBwYXJhbXMsIHJldHVybnMsIGJvZHksIG5ld2xpbmUsIGlzU2xvdCB9ID0gbm9kZTtcclxuICBpZiAoaXNTbG90KSB7XHJcbiAgICBwdXNoKGBfJHtoZWxwZXJOYW1lTWFwW1dJVEhfQ1RYXX0oYCk7XHJcbiAgfVxyXG4gIHB1c2goYChgLCAtMiAvKiBOb25lICovLCBub2RlKTtcclxuICBpZiAoaXNBcnJheShwYXJhbXMpKSB7XHJcbiAgICBnZW5Ob2RlTGlzdChwYXJhbXMsIGNvbnRleHQpO1xyXG4gIH0gZWxzZSBpZiAocGFyYW1zKSB7XHJcbiAgICBnZW5Ob2RlKHBhcmFtcywgY29udGV4dCk7XHJcbiAgfVxyXG4gIHB1c2goYCkgPT4gYCk7XHJcbiAgaWYgKG5ld2xpbmUgfHwgYm9keSkge1xyXG4gICAgcHVzaChge2ApO1xyXG4gICAgaW5kZW50KCk7XHJcbiAgfVxyXG4gIGlmIChyZXR1cm5zKSB7XHJcbiAgICBpZiAobmV3bGluZSkge1xyXG4gICAgICBwdXNoKGByZXR1cm4gYCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNBcnJheShyZXR1cm5zKSkge1xyXG4gICAgICBnZW5Ob2RlTGlzdEFzQXJyYXkocmV0dXJucywgY29udGV4dCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBnZW5Ob2RlKHJldHVybnMsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoYm9keSkge1xyXG4gICAgZ2VuTm9kZShib2R5LCBjb250ZXh0KTtcclxuICB9XHJcbiAgaWYgKG5ld2xpbmUgfHwgYm9keSkge1xyXG4gICAgZGVpbmRlbnQoKTtcclxuICAgIHB1c2goYH1gKTtcclxuICB9XHJcbiAgaWYgKGlzU2xvdCkge1xyXG4gICAgaWYgKG5vZGUuaXNOb25TY29wZWRTbG90KSB7XHJcbiAgICAgIHB1c2goYCwgdW5kZWZpbmVkLCB0cnVlYCk7XHJcbiAgICB9XHJcbiAgICBwdXNoKGApYCk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbkNvbmRpdGlvbmFsRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgY29uc3QgeyB0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUsIG5ld2xpbmU6IG5lZWROZXdsaW5lIH0gPSBub2RlO1xyXG4gIGNvbnN0IHsgcHVzaCwgaW5kZW50LCBkZWluZGVudCwgbmV3bGluZSB9ID0gY29udGV4dDtcclxuICBpZiAodGVzdC50eXBlID09PSA0KSB7XHJcbiAgICBjb25zdCBuZWVkc1BhcmVucyA9ICFpc1NpbXBsZUlkZW50aWZpZXIodGVzdC5jb250ZW50KTtcclxuICAgIG5lZWRzUGFyZW5zICYmIHB1c2goYChgKTtcclxuICAgIGdlbkV4cHJlc3Npb24odGVzdCwgY29udGV4dCk7XHJcbiAgICBuZWVkc1BhcmVucyAmJiBwdXNoKGApYCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHB1c2goYChgKTtcclxuICAgIGdlbk5vZGUodGVzdCwgY29udGV4dCk7XHJcbiAgICBwdXNoKGApYCk7XHJcbiAgfVxyXG4gIG5lZWROZXdsaW5lICYmIGluZGVudCgpO1xyXG4gIGNvbnRleHQuaW5kZW50TGV2ZWwrKztcclxuICBuZWVkTmV3bGluZSB8fCBwdXNoKGAgYCk7XHJcbiAgcHVzaChgPyBgKTtcclxuICBnZW5Ob2RlKGNvbnNlcXVlbnQsIGNvbnRleHQpO1xyXG4gIGNvbnRleHQuaW5kZW50TGV2ZWwtLTtcclxuICBuZWVkTmV3bGluZSAmJiBuZXdsaW5lKCk7XHJcbiAgbmVlZE5ld2xpbmUgfHwgcHVzaChgIGApO1xyXG4gIHB1c2goYDogYCk7XHJcbiAgY29uc3QgaXNOZXN0ZWQgPSBhbHRlcm5hdGUudHlwZSA9PT0gMTk7XHJcbiAgaWYgKCFpc05lc3RlZCkge1xyXG4gICAgY29udGV4dC5pbmRlbnRMZXZlbCsrO1xyXG4gIH1cclxuICBnZW5Ob2RlKGFsdGVybmF0ZSwgY29udGV4dCk7XHJcbiAgaWYgKCFpc05lc3RlZCkge1xyXG4gICAgY29udGV4dC5pbmRlbnRMZXZlbC0tO1xyXG4gIH1cclxuICBuZWVkTmV3bGluZSAmJiBkZWluZGVudChcclxuICAgIHRydWVcclxuICAgIC8qIHdpdGhvdXQgbmV3bGluZSAqL1xyXG4gICk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuQ2FjaGVFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICBjb25zdCB7IHB1c2gsIGhlbHBlciwgaW5kZW50LCBkZWluZGVudCwgbmV3bGluZSB9ID0gY29udGV4dDtcclxuICBjb25zdCB7IG5lZWRQYXVzZVRyYWNraW5nLCBuZWVkQXJyYXlTcHJlYWQgfSA9IG5vZGU7XHJcbiAgaWYgKG5lZWRBcnJheVNwcmVhZCkge1xyXG4gICAgcHVzaChgWy4uLihgKTtcclxuICB9XHJcbiAgcHVzaChgX2NhY2hlWyR7bm9kZS5pbmRleH1dIHx8IChgKTtcclxuICBpZiAobmVlZFBhdXNlVHJhY2tpbmcpIHtcclxuICAgIGluZGVudCgpO1xyXG4gICAgcHVzaChgJHtoZWxwZXIoU0VUX0JMT0NLX1RSQUNLSU5HKX0oLTFgKTtcclxuICAgIGlmIChub2RlLmluVk9uY2UpIHB1c2goYCwgdHJ1ZWApO1xyXG4gICAgcHVzaChgKSxgKTtcclxuICAgIG5ld2xpbmUoKTtcclxuICAgIHB1c2goYChgKTtcclxuICB9XHJcbiAgcHVzaChgX2NhY2hlWyR7bm9kZS5pbmRleH1dID0gYCk7XHJcbiAgZ2VuTm9kZShub2RlLnZhbHVlLCBjb250ZXh0KTtcclxuICBpZiAobmVlZFBhdXNlVHJhY2tpbmcpIHtcclxuICAgIHB1c2goYCkuY2FjaGVJbmRleCA9ICR7bm9kZS5pbmRleH0sYCk7XHJcbiAgICBuZXdsaW5lKCk7XHJcbiAgICBwdXNoKGAke2hlbHBlcihTRVRfQkxPQ0tfVFJBQ0tJTkcpfSgxKSxgKTtcclxuICAgIG5ld2xpbmUoKTtcclxuICAgIHB1c2goYF9jYWNoZVske25vZGUuaW5kZXh9XWApO1xyXG4gICAgZGVpbmRlbnQoKTtcclxuICB9XHJcbiAgcHVzaChgKWApO1xyXG4gIGlmIChuZWVkQXJyYXlTcHJlYWQpIHtcclxuICAgIHB1c2goYCldYCk7XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cChcclxuICBcIlxcXFxiXCIgKyBcImFyZ3VtZW50cyxhd2FpdCxicmVhayxjYXNlLGNhdGNoLGNsYXNzLGNvbnN0LGNvbnRpbnVlLGRlYnVnZ2VyLGRlZmF1bHQsZGVsZXRlLGRvLGVsc2UsZXhwb3J0LGV4dGVuZHMsZmluYWxseSxmb3IsZnVuY3Rpb24saWYsaW1wb3J0LGxldCxuZXcscmV0dXJuLHN1cGVyLHN3aXRjaCx0aHJvdyx0cnksdmFyLHZvaWQsd2hpbGUsd2l0aCx5aWVsZFwiLnNwbGl0KFwiLFwiKS5qb2luKFwiXFxcXGJ8XFxcXGJcIikgKyBcIlxcXFxiXCJcclxuKTtcclxuY29uc3Qgc3RyaXBTdHJpbmdSRSA9IC8nKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYC9nO1xyXG5mdW5jdGlvbiB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQsIGFzUGFyYW1zID0gZmFsc2UsIGFzUmF3U3RhdGVtZW50cyA9IGZhbHNlKSB7XHJcbiAgY29uc3QgZXhwID0gbm9kZS5jb250ZW50O1xyXG4gIGlmICghZXhwLnRyaW0oKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB0cnkge1xyXG4gICAgbmV3IEZ1bmN0aW9uKFxyXG4gICAgICBhc1Jhd1N0YXRlbWVudHMgPyBgICR7ZXhwfSBgIDogYHJldHVybiAke2FzUGFyYW1zID8gYCgke2V4cH0pID0+IHt9YCA6IGAoJHtleHB9KWB9YFxyXG4gICAgKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBsZXQgbWVzc2FnZSA9IGUubWVzc2FnZTtcclxuICAgIGNvbnN0IGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsIFwiXCIpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xyXG4gICAgaWYgKGtleXdvcmRNYXRjaCkge1xyXG4gICAgICBtZXNzYWdlID0gYGF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiR7a2V5d29yZE1hdGNoWzBdfVwiYDtcclxuICAgIH1cclxuICAgIGNvbnRleHQub25FcnJvcihcclxuICAgICAgY3JlYXRlQ29tcGlsZXJFcnJvcihcclxuICAgICAgICA0NSxcclxuICAgICAgICBub2RlLmxvYyxcclxuICAgICAgICB2b2lkIDAsXHJcbiAgICAgICAgbWVzc2FnZVxyXG4gICAgICApXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuY29uc3QgdHJhbnNmb3JtRXhwcmVzc2lvbiA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgaWYgKG5vZGUudHlwZSA9PT0gNSkge1xyXG4gICAgbm9kZS5jb250ZW50ID0gcHJvY2Vzc0V4cHJlc3Npb24oXHJcbiAgICAgIG5vZGUuY29udGVudCxcclxuICAgICAgY29udGV4dFxyXG4gICAgKTtcclxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xyXG4gICAgY29uc3QgbWVtbyA9IGZpbmREaXIobm9kZSwgXCJtZW1vXCIpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGRpciA9IG5vZGUucHJvcHNbaV07XHJcbiAgICAgIGlmIChkaXIudHlwZSA9PT0gNyAmJiBkaXIubmFtZSAhPT0gXCJmb3JcIikge1xyXG4gICAgICAgIGNvbnN0IGV4cCA9IGRpci5leHA7XHJcbiAgICAgICAgY29uc3QgYXJnID0gZGlyLmFyZztcclxuICAgICAgICBpZiAoZXhwICYmIGV4cC50eXBlID09PSA0ICYmICEoZGlyLm5hbWUgPT09IFwib25cIiAmJiBhcmcpICYmIC8vIGtleSBoYXMgYmVlbiBwcm9jZXNzZWQgaW4gdHJhbnNmb3JtRm9yKHZNZW1vICsgdkZvcilcclxuICAgICAgICAhKG1lbW8gJiYgYXJnICYmIGFyZy50eXBlID09PSA0ICYmIGFyZy5jb250ZW50ID09PSBcImtleVwiKSkge1xyXG4gICAgICAgICAgZGlyLmV4cCA9IHByb2Nlc3NFeHByZXNzaW9uKFxyXG4gICAgICAgICAgICBleHAsXHJcbiAgICAgICAgICAgIGNvbnRleHQsXHJcbiAgICAgICAgICAgIC8vIHNsb3QgYXJncyBtdXN0IGJlIHByb2Nlc3NlZCBhcyBmdW5jdGlvbiBwYXJhbXNcclxuICAgICAgICAgICAgZGlyLm5hbWUgPT09IFwic2xvdFwiXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXJnICYmIGFyZy50eXBlID09PSA0ICYmICFhcmcuaXNTdGF0aWMpIHtcclxuICAgICAgICAgIGRpci5hcmcgPSBwcm9jZXNzRXhwcmVzc2lvbihhcmcsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufTtcclxuZnVuY3Rpb24gcHJvY2Vzc0V4cHJlc3Npb24obm9kZSwgY29udGV4dCwgYXNQYXJhbXMgPSBmYWxzZSwgYXNSYXdTdGF0ZW1lbnRzID0gZmFsc2UsIGxvY2FsVmFycyA9IE9iamVjdC5jcmVhdGUoY29udGV4dC5pZGVudGlmaWVycykpIHtcclxuICB7XHJcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQsIGFzUGFyYW1zLCBhc1Jhd1N0YXRlbWVudHMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vZGU7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeUV4cHJlc3Npb24oZXhwKSB7XHJcbiAgaWYgKGlzU3RyaW5nKGV4cCkpIHtcclxuICAgIHJldHVybiBleHA7XHJcbiAgfSBlbHNlIGlmIChleHAudHlwZSA9PT0gNCkge1xyXG4gICAgcmV0dXJuIGV4cC5jb250ZW50O1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gZXhwLmNoaWxkcmVuLm1hcChzdHJpbmdpZnlFeHByZXNzaW9uKS5qb2luKFwiXCIpO1xyXG4gIH1cclxufVxyXG5cclxuY29uc3QgdHJhbnNmb3JtSWYgPSBjcmVhdGVTdHJ1Y3R1cmFsRGlyZWN0aXZlVHJhbnNmb3JtKFxyXG4gIC9eKGlmfGVsc2V8ZWxzZS1pZikkLyxcclxuICAobm9kZSwgZGlyLCBjb250ZXh0KSA9PiB7XHJcbiAgICByZXR1cm4gcHJvY2Vzc0lmKG5vZGUsIGRpciwgY29udGV4dCwgKGlmTm9kZSwgYnJhbmNoLCBpc1Jvb3QpID0+IHtcclxuICAgICAgY29uc3Qgc2libGluZ3MgPSBjb250ZXh0LnBhcmVudC5jaGlsZHJlbjtcclxuICAgICAgbGV0IGkgPSBzaWJsaW5ncy5pbmRleE9mKGlmTm9kZSk7XHJcbiAgICAgIGxldCBrZXkgPSAwO1xyXG4gICAgICB3aGlsZSAoaS0tID49IDApIHtcclxuICAgICAgICBjb25zdCBzaWJsaW5nID0gc2libGluZ3NbaV07XHJcbiAgICAgICAgaWYgKHNpYmxpbmcgJiYgc2libGluZy50eXBlID09PSA5KSB7XHJcbiAgICAgICAgICBrZXkgKz0gc2libGluZy5icmFuY2hlcy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgaWYgKGlzUm9vdCkge1xyXG4gICAgICAgICAgaWZOb2RlLmNvZGVnZW5Ob2RlID0gY3JlYXRlQ29kZWdlbk5vZGVGb3JCcmFuY2goXHJcbiAgICAgICAgICAgIGJyYW5jaCxcclxuICAgICAgICAgICAga2V5LFxyXG4gICAgICAgICAgICBjb250ZXh0XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zdCBwYXJlbnRDb25kaXRpb24gPSBnZXRQYXJlbnRDb25kaXRpb24oaWZOb2RlLmNvZGVnZW5Ob2RlKTtcclxuICAgICAgICAgIHBhcmVudENvbmRpdGlvbi5hbHRlcm5hdGUgPSBjcmVhdGVDb2RlZ2VuTm9kZUZvckJyYW5jaChcclxuICAgICAgICAgICAgYnJhbmNoLFxyXG4gICAgICAgICAgICBrZXkgKyBpZk5vZGUuYnJhbmNoZXMubGVuZ3RoIC0gMSxcclxuICAgICAgICAgICAgY29udGV4dFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuICB9XHJcbik7XHJcbmZ1bmN0aW9uIHByb2Nlc3NJZihub2RlLCBkaXIsIGNvbnRleHQsIHByb2Nlc3NDb2RlZ2VuKSB7XHJcbiAgaWYgKGRpci5uYW1lICE9PSBcImVsc2VcIiAmJiAoIWRpci5leHAgfHwgIWRpci5leHAuY29udGVudC50cmltKCkpKSB7XHJcbiAgICBjb25zdCBsb2MgPSBkaXIuZXhwID8gZGlyLmV4cC5sb2MgOiBub2RlLmxvYztcclxuICAgIGNvbnRleHQub25FcnJvcihcclxuICAgICAgY3JlYXRlQ29tcGlsZXJFcnJvcigyOCwgZGlyLmxvYylcclxuICAgICk7XHJcbiAgICBkaXIuZXhwID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgdHJ1ZWAsIGZhbHNlLCBsb2MpO1xyXG4gIH1cclxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB0cnVlICYmIGRpci5leHApIHtcclxuICAgIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24oZGlyLmV4cCwgY29udGV4dCk7XHJcbiAgfVxyXG4gIGlmIChkaXIubmFtZSA9PT0gXCJpZlwiKSB7XHJcbiAgICBjb25zdCBicmFuY2ggPSBjcmVhdGVJZkJyYW5jaChub2RlLCBkaXIpO1xyXG4gICAgY29uc3QgaWZOb2RlID0ge1xyXG4gICAgICB0eXBlOiA5LFxyXG4gICAgICBsb2M6IGNsb25lTG9jKG5vZGUubG9jKSxcclxuICAgICAgYnJhbmNoZXM6IFticmFuY2hdXHJcbiAgICB9O1xyXG4gICAgY29udGV4dC5yZXBsYWNlTm9kZShpZk5vZGUpO1xyXG4gICAgaWYgKHByb2Nlc3NDb2RlZ2VuKSB7XHJcbiAgICAgIHJldHVybiBwcm9jZXNzQ29kZWdlbihpZk5vZGUsIGJyYW5jaCwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnN0IHNpYmxpbmdzID0gY29udGV4dC5wYXJlbnQuY2hpbGRyZW47XHJcbiAgICBjb25zdCBjb21tZW50cyA9IFtdO1xyXG4gICAgbGV0IGkgPSBzaWJsaW5ncy5pbmRleE9mKG5vZGUpO1xyXG4gICAgd2hpbGUgKGktLSA+PSAtMSkge1xyXG4gICAgICBjb25zdCBzaWJsaW5nID0gc2libGluZ3NbaV07XHJcbiAgICAgIGlmIChzaWJsaW5nICYmIHNpYmxpbmcudHlwZSA9PT0gMykge1xyXG4gICAgICAgIGNvbnRleHQucmVtb3ZlTm9kZShzaWJsaW5nKTtcclxuICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNvbW1lbnRzLnVuc2hpZnQoc2libGluZyk7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNpYmxpbmcgJiYgc2libGluZy50eXBlID09PSAyICYmICFzaWJsaW5nLmNvbnRlbnQudHJpbSgpLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnRleHQucmVtb3ZlTm9kZShzaWJsaW5nKTtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2libGluZyAmJiBzaWJsaW5nLnR5cGUgPT09IDkpIHtcclxuICAgICAgICBpZiAoZGlyLm5hbWUgPT09IFwiZWxzZS1pZlwiICYmIHNpYmxpbmcuYnJhbmNoZXNbc2libGluZy5icmFuY2hlcy5sZW5ndGggLSAxXS5jb25kaXRpb24gPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgY29udGV4dC5vbkVycm9yKFxyXG4gICAgICAgICAgICBjcmVhdGVDb21waWxlckVycm9yKDMwLCBub2RlLmxvYylcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRleHQucmVtb3ZlTm9kZSgpO1xyXG4gICAgICAgIGNvbnN0IGJyYW5jaCA9IGNyZWF0ZUlmQnJhbmNoKG5vZGUsIGRpcik7XHJcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY29tbWVudHMubGVuZ3RoICYmIC8vICMzNjE5IGlnbm9yZSBjb21tZW50cyBpZiB0aGUgdi1pZiBpcyBkaXJlY3QgY2hpbGQgb2YgPHRyYW5zaXRpb24+XHJcbiAgICAgICAgIShjb250ZXh0LnBhcmVudCAmJiBjb250ZXh0LnBhcmVudC50eXBlID09PSAxICYmIChjb250ZXh0LnBhcmVudC50YWcgPT09IFwidHJhbnNpdGlvblwiIHx8IGNvbnRleHQucGFyZW50LnRhZyA9PT0gXCJUcmFuc2l0aW9uXCIpKSkge1xyXG4gICAgICAgICAgYnJhbmNoLmNoaWxkcmVuID0gWy4uLmNvbW1lbnRzLCAuLi5icmFuY2guY2hpbGRyZW5dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBmYWxzZSkge1xyXG4gICAgICAgICAgY29uc3Qga2V5ID0gYnJhbmNoLnVzZXJLZXk7XHJcbiAgICAgICAgICBpZiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHNpYmxpbmcuYnJhbmNoZXMuZm9yRWFjaCgoeyB1c2VyS2V5IH0pID0+IHtcclxuICAgICAgICAgICAgICBpZiAoaXNTYW1lS2V5KHVzZXJLZXksIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihcclxuICAgICAgICAgICAgICAgICAgY3JlYXRlQ29tcGlsZXJFcnJvcihcclxuICAgICAgICAgICAgICAgICAgICAyOSxcclxuICAgICAgICAgICAgICAgICAgICBicmFuY2gudXNlcktleS5sb2NcclxuICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzaWJsaW5nLmJyYW5jaGVzLnB1c2goYnJhbmNoKTtcclxuICAgICAgICBjb25zdCBvbkV4aXQgPSBwcm9jZXNzQ29kZWdlbiAmJiBwcm9jZXNzQ29kZWdlbihzaWJsaW5nLCBicmFuY2gsIGZhbHNlKTtcclxuICAgICAgICB0cmF2ZXJzZU5vZGUoYnJhbmNoLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAob25FeGl0KSBvbkV4aXQoKTtcclxuICAgICAgICBjb250ZXh0LmN1cnJlbnROb2RlID0gbnVsbDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoXHJcbiAgICAgICAgICBjcmVhdGVDb21waWxlckVycm9yKDMwLCBub2RlLmxvYylcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJZkJyYW5jaChub2RlLCBkaXIpIHtcclxuICBjb25zdCBpc1RlbXBsYXRlSWYgPSBub2RlLnRhZ1R5cGUgPT09IDM7XHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGU6IDEwLFxyXG4gICAgbG9jOiBub2RlLmxvYyxcclxuICAgIGNvbmRpdGlvbjogZGlyLm5hbWUgPT09IFwiZWxzZVwiID8gdm9pZCAwIDogZGlyLmV4cCxcclxuICAgIGNoaWxkcmVuOiBpc1RlbXBsYXRlSWYgJiYgIWZpbmREaXIobm9kZSwgXCJmb3JcIikgPyBub2RlLmNoaWxkcmVuIDogW25vZGVdLFxyXG4gICAgdXNlcktleTogZmluZFByb3Aobm9kZSwgYGtleWApLFxyXG4gICAgaXNUZW1wbGF0ZUlmXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDb2RlZ2VuTm9kZUZvckJyYW5jaChicmFuY2gsIGtleUluZGV4LCBjb250ZXh0KSB7XHJcbiAgaWYgKGJyYW5jaC5jb25kaXRpb24pIHtcclxuICAgIHJldHVybiBjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24oXHJcbiAgICAgIGJyYW5jaC5jb25kaXRpb24sXHJcbiAgICAgIGNyZWF0ZUNoaWxkcmVuQ29kZWdlbk5vZGUoYnJhbmNoLCBrZXlJbmRleCwgY29udGV4dCksXHJcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBwYXNzIGluIGFzQmxvY2s6IHRydWUgc28gdGhhdCB0aGUgY29tbWVudCBub2RlIGNhbGxcclxuICAgICAgLy8gY2xvc2VzIHRoZSBjdXJyZW50IGJsb2NrLlxyXG4gICAgICBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihDUkVBVEVfQ09NTUVOVCksIFtcclxuICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gJ1widi1pZlwiJyA6ICdcIlwiJyxcclxuICAgICAgICBcInRydWVcIlxyXG4gICAgICBdKVxyXG4gICAgKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGNyZWF0ZUNoaWxkcmVuQ29kZWdlbk5vZGUoYnJhbmNoLCBrZXlJbmRleCwgY29udGV4dCk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuQ29kZWdlbk5vZGUoYnJhbmNoLCBrZXlJbmRleCwgY29udGV4dCkge1xyXG4gIGNvbnN0IHsgaGVscGVyIH0gPSBjb250ZXh0O1xyXG4gIGNvbnN0IGtleVByb3BlcnR5ID0gY3JlYXRlT2JqZWN0UHJvcGVydHkoXHJcbiAgICBga2V5YCxcclxuICAgIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oXHJcbiAgICAgIGAke2tleUluZGV4fWAsXHJcbiAgICAgIGZhbHNlLFxyXG4gICAgICBsb2NTdHViLFxyXG4gICAgICAyXHJcbiAgICApXHJcbiAgKTtcclxuICBjb25zdCB7IGNoaWxkcmVuIH0gPSBicmFuY2g7XHJcbiAgY29uc3QgZmlyc3RDaGlsZCA9IGNoaWxkcmVuWzBdO1xyXG4gIGNvbnN0IG5lZWRGcmFnbWVudFdyYXBwZXIgPSBjaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgZmlyc3RDaGlsZC50eXBlICE9PSAxO1xyXG4gIGlmIChuZWVkRnJhZ21lbnRXcmFwcGVyKSB7XHJcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGZpcnN0Q2hpbGQudHlwZSA9PT0gMTEpIHtcclxuICAgICAgY29uc3Qgdm5vZGVDYWxsID0gZmlyc3RDaGlsZC5jb2RlZ2VuTm9kZTtcclxuICAgICAgaW5qZWN0UHJvcCh2bm9kZUNhbGwsIGtleVByb3BlcnR5LCBjb250ZXh0KTtcclxuICAgICAgcmV0dXJuIHZub2RlQ2FsbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxldCBwYXRjaEZsYWcgPSA2NDtcclxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWJyYW5jaC5pc1RlbXBsYXRlSWYgJiYgY2hpbGRyZW4uZmlsdGVyKChjKSA9PiBjLnR5cGUgIT09IDMpLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHBhdGNoRmxhZyB8PSAyMDQ4O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjcmVhdGVWTm9kZUNhbGwoXHJcbiAgICAgICAgY29udGV4dCxcclxuICAgICAgICBoZWxwZXIoRlJBR01FTlQpLFxyXG4gICAgICAgIGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oW2tleVByb3BlcnR5XSksXHJcbiAgICAgICAgY2hpbGRyZW4sXHJcbiAgICAgICAgcGF0Y2hGbGFnLFxyXG4gICAgICAgIHZvaWQgMCxcclxuICAgICAgICB2b2lkIDAsXHJcbiAgICAgICAgdHJ1ZSxcclxuICAgICAgICBmYWxzZSxcclxuICAgICAgICBmYWxzZSxcclxuICAgICAgICBicmFuY2gubG9jXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnN0IHJldCA9IGZpcnN0Q2hpbGQuY29kZWdlbk5vZGU7XHJcbiAgICBjb25zdCB2bm9kZUNhbGwgPSBnZXRNZW1vZWRWTm9kZUNhbGwocmV0KTtcclxuICAgIGlmICh2bm9kZUNhbGwudHlwZSA9PT0gMTMpIHtcclxuICAgICAgY29udmVydFRvQmxvY2sodm5vZGVDYWxsLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGluamVjdFByb3Aodm5vZGVDYWxsLCBrZXlQcm9wZXJ0eSwgY29udGV4dCk7XHJcbiAgICByZXR1cm4gcmV0O1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBpc1NhbWVLZXkoYSwgYikge1xyXG4gIGlmICghYSB8fCBhLnR5cGUgIT09IGIudHlwZSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBpZiAoYS50eXBlID09PSA2KSB7XHJcbiAgICBpZiAoYS52YWx1ZS5jb250ZW50ICE9PSBiLnZhbHVlLmNvbnRlbnQpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdCBleHAgPSBhLmV4cDtcclxuICAgIGNvbnN0IGJyYW5jaEV4cCA9IGIuZXhwO1xyXG4gICAgaWYgKGV4cC50eXBlICE9PSBicmFuY2hFeHAudHlwZSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoZXhwLnR5cGUgIT09IDQgfHwgZXhwLmlzU3RhdGljICE9PSBicmFuY2hFeHAuaXNTdGF0aWMgfHwgZXhwLmNvbnRlbnQgIT09IGJyYW5jaEV4cC5jb250ZW50KSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gZ2V0UGFyZW50Q29uZGl0aW9uKG5vZGUpIHtcclxuICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMTkpIHtcclxuICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlLnR5cGUgPT09IDE5KSB7XHJcbiAgICAgICAgbm9kZSA9IG5vZGUuYWx0ZXJuYXRlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMjApIHtcclxuICAgICAgbm9kZSA9IG5vZGUudmFsdWU7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCB0cmFuc2Zvcm1CaW5kID0gKGRpciwgX25vZGUsIGNvbnRleHQpID0+IHtcclxuICBjb25zdCB7IG1vZGlmaWVycywgbG9jIH0gPSBkaXI7XHJcbiAgY29uc3QgYXJnID0gZGlyLmFyZztcclxuICBsZXQgeyBleHAgfSA9IGRpcjtcclxuICBpZiAoZXhwICYmIGV4cC50eXBlID09PSA0ICYmICFleHAuY29udGVudC50cmltKCkpIHtcclxuICAgIHtcclxuICAgICAgZXhwID0gdm9pZCAwO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoIWV4cCkge1xyXG4gICAgaWYgKGFyZy50eXBlICE9PSA0IHx8ICFhcmcuaXNTdGF0aWMpIHtcclxuICAgICAgY29udGV4dC5vbkVycm9yKFxyXG4gICAgICAgIGNyZWF0ZUNvbXBpbGVyRXJyb3IoXHJcbiAgICAgICAgICA1MixcclxuICAgICAgICAgIGFyZy5sb2NcclxuICAgICAgICApXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgcHJvcHM6IFtcclxuICAgICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGFyZywgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihcIlwiLCB0cnVlLCBsb2MpKVxyXG4gICAgICAgIF1cclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIHRyYW5zZm9ybUJpbmRTaG9ydGhhbmQoZGlyKTtcclxuICAgIGV4cCA9IGRpci5leHA7XHJcbiAgfVxyXG4gIGlmIChhcmcudHlwZSAhPT0gNCkge1xyXG4gICAgYXJnLmNoaWxkcmVuLnVuc2hpZnQoYChgKTtcclxuICAgIGFyZy5jaGlsZHJlbi5wdXNoKGApIHx8IFwiXCJgKTtcclxuICB9IGVsc2UgaWYgKCFhcmcuaXNTdGF0aWMpIHtcclxuICAgIGFyZy5jb250ZW50ID0gYCR7YXJnLmNvbnRlbnR9IHx8IFwiXCJgO1xyXG4gIH1cclxuICBpZiAobW9kaWZpZXJzLnNvbWUoKG1vZCkgPT4gbW9kLmNvbnRlbnQgPT09IFwiY2FtZWxcIikpIHtcclxuICAgIGlmIChhcmcudHlwZSA9PT0gNCkge1xyXG4gICAgICBpZiAoYXJnLmlzU3RhdGljKSB7XHJcbiAgICAgICAgYXJnLmNvbnRlbnQgPSBjYW1lbGl6ZShhcmcuY29udGVudCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYXJnLmNvbnRlbnQgPSBgJHtjb250ZXh0LmhlbHBlclN0cmluZyhDQU1FTElaRSl9KCR7YXJnLmNvbnRlbnR9KWA7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGFyZy5jaGlsZHJlbi51bnNoaWZ0KGAke2NvbnRleHQuaGVscGVyU3RyaW5nKENBTUVMSVpFKX0oYCk7XHJcbiAgICAgIGFyZy5jaGlsZHJlbi5wdXNoKGApYCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmICghY29udGV4dC5pblNTUikge1xyXG4gICAgaWYgKG1vZGlmaWVycy5zb21lKChtb2QpID0+IG1vZC5jb250ZW50ID09PSBcInByb3BcIikpIHtcclxuICAgICAgaW5qZWN0UHJlZml4KGFyZywgXCIuXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKG1vZGlmaWVycy5zb21lKChtb2QpID0+IG1vZC5jb250ZW50ID09PSBcImF0dHJcIikpIHtcclxuICAgICAgaW5qZWN0UHJlZml4KGFyZywgXCJeXCIpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4ge1xyXG4gICAgcHJvcHM6IFtjcmVhdGVPYmplY3RQcm9wZXJ0eShhcmcsIGV4cCldXHJcbiAgfTtcclxufTtcclxuY29uc3QgdHJhbnNmb3JtQmluZFNob3J0aGFuZCA9IChkaXIsIGNvbnRleHQpID0+IHtcclxuICBjb25zdCBhcmcgPSBkaXIuYXJnO1xyXG4gIGNvbnN0IHByb3BOYW1lID0gY2FtZWxpemUoYXJnLmNvbnRlbnQpO1xyXG4gIGRpci5leHAgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKHByb3BOYW1lLCBmYWxzZSwgYXJnLmxvYyk7XHJcbn07XHJcbmNvbnN0IGluamVjdFByZWZpeCA9IChhcmcsIHByZWZpeCkgPT4ge1xyXG4gIGlmIChhcmcudHlwZSA9PT0gNCkge1xyXG4gICAgaWYgKGFyZy5pc1N0YXRpYykge1xyXG4gICAgICBhcmcuY29udGVudCA9IHByZWZpeCArIGFyZy5jb250ZW50O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYXJnLmNvbnRlbnQgPSBgXFxgJHtwcmVmaXh9XFwkeyR7YXJnLmNvbnRlbnR9fVxcYGA7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGFyZy5jaGlsZHJlbi51bnNoaWZ0KGAnJHtwcmVmaXh9JyArIChgKTtcclxuICAgIGFyZy5jaGlsZHJlbi5wdXNoKGApYCk7XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgdHJhbnNmb3JtRm9yID0gY3JlYXRlU3RydWN0dXJhbERpcmVjdGl2ZVRyYW5zZm9ybShcclxuICBcImZvclwiLFxyXG4gIChub2RlLCBkaXIsIGNvbnRleHQpID0+IHtcclxuICAgIGNvbnN0IHsgaGVscGVyLCByZW1vdmVIZWxwZXIgfSA9IGNvbnRleHQ7XHJcbiAgICByZXR1cm4gcHJvY2Vzc0Zvcihub2RlLCBkaXIsIGNvbnRleHQsIChmb3JOb2RlKSA9PiB7XHJcbiAgICAgIGNvbnN0IHJlbmRlckV4cCA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGhlbHBlcihSRU5ERVJfTElTVCksIFtcclxuICAgICAgICBmb3JOb2RlLnNvdXJjZVxyXG4gICAgICBdKTtcclxuICAgICAgY29uc3QgaXNUZW1wbGF0ZSA9IGlzVGVtcGxhdGVOb2RlKG5vZGUpO1xyXG4gICAgICBjb25zdCBtZW1vID0gZmluZERpcihub2RlLCBcIm1lbW9cIik7XHJcbiAgICAgIGNvbnN0IGtleVByb3AgPSBmaW5kUHJvcChub2RlLCBga2V5YCwgZmFsc2UsIHRydWUpO1xyXG4gICAgICBjb25zdCBpc0RpcktleSA9IGtleVByb3AgJiYga2V5UHJvcC50eXBlID09PSA3O1xyXG4gICAgICBpZiAoaXNEaXJLZXkgJiYgIWtleVByb3AuZXhwKSB7XHJcbiAgICAgICAgdHJhbnNmb3JtQmluZFNob3J0aGFuZChrZXlQcm9wKTtcclxuICAgICAgfVxyXG4gICAgICBsZXQga2V5RXhwID0ga2V5UHJvcCAmJiAoa2V5UHJvcC50eXBlID09PSA2ID8ga2V5UHJvcC52YWx1ZSA/IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oa2V5UHJvcC52YWx1ZS5jb250ZW50LCB0cnVlKSA6IHZvaWQgMCA6IGtleVByb3AuZXhwKTtcclxuICAgICAgY29uc3Qga2V5UHJvcGVydHkgPSBrZXlQcm9wICYmIGtleUV4cCA/IGNyZWF0ZU9iamVjdFByb3BlcnR5KGBrZXlgLCBrZXlFeHApIDogbnVsbDtcclxuICAgICAgY29uc3QgaXNTdGFibGVGcmFnbWVudCA9IGZvck5vZGUuc291cmNlLnR5cGUgPT09IDQgJiYgZm9yTm9kZS5zb3VyY2UuY29uc3RUeXBlID4gMDtcclxuICAgICAgY29uc3QgZnJhZ21lbnRGbGFnID0gaXNTdGFibGVGcmFnbWVudCA/IDY0IDoga2V5UHJvcCA/IDEyOCA6IDI1NjtcclxuICAgICAgZm9yTm9kZS5jb2RlZ2VuTm9kZSA9IGNyZWF0ZVZOb2RlQ2FsbChcclxuICAgICAgICBjb250ZXh0LFxyXG4gICAgICAgIGhlbHBlcihGUkFHTUVOVCksXHJcbiAgICAgICAgdm9pZCAwLFxyXG4gICAgICAgIHJlbmRlckV4cCxcclxuICAgICAgICBmcmFnbWVudEZsYWcsXHJcbiAgICAgICAgdm9pZCAwLFxyXG4gICAgICAgIHZvaWQgMCxcclxuICAgICAgICB0cnVlLFxyXG4gICAgICAgICFpc1N0YWJsZUZyYWdtZW50LFxyXG4gICAgICAgIGZhbHNlLFxyXG4gICAgICAgIG5vZGUubG9jXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgbGV0IGNoaWxkQmxvY2s7XHJcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gZm9yTm9kZTtcclxuICAgICAgICBpZiAoKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgZmFsc2UpICYmIGlzVGVtcGxhdGUpIHtcclxuICAgICAgICAgIG5vZGUuY2hpbGRyZW4uc29tZSgoYykgPT4ge1xyXG4gICAgICAgICAgICBpZiAoYy50eXBlID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgY29uc3Qga2V5ID0gZmluZFByb3AoYywgXCJrZXlcIik7XHJcbiAgICAgICAgICAgICAgaWYgKGtleSkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKFxyXG4gICAgICAgICAgICAgICAgICBjcmVhdGVDb21waWxlckVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgIDMzLFxyXG4gICAgICAgICAgICAgICAgICAgIGtleS5sb2NcclxuICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5lZWRGcmFnbWVudFdyYXBwZXIgPSBjaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgY2hpbGRyZW5bMF0udHlwZSAhPT0gMTtcclxuICAgICAgICBjb25zdCBzbG90T3V0bGV0ID0gaXNTbG90T3V0bGV0KG5vZGUpID8gbm9kZSA6IGlzVGVtcGxhdGUgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgaXNTbG90T3V0bGV0KG5vZGUuY2hpbGRyZW5bMF0pID8gbm9kZS5jaGlsZHJlblswXSA6IG51bGw7XHJcbiAgICAgICAgaWYgKHNsb3RPdXRsZXQpIHtcclxuICAgICAgICAgIGNoaWxkQmxvY2sgPSBzbG90T3V0bGV0LmNvZGVnZW5Ob2RlO1xyXG4gICAgICAgICAgaWYgKGlzVGVtcGxhdGUgJiYga2V5UHJvcGVydHkpIHtcclxuICAgICAgICAgICAgaW5qZWN0UHJvcChjaGlsZEJsb2NrLCBrZXlQcm9wZXJ0eSwgY29udGV4dCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChuZWVkRnJhZ21lbnRXcmFwcGVyKSB7XHJcbiAgICAgICAgICBjaGlsZEJsb2NrID0gY3JlYXRlVk5vZGVDYWxsKFxyXG4gICAgICAgICAgICBjb250ZXh0LFxyXG4gICAgICAgICAgICBoZWxwZXIoRlJBR01FTlQpLFxyXG4gICAgICAgICAgICBrZXlQcm9wZXJ0eSA/IGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oW2tleVByb3BlcnR5XSkgOiB2b2lkIDAsXHJcbiAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4sXHJcbiAgICAgICAgICAgIDY0LFxyXG4gICAgICAgICAgICB2b2lkIDAsXHJcbiAgICAgICAgICAgIHZvaWQgMCxcclxuICAgICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgICAgdm9pZCAwLFxyXG4gICAgICAgICAgICBmYWxzZVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY2hpbGRCbG9jayA9IGNoaWxkcmVuWzBdLmNvZGVnZW5Ob2RlO1xyXG4gICAgICAgICAgaWYgKGlzVGVtcGxhdGUgJiYga2V5UHJvcGVydHkpIHtcclxuICAgICAgICAgICAgaW5qZWN0UHJvcChjaGlsZEJsb2NrLCBrZXlQcm9wZXJ0eSwgY29udGV4dCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoY2hpbGRCbG9jay5pc0Jsb2NrICE9PSAhaXNTdGFibGVGcmFnbWVudCkge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRCbG9jay5pc0Jsb2NrKSB7XHJcbiAgICAgICAgICAgICAgcmVtb3ZlSGVscGVyKE9QRU5fQkxPQ0spO1xyXG4gICAgICAgICAgICAgIHJlbW92ZUhlbHBlcihcclxuICAgICAgICAgICAgICAgIGdldFZOb2RlQmxvY2tIZWxwZXIoY29udGV4dC5pblNTUiwgY2hpbGRCbG9jay5pc0NvbXBvbmVudClcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJlbW92ZUhlbHBlcihcclxuICAgICAgICAgICAgICAgIGdldFZOb2RlSGVscGVyKGNvbnRleHQuaW5TU1IsIGNoaWxkQmxvY2suaXNDb21wb25lbnQpXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY2hpbGRCbG9jay5pc0Jsb2NrID0gIWlzU3RhYmxlRnJhZ21lbnQ7XHJcbiAgICAgICAgICBpZiAoY2hpbGRCbG9jay5pc0Jsb2NrKSB7XHJcbiAgICAgICAgICAgIGhlbHBlcihPUEVOX0JMT0NLKTtcclxuICAgICAgICAgICAgaGVscGVyKGdldFZOb2RlQmxvY2tIZWxwZXIoY29udGV4dC5pblNTUiwgY2hpbGRCbG9jay5pc0NvbXBvbmVudCkpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaGVscGVyKGdldFZOb2RlSGVscGVyKGNvbnRleHQuaW5TU1IsIGNoaWxkQmxvY2suaXNDb21wb25lbnQpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1lbW8pIHtcclxuICAgICAgICAgIGNvbnN0IGxvb3AgPSBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24oXHJcbiAgICAgICAgICAgIGNyZWF0ZUZvckxvb3BQYXJhbXMoZm9yTm9kZS5wYXJzZVJlc3VsdCwgW1xyXG4gICAgICAgICAgICAgIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9jYWNoZWRgKVxyXG4gICAgICAgICAgICBdKVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGxvb3AuYm9keSA9IGNyZWF0ZUJsb2NrU3RhdGVtZW50KFtcclxuICAgICAgICAgICAgY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtgY29uc3QgX21lbW8gPSAoYCwgbWVtby5leHAsIGApYF0pLFxyXG4gICAgICAgICAgICBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW1xyXG4gICAgICAgICAgICAgIGBpZiAoX2NhY2hlZGAsXHJcbiAgICAgICAgICAgICAgLi4ua2V5RXhwID8gW2AgJiYgX2NhY2hlZC5rZXkgPT09IGAsIGtleUV4cF0gOiBbXSxcclxuICAgICAgICAgICAgICBgICYmICR7Y29udGV4dC5oZWxwZXJTdHJpbmcoXHJcbiAgICAgICAgICAgICAgICBJU19NRU1PX1NBTUVcclxuICAgICAgICAgICAgICApfShfY2FjaGVkLCBfbWVtbykpIHJldHVybiBfY2FjaGVkYFxyXG4gICAgICAgICAgICBdKSxcclxuICAgICAgICAgICAgY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtgY29uc3QgX2l0ZW0gPSBgLCBjaGlsZEJsb2NrXSksXHJcbiAgICAgICAgICAgIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9pdGVtLm1lbW8gPSBfbWVtb2ApLFxyXG4gICAgICAgICAgICBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGByZXR1cm4gX2l0ZW1gKVxyXG4gICAgICAgICAgXSk7XHJcbiAgICAgICAgICByZW5kZXJFeHAuYXJndW1lbnRzLnB1c2goXHJcbiAgICAgICAgICAgIGxvb3AsXHJcbiAgICAgICAgICAgIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9jYWNoZWApLFxyXG4gICAgICAgICAgICBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKFN0cmluZyhjb250ZXh0LmNhY2hlZC5sZW5ndGgpKVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGNvbnRleHQuY2FjaGVkLnB1c2gobnVsbCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJlbmRlckV4cC5hcmd1bWVudHMucHVzaChcclxuICAgICAgICAgICAgY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKFxyXG4gICAgICAgICAgICAgIGNyZWF0ZUZvckxvb3BQYXJhbXMoZm9yTm9kZS5wYXJzZVJlc3VsdCksXHJcbiAgICAgICAgICAgICAgY2hpbGRCbG9jayxcclxuICAgICAgICAgICAgICB0cnVlXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcbiAgfVxyXG4pO1xyXG5mdW5jdGlvbiBwcm9jZXNzRm9yKG5vZGUsIGRpciwgY29udGV4dCwgcHJvY2Vzc0NvZGVnZW4pIHtcclxuICBpZiAoIWRpci5leHApIHtcclxuICAgIGNvbnRleHQub25FcnJvcihcclxuICAgICAgY3JlYXRlQ29tcGlsZXJFcnJvcigzMSwgZGlyLmxvYylcclxuICAgICk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGNvbnN0IHBhcnNlUmVzdWx0ID0gZGlyLmZvclBhcnNlUmVzdWx0O1xyXG4gIGlmICghcGFyc2VSZXN1bHQpIHtcclxuICAgIGNvbnRleHQub25FcnJvcihcclxuICAgICAgY3JlYXRlQ29tcGlsZXJFcnJvcigzMiwgZGlyLmxvYylcclxuICAgICk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGZpbmFsaXplRm9yUGFyc2VSZXN1bHQocGFyc2VSZXN1bHQsIGNvbnRleHQpO1xyXG4gIGNvbnN0IHsgYWRkSWRlbnRpZmllcnMsIHJlbW92ZUlkZW50aWZpZXJzLCBzY29wZXMgfSA9IGNvbnRleHQ7XHJcbiAgY29uc3QgeyBzb3VyY2UsIHZhbHVlLCBrZXksIGluZGV4IH0gPSBwYXJzZVJlc3VsdDtcclxuICBjb25zdCBmb3JOb2RlID0ge1xyXG4gICAgdHlwZTogMTEsXHJcbiAgICBsb2M6IGRpci5sb2MsXHJcbiAgICBzb3VyY2UsXHJcbiAgICB2YWx1ZUFsaWFzOiB2YWx1ZSxcclxuICAgIGtleUFsaWFzOiBrZXksXHJcbiAgICBvYmplY3RJbmRleEFsaWFzOiBpbmRleCxcclxuICAgIHBhcnNlUmVzdWx0LFxyXG4gICAgY2hpbGRyZW46IGlzVGVtcGxhdGVOb2RlKG5vZGUpID8gbm9kZS5jaGlsZHJlbiA6IFtub2RlXVxyXG4gIH07XHJcbiAgY29udGV4dC5yZXBsYWNlTm9kZShmb3JOb2RlKTtcclxuICBzY29wZXMudkZvcisrO1xyXG4gIGNvbnN0IG9uRXhpdCA9IHByb2Nlc3NDb2RlZ2VuICYmIHByb2Nlc3NDb2RlZ2VuKGZvck5vZGUpO1xyXG4gIHJldHVybiAoKSA9PiB7XHJcbiAgICBzY29wZXMudkZvci0tO1xyXG4gICAgaWYgKG9uRXhpdCkgb25FeGl0KCk7XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBmaW5hbGl6ZUZvclBhcnNlUmVzdWx0KHJlc3VsdCwgY29udGV4dCkge1xyXG4gIGlmIChyZXN1bHQuZmluYWxpemVkKSByZXR1cm47XHJcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdHJ1ZSkge1xyXG4gICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihyZXN1bHQuc291cmNlLCBjb250ZXh0KTtcclxuICAgIGlmIChyZXN1bHQua2V5KSB7XHJcbiAgICAgIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24oXHJcbiAgICAgICAgcmVzdWx0LmtleSxcclxuICAgICAgICBjb250ZXh0LFxyXG4gICAgICAgIHRydWVcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIGlmIChyZXN1bHQuaW5kZXgpIHtcclxuICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihcclxuICAgICAgICByZXN1bHQuaW5kZXgsXHJcbiAgICAgICAgY29udGV4dCxcclxuICAgICAgICB0cnVlXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICBpZiAocmVzdWx0LnZhbHVlKSB7XHJcbiAgICAgIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24oXHJcbiAgICAgICAgcmVzdWx0LnZhbHVlLFxyXG4gICAgICAgIGNvbnRleHQsXHJcbiAgICAgICAgdHJ1ZVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXN1bHQuZmluYWxpemVkID0gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVGb3JMb29wUGFyYW1zKHsgdmFsdWUsIGtleSwgaW5kZXggfSwgbWVtb0FyZ3MgPSBbXSkge1xyXG4gIHJldHVybiBjcmVhdGVQYXJhbXNMaXN0KFt2YWx1ZSwga2V5LCBpbmRleCwgLi4ubWVtb0FyZ3NdKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVQYXJhbXNMaXN0KGFyZ3MpIHtcclxuICBsZXQgaSA9IGFyZ3MubGVuZ3RoO1xyXG4gIHdoaWxlIChpLS0pIHtcclxuICAgIGlmIChhcmdzW2ldKSBicmVhaztcclxuICB9XHJcbiAgcmV0dXJuIGFyZ3Muc2xpY2UoMCwgaSArIDEpLm1hcCgoYXJnLCBpMikgPT4gYXJnIHx8IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9gLnJlcGVhdChpMiArIDEpLCBmYWxzZSkpO1xyXG59XHJcblxyXG5jb25zdCBkZWZhdWx0RmFsbGJhY2sgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGB1bmRlZmluZWRgLCBmYWxzZSk7XHJcbmNvbnN0IHRyYWNrU2xvdFNjb3BlcyA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSAmJiAobm9kZS50YWdUeXBlID09PSAxIHx8IG5vZGUudGFnVHlwZSA9PT0gMykpIHtcclxuICAgIGNvbnN0IHZTbG90ID0gZmluZERpcihub2RlLCBcInNsb3RcIik7XHJcbiAgICBpZiAodlNsb3QpIHtcclxuICAgICAgdlNsb3QuZXhwO1xyXG4gICAgICBjb250ZXh0LnNjb3Blcy52U2xvdCsrO1xyXG4gICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIGNvbnRleHQuc2NvcGVzLnZTbG90LS07XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5jb25zdCB0cmFja1ZGb3JTbG90U2NvcGVzID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICBsZXQgdkZvcjtcclxuICBpZiAoaXNUZW1wbGF0ZU5vZGUobm9kZSkgJiYgbm9kZS5wcm9wcy5zb21lKGlzVlNsb3QpICYmICh2Rm9yID0gZmluZERpcihub2RlLCBcImZvclwiKSkpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHZGb3IuZm9yUGFyc2VSZXN1bHQ7XHJcbiAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgIGZpbmFsaXplRm9yUGFyc2VSZXN1bHQocmVzdWx0LCBjb250ZXh0KTtcclxuICAgICAgY29uc3QgeyB2YWx1ZSwga2V5LCBpbmRleCB9ID0gcmVzdWx0O1xyXG4gICAgICBjb25zdCB7IGFkZElkZW50aWZpZXJzLCByZW1vdmVJZGVudGlmaWVycyB9ID0gY29udGV4dDtcclxuICAgICAgdmFsdWUgJiYgYWRkSWRlbnRpZmllcnModmFsdWUpO1xyXG4gICAgICBrZXkgJiYgYWRkSWRlbnRpZmllcnMoa2V5KTtcclxuICAgICAgaW5kZXggJiYgYWRkSWRlbnRpZmllcnMoaW5kZXgpO1xyXG4gICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIHZhbHVlICYmIHJlbW92ZUlkZW50aWZpZXJzKHZhbHVlKTtcclxuICAgICAgICBrZXkgJiYgcmVtb3ZlSWRlbnRpZmllcnMoa2V5KTtcclxuICAgICAgICBpbmRleCAmJiByZW1vdmVJZGVudGlmaWVycyhpbmRleCk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5jb25zdCBidWlsZENsaWVudFNsb3RGbiA9IChwcm9wcywgX3ZGb3JFeHAsIGNoaWxkcmVuLCBsb2MpID0+IGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbihcclxuICBwcm9wcyxcclxuICBjaGlsZHJlbixcclxuICBmYWxzZSxcclxuICB0cnVlLFxyXG4gIGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuWzBdLmxvYyA6IGxvY1xyXG4pO1xyXG5mdW5jdGlvbiBidWlsZFNsb3RzKG5vZGUsIGNvbnRleHQsIGJ1aWxkU2xvdEZuID0gYnVpbGRDbGllbnRTbG90Rm4pIHtcclxuICBjb250ZXh0LmhlbHBlcihXSVRIX0NUWCk7XHJcbiAgY29uc3QgeyBjaGlsZHJlbiwgbG9jIH0gPSBub2RlO1xyXG4gIGNvbnN0IHNsb3RzUHJvcGVydGllcyA9IFtdO1xyXG4gIGNvbnN0IGR5bmFtaWNTbG90cyA9IFtdO1xyXG4gIGxldCBoYXNEeW5hbWljU2xvdHMgPSBjb250ZXh0LnNjb3Blcy52U2xvdCA+IDAgfHwgY29udGV4dC5zY29wZXMudkZvciA+IDA7XHJcbiAgY29uc3Qgb25Db21wb25lbnRTbG90ID0gZmluZERpcihub2RlLCBcInNsb3RcIiwgdHJ1ZSk7XHJcbiAgaWYgKG9uQ29tcG9uZW50U2xvdCkge1xyXG4gICAgY29uc3QgeyBhcmcsIGV4cCB9ID0gb25Db21wb25lbnRTbG90O1xyXG4gICAgaWYgKGFyZyAmJiAhaXNTdGF0aWNFeHAoYXJnKSkge1xyXG4gICAgICBoYXNEeW5hbWljU2xvdHMgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgc2xvdHNQcm9wZXJ0aWVzLnB1c2goXHJcbiAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KFxyXG4gICAgICAgIGFyZyB8fCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKFwiZGVmYXVsdFwiLCB0cnVlKSxcclxuICAgICAgICBidWlsZFNsb3RGbihleHAsIHZvaWQgMCwgY2hpbGRyZW4sIGxvYylcclxuICAgICAgKVxyXG4gICAgKTtcclxuICB9XHJcbiAgbGV0IGhhc1RlbXBsYXRlU2xvdHMgPSBmYWxzZTtcclxuICBsZXQgaGFzTmFtZWREZWZhdWx0U2xvdCA9IGZhbHNlO1xyXG4gIGNvbnN0IGltcGxpY2l0RGVmYXVsdENoaWxkcmVuID0gW107XHJcbiAgY29uc3Qgc2VlblNsb3ROYW1lcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XHJcbiAgbGV0IGNvbmRpdGlvbmFsQnJhbmNoSW5kZXggPSAwO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IHNsb3RFbGVtZW50ID0gY2hpbGRyZW5baV07XHJcbiAgICBsZXQgc2xvdERpcjtcclxuICAgIGlmICghaXNUZW1wbGF0ZU5vZGUoc2xvdEVsZW1lbnQpIHx8ICEoc2xvdERpciA9IGZpbmREaXIoc2xvdEVsZW1lbnQsIFwic2xvdFwiLCB0cnVlKSkpIHtcclxuICAgICAgaWYgKHNsb3RFbGVtZW50LnR5cGUgIT09IDMpIHtcclxuICAgICAgICBpbXBsaWNpdERlZmF1bHRDaGlsZHJlbi5wdXNoKHNsb3RFbGVtZW50KTtcclxuICAgICAgfVxyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIGlmIChvbkNvbXBvbmVudFNsb3QpIHtcclxuICAgICAgY29udGV4dC5vbkVycm9yKFxyXG4gICAgICAgIGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzcsIHNsb3REaXIubG9jKVxyXG4gICAgICApO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICAgIGhhc1RlbXBsYXRlU2xvdHMgPSB0cnVlO1xyXG4gICAgY29uc3QgeyBjaGlsZHJlbjogc2xvdENoaWxkcmVuLCBsb2M6IHNsb3RMb2MgfSA9IHNsb3RFbGVtZW50O1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBhcmc6IHNsb3ROYW1lID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgZGVmYXVsdGAsIHRydWUpLFxyXG4gICAgICBleHA6IHNsb3RQcm9wcyxcclxuICAgICAgbG9jOiBkaXJMb2NcclxuICAgIH0gPSBzbG90RGlyO1xyXG4gICAgbGV0IHN0YXRpY1Nsb3ROYW1lO1xyXG4gICAgaWYgKGlzU3RhdGljRXhwKHNsb3ROYW1lKSkge1xyXG4gICAgICBzdGF0aWNTbG90TmFtZSA9IHNsb3ROYW1lID8gc2xvdE5hbWUuY29udGVudCA6IGBkZWZhdWx0YDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGhhc0R5bmFtaWNTbG90cyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBjb25zdCB2Rm9yID0gZmluZERpcihzbG90RWxlbWVudCwgXCJmb3JcIik7XHJcbiAgICBjb25zdCBzbG90RnVuY3Rpb24gPSBidWlsZFNsb3RGbihzbG90UHJvcHMsIHZGb3IsIHNsb3RDaGlsZHJlbiwgc2xvdExvYyk7XHJcbiAgICBsZXQgdklmO1xyXG4gICAgbGV0IHZFbHNlO1xyXG4gICAgaWYgKHZJZiA9IGZpbmREaXIoc2xvdEVsZW1lbnQsIFwiaWZcIikpIHtcclxuICAgICAgaGFzRHluYW1pY1Nsb3RzID0gdHJ1ZTtcclxuICAgICAgZHluYW1pY1Nsb3RzLnB1c2goXHJcbiAgICAgICAgY3JlYXRlQ29uZGl0aW9uYWxFeHByZXNzaW9uKFxyXG4gICAgICAgICAgdklmLmV4cCxcclxuICAgICAgICAgIGJ1aWxkRHluYW1pY1Nsb3Qoc2xvdE5hbWUsIHNsb3RGdW5jdGlvbiwgY29uZGl0aW9uYWxCcmFuY2hJbmRleCsrKSxcclxuICAgICAgICAgIGRlZmF1bHRGYWxsYmFja1xyXG4gICAgICAgIClcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSBpZiAodkVsc2UgPSBmaW5kRGlyKFxyXG4gICAgICBzbG90RWxlbWVudCxcclxuICAgICAgL15lbHNlKC1pZik/JC8sXHJcbiAgICAgIHRydWVcclxuICAgICAgLyogYWxsb3dFbXB0eSAqL1xyXG4gICAgKSkge1xyXG4gICAgICBsZXQgaiA9IGk7XHJcbiAgICAgIGxldCBwcmV2O1xyXG4gICAgICB3aGlsZSAoai0tKSB7XHJcbiAgICAgICAgcHJldiA9IGNoaWxkcmVuW2pdO1xyXG4gICAgICAgIGlmIChwcmV2LnR5cGUgIT09IDMpIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAocHJldiAmJiBpc1RlbXBsYXRlTm9kZShwcmV2KSAmJiBmaW5kRGlyKHByZXYsIC9eKGVsc2UtKT9pZiQvKSkge1xyXG4gICAgICAgIGxldCBjb25kaXRpb25hbCA9IGR5bmFtaWNTbG90c1tkeW5hbWljU2xvdHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgd2hpbGUgKGNvbmRpdGlvbmFsLmFsdGVybmF0ZS50eXBlID09PSAxOSkge1xyXG4gICAgICAgICAgY29uZGl0aW9uYWwgPSBjb25kaXRpb25hbC5hbHRlcm5hdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbmRpdGlvbmFsLmFsdGVybmF0ZSA9IHZFbHNlLmV4cCA/IGNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbihcclxuICAgICAgICAgIHZFbHNlLmV4cCxcclxuICAgICAgICAgIGJ1aWxkRHluYW1pY1Nsb3QoXHJcbiAgICAgICAgICAgIHNsb3ROYW1lLFxyXG4gICAgICAgICAgICBzbG90RnVuY3Rpb24sXHJcbiAgICAgICAgICAgIGNvbmRpdGlvbmFsQnJhbmNoSW5kZXgrK1xyXG4gICAgICAgICAgKSxcclxuICAgICAgICAgIGRlZmF1bHRGYWxsYmFja1xyXG4gICAgICAgICkgOiBidWlsZER5bmFtaWNTbG90KHNsb3ROYW1lLCBzbG90RnVuY3Rpb24sIGNvbmRpdGlvbmFsQnJhbmNoSW5kZXgrKyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKFxyXG4gICAgICAgICAgY3JlYXRlQ29tcGlsZXJFcnJvcigzMCwgdkVsc2UubG9jKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodkZvcikge1xyXG4gICAgICBoYXNEeW5hbWljU2xvdHMgPSB0cnVlO1xyXG4gICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IHZGb3IuZm9yUGFyc2VSZXN1bHQ7XHJcbiAgICAgIGlmIChwYXJzZVJlc3VsdCkge1xyXG4gICAgICAgIGZpbmFsaXplRm9yUGFyc2VSZXN1bHQocGFyc2VSZXN1bHQsIGNvbnRleHQpO1xyXG4gICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKFxyXG4gICAgICAgICAgY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoUkVOREVSX0xJU1QpLCBbXHJcbiAgICAgICAgICAgIHBhcnNlUmVzdWx0LnNvdXJjZSxcclxuICAgICAgICAgICAgY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKFxyXG4gICAgICAgICAgICAgIGNyZWF0ZUZvckxvb3BQYXJhbXMocGFyc2VSZXN1bHQpLFxyXG4gICAgICAgICAgICAgIGJ1aWxkRHluYW1pY1Nsb3Qoc2xvdE5hbWUsIHNsb3RGdW5jdGlvbiksXHJcbiAgICAgICAgICAgICAgdHJ1ZVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICBdKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKFxyXG4gICAgICAgICAgY3JlYXRlQ29tcGlsZXJFcnJvcihcclxuICAgICAgICAgICAgMzIsXHJcbiAgICAgICAgICAgIHZGb3IubG9jXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHN0YXRpY1Nsb3ROYW1lKSB7XHJcbiAgICAgICAgaWYgKHNlZW5TbG90TmFtZXMuaGFzKHN0YXRpY1Nsb3ROYW1lKSkge1xyXG4gICAgICAgICAgY29udGV4dC5vbkVycm9yKFxyXG4gICAgICAgICAgICBjcmVhdGVDb21waWxlckVycm9yKFxyXG4gICAgICAgICAgICAgIDM4LFxyXG4gICAgICAgICAgICAgIGRpckxvY1xyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlZW5TbG90TmFtZXMuYWRkKHN0YXRpY1Nsb3ROYW1lKTtcclxuICAgICAgICBpZiAoc3RhdGljU2xvdE5hbWUgPT09IFwiZGVmYXVsdFwiKSB7XHJcbiAgICAgICAgICBoYXNOYW1lZERlZmF1bHRTbG90ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgc2xvdHNQcm9wZXJ0aWVzLnB1c2goY3JlYXRlT2JqZWN0UHJvcGVydHkoc2xvdE5hbWUsIHNsb3RGdW5jdGlvbikpO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoIW9uQ29tcG9uZW50U2xvdCkge1xyXG4gICAgY29uc3QgYnVpbGREZWZhdWx0U2xvdFByb3BlcnR5ID0gKHByb3BzLCBjaGlsZHJlbjIpID0+IHtcclxuICAgICAgY29uc3QgZm4gPSBidWlsZFNsb3RGbihwcm9wcywgdm9pZCAwLCBjaGlsZHJlbjIsIGxvYyk7XHJcbiAgICAgIGlmIChjb250ZXh0LmNvbXBhdENvbmZpZykge1xyXG4gICAgICAgIGZuLmlzTm9uU2NvcGVkU2xvdCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNyZWF0ZU9iamVjdFByb3BlcnR5KGBkZWZhdWx0YCwgZm4pO1xyXG4gICAgfTtcclxuICAgIGlmICghaGFzVGVtcGxhdGVTbG90cykge1xyXG4gICAgICBzbG90c1Byb3BlcnRpZXMucHVzaChidWlsZERlZmF1bHRTbG90UHJvcGVydHkodm9pZCAwLCBjaGlsZHJlbikpO1xyXG4gICAgfSBlbHNlIGlmIChpbXBsaWNpdERlZmF1bHRDaGlsZHJlbi5sZW5ndGggJiYgLy8gIzM3NjZcclxuICAgIC8vIHdpdGggd2hpdGVzcGFjZTogJ3ByZXNlcnZlJywgd2hpdGVzcGFjZXMgYmV0d2VlbiBzbG90cyB3aWxsIGVuZCB1cCBpblxyXG4gICAgLy8gaW1wbGljaXREZWZhdWx0Q2hpbGRyZW4uIElnbm9yZSBpZiBhbGwgaW1wbGljaXQgY2hpbGRyZW4gYXJlIHdoaXRlc3BhY2VzLlxyXG4gICAgaW1wbGljaXREZWZhdWx0Q2hpbGRyZW4uc29tZSgobm9kZTIpID0+IGlzTm9uV2hpdGVzcGFjZUNvbnRlbnQobm9kZTIpKSkge1xyXG4gICAgICBpZiAoaGFzTmFtZWREZWZhdWx0U2xvdCkge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihcclxuICAgICAgICAgIGNyZWF0ZUNvbXBpbGVyRXJyb3IoXHJcbiAgICAgICAgICAgIDM5LFxyXG4gICAgICAgICAgICBpbXBsaWNpdERlZmF1bHRDaGlsZHJlblswXS5sb2NcclxuICAgICAgICAgIClcclxuICAgICAgICApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNsb3RzUHJvcGVydGllcy5wdXNoKFxyXG4gICAgICAgICAgYnVpbGREZWZhdWx0U2xvdFByb3BlcnR5KHZvaWQgMCwgaW1wbGljaXREZWZhdWx0Q2hpbGRyZW4pXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBjb25zdCBzbG90RmxhZyA9IGhhc0R5bmFtaWNTbG90cyA/IDIgOiBoYXNGb3J3YXJkZWRTbG90cyhub2RlLmNoaWxkcmVuKSA/IDMgOiAxO1xyXG4gIGxldCBzbG90cyA9IGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oXHJcbiAgICBzbG90c1Byb3BlcnRpZXMuY29uY2F0KFxyXG4gICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShcclxuICAgICAgICBgX2AsXHJcbiAgICAgICAgLy8gMiA9IGNvbXBpbGVkIGJ1dCBkeW5hbWljID0gY2FuIHNraXAgbm9ybWFsaXphdGlvbiwgYnV0IG11c3QgcnVuIGRpZmZcclxuICAgICAgICAvLyAxID0gY29tcGlsZWQgYW5kIHN0YXRpYyA9IGNhbiBza2lwIG5vcm1hbGl6YXRpb24gQU5EIGRpZmYgYXMgb3B0aW1pemVkXHJcbiAgICAgICAgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihcclxuICAgICAgICAgIHNsb3RGbGFnICsgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgIC8qICR7c2xvdEZsYWdzVGV4dFtzbG90RmxhZ119ICovYCA6IGBgKSxcclxuICAgICAgICAgIGZhbHNlXHJcbiAgICAgICAgKVxyXG4gICAgICApXHJcbiAgICApLFxyXG4gICAgbG9jXHJcbiAgKTtcclxuICBpZiAoZHluYW1pY1Nsb3RzLmxlbmd0aCkge1xyXG4gICAgc2xvdHMgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihDUkVBVEVfU0xPVFMpLCBbXHJcbiAgICAgIHNsb3RzLFxyXG4gICAgICBjcmVhdGVBcnJheUV4cHJlc3Npb24oZHluYW1pY1Nsb3RzKVxyXG4gICAgXSk7XHJcbiAgfVxyXG4gIHJldHVybiB7XHJcbiAgICBzbG90cyxcclxuICAgIGhhc0R5bmFtaWNTbG90c1xyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gYnVpbGREeW5hbWljU2xvdChuYW1lLCBmbiwgaW5kZXgpIHtcclxuICBjb25zdCBwcm9wcyA9IFtcclxuICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGBuYW1lYCwgbmFtZSksXHJcbiAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShgZm5gLCBmbilcclxuICBdO1xyXG4gIGlmIChpbmRleCAhPSBudWxsKSB7XHJcbiAgICBwcm9wcy5wdXNoKFxyXG4gICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShga2V5YCwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihTdHJpbmcoaW5kZXgpLCB0cnVlKSlcclxuICAgICk7XHJcbiAgfVxyXG4gIHJldHVybiBjcmVhdGVPYmplY3RFeHByZXNzaW9uKHByb3BzKTtcclxufVxyXG5mdW5jdGlvbiBoYXNGb3J3YXJkZWRTbG90cyhjaGlsZHJlbikge1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICBzd2l0Y2ggKGNoaWxkLnR5cGUpIHtcclxuICAgICAgY2FzZSAxOlxyXG4gICAgICAgIGlmIChjaGlsZC50YWdUeXBlID09PSAyIHx8IGhhc0ZvcndhcmRlZFNsb3RzKGNoaWxkLmNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDk6XHJcbiAgICAgICAgaWYgKGhhc0ZvcndhcmRlZFNsb3RzKGNoaWxkLmJyYW5jaGVzKSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMTA6XHJcbiAgICAgIGNhc2UgMTE6XHJcbiAgICAgICAgaWYgKGhhc0ZvcndhcmRlZFNsb3RzKGNoaWxkLmNoaWxkcmVuKSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBpc05vbldoaXRlc3BhY2VDb250ZW50KG5vZGUpIHtcclxuICBpZiAobm9kZS50eXBlICE9PSAyICYmIG5vZGUudHlwZSAhPT0gMTIpXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICByZXR1cm4gbm9kZS50eXBlID09PSAyID8gISFub2RlLmNvbnRlbnQudHJpbSgpIDogaXNOb25XaGl0ZXNwYWNlQ29udGVudChub2RlLmNvbnRlbnQpO1xyXG59XHJcblxyXG5jb25zdCBkaXJlY3RpdmVJbXBvcnRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcclxuY29uc3QgdHJhbnNmb3JtRWxlbWVudCA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIHBvc3RUcmFuc2Zvcm1FbGVtZW50KCkge1xyXG4gICAgbm9kZSA9IGNvbnRleHQuY3VycmVudE5vZGU7XHJcbiAgICBpZiAoIShub2RlLnR5cGUgPT09IDEgJiYgKG5vZGUudGFnVHlwZSA9PT0gMCB8fCBub2RlLnRhZ1R5cGUgPT09IDEpKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IHRhZywgcHJvcHMgfSA9IG5vZGU7XHJcbiAgICBjb25zdCBpc0NvbXBvbmVudCA9IG5vZGUudGFnVHlwZSA9PT0gMTtcclxuICAgIGxldCB2bm9kZVRhZyA9IGlzQ29tcG9uZW50ID8gcmVzb2x2ZUNvbXBvbmVudFR5cGUobm9kZSwgY29udGV4dCkgOiBgXCIke3RhZ31cImA7XHJcbiAgICBjb25zdCBpc0R5bmFtaWNDb21wb25lbnQgPSBpc09iamVjdCh2bm9kZVRhZykgJiYgdm5vZGVUYWcuY2FsbGVlID09PSBSRVNPTFZFX0RZTkFNSUNfQ09NUE9ORU5UO1xyXG4gICAgbGV0IHZub2RlUHJvcHM7XHJcbiAgICBsZXQgdm5vZGVDaGlsZHJlbjtcclxuICAgIGxldCBwYXRjaEZsYWcgPSAwO1xyXG4gICAgbGV0IHZub2RlRHluYW1pY1Byb3BzO1xyXG4gICAgbGV0IGR5bmFtaWNQcm9wTmFtZXM7XHJcbiAgICBsZXQgdm5vZGVEaXJlY3RpdmVzO1xyXG4gICAgbGV0IHNob3VsZFVzZUJsb2NrID0gKFxyXG4gICAgICAvLyBkeW5hbWljIGNvbXBvbmVudCBtYXkgcmVzb2x2ZSB0byBwbGFpbiBlbGVtZW50c1xyXG4gICAgICBpc0R5bmFtaWNDb21wb25lbnQgfHwgdm5vZGVUYWcgPT09IFRFTEVQT1JUIHx8IHZub2RlVGFnID09PSBTVVNQRU5TRSB8fCAhaXNDb21wb25lbnQgJiYgLy8gPHN2Zz4gYW5kIDxmb3JlaWduT2JqZWN0PiBtdXN0IGJlIGZvcmNlZCBpbnRvIGJsb2NrcyBzbyB0aGF0IGJsb2NrXHJcbiAgICAgIC8vIHVwZGF0ZXMgaW5zaWRlIGdldCBwcm9wZXIgaXNTVkcgZmxhZyBhdCBydW50aW1lLiAoIzYzOSwgIzY0MylcclxuICAgICAgLy8gVGhpcyBpcyB0ZWNobmljYWxseSB3ZWItc3BlY2lmaWMsIGJ1dCBzcGxpdHRpbmcgdGhlIGxvZ2ljIG91dCBvZiBjb3JlXHJcbiAgICAgIC8vIGxlYWRzIHRvIHRvbyBtdWNoIHVubmVjZXNzYXJ5IGNvbXBsZXhpdHkuXHJcbiAgICAgICh0YWcgPT09IFwic3ZnXCIgfHwgdGFnID09PSBcImZvcmVpZ25PYmplY3RcIiB8fCB0YWcgPT09IFwibWF0aFwiKVxyXG4gICAgKTtcclxuICAgIGlmIChwcm9wcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IHByb3BzQnVpbGRSZXN1bHQgPSBidWlsZFByb3BzKFxyXG4gICAgICAgIG5vZGUsXHJcbiAgICAgICAgY29udGV4dCxcclxuICAgICAgICB2b2lkIDAsXHJcbiAgICAgICAgaXNDb21wb25lbnQsXHJcbiAgICAgICAgaXNEeW5hbWljQ29tcG9uZW50XHJcbiAgICAgICk7XHJcbiAgICAgIHZub2RlUHJvcHMgPSBwcm9wc0J1aWxkUmVzdWx0LnByb3BzO1xyXG4gICAgICBwYXRjaEZsYWcgPSBwcm9wc0J1aWxkUmVzdWx0LnBhdGNoRmxhZztcclxuICAgICAgZHluYW1pY1Byb3BOYW1lcyA9IHByb3BzQnVpbGRSZXN1bHQuZHluYW1pY1Byb3BOYW1lcztcclxuICAgICAgY29uc3QgZGlyZWN0aXZlcyA9IHByb3BzQnVpbGRSZXN1bHQuZGlyZWN0aXZlcztcclxuICAgICAgdm5vZGVEaXJlY3RpdmVzID0gZGlyZWN0aXZlcyAmJiBkaXJlY3RpdmVzLmxlbmd0aCA/IGNyZWF0ZUFycmF5RXhwcmVzc2lvbihcclxuICAgICAgICBkaXJlY3RpdmVzLm1hcCgoZGlyKSA9PiBidWlsZERpcmVjdGl2ZUFyZ3MoZGlyLCBjb250ZXh0KSlcclxuICAgICAgKSA6IHZvaWQgMDtcclxuICAgICAgaWYgKHByb3BzQnVpbGRSZXN1bHQuc2hvdWxkVXNlQmxvY2spIHtcclxuICAgICAgICBzaG91bGRVc2VCbG9jayA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcclxuICAgICAgaWYgKHZub2RlVGFnID09PSBLRUVQX0FMSVZFKSB7XHJcbiAgICAgICAgc2hvdWxkVXNlQmxvY2sgPSB0cnVlO1xyXG4gICAgICAgIHBhdGNoRmxhZyB8PSAxMDI0O1xyXG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgY29udGV4dC5vbkVycm9yKFxyXG4gICAgICAgICAgICBjcmVhdGVDb21waWxlckVycm9yKDQ2LCB7XHJcbiAgICAgICAgICAgICAgc3RhcnQ6IG5vZGUuY2hpbGRyZW5bMF0ubG9jLnN0YXJ0LFxyXG4gICAgICAgICAgICAgIGVuZDogbm9kZS5jaGlsZHJlbltub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDFdLmxvYy5lbmQsXHJcbiAgICAgICAgICAgICAgc291cmNlOiBcIlwiXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBjb25zdCBzaG91bGRCdWlsZEFzU2xvdHMgPSBpc0NvbXBvbmVudCAmJiAvLyBUZWxlcG9ydCBpcyBub3QgYSByZWFsIGNvbXBvbmVudCBhbmQgaGFzIGRlZGljYXRlZCBydW50aW1lIGhhbmRsaW5nXHJcbiAgICAgIHZub2RlVGFnICE9PSBURUxFUE9SVCAmJiAvLyBleHBsYWluZWQgYWJvdmUuXHJcbiAgICAgIHZub2RlVGFnICE9PSBLRUVQX0FMSVZFO1xyXG4gICAgICBpZiAoc2hvdWxkQnVpbGRBc1Nsb3RzKSB7XHJcbiAgICAgICAgY29uc3QgeyBzbG90cywgaGFzRHluYW1pY1Nsb3RzIH0gPSBidWlsZFNsb3RzKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgIHZub2RlQ2hpbGRyZW4gPSBzbG90cztcclxuICAgICAgICBpZiAoaGFzRHluYW1pY1Nsb3RzKSB7XHJcbiAgICAgICAgICBwYXRjaEZsYWcgfD0gMTAyNDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgdm5vZGVUYWcgIT09IFRFTEVQT1JUKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuWzBdO1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSBjaGlsZC50eXBlO1xyXG4gICAgICAgIGNvbnN0IGhhc0R5bmFtaWNUZXh0Q2hpbGQgPSB0eXBlID09PSA1IHx8IHR5cGUgPT09IDg7XHJcbiAgICAgICAgaWYgKGhhc0R5bmFtaWNUZXh0Q2hpbGQgJiYgZ2V0Q29uc3RhbnRUeXBlKGNoaWxkLCBjb250ZXh0KSA9PT0gMCkge1xyXG4gICAgICAgICAgcGF0Y2hGbGFnIHw9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoYXNEeW5hbWljVGV4dENoaWxkIHx8IHR5cGUgPT09IDIpIHtcclxuICAgICAgICAgIHZub2RlQ2hpbGRyZW4gPSBjaGlsZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdm5vZGVDaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZub2RlQ2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoZHluYW1pY1Byb3BOYW1lcyAmJiBkeW5hbWljUHJvcE5hbWVzLmxlbmd0aCkge1xyXG4gICAgICB2bm9kZUR5bmFtaWNQcm9wcyA9IHN0cmluZ2lmeUR5bmFtaWNQcm9wTmFtZXMoZHluYW1pY1Byb3BOYW1lcyk7XHJcbiAgICB9XHJcbiAgICBub2RlLmNvZGVnZW5Ob2RlID0gY3JlYXRlVk5vZGVDYWxsKFxyXG4gICAgICBjb250ZXh0LFxyXG4gICAgICB2bm9kZVRhZyxcclxuICAgICAgdm5vZGVQcm9wcyxcclxuICAgICAgdm5vZGVDaGlsZHJlbixcclxuICAgICAgcGF0Y2hGbGFnID09PSAwID8gdm9pZCAwIDogcGF0Y2hGbGFnLFxyXG4gICAgICB2bm9kZUR5bmFtaWNQcm9wcyxcclxuICAgICAgdm5vZGVEaXJlY3RpdmVzLFxyXG4gICAgICAhIXNob3VsZFVzZUJsb2NrLFxyXG4gICAgICBmYWxzZSxcclxuICAgICAgaXNDb21wb25lbnQsXHJcbiAgICAgIG5vZGUubG9jXHJcbiAgICApO1xyXG4gIH07XHJcbn07XHJcbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnRUeXBlKG5vZGUsIGNvbnRleHQsIHNzciA9IGZhbHNlKSB7XHJcbiAgbGV0IHsgdGFnIH0gPSBub2RlO1xyXG4gIGNvbnN0IGlzRXhwbGljaXREeW5hbWljID0gaXNDb21wb25lbnRUYWcodGFnKTtcclxuICBjb25zdCBpc1Byb3AgPSBmaW5kUHJvcChcclxuICAgIG5vZGUsXHJcbiAgICBcImlzXCIsXHJcbiAgICBmYWxzZSxcclxuICAgIHRydWVcclxuICAgIC8qIGFsbG93IGVtcHR5ICovXHJcbiAgKTtcclxuICBpZiAoaXNQcm9wKSB7XHJcbiAgICBpZiAoaXNFeHBsaWNpdER5bmFtaWMgfHwgaXNDb21wYXRFbmFibGVkKFxyXG4gICAgICBcIkNPTVBJTEVSX0lTX09OX0VMRU1FTlRcIixcclxuICAgICAgY29udGV4dFxyXG4gICAgKSkge1xyXG4gICAgICBsZXQgZXhwO1xyXG4gICAgICBpZiAoaXNQcm9wLnR5cGUgPT09IDYpIHtcclxuICAgICAgICBleHAgPSBpc1Byb3AudmFsdWUgJiYgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihpc1Byb3AudmFsdWUuY29udGVudCwgdHJ1ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZXhwID0gaXNQcm9wLmV4cDtcclxuICAgICAgICBpZiAoIWV4cCkge1xyXG4gICAgICAgICAgZXhwID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgaXNgLCBmYWxzZSwgaXNQcm9wLmFyZy5sb2MpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoZXhwKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQpLCBbXHJcbiAgICAgICAgICBleHBcclxuICAgICAgICBdKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChpc1Byb3AudHlwZSA9PT0gNiAmJiBpc1Byb3AudmFsdWUuY29udGVudC5zdGFydHNXaXRoKFwidnVlOlwiKSkge1xyXG4gICAgICB0YWcgPSBpc1Byb3AudmFsdWUuY29udGVudC5zbGljZSg0KTtcclxuICAgIH1cclxuICB9XHJcbiAgY29uc3QgYnVpbHRJbiA9IGlzQ29yZUNvbXBvbmVudCh0YWcpIHx8IGNvbnRleHQuaXNCdWlsdEluQ29tcG9uZW50KHRhZyk7XHJcbiAgaWYgKGJ1aWx0SW4pIHtcclxuICAgIGlmICghc3NyKSBjb250ZXh0LmhlbHBlcihidWlsdEluKTtcclxuICAgIHJldHVybiBidWlsdEluO1xyXG4gIH1cclxuICBjb250ZXh0LmhlbHBlcihSRVNPTFZFX0NPTVBPTkVOVCk7XHJcbiAgY29udGV4dC5jb21wb25lbnRzLmFkZCh0YWcpO1xyXG4gIHJldHVybiB0b1ZhbGlkQXNzZXRJZCh0YWcsIGBjb21wb25lbnRgKTtcclxufVxyXG5mdW5jdGlvbiBidWlsZFByb3BzKG5vZGUsIGNvbnRleHQsIHByb3BzID0gbm9kZS5wcm9wcywgaXNDb21wb25lbnQsIGlzRHluYW1pY0NvbXBvbmVudCwgc3NyID0gZmFsc2UpIHtcclxuICBjb25zdCB7IHRhZywgbG9jOiBlbGVtZW50TG9jLCBjaGlsZHJlbiB9ID0gbm9kZTtcclxuICBsZXQgcHJvcGVydGllcyA9IFtdO1xyXG4gIGNvbnN0IG1lcmdlQXJncyA9IFtdO1xyXG4gIGNvbnN0IHJ1bnRpbWVEaXJlY3RpdmVzID0gW107XHJcbiAgY29uc3QgaGFzQ2hpbGRyZW4gPSBjaGlsZHJlbi5sZW5ndGggPiAwO1xyXG4gIGxldCBzaG91bGRVc2VCbG9jayA9IGZhbHNlO1xyXG4gIGxldCBwYXRjaEZsYWcgPSAwO1xyXG4gIGxldCBoYXNSZWYgPSBmYWxzZTtcclxuICBsZXQgaGFzQ2xhc3NCaW5kaW5nID0gZmFsc2U7XHJcbiAgbGV0IGhhc1N0eWxlQmluZGluZyA9IGZhbHNlO1xyXG4gIGxldCBoYXNIeWRyYXRpb25FdmVudEJpbmRpbmcgPSBmYWxzZTtcclxuICBsZXQgaGFzRHluYW1pY0tleXMgPSBmYWxzZTtcclxuICBsZXQgaGFzVm5vZGVIb29rID0gZmFsc2U7XHJcbiAgY29uc3QgZHluYW1pY1Byb3BOYW1lcyA9IFtdO1xyXG4gIGNvbnN0IHB1c2hNZXJnZUFyZyA9IChhcmcpID0+IHtcclxuICAgIGlmIChwcm9wZXJ0aWVzLmxlbmd0aCkge1xyXG4gICAgICBtZXJnZUFyZ3MucHVzaChcclxuICAgICAgICBjcmVhdGVPYmplY3RFeHByZXNzaW9uKGRlZHVwZVByb3BlcnRpZXMocHJvcGVydGllcyksIGVsZW1lbnRMb2MpXHJcbiAgICAgICk7XHJcbiAgICAgIHByb3BlcnRpZXMgPSBbXTtcclxuICAgIH1cclxuICAgIGlmIChhcmcpIG1lcmdlQXJncy5wdXNoKGFyZyk7XHJcbiAgfTtcclxuICBjb25zdCBwdXNoUmVmVkZvck1hcmtlciA9ICgpID0+IHtcclxuICAgIGlmIChjb250ZXh0LnNjb3Blcy52Rm9yID4gMCkge1xyXG4gICAgICBwcm9wZXJ0aWVzLnB1c2goXHJcbiAgICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoXHJcbiAgICAgICAgICBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKFwicmVmX2ZvclwiLCB0cnVlKSxcclxuICAgICAgICAgIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oXCJ0cnVlXCIpXHJcbiAgICAgICAgKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgY29uc3QgYW5hbHl6ZVBhdGNoRmxhZyA9ICh7IGtleSwgdmFsdWUgfSkgPT4ge1xyXG4gICAgaWYgKGlzU3RhdGljRXhwKGtleSkpIHtcclxuICAgICAgY29uc3QgbmFtZSA9IGtleS5jb250ZW50O1xyXG4gICAgICBjb25zdCBpc0V2ZW50SGFuZGxlciA9IGlzT24obmFtZSk7XHJcbiAgICAgIGlmIChpc0V2ZW50SGFuZGxlciAmJiAoIWlzQ29tcG9uZW50IHx8IGlzRHluYW1pY0NvbXBvbmVudCkgJiYgLy8gb21pdCB0aGUgZmxhZyBmb3IgY2xpY2sgaGFuZGxlcnMgYmVjYXVzZSBoeWRyYXRpb24gZ2l2ZXMgY2xpY2tcclxuICAgICAgLy8gZGVkaWNhdGVkIGZhc3QgcGF0aC5cclxuICAgICAgbmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9uY2xpY2tcIiAmJiAvLyBvbWl0IHYtbW9kZWwgaGFuZGxlcnNcclxuICAgICAgbmFtZSAhPT0gXCJvblVwZGF0ZTptb2RlbFZhbHVlXCIgJiYgLy8gb21pdCBvblZub2RlWFhYIGhvb2tzXHJcbiAgICAgICFpc1Jlc2VydmVkUHJvcChuYW1lKSkge1xyXG4gICAgICAgIGhhc0h5ZHJhdGlvbkV2ZW50QmluZGluZyA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzRXZlbnRIYW5kbGVyICYmIGlzUmVzZXJ2ZWRQcm9wKG5hbWUpKSB7XHJcbiAgICAgICAgaGFzVm5vZGVIb29rID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNFdmVudEhhbmRsZXIgJiYgdmFsdWUudHlwZSA9PT0gMTQpIHtcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlLmFyZ3VtZW50c1swXTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodmFsdWUudHlwZSA9PT0gMjAgfHwgKHZhbHVlLnR5cGUgPT09IDQgfHwgdmFsdWUudHlwZSA9PT0gOCkgJiYgZ2V0Q29uc3RhbnRUeXBlKHZhbHVlLCBjb250ZXh0KSA+IDApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG5hbWUgPT09IFwicmVmXCIpIHtcclxuICAgICAgICBoYXNSZWYgPSB0cnVlO1xyXG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwiY2xhc3NcIikge1xyXG4gICAgICAgIGhhc0NsYXNzQmluZGluZyA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJzdHlsZVwiKSB7XHJcbiAgICAgICAgaGFzU3R5bGVCaW5kaW5nID0gdHJ1ZTtcclxuICAgICAgfSBlbHNlIGlmIChuYW1lICE9PSBcImtleVwiICYmICFkeW5hbWljUHJvcE5hbWVzLmluY2x1ZGVzKG5hbWUpKSB7XHJcbiAgICAgICAgZHluYW1pY1Byb3BOYW1lcy5wdXNoKG5hbWUpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc0NvbXBvbmVudCAmJiAobmFtZSA9PT0gXCJjbGFzc1wiIHx8IG5hbWUgPT09IFwic3R5bGVcIikgJiYgIWR5bmFtaWNQcm9wTmFtZXMuaW5jbHVkZXMobmFtZSkpIHtcclxuICAgICAgICBkeW5hbWljUHJvcE5hbWVzLnB1c2gobmFtZSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGhhc0R5bmFtaWNLZXlzID0gdHJ1ZTtcclxuICAgIH1cclxuICB9O1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IHByb3AgPSBwcm9wc1tpXTtcclxuICAgIGlmIChwcm9wLnR5cGUgPT09IDYpIHtcclxuICAgICAgY29uc3QgeyBsb2MsIG5hbWUsIG5hbWVMb2MsIHZhbHVlIH0gPSBwcm9wO1xyXG4gICAgICBsZXQgaXNTdGF0aWMgPSB0cnVlO1xyXG4gICAgICBpZiAobmFtZSA9PT0gXCJyZWZcIikge1xyXG4gICAgICAgIGhhc1JlZiA9IHRydWU7XHJcbiAgICAgICAgcHVzaFJlZlZGb3JNYXJrZXIoKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobmFtZSA9PT0gXCJpc1wiICYmIChpc0NvbXBvbmVudFRhZyh0YWcpIHx8IHZhbHVlICYmIHZhbHVlLmNvbnRlbnQuc3RhcnRzV2l0aChcInZ1ZTpcIikgfHwgaXNDb21wYXRFbmFibGVkKFxyXG4gICAgICAgIFwiQ09NUElMRVJfSVNfT05fRUxFTUVOVFwiLFxyXG4gICAgICAgIGNvbnRleHRcclxuICAgICAgKSkpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICBwcm9wZXJ0aWVzLnB1c2goXHJcbiAgICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoXHJcbiAgICAgICAgICBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKG5hbWUsIHRydWUsIG5hbWVMb2MpLFxyXG4gICAgICAgICAgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihcclxuICAgICAgICAgICAgdmFsdWUgPyB2YWx1ZS5jb250ZW50IDogXCJcIixcclxuICAgICAgICAgICAgaXNTdGF0aWMsXHJcbiAgICAgICAgICAgIHZhbHVlID8gdmFsdWUubG9jIDogbG9jXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgKVxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgeyBuYW1lLCBhcmcsIGV4cCwgbG9jLCBtb2RpZmllcnMgfSA9IHByb3A7XHJcbiAgICAgIGNvbnN0IGlzVkJpbmQgPSBuYW1lID09PSBcImJpbmRcIjtcclxuICAgICAgY29uc3QgaXNWT24gPSBuYW1lID09PSBcIm9uXCI7XHJcbiAgICAgIGlmIChuYW1lID09PSBcInNsb3RcIikge1xyXG4gICAgICAgIGlmICghaXNDb21wb25lbnQpIHtcclxuICAgICAgICAgIGNvbnRleHQub25FcnJvcihcclxuICAgICAgICAgICAgY3JlYXRlQ29tcGlsZXJFcnJvcig0MCwgbG9jKVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG5hbWUgPT09IFwib25jZVwiIHx8IG5hbWUgPT09IFwibWVtb1wiKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG5hbWUgPT09IFwiaXNcIiB8fCBpc1ZCaW5kICYmIGlzU3RhdGljQXJnT2YoYXJnLCBcImlzXCIpICYmIChpc0NvbXBvbmVudFRhZyh0YWcpIHx8IGlzQ29tcGF0RW5hYmxlZChcclxuICAgICAgICBcIkNPTVBJTEVSX0lTX09OX0VMRU1FTlRcIixcclxuICAgICAgICBjb250ZXh0XHJcbiAgICAgICkpKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzVk9uICYmIHNzcikge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChcclxuICAgICAgICAvLyAjOTM4OiBlbGVtZW50cyB3aXRoIGR5bmFtaWMga2V5cyBzaG91bGQgYmUgZm9yY2VkIGludG8gYmxvY2tzXHJcbiAgICAgICAgaXNWQmluZCAmJiBpc1N0YXRpY0FyZ09mKGFyZywgXCJrZXlcIikgfHwgLy8gaW5saW5lIGJlZm9yZS11cGRhdGUgaG9va3MgbmVlZCB0byBmb3JjZSBibG9jayBzbyB0aGF0IGl0IGlzIGludm9rZWRcclxuICAgICAgICAvLyBiZWZvcmUgY2hpbGRyZW5cclxuICAgICAgICBpc1ZPbiAmJiBoYXNDaGlsZHJlbiAmJiBpc1N0YXRpY0FyZ09mKGFyZywgXCJ2dWU6YmVmb3JlLXVwZGF0ZVwiKVxyXG4gICAgICApIHtcclxuICAgICAgICBzaG91bGRVc2VCbG9jayA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzVkJpbmQgJiYgaXNTdGF0aWNBcmdPZihhcmcsIFwicmVmXCIpKSB7XHJcbiAgICAgICAgcHVzaFJlZlZGb3JNYXJrZXIoKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWFyZyAmJiAoaXNWQmluZCB8fCBpc1ZPbikpIHtcclxuICAgICAgICBoYXNEeW5hbWljS2V5cyA9IHRydWU7XHJcbiAgICAgICAgaWYgKGV4cCkge1xyXG4gICAgICAgICAgaWYgKGlzVkJpbmQpIHtcclxuICAgICAgICAgICAgcHVzaFJlZlZGb3JNYXJrZXIoKTtcclxuICAgICAgICAgICAgcHVzaE1lcmdlQXJnKCk7XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaGFzT3ZlcnJpZGFibGVLZXlzID0gbWVyZ2VBcmdzLnNvbWUoKGFyZzIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgaWYgKGFyZzIudHlwZSA9PT0gMTUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnMi5wcm9wZXJ0aWVzLnNvbWUoKHsga2V5IH0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkudHlwZSAhPT0gNCB8fCAha2V5LmlzU3RhdGljKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleS5jb250ZW50ICE9PSBcImNsYXNzXCIgJiYga2V5LmNvbnRlbnQgIT09IFwic3R5bGVcIiAmJiAhaXNPbihrZXkuY29udGVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc092ZXJyaWRhYmxlS2V5cykge1xyXG4gICAgICAgICAgICAgICAgICBjaGVja0NvbXBhdEVuYWJsZWQoXHJcbiAgICAgICAgICAgICAgICAgICAgXCJDT01QSUxFUl9WX0JJTkRfT0JKRUNUX09SREVSXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCxcclxuICAgICAgICAgICAgICAgICAgICBsb2NcclxuICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKGlzQ29tcGF0RW5hYmxlZChcclxuICAgICAgICAgICAgICAgIFwiQ09NUElMRVJfVl9CSU5EX09CSkVDVF9PUkRFUlwiLFxyXG4gICAgICAgICAgICAgICAgY29udGV4dFxyXG4gICAgICAgICAgICAgICkpIHtcclxuICAgICAgICAgICAgICAgIG1lcmdlQXJncy51bnNoaWZ0KGV4cCk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWVyZ2VBcmdzLnB1c2goZXhwKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHB1c2hNZXJnZUFyZyh7XHJcbiAgICAgICAgICAgICAgdHlwZTogMTQsXHJcbiAgICAgICAgICAgICAgbG9jLFxyXG4gICAgICAgICAgICAgIGNhbGxlZTogY29udGV4dC5oZWxwZXIoVE9fSEFORExFUlMpLFxyXG4gICAgICAgICAgICAgIGFyZ3VtZW50czogaXNDb21wb25lbnQgPyBbZXhwXSA6IFtleHAsIGB0cnVlYF1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnRleHQub25FcnJvcihcclxuICAgICAgICAgICAgY3JlYXRlQ29tcGlsZXJFcnJvcihcclxuICAgICAgICAgICAgICBpc1ZCaW5kID8gMzQgOiAzNSxcclxuICAgICAgICAgICAgICBsb2NcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzVkJpbmQgJiYgbW9kaWZpZXJzLnNvbWUoKG1vZCkgPT4gbW9kLmNvbnRlbnQgPT09IFwicHJvcFwiKSkge1xyXG4gICAgICAgIHBhdGNoRmxhZyB8PSAzMjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBkaXJlY3RpdmVUcmFuc2Zvcm0gPSBjb250ZXh0LmRpcmVjdGl2ZVRyYW5zZm9ybXNbbmFtZV07XHJcbiAgICAgIGlmIChkaXJlY3RpdmVUcmFuc2Zvcm0pIHtcclxuICAgICAgICBjb25zdCB7IHByb3BzOiBwcm9wczIsIG5lZWRSdW50aW1lIH0gPSBkaXJlY3RpdmVUcmFuc2Zvcm0ocHJvcCwgbm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgIXNzciAmJiBwcm9wczIuZm9yRWFjaChhbmFseXplUGF0Y2hGbGFnKTtcclxuICAgICAgICBpZiAoaXNWT24gJiYgYXJnICYmICFpc1N0YXRpY0V4cChhcmcpKSB7XHJcbiAgICAgICAgICBwdXNoTWVyZ2VBcmcoY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihwcm9wczIsIGVsZW1lbnRMb2MpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcHJvcGVydGllcy5wdXNoKC4uLnByb3BzMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZWVkUnVudGltZSkge1xyXG4gICAgICAgICAgcnVudGltZURpcmVjdGl2ZXMucHVzaChwcm9wKTtcclxuICAgICAgICAgIGlmIChpc1N5bWJvbChuZWVkUnVudGltZSkpIHtcclxuICAgICAgICAgICAgZGlyZWN0aXZlSW1wb3J0TWFwLnNldChwcm9wLCBuZWVkUnVudGltZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKCFpc0J1aWx0SW5EaXJlY3RpdmUobmFtZSkpIHtcclxuICAgICAgICBydW50aW1lRGlyZWN0aXZlcy5wdXNoKHByb3ApO1xyXG4gICAgICAgIGlmIChoYXNDaGlsZHJlbikge1xyXG4gICAgICAgICAgc2hvdWxkVXNlQmxvY2sgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBsZXQgcHJvcHNFeHByZXNzaW9uID0gdm9pZCAwO1xyXG4gIGlmIChtZXJnZUFyZ3MubGVuZ3RoKSB7XHJcbiAgICBwdXNoTWVyZ2VBcmcoKTtcclxuICAgIGlmIChtZXJnZUFyZ3MubGVuZ3RoID4gMSkge1xyXG4gICAgICBwcm9wc0V4cHJlc3Npb24gPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihcclxuICAgICAgICBjb250ZXh0LmhlbHBlcihNRVJHRV9QUk9QUyksXHJcbiAgICAgICAgbWVyZ2VBcmdzLFxyXG4gICAgICAgIGVsZW1lbnRMb2NcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHByb3BzRXhwcmVzc2lvbiA9IG1lcmdlQXJnc1swXTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKHByb3BlcnRpZXMubGVuZ3RoKSB7XHJcbiAgICBwcm9wc0V4cHJlc3Npb24gPSBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFxyXG4gICAgICBkZWR1cGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpLFxyXG4gICAgICBlbGVtZW50TG9jXHJcbiAgICApO1xyXG4gIH1cclxuICBpZiAoaGFzRHluYW1pY0tleXMpIHtcclxuICAgIHBhdGNoRmxhZyB8PSAxNjtcclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKGhhc0NsYXNzQmluZGluZyAmJiAhaXNDb21wb25lbnQpIHtcclxuICAgICAgcGF0Y2hGbGFnIHw9IDI7XHJcbiAgICB9XHJcbiAgICBpZiAoaGFzU3R5bGVCaW5kaW5nICYmICFpc0NvbXBvbmVudCkge1xyXG4gICAgICBwYXRjaEZsYWcgfD0gNDtcclxuICAgIH1cclxuICAgIGlmIChkeW5hbWljUHJvcE5hbWVzLmxlbmd0aCkge1xyXG4gICAgICBwYXRjaEZsYWcgfD0gODtcclxuICAgIH1cclxuICAgIGlmIChoYXNIeWRyYXRpb25FdmVudEJpbmRpbmcpIHtcclxuICAgICAgcGF0Y2hGbGFnIHw9IDMyO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoIXNob3VsZFVzZUJsb2NrICYmIChwYXRjaEZsYWcgPT09IDAgfHwgcGF0Y2hGbGFnID09PSAzMikgJiYgKGhhc1JlZiB8fCBoYXNWbm9kZUhvb2sgfHwgcnVudGltZURpcmVjdGl2ZXMubGVuZ3RoID4gMCkpIHtcclxuICAgIHBhdGNoRmxhZyB8PSA1MTI7XHJcbiAgfVxyXG4gIGlmICghY29udGV4dC5pblNTUiAmJiBwcm9wc0V4cHJlc3Npb24pIHtcclxuICAgIHN3aXRjaCAocHJvcHNFeHByZXNzaW9uLnR5cGUpIHtcclxuICAgICAgY2FzZSAxNTpcclxuICAgICAgICBsZXQgY2xhc3NLZXlJbmRleCA9IC0xO1xyXG4gICAgICAgIGxldCBzdHlsZUtleUluZGV4ID0gLTE7XHJcbiAgICAgICAgbGV0IGhhc0R5bmFtaWNLZXkgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzRXhwcmVzc2lvbi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBjb25zdCBrZXkgPSBwcm9wc0V4cHJlc3Npb24ucHJvcGVydGllc1tpXS5rZXk7XHJcbiAgICAgICAgICBpZiAoaXNTdGF0aWNFeHAoa2V5KSkge1xyXG4gICAgICAgICAgICBpZiAoa2V5LmNvbnRlbnQgPT09IFwiY2xhc3NcIikge1xyXG4gICAgICAgICAgICAgIGNsYXNzS2V5SW5kZXggPSBpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleS5jb250ZW50ID09PSBcInN0eWxlXCIpIHtcclxuICAgICAgICAgICAgICBzdHlsZUtleUluZGV4ID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIGlmICgha2V5LmlzSGFuZGxlcktleSkge1xyXG4gICAgICAgICAgICBoYXNEeW5hbWljS2V5ID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2xhc3NQcm9wID0gcHJvcHNFeHByZXNzaW9uLnByb3BlcnRpZXNbY2xhc3NLZXlJbmRleF07XHJcbiAgICAgICAgY29uc3Qgc3R5bGVQcm9wID0gcHJvcHNFeHByZXNzaW9uLnByb3BlcnRpZXNbc3R5bGVLZXlJbmRleF07XHJcbiAgICAgICAgaWYgKCFoYXNEeW5hbWljS2V5KSB7XHJcbiAgICAgICAgICBpZiAoY2xhc3NQcm9wICYmICFpc1N0YXRpY0V4cChjbGFzc1Byb3AudmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGNsYXNzUHJvcC52YWx1ZSA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKFxyXG4gICAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKE5PUk1BTElaRV9DTEFTUyksXHJcbiAgICAgICAgICAgICAgW2NsYXNzUHJvcC52YWx1ZV1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChzdHlsZVByb3AgJiYgLy8gdGhlIHN0YXRpYyBzdHlsZSBpcyBjb21waWxlZCBpbnRvIGFuIG9iamVjdCxcclxuICAgICAgICAgIC8vIHNvIHVzZSBgaGFzU3R5bGVCaW5kaW5nYCB0byBlbnN1cmUgdGhhdCBpdCBpcyBhIGR5bmFtaWMgc3R5bGUgYmluZGluZ1xyXG4gICAgICAgICAgKGhhc1N0eWxlQmluZGluZyB8fCBzdHlsZVByb3AudmFsdWUudHlwZSA9PT0gNCAmJiBzdHlsZVByb3AudmFsdWUuY29udGVudC50cmltKClbMF0gPT09IGBbYCB8fCAvLyB2LWJpbmQ6c3R5bGUgYW5kIHN0eWxlIGJvdGggZXhpc3QsXHJcbiAgICAgICAgICAvLyB2LWJpbmQ6c3R5bGUgd2l0aCBzdGF0aWMgbGl0ZXJhbCBvYmplY3RcclxuICAgICAgICAgIHN0eWxlUHJvcC52YWx1ZS50eXBlID09PSAxNykpIHtcclxuICAgICAgICAgICAgc3R5bGVQcm9wLnZhbHVlID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oXHJcbiAgICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoTk9STUFMSVpFX1NUWUxFKSxcclxuICAgICAgICAgICAgICBbc3R5bGVQcm9wLnZhbHVlXVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBwcm9wc0V4cHJlc3Npb24gPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihcclxuICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoTk9STUFMSVpFX1BST1BTKSxcclxuICAgICAgICAgICAgW3Byb3BzRXhwcmVzc2lvbl1cclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDE0OlxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHByb3BzRXhwcmVzc2lvbiA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKFxyXG4gICAgICAgICAgY29udGV4dC5oZWxwZXIoTk9STUFMSVpFX1BST1BTKSxcclxuICAgICAgICAgIFtcclxuICAgICAgICAgICAgY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoR1VBUkRfUkVBQ1RJVkVfUFJPUFMpLCBbXHJcbiAgICAgICAgICAgICAgcHJvcHNFeHByZXNzaW9uXHJcbiAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICBdXHJcbiAgICAgICAgKTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIHByb3BzOiBwcm9wc0V4cHJlc3Npb24sXHJcbiAgICBkaXJlY3RpdmVzOiBydW50aW1lRGlyZWN0aXZlcyxcclxuICAgIHBhdGNoRmxhZyxcclxuICAgIGR5bmFtaWNQcm9wTmFtZXMsXHJcbiAgICBzaG91bGRVc2VCbG9ja1xyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gZGVkdXBlUHJvcGVydGllcyhwcm9wZXJ0aWVzKSB7XHJcbiAgY29uc3Qga25vd25Qcm9wcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XHJcbiAgY29uc3QgZGVkdXBlZCA9IFtdO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3QgcHJvcCA9IHByb3BlcnRpZXNbaV07XHJcbiAgICBpZiAocHJvcC5rZXkudHlwZSA9PT0gOCB8fCAhcHJvcC5rZXkuaXNTdGF0aWMpIHtcclxuICAgICAgZGVkdXBlZC5wdXNoKHByb3ApO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5hbWUgPSBwcm9wLmtleS5jb250ZW50O1xyXG4gICAgY29uc3QgZXhpc3RpbmcgPSBrbm93blByb3BzLmdldChuYW1lKTtcclxuICAgIGlmIChleGlzdGluZykge1xyXG4gICAgICBpZiAobmFtZSA9PT0gXCJzdHlsZVwiIHx8IG5hbWUgPT09IFwiY2xhc3NcIiB8fCBpc09uKG5hbWUpKSB7XHJcbiAgICAgICAgbWVyZ2VBc0FycmF5KGV4aXN0aW5nLCBwcm9wKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAga25vd25Qcm9wcy5zZXQobmFtZSwgcHJvcCk7XHJcbiAgICAgIGRlZHVwZWQucHVzaChwcm9wKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGRlZHVwZWQ7XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VBc0FycmF5KGV4aXN0aW5nLCBpbmNvbWluZykge1xyXG4gIGlmIChleGlzdGluZy52YWx1ZS50eXBlID09PSAxNykge1xyXG4gICAgZXhpc3RpbmcudmFsdWUuZWxlbWVudHMucHVzaChpbmNvbWluZy52YWx1ZSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGV4aXN0aW5nLnZhbHVlID0gY3JlYXRlQXJyYXlFeHByZXNzaW9uKFxyXG4gICAgICBbZXhpc3RpbmcudmFsdWUsIGluY29taW5nLnZhbHVlXSxcclxuICAgICAgZXhpc3RpbmcubG9jXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBidWlsZERpcmVjdGl2ZUFyZ3MoZGlyLCBjb250ZXh0KSB7XHJcbiAgY29uc3QgZGlyQXJncyA9IFtdO1xyXG4gIGNvbnN0IHJ1bnRpbWUgPSBkaXJlY3RpdmVJbXBvcnRNYXAuZ2V0KGRpcik7XHJcbiAgaWYgKHJ1bnRpbWUpIHtcclxuICAgIGRpckFyZ3MucHVzaChjb250ZXh0LmhlbHBlclN0cmluZyhydW50aW1lKSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHtcclxuICAgICAgY29udGV4dC5oZWxwZXIoUkVTT0xWRV9ESVJFQ1RJVkUpO1xyXG4gICAgICBjb250ZXh0LmRpcmVjdGl2ZXMuYWRkKGRpci5uYW1lKTtcclxuICAgICAgZGlyQXJncy5wdXNoKHRvVmFsaWRBc3NldElkKGRpci5uYW1lLCBgZGlyZWN0aXZlYCkpO1xyXG4gICAgfVxyXG4gIH1cclxuICBjb25zdCB7IGxvYyB9ID0gZGlyO1xyXG4gIGlmIChkaXIuZXhwKSBkaXJBcmdzLnB1c2goZGlyLmV4cCk7XHJcbiAgaWYgKGRpci5hcmcpIHtcclxuICAgIGlmICghZGlyLmV4cCkge1xyXG4gICAgICBkaXJBcmdzLnB1c2goYHZvaWQgMGApO1xyXG4gICAgfVxyXG4gICAgZGlyQXJncy5wdXNoKGRpci5hcmcpO1xyXG4gIH1cclxuICBpZiAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycykubGVuZ3RoKSB7XHJcbiAgICBpZiAoIWRpci5hcmcpIHtcclxuICAgICAgaWYgKCFkaXIuZXhwKSB7XHJcbiAgICAgICAgZGlyQXJncy5wdXNoKGB2b2lkIDBgKTtcclxuICAgICAgfVxyXG4gICAgICBkaXJBcmdzLnB1c2goYHZvaWQgMGApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdHJ1ZUV4cHJlc3Npb24gPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGB0cnVlYCwgZmFsc2UsIGxvYyk7XHJcbiAgICBkaXJBcmdzLnB1c2goXHJcbiAgICAgIGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oXHJcbiAgICAgICAgZGlyLm1vZGlmaWVycy5tYXAoXHJcbiAgICAgICAgICAobW9kaWZpZXIpID0+IGNyZWF0ZU9iamVjdFByb3BlcnR5KG1vZGlmaWVyLCB0cnVlRXhwcmVzc2lvbilcclxuICAgICAgICApLFxyXG4gICAgICAgIGxvY1xyXG4gICAgICApXHJcbiAgICApO1xyXG4gIH1cclxuICByZXR1cm4gY3JlYXRlQXJyYXlFeHByZXNzaW9uKGRpckFyZ3MsIGRpci5sb2MpO1xyXG59XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeUR5bmFtaWNQcm9wTmFtZXMocHJvcHMpIHtcclxuICBsZXQgcHJvcHNOYW1lc1N0cmluZyA9IGBbYDtcclxuICBmb3IgKGxldCBpID0gMCwgbCA9IHByb3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgcHJvcHNOYW1lc1N0cmluZyArPSBKU09OLnN0cmluZ2lmeShwcm9wc1tpXSk7XHJcbiAgICBpZiAoaSA8IGwgLSAxKSBwcm9wc05hbWVzU3RyaW5nICs9IFwiLCBcIjtcclxuICB9XHJcbiAgcmV0dXJuIHByb3BzTmFtZXNTdHJpbmcgKyBgXWA7XHJcbn1cclxuZnVuY3Rpb24gaXNDb21wb25lbnRUYWcodGFnKSB7XHJcbiAgcmV0dXJuIHRhZyA9PT0gXCJjb21wb25lbnRcIiB8fCB0YWcgPT09IFwiQ29tcG9uZW50XCI7XHJcbn1cclxuXHJcbmNvbnN0IHRyYW5zZm9ybVNsb3RPdXRsZXQgPSAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gIGlmIChpc1Nsb3RPdXRsZXQobm9kZSkpIHtcclxuICAgIGNvbnN0IHsgY2hpbGRyZW4sIGxvYyB9ID0gbm9kZTtcclxuICAgIGNvbnN0IHsgc2xvdE5hbWUsIHNsb3RQcm9wcyB9ID0gcHJvY2Vzc1Nsb3RPdXRsZXQobm9kZSwgY29udGV4dCk7XHJcbiAgICBjb25zdCBzbG90QXJncyA9IFtcclxuICAgICAgY29udGV4dC5wcmVmaXhJZGVudGlmaWVycyA/IGBfY3R4LiRzbG90c2AgOiBgJHNsb3RzYCxcclxuICAgICAgc2xvdE5hbWUsXHJcbiAgICAgIFwie31cIixcclxuICAgICAgXCJ1bmRlZmluZWRcIixcclxuICAgICAgXCJ0cnVlXCJcclxuICAgIF07XHJcbiAgICBsZXQgZXhwZWN0ZWRMZW4gPSAyO1xyXG4gICAgaWYgKHNsb3RQcm9wcykge1xyXG4gICAgICBzbG90QXJnc1syXSA9IHNsb3RQcm9wcztcclxuICAgICAgZXhwZWN0ZWRMZW4gPSAzO1xyXG4gICAgfVxyXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICBzbG90QXJnc1szXSA9IGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbihbXSwgY2hpbGRyZW4sIGZhbHNlLCBmYWxzZSwgbG9jKTtcclxuICAgICAgZXhwZWN0ZWRMZW4gPSA0O1xyXG4gICAgfVxyXG4gICAgaWYgKGNvbnRleHQuc2NvcGVJZCAmJiAhY29udGV4dC5zbG90dGVkKSB7XHJcbiAgICAgIGV4cGVjdGVkTGVuID0gNTtcclxuICAgIH1cclxuICAgIHNsb3RBcmdzLnNwbGljZShleHBlY3RlZExlbik7XHJcbiAgICBub2RlLmNvZGVnZW5Ob2RlID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oXHJcbiAgICAgIGNvbnRleHQuaGVscGVyKFJFTkRFUl9TTE9UKSxcclxuICAgICAgc2xvdEFyZ3MsXHJcbiAgICAgIGxvY1xyXG4gICAgKTtcclxuICB9XHJcbn07XHJcbmZ1bmN0aW9uIHByb2Nlc3NTbG90T3V0bGV0KG5vZGUsIGNvbnRleHQpIHtcclxuICBsZXQgc2xvdE5hbWUgPSBgXCJkZWZhdWx0XCJgO1xyXG4gIGxldCBzbG90UHJvcHMgPSB2b2lkIDA7XHJcbiAgY29uc3Qgbm9uTmFtZVByb3BzID0gW107XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBwID0gbm9kZS5wcm9wc1tpXTtcclxuICAgIGlmIChwLnR5cGUgPT09IDYpIHtcclxuICAgICAgaWYgKHAudmFsdWUpIHtcclxuICAgICAgICBpZiAocC5uYW1lID09PSBcIm5hbWVcIikge1xyXG4gICAgICAgICAgc2xvdE5hbWUgPSBKU09OLnN0cmluZ2lmeShwLnZhbHVlLmNvbnRlbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBwLm5hbWUgPSBjYW1lbGl6ZShwLm5hbWUpO1xyXG4gICAgICAgICAgbm9uTmFtZVByb3BzLnB1c2gocCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAocC5uYW1lID09PSBcImJpbmRcIiAmJiBpc1N0YXRpY0FyZ09mKHAuYXJnLCBcIm5hbWVcIikpIHtcclxuICAgICAgICBpZiAocC5leHApIHtcclxuICAgICAgICAgIHNsb3ROYW1lID0gcC5leHA7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwLmFyZyAmJiBwLmFyZy50eXBlID09PSA0KSB7XHJcbiAgICAgICAgICBjb25zdCBuYW1lID0gY2FtZWxpemUocC5hcmcuY29udGVudCk7XHJcbiAgICAgICAgICBzbG90TmFtZSA9IHAuZXhwID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihuYW1lLCBmYWxzZSwgcC5hcmcubG9jKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKHAubmFtZSA9PT0gXCJiaW5kXCIgJiYgcC5hcmcgJiYgaXNTdGF0aWNFeHAocC5hcmcpKSB7XHJcbiAgICAgICAgICBwLmFyZy5jb250ZW50ID0gY2FtZWxpemUocC5hcmcuY29udGVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vbk5hbWVQcm9wcy5wdXNoKHApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChub25OYW1lUHJvcHMubGVuZ3RoID4gMCkge1xyXG4gICAgY29uc3QgeyBwcm9wcywgZGlyZWN0aXZlcyB9ID0gYnVpbGRQcm9wcyhcclxuICAgICAgbm9kZSxcclxuICAgICAgY29udGV4dCxcclxuICAgICAgbm9uTmFtZVByb3BzLFxyXG4gICAgICBmYWxzZSxcclxuICAgICAgZmFsc2VcclxuICAgICk7XHJcbiAgICBzbG90UHJvcHMgPSBwcm9wcztcclxuICAgIGlmIChkaXJlY3RpdmVzLmxlbmd0aCkge1xyXG4gICAgICBjb250ZXh0Lm9uRXJyb3IoXHJcbiAgICAgICAgY3JlYXRlQ29tcGlsZXJFcnJvcihcclxuICAgICAgICAgIDM2LFxyXG4gICAgICAgICAgZGlyZWN0aXZlc1swXS5sb2NcclxuICAgICAgICApXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB7XHJcbiAgICBzbG90TmFtZSxcclxuICAgIHNsb3RQcm9wc1xyXG4gIH07XHJcbn1cclxuXHJcbmNvbnN0IHRyYW5zZm9ybU9uID0gKGRpciwgbm9kZSwgY29udGV4dCwgYXVnbWVudG9yKSA9PiB7XHJcbiAgY29uc3QgeyBsb2MsIG1vZGlmaWVycywgYXJnIH0gPSBkaXI7XHJcbiAgaWYgKCFkaXIuZXhwICYmICFtb2RpZmllcnMubGVuZ3RoKSB7XHJcbiAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzNSwgbG9jKSk7XHJcbiAgfVxyXG4gIGxldCBldmVudE5hbWU7XHJcbiAgaWYgKGFyZy50eXBlID09PSA0KSB7XHJcbiAgICBpZiAoYXJnLmlzU3RhdGljKSB7XHJcbiAgICAgIGxldCByYXdOYW1lID0gYXJnLmNvbnRlbnQ7XHJcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHJhd05hbWUuc3RhcnRzV2l0aChcInZub2RlXCIpKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNTEsIGFyZy5sb2MpKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocmF3TmFtZS5zdGFydHNXaXRoKFwidnVlOlwiKSkge1xyXG4gICAgICAgIHJhd05hbWUgPSBgdm5vZGUtJHtyYXdOYW1lLnNsaWNlKDQpfWA7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgZXZlbnRTdHJpbmcgPSBub2RlLnRhZ1R5cGUgIT09IDAgfHwgcmF3TmFtZS5zdGFydHNXaXRoKFwidm5vZGVcIikgfHwgIS9bQS1aXS8udGVzdChyYXdOYW1lKSA/IChcclxuICAgICAgICAvLyBmb3Igbm9uLWVsZW1lbnQgYW5kIHZub2RlIGxpZmVjeWNsZSBldmVudCBsaXN0ZW5lcnMsIGF1dG8gY29udmVydFxyXG4gICAgICAgIC8vIGl0IHRvIGNhbWVsQ2FzZS4gU2VlIGlzc3VlICMyMjQ5XHJcbiAgICAgICAgdG9IYW5kbGVyS2V5KGNhbWVsaXplKHJhd05hbWUpKVxyXG4gICAgICApIDogKFxyXG4gICAgICAgIC8vIHByZXNlcnZlIGNhc2UgZm9yIHBsYWluIGVsZW1lbnQgbGlzdGVuZXJzIHRoYXQgaGF2ZSB1cHBlcmNhc2VcclxuICAgICAgICAvLyBsZXR0ZXJzLCBhcyB0aGVzZSBtYXkgYmUgY3VzdG9tIGVsZW1lbnRzJyBjdXN0b20gZXZlbnRzXHJcbiAgICAgICAgYG9uOiR7cmF3TmFtZX1gXHJcbiAgICAgICk7XHJcbiAgICAgIGV2ZW50TmFtZSA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oZXZlbnRTdHJpbmcsIHRydWUsIGFyZy5sb2MpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZXZlbnROYW1lID0gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtcclxuICAgICAgICBgJHtjb250ZXh0LmhlbHBlclN0cmluZyhUT19IQU5ETEVSX0tFWSl9KGAsXHJcbiAgICAgICAgYXJnLFxyXG4gICAgICAgIGApYFxyXG4gICAgICBdKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgZXZlbnROYW1lID0gYXJnO1xyXG4gICAgZXZlbnROYW1lLmNoaWxkcmVuLnVuc2hpZnQoYCR7Y29udGV4dC5oZWxwZXJTdHJpbmcoVE9fSEFORExFUl9LRVkpfShgKTtcclxuICAgIGV2ZW50TmFtZS5jaGlsZHJlbi5wdXNoKGApYCk7XHJcbiAgfVxyXG4gIGxldCBleHAgPSBkaXIuZXhwO1xyXG4gIGlmIChleHAgJiYgIWV4cC5jb250ZW50LnRyaW0oKSkge1xyXG4gICAgZXhwID0gdm9pZCAwO1xyXG4gIH1cclxuICBsZXQgc2hvdWxkQ2FjaGUgPSBjb250ZXh0LmNhY2hlSGFuZGxlcnMgJiYgIWV4cCAmJiAhY29udGV4dC5pblZPbmNlO1xyXG4gIGlmIChleHApIHtcclxuICAgIGNvbnN0IGlzTWVtYmVyRXhwID0gaXNNZW1iZXJFeHByZXNzaW9uKGV4cCk7XHJcbiAgICBjb25zdCBpc0lubGluZVN0YXRlbWVudCA9ICEoaXNNZW1iZXJFeHAgfHwgaXNGbkV4cHJlc3Npb24oZXhwKSk7XHJcbiAgICBjb25zdCBoYXNNdWx0aXBsZVN0YXRlbWVudHMgPSBleHAuY29udGVudC5pbmNsdWRlcyhgO2ApO1xyXG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdHJ1ZSkge1xyXG4gICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKFxyXG4gICAgICAgIGV4cCxcclxuICAgICAgICBjb250ZXh0LFxyXG4gICAgICAgIGZhbHNlLFxyXG4gICAgICAgIGhhc011bHRpcGxlU3RhdGVtZW50c1xyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzSW5saW5lU3RhdGVtZW50IHx8IHNob3VsZENhY2hlICYmIGlzTWVtYmVyRXhwKSB7XHJcbiAgICAgIGV4cCA9IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbXHJcbiAgICAgICAgYCR7aXNJbmxpbmVTdGF0ZW1lbnQgPyBgJGV2ZW50YCA6IGAke2BgfSguLi5hcmdzKWB9ID0+ICR7aGFzTXVsdGlwbGVTdGF0ZW1lbnRzID8gYHtgIDogYChgfWAsXHJcbiAgICAgICAgZXhwLFxyXG4gICAgICAgIGhhc011bHRpcGxlU3RhdGVtZW50cyA/IGB9YCA6IGApYFxyXG4gICAgICBdKTtcclxuICAgIH1cclxuICB9XHJcbiAgbGV0IHJldCA9IHtcclxuICAgIHByb3BzOiBbXHJcbiAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KFxyXG4gICAgICAgIGV2ZW50TmFtZSxcclxuICAgICAgICBleHAgfHwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgKCkgPT4ge31gLCBmYWxzZSwgbG9jKVxyXG4gICAgICApXHJcbiAgICBdXHJcbiAgfTtcclxuICBpZiAoYXVnbWVudG9yKSB7XHJcbiAgICByZXQgPSBhdWdtZW50b3IocmV0KTtcclxuICB9XHJcbiAgaWYgKHNob3VsZENhY2hlKSB7XHJcbiAgICByZXQucHJvcHNbMF0udmFsdWUgPSBjb250ZXh0LmNhY2hlKHJldC5wcm9wc1swXS52YWx1ZSk7XHJcbiAgfVxyXG4gIHJldC5wcm9wcy5mb3JFYWNoKChwKSA9PiBwLmtleS5pc0hhbmRsZXJLZXkgPSB0cnVlKTtcclxuICByZXR1cm4gcmV0O1xyXG59O1xyXG5cclxuY29uc3QgdHJhbnNmb3JtVGV4dCA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgaWYgKG5vZGUudHlwZSA9PT0gMCB8fCBub2RlLnR5cGUgPT09IDEgfHwgbm9kZS50eXBlID09PSAxMSB8fCBub2RlLnR5cGUgPT09IDEwKSB7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XHJcbiAgICAgIGxldCBjdXJyZW50Q29udGFpbmVyID0gdm9pZCAwO1xyXG4gICAgICBsZXQgaGFzVGV4dCA9IGZhbHNlO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICBpZiAoaXNUZXh0JDEoY2hpbGQpKSB7XHJcbiAgICAgICAgICBoYXNUZXh0ID0gdHJ1ZTtcclxuICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBjaGlsZHJlbltqXTtcclxuICAgICAgICAgICAgaWYgKGlzVGV4dCQxKG5leHQpKSB7XHJcbiAgICAgICAgICAgICAgaWYgKCFjdXJyZW50Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyID0gY2hpbGRyZW5baV0gPSBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oXHJcbiAgICAgICAgICAgICAgICAgIFtjaGlsZF0sXHJcbiAgICAgICAgICAgICAgICAgIGNoaWxkLmxvY1xyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgY3VycmVudENvbnRhaW5lci5jaGlsZHJlbi5wdXNoKGAgKyBgLCBuZXh0KTtcclxuICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaiwgMSk7XHJcbiAgICAgICAgICAgICAgai0tO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXIgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFoYXNUZXh0IHx8IC8vIGlmIHRoaXMgaXMgYSBwbGFpbiBlbGVtZW50IHdpdGggYSBzaW5nbGUgdGV4dCBjaGlsZCwgbGVhdmUgaXRcclxuICAgICAgLy8gYXMtaXMgc2luY2UgdGhlIHJ1bnRpbWUgaGFzIGRlZGljYXRlZCBmYXN0IHBhdGggZm9yIHRoaXMgYnkgZGlyZWN0bHlcclxuICAgICAgLy8gc2V0dGluZyB0ZXh0Q29udGVudCBvZiB0aGUgZWxlbWVudC5cclxuICAgICAgLy8gZm9yIGNvbXBvbmVudCByb290IGl0J3MgYWx3YXlzIG5vcm1hbGl6ZWQgYW55d2F5LlxyXG4gICAgICBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgKG5vZGUudHlwZSA9PT0gMCB8fCBub2RlLnR5cGUgPT09IDEgJiYgbm9kZS50YWdUeXBlID09PSAwICYmIC8vICMzNzU2XHJcbiAgICAgIC8vIGN1c3RvbSBkaXJlY3RpdmVzIGNhbiBwb3RlbnRpYWxseSBhZGQgRE9NIGVsZW1lbnRzIGFyYml0cmFyaWx5LFxyXG4gICAgICAvLyB3ZSBuZWVkIHRvIGF2b2lkIHNldHRpbmcgdGV4dENvbnRlbnQgb2YgdGhlIGVsZW1lbnQgYXQgcnVudGltZVxyXG4gICAgICAvLyB0byBhdm9pZCBhY2NpZGVudGFsbHkgb3ZlcndyaXRpbmcgdGhlIERPTSBlbGVtZW50cyBhZGRlZFxyXG4gICAgICAvLyBieSB0aGUgdXNlciB0aHJvdWdoIGN1c3RvbSBkaXJlY3RpdmVzLlxyXG4gICAgICAhbm9kZS5wcm9wcy5maW5kKFxyXG4gICAgICAgIChwKSA9PiBwLnR5cGUgPT09IDcgJiYgIWNvbnRleHQuZGlyZWN0aXZlVHJhbnNmb3Jtc1twLm5hbWVdXHJcbiAgICAgICkgJiYgLy8gaW4gY29tcGF0IG1vZGUsIDx0ZW1wbGF0ZT4gdGFncyB3aXRoIG5vIHNwZWNpYWwgZGlyZWN0aXZlc1xyXG4gICAgICAvLyB3aWxsIGJlIHJlbmRlcmVkIGFzIGEgZnJhZ21lbnQgc28gaXRzIGNoaWxkcmVuIG11c3QgYmVcclxuICAgICAgLy8gY29udmVydGVkIGludG8gdm5vZGVzLlxyXG4gICAgICAhKG5vZGUudGFnID09PSBcInRlbXBsYXRlXCIpKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICBpZiAoaXNUZXh0JDEoY2hpbGQpIHx8IGNoaWxkLnR5cGUgPT09IDgpIHtcclxuICAgICAgICAgIGNvbnN0IGNhbGxBcmdzID0gW107XHJcbiAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gMiB8fCBjaGlsZC5jb250ZW50ICE9PSBcIiBcIikge1xyXG4gICAgICAgICAgICBjYWxsQXJncy5wdXNoKGNoaWxkKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICghY29udGV4dC5zc3IgJiYgZ2V0Q29uc3RhbnRUeXBlKGNoaWxkLCBjb250ZXh0KSA9PT0gMCkge1xyXG4gICAgICAgICAgICBjYWxsQXJncy5wdXNoKFxyXG4gICAgICAgICAgICAgIDEgKyAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGAgLyogJHtQYXRjaEZsYWdOYW1lc1sxXX0gKi9gIDogYGApXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjaGlsZHJlbltpXSA9IHtcclxuICAgICAgICAgICAgdHlwZTogMTIsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNoaWxkLFxyXG4gICAgICAgICAgICBsb2M6IGNoaWxkLmxvYyxcclxuICAgICAgICAgICAgY29kZWdlbk5vZGU6IGNyZWF0ZUNhbGxFeHByZXNzaW9uKFxyXG4gICAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKENSRUFURV9URVhUKSxcclxuICAgICAgICAgICAgICBjYWxsQXJnc1xyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBzZWVuJDEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcclxuY29uc3QgdHJhbnNmb3JtT25jZSA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSAmJiBmaW5kRGlyKG5vZGUsIFwib25jZVwiLCB0cnVlKSkge1xyXG4gICAgaWYgKHNlZW4kMS5oYXMobm9kZSkgfHwgY29udGV4dC5pblZPbmNlIHx8IGNvbnRleHQuaW5TU1IpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgc2VlbiQxLmFkZChub2RlKTtcclxuICAgIGNvbnRleHQuaW5WT25jZSA9IHRydWU7XHJcbiAgICBjb250ZXh0LmhlbHBlcihTRVRfQkxPQ0tfVFJBQ0tJTkcpO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgY29udGV4dC5pblZPbmNlID0gZmFsc2U7XHJcbiAgICAgIGNvbnN0IGN1ciA9IGNvbnRleHQuY3VycmVudE5vZGU7XHJcbiAgICAgIGlmIChjdXIuY29kZWdlbk5vZGUpIHtcclxuICAgICAgICBjdXIuY29kZWdlbk5vZGUgPSBjb250ZXh0LmNhY2hlKFxyXG4gICAgICAgICAgY3VyLmNvZGVnZW5Ob2RlLFxyXG4gICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgIHRydWVcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IHRyYW5zZm9ybU1vZGVsID0gKGRpciwgbm9kZSwgY29udGV4dCkgPT4ge1xyXG4gIGNvbnN0IHsgZXhwLCBhcmcgfSA9IGRpcjtcclxuICBpZiAoIWV4cCkge1xyXG4gICAgY29udGV4dC5vbkVycm9yKFxyXG4gICAgICBjcmVhdGVDb21waWxlckVycm9yKDQxLCBkaXIubG9jKVxyXG4gICAgKTtcclxuICAgIHJldHVybiBjcmVhdGVUcmFuc2Zvcm1Qcm9wcygpO1xyXG4gIH1cclxuICBjb25zdCByYXdFeHAgPSBleHAubG9jLnNvdXJjZS50cmltKCk7XHJcbiAgY29uc3QgZXhwU3RyaW5nID0gZXhwLnR5cGUgPT09IDQgPyBleHAuY29udGVudCA6IHJhd0V4cDtcclxuICBjb25zdCBiaW5kaW5nVHlwZSA9IGNvbnRleHQuYmluZGluZ01ldGFkYXRhW3Jhd0V4cF07XHJcbiAgaWYgKGJpbmRpbmdUeXBlID09PSBcInByb3BzXCIgfHwgYmluZGluZ1R5cGUgPT09IFwicHJvcHMtYWxpYXNlZFwiKSB7XHJcbiAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0NCwgZXhwLmxvYykpO1xyXG4gICAgcmV0dXJuIGNyZWF0ZVRyYW5zZm9ybVByb3BzKCk7XHJcbiAgfVxyXG4gIGNvbnN0IG1heWJlUmVmID0gZmFsc2U7XHJcbiAgaWYgKCFleHBTdHJpbmcudHJpbSgpIHx8ICFpc01lbWJlckV4cHJlc3Npb24oZXhwKSAmJiAhbWF5YmVSZWYpIHtcclxuICAgIGNvbnRleHQub25FcnJvcihcclxuICAgICAgY3JlYXRlQ29tcGlsZXJFcnJvcig0MiwgZXhwLmxvYylcclxuICAgICk7XHJcbiAgICByZXR1cm4gY3JlYXRlVHJhbnNmb3JtUHJvcHMoKTtcclxuICB9XHJcbiAgY29uc3QgcHJvcE5hbWUgPSBhcmcgPyBhcmcgOiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKFwibW9kZWxWYWx1ZVwiLCB0cnVlKTtcclxuICBjb25zdCBldmVudE5hbWUgPSBhcmcgPyBpc1N0YXRpY0V4cChhcmcpID8gYG9uVXBkYXRlOiR7Y2FtZWxpemUoYXJnLmNvbnRlbnQpfWAgOiBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oWydcIm9uVXBkYXRlOlwiICsgJywgYXJnXSkgOiBgb25VcGRhdGU6bW9kZWxWYWx1ZWA7XHJcbiAgbGV0IGFzc2lnbm1lbnRFeHA7XHJcbiAgY29uc3QgZXZlbnRBcmcgPSBjb250ZXh0LmlzVFMgPyBgKCRldmVudDogYW55KWAgOiBgJGV2ZW50YDtcclxuICB7XHJcbiAgICBhc3NpZ25tZW50RXhwID0gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtcclxuICAgICAgYCR7ZXZlbnRBcmd9ID0+ICgoYCxcclxuICAgICAgZXhwLFxyXG4gICAgICBgKSA9ICRldmVudClgXHJcbiAgICBdKTtcclxuICB9XHJcbiAgY29uc3QgcHJvcHMgPSBbXHJcbiAgICAvLyBtb2RlbFZhbHVlOiBmb29cclxuICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KHByb3BOYW1lLCBkaXIuZXhwKSxcclxuICAgIC8vIFwib25VcGRhdGU6bW9kZWxWYWx1ZVwiOiAkZXZlbnQgPT4gKGZvbyA9ICRldmVudClcclxuICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGV2ZW50TmFtZSwgYXNzaWdubWVudEV4cClcclxuICBdO1xyXG4gIGlmIChkaXIubW9kaWZpZXJzLmxlbmd0aCAmJiBub2RlLnRhZ1R5cGUgPT09IDEpIHtcclxuICAgIGNvbnN0IG1vZGlmaWVycyA9IGRpci5tb2RpZmllcnMubWFwKChtKSA9PiBtLmNvbnRlbnQpLm1hcCgobSkgPT4gKGlzU2ltcGxlSWRlbnRpZmllcihtKSA/IG0gOiBKU09OLnN0cmluZ2lmeShtKSkgKyBgOiB0cnVlYCkuam9pbihgLCBgKTtcclxuICAgIGNvbnN0IG1vZGlmaWVyc0tleSA9IGFyZyA/IGlzU3RhdGljRXhwKGFyZykgPyBgJHthcmcuY29udGVudH1Nb2RpZmllcnNgIDogY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFthcmcsICcgKyBcIk1vZGlmaWVyc1wiJ10pIDogYG1vZGVsTW9kaWZpZXJzYDtcclxuICAgIHByb3BzLnB1c2goXHJcbiAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KFxyXG4gICAgICAgIG1vZGlmaWVyc0tleSxcclxuICAgICAgICBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKFxyXG4gICAgICAgICAgYHsgJHttb2RpZmllcnN9IH1gLFxyXG4gICAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgICBkaXIubG9jLFxyXG4gICAgICAgICAgMlxyXG4gICAgICAgIClcclxuICAgICAgKVxyXG4gICAgKTtcclxuICB9XHJcbiAgcmV0dXJuIGNyZWF0ZVRyYW5zZm9ybVByb3BzKHByb3BzKTtcclxufTtcclxuZnVuY3Rpb24gY3JlYXRlVHJhbnNmb3JtUHJvcHMocHJvcHMgPSBbXSkge1xyXG4gIHJldHVybiB7IHByb3BzIH07XHJcbn1cclxuXHJcbmNvbnN0IHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XHJcbmNvbnN0IHRyYW5zZm9ybUZpbHRlciA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgaWYgKCFpc0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9GSUxURVJTXCIsIGNvbnRleHQpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmIChub2RlLnR5cGUgPT09IDUpIHtcclxuICAgIHJld3JpdGVGaWx0ZXIobm9kZS5jb250ZW50LCBjb250ZXh0KTtcclxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xyXG4gICAgbm9kZS5wcm9wcy5mb3JFYWNoKChwcm9wKSA9PiB7XHJcbiAgICAgIGlmIChwcm9wLnR5cGUgPT09IDcgJiYgcHJvcC5uYW1lICE9PSBcImZvclwiICYmIHByb3AuZXhwKSB7XHJcbiAgICAgICAgcmV3cml0ZUZpbHRlcihwcm9wLmV4cCwgY29udGV4dCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufTtcclxuZnVuY3Rpb24gcmV3cml0ZUZpbHRlcihub2RlLCBjb250ZXh0KSB7XHJcbiAgaWYgKG5vZGUudHlwZSA9PT0gNCkge1xyXG4gICAgcGFyc2VGaWx0ZXIobm9kZSwgY29udGV4dCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XHJcbiAgICAgIGlmICh0eXBlb2YgY2hpbGQgIT09IFwib2JqZWN0XCIpIGNvbnRpbnVlO1xyXG4gICAgICBpZiAoY2hpbGQudHlwZSA9PT0gNCkge1xyXG4gICAgICAgIHBhcnNlRmlsdGVyKGNoaWxkLCBjb250ZXh0KTtcclxuICAgICAgfSBlbHNlIGlmIChjaGlsZC50eXBlID09PSA4KSB7XHJcbiAgICAgICAgcmV3cml0ZUZpbHRlcihub2RlLCBjb250ZXh0KTtcclxuICAgICAgfSBlbHNlIGlmIChjaGlsZC50eXBlID09PSA1KSB7XHJcbiAgICAgICAgcmV3cml0ZUZpbHRlcihjaGlsZC5jb250ZW50LCBjb250ZXh0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBwYXJzZUZpbHRlcihub2RlLCBjb250ZXh0KSB7XHJcbiAgY29uc3QgZXhwID0gbm9kZS5jb250ZW50O1xyXG4gIGxldCBpblNpbmdsZSA9IGZhbHNlO1xyXG4gIGxldCBpbkRvdWJsZSA9IGZhbHNlO1xyXG4gIGxldCBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XHJcbiAgbGV0IGluUmVnZXggPSBmYWxzZTtcclxuICBsZXQgY3VybHkgPSAwO1xyXG4gIGxldCBzcXVhcmUgPSAwO1xyXG4gIGxldCBwYXJlbiA9IDA7XHJcbiAgbGV0IGxhc3RGaWx0ZXJJbmRleCA9IDA7XHJcbiAgbGV0IGMsIHByZXYsIGksIGV4cHJlc3Npb24sIGZpbHRlcnMgPSBbXTtcclxuICBmb3IgKGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBwcmV2ID0gYztcclxuICAgIGMgPSBleHAuY2hhckNvZGVBdChpKTtcclxuICAgIGlmIChpblNpbmdsZSkge1xyXG4gICAgICBpZiAoYyA9PT0gMzkgJiYgcHJldiAhPT0gOTIpIGluU2luZ2xlID0gZmFsc2U7XHJcbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XHJcbiAgICAgIGlmIChjID09PSAzNCAmJiBwcmV2ICE9PSA5MikgaW5Eb3VibGUgPSBmYWxzZTtcclxuICAgIH0gZWxzZSBpZiAoaW5UZW1wbGF0ZVN0cmluZykge1xyXG4gICAgICBpZiAoYyA9PT0gOTYgJiYgcHJldiAhPT0gOTIpIGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcclxuICAgIH0gZWxzZSBpZiAoaW5SZWdleCkge1xyXG4gICAgICBpZiAoYyA9PT0gNDcgJiYgcHJldiAhPT0gOTIpIGluUmVnZXggPSBmYWxzZTtcclxuICAgIH0gZWxzZSBpZiAoYyA9PT0gMTI0ICYmIC8vIHBpcGVcclxuICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMTI0ICYmIGV4cC5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gMTI0ICYmICFjdXJseSAmJiAhc3F1YXJlICYmICFwYXJlbikge1xyXG4gICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XHJcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcHVzaEZpbHRlcigpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzd2l0Y2ggKGMpIHtcclxuICAgICAgICBjYXNlIDM0OlxyXG4gICAgICAgICAgaW5Eb3VibGUgPSB0cnVlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gXCJcclxuICAgICAgICBjYXNlIDM5OlxyXG4gICAgICAgICAgaW5TaW5nbGUgPSB0cnVlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gJ1xyXG4gICAgICAgIGNhc2UgOTY6XHJcbiAgICAgICAgICBpblRlbXBsYXRlU3RyaW5nID0gdHJ1ZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIC8vIGBcclxuICAgICAgICBjYXNlIDQwOlxyXG4gICAgICAgICAgcGFyZW4rKztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIC8vIChcclxuICAgICAgICBjYXNlIDQxOlxyXG4gICAgICAgICAgcGFyZW4tLTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIC8vIClcclxuICAgICAgICBjYXNlIDkxOlxyXG4gICAgICAgICAgc3F1YXJlKys7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICAvLyBbXHJcbiAgICAgICAgY2FzZSA5MzpcclxuICAgICAgICAgIHNxdWFyZS0tO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gXVxyXG4gICAgICAgIGNhc2UgMTIzOlxyXG4gICAgICAgICAgY3VybHkrKztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIC8vIHtcclxuICAgICAgICBjYXNlIDEyNTpcclxuICAgICAgICAgIGN1cmx5LS07XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBpZiAoYyA9PT0gNDcpIHtcclxuICAgICAgICBsZXQgaiA9IGkgLSAxO1xyXG4gICAgICAgIGxldCBwO1xyXG4gICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xyXG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XHJcbiAgICAgICAgICBpZiAocCAhPT0gXCIgXCIpIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXAgfHwgIXZhbGlkRGl2aXNpb25DaGFyUkUudGVzdChwKSkge1xyXG4gICAgICAgICAgaW5SZWdleCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChleHByZXNzaW9uID09PSB2b2lkIDApIHtcclxuICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xyXG4gIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XHJcbiAgICBwdXNoRmlsdGVyKCk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHB1c2hGaWx0ZXIoKSB7XHJcbiAgICBmaWx0ZXJzLnB1c2goZXhwLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpKTtcclxuICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xyXG4gIH1cclxuICBpZiAoZmlsdGVycy5sZW5ndGgpIHtcclxuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybkRlcHJlY2F0aW9uKFxyXG4gICAgICBcIkNPTVBJTEVSX0ZJTFRFUlNcIixcclxuICAgICAgY29udGV4dCxcclxuICAgICAgbm9kZS5sb2NcclxuICAgICk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBleHByZXNzaW9uID0gd3JhcEZpbHRlcihleHByZXNzaW9uLCBmaWx0ZXJzW2ldLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIG5vZGUuY29udGVudCA9IGV4cHJlc3Npb247XHJcbiAgICBub2RlLmFzdCA9IHZvaWQgMDtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gd3JhcEZpbHRlcihleHAsIGZpbHRlciwgY29udGV4dCkge1xyXG4gIGNvbnRleHQuaGVscGVyKFJFU09MVkVfRklMVEVSKTtcclxuICBjb25zdCBpID0gZmlsdGVyLmluZGV4T2YoXCIoXCIpO1xyXG4gIGlmIChpIDwgMCkge1xyXG4gICAgY29udGV4dC5maWx0ZXJzLmFkZChmaWx0ZXIpO1xyXG4gICAgcmV0dXJuIGAke3RvVmFsaWRBc3NldElkKGZpbHRlciwgXCJmaWx0ZXJcIil9KCR7ZXhwfSlgO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdCBuYW1lID0gZmlsdGVyLnNsaWNlKDAsIGkpO1xyXG4gICAgY29uc3QgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XHJcbiAgICBjb250ZXh0LmZpbHRlcnMuYWRkKG5hbWUpO1xyXG4gICAgcmV0dXJuIGAke3RvVmFsaWRBc3NldElkKG5hbWUsIFwiZmlsdGVyXCIpfSgke2V4cH0ke2FyZ3MgIT09IFwiKVwiID8gXCIsXCIgKyBhcmdzIDogYXJnc31gO1xyXG4gIH1cclxufVxyXG5cclxuY29uc3Qgc2VlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xyXG5jb25zdCB0cmFuc2Zvcm1NZW1vID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICBpZiAobm9kZS50eXBlID09PSAxKSB7XHJcbiAgICBjb25zdCBkaXIgPSBmaW5kRGlyKG5vZGUsIFwibWVtb1wiKTtcclxuICAgIGlmICghZGlyIHx8IHNlZW4uaGFzKG5vZGUpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHNlZW4uYWRkKG5vZGUpO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgY29uc3QgY29kZWdlbk5vZGUgPSBub2RlLmNvZGVnZW5Ob2RlIHx8IGNvbnRleHQuY3VycmVudE5vZGUuY29kZWdlbk5vZGU7XHJcbiAgICAgIGlmIChjb2RlZ2VuTm9kZSAmJiBjb2RlZ2VuTm9kZS50eXBlID09PSAxMykge1xyXG4gICAgICAgIGlmIChub2RlLnRhZ1R5cGUgIT09IDEpIHtcclxuICAgICAgICAgIGNvbnZlcnRUb0Jsb2NrKGNvZGVnZW5Ob2RlLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZS5jb2RlZ2VuTm9kZSA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFdJVEhfTUVNTyksIFtcclxuICAgICAgICAgIGRpci5leHAsXHJcbiAgICAgICAgICBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24odm9pZCAwLCBjb2RlZ2VuTm9kZSksXHJcbiAgICAgICAgICBgX2NhY2hlYCxcclxuICAgICAgICAgIFN0cmluZyhjb250ZXh0LmNhY2hlZC5sZW5ndGgpXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgY29udGV4dC5jYWNoZWQucHVzaChudWxsKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBnZXRCYXNlVHJhbnNmb3JtUHJlc2V0KHByZWZpeElkZW50aWZpZXJzKSB7XHJcbiAgcmV0dXJuIFtcclxuICAgIFtcclxuICAgICAgdHJhbnNmb3JtT25jZSxcclxuICAgICAgdHJhbnNmb3JtSWYsXHJcbiAgICAgIHRyYW5zZm9ybU1lbW8sXHJcbiAgICAgIHRyYW5zZm9ybUZvcixcclxuICAgICAgLi4uW3RyYW5zZm9ybUZpbHRlcl0gLFxyXG4gICAgICAuLi4hIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gW3RyYW5zZm9ybUV4cHJlc3Npb25dIDogW10sXHJcbiAgICAgIHRyYW5zZm9ybVNsb3RPdXRsZXQsXHJcbiAgICAgIHRyYW5zZm9ybUVsZW1lbnQsXHJcbiAgICAgIHRyYWNrU2xvdFNjb3BlcyxcclxuICAgICAgdHJhbnNmb3JtVGV4dFxyXG4gICAgXSxcclxuICAgIHtcclxuICAgICAgb246IHRyYW5zZm9ybU9uLFxyXG4gICAgICBiaW5kOiB0cmFuc2Zvcm1CaW5kLFxyXG4gICAgICBtb2RlbDogdHJhbnNmb3JtTW9kZWxcclxuICAgIH1cclxuICBdO1xyXG59XHJcbmZ1bmN0aW9uIGJhc2VDb21waWxlKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgY29uc3Qgb25FcnJvciA9IG9wdGlvbnMub25FcnJvciB8fCBkZWZhdWx0T25FcnJvcjtcclxuICBjb25zdCBpc01vZHVsZU1vZGUgPSBvcHRpb25zLm1vZGUgPT09IFwibW9kdWxlXCI7XHJcbiAge1xyXG4gICAgaWYgKG9wdGlvbnMucHJlZml4SWRlbnRpZmllcnMgPT09IHRydWUpIHtcclxuICAgICAgb25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQ3KSk7XHJcbiAgICB9IGVsc2UgaWYgKGlzTW9kdWxlTW9kZSkge1xyXG4gICAgICBvbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDgpKTtcclxuICAgIH1cclxuICB9XHJcbiAgY29uc3QgcHJlZml4SWRlbnRpZmllcnMgPSBmYWxzZTtcclxuICBpZiAob3B0aW9ucy5jYWNoZUhhbmRsZXJzKSB7XHJcbiAgICBvbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDkpKTtcclxuICB9XHJcbiAgaWYgKG9wdGlvbnMuc2NvcGVJZCAmJiAhaXNNb2R1bGVNb2RlKSB7XHJcbiAgICBvbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNTApKTtcclxuICB9XHJcbiAgY29uc3QgcmVzb2x2ZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zLCB7XHJcbiAgICBwcmVmaXhJZGVudGlmaWVyc1xyXG4gIH0pO1xyXG4gIGNvbnN0IGFzdCA9IGlzU3RyaW5nKHNvdXJjZSkgPyBiYXNlUGFyc2Uoc291cmNlLCByZXNvbHZlZE9wdGlvbnMpIDogc291cmNlO1xyXG4gIGNvbnN0IFtub2RlVHJhbnNmb3JtcywgZGlyZWN0aXZlVHJhbnNmb3Jtc10gPSBnZXRCYXNlVHJhbnNmb3JtUHJlc2V0KCk7XHJcbiAgdHJhbnNmb3JtKFxyXG4gICAgYXN0LFxyXG4gICAgZXh0ZW5kKHt9LCByZXNvbHZlZE9wdGlvbnMsIHtcclxuICAgICAgbm9kZVRyYW5zZm9ybXM6IFtcclxuICAgICAgICAuLi5ub2RlVHJhbnNmb3JtcyxcclxuICAgICAgICAuLi5vcHRpb25zLm5vZGVUcmFuc2Zvcm1zIHx8IFtdXHJcbiAgICAgICAgLy8gdXNlciB0cmFuc2Zvcm1zXHJcbiAgICAgIF0sXHJcbiAgICAgIGRpcmVjdGl2ZVRyYW5zZm9ybXM6IGV4dGVuZChcclxuICAgICAgICB7fSxcclxuICAgICAgICBkaXJlY3RpdmVUcmFuc2Zvcm1zLFxyXG4gICAgICAgIG9wdGlvbnMuZGlyZWN0aXZlVHJhbnNmb3JtcyB8fCB7fVxyXG4gICAgICAgIC8vIHVzZXIgdHJhbnNmb3Jtc1xyXG4gICAgICApXHJcbiAgICB9KVxyXG4gICk7XHJcbiAgcmV0dXJuIGdlbmVyYXRlKGFzdCwgcmVzb2x2ZWRPcHRpb25zKTtcclxufVxyXG5cclxuY29uc3QgQmluZGluZ1R5cGVzID0ge1xyXG4gIFwiREFUQVwiOiBcImRhdGFcIixcclxuICBcIlBST1BTXCI6IFwicHJvcHNcIixcclxuICBcIlBST1BTX0FMSUFTRURcIjogXCJwcm9wcy1hbGlhc2VkXCIsXHJcbiAgXCJTRVRVUF9MRVRcIjogXCJzZXR1cC1sZXRcIixcclxuICBcIlNFVFVQX0NPTlNUXCI6IFwic2V0dXAtY29uc3RcIixcclxuICBcIlNFVFVQX1JFQUNUSVZFX0NPTlNUXCI6IFwic2V0dXAtcmVhY3RpdmUtY29uc3RcIixcclxuICBcIlNFVFVQX01BWUJFX1JFRlwiOiBcInNldHVwLW1heWJlLXJlZlwiLFxyXG4gIFwiU0VUVVBfUkVGXCI6IFwic2V0dXAtcmVmXCIsXHJcbiAgXCJPUFRJT05TXCI6IFwib3B0aW9uc1wiLFxyXG4gIFwiTElURVJBTF9DT05TVFwiOiBcImxpdGVyYWwtY29uc3RcIlxyXG59O1xyXG5cclxuY29uc3Qgbm9vcERpcmVjdGl2ZVRyYW5zZm9ybSA9ICgpID0+ICh7IHByb3BzOiBbXSB9KTtcclxuXHJcbmV4cG9ydCB7IEJBU0VfVFJBTlNJVElPTiwgQmluZGluZ1R5cGVzLCBDQU1FTElaRSwgQ0FQSVRBTElaRSwgQ1JFQVRFX0JMT0NLLCBDUkVBVEVfQ09NTUVOVCwgQ1JFQVRFX0VMRU1FTlRfQkxPQ0ssIENSRUFURV9FTEVNRU5UX1ZOT0RFLCBDUkVBVEVfU0xPVFMsIENSRUFURV9TVEFUSUMsIENSRUFURV9URVhULCBDUkVBVEVfVk5PREUsIENvbXBpbGVyRGVwcmVjYXRpb25UeXBlcywgQ29uc3RhbnRUeXBlcywgRWxlbWVudFR5cGVzLCBFcnJvckNvZGVzLCBGUkFHTUVOVCwgR1VBUkRfUkVBQ1RJVkVfUFJPUFMsIElTX01FTU9fU0FNRSwgSVNfUkVGLCBLRUVQX0FMSVZFLCBNRVJHRV9QUk9QUywgTk9STUFMSVpFX0NMQVNTLCBOT1JNQUxJWkVfUFJPUFMsIE5PUk1BTElaRV9TVFlMRSwgTmFtZXNwYWNlcywgTm9kZVR5cGVzLCBPUEVOX0JMT0NLLCBQT1BfU0NPUEVfSUQsIFBVU0hfU0NPUEVfSUQsIFJFTkRFUl9MSVNULCBSRU5ERVJfU0xPVCwgUkVTT0xWRV9DT01QT05FTlQsIFJFU09MVkVfRElSRUNUSVZFLCBSRVNPTFZFX0RZTkFNSUNfQ09NUE9ORU5ULCBSRVNPTFZFX0ZJTFRFUiwgU0VUX0JMT0NLX1RSQUNLSU5HLCBTVVNQRU5TRSwgVEVMRVBPUlQsIFRPX0RJU1BMQVlfU1RSSU5HLCBUT19IQU5ETEVSUywgVE9fSEFORExFUl9LRVksIFRTX05PREVfVFlQRVMsIFVOUkVGLCBXSVRIX0NUWCwgV0lUSF9ESVJFQ1RJVkVTLCBXSVRIX01FTU8sIGFkdmFuY2VQb3NpdGlvbldpdGhDbG9uZSwgYWR2YW5jZVBvc2l0aW9uV2l0aE11dGF0aW9uLCBhc3NlcnQsIGJhc2VDb21waWxlLCBiYXNlUGFyc2UsIGJ1aWxkRGlyZWN0aXZlQXJncywgYnVpbGRQcm9wcywgYnVpbGRTbG90cywgY2hlY2tDb21wYXRFbmFibGVkLCBjb252ZXJ0VG9CbG9jaywgY3JlYXRlQXJyYXlFeHByZXNzaW9uLCBjcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbiwgY3JlYXRlQmxvY2tTdGF0ZW1lbnQsIGNyZWF0ZUNhY2hlRXhwcmVzc2lvbiwgY3JlYXRlQ2FsbEV4cHJlc3Npb24sIGNyZWF0ZUNvbXBpbGVyRXJyb3IsIGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbiwgY3JlYXRlQ29uZGl0aW9uYWxFeHByZXNzaW9uLCBjcmVhdGVGb3JMb29wUGFyYW1zLCBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24sIGNyZWF0ZUlmU3RhdGVtZW50LCBjcmVhdGVJbnRlcnBvbGF0aW9uLCBjcmVhdGVPYmplY3RFeHByZXNzaW9uLCBjcmVhdGVPYmplY3RQcm9wZXJ0eSwgY3JlYXRlUmV0dXJuU3RhdGVtZW50LCBjcmVhdGVSb290LCBjcmVhdGVTZXF1ZW5jZUV4cHJlc3Npb24sIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24sIGNyZWF0ZVN0cnVjdHVyYWxEaXJlY3RpdmVUcmFuc2Zvcm0sIGNyZWF0ZVRlbXBsYXRlTGl0ZXJhbCwgY3JlYXRlVHJhbnNmb3JtQ29udGV4dCwgY3JlYXRlVk5vZGVDYWxsLCBlcnJvck1lc3NhZ2VzLCBleHRyYWN0SWRlbnRpZmllcnMsIGZpbmREaXIsIGZpbmRQcm9wLCBmb3JBbGlhc1JFLCBnZW5lcmF0ZSwgZ2V0QmFzZVRyYW5zZm9ybVByZXNldCwgZ2V0Q29uc3RhbnRUeXBlLCBnZXRNZW1vZWRWTm9kZUNhbGwsIGdldFZOb2RlQmxvY2tIZWxwZXIsIGdldFZOb2RlSGVscGVyLCBoYXNEeW5hbWljS2V5VkJpbmQsIGhhc1Njb3BlUmVmLCBoZWxwZXJOYW1lTWFwLCBpbmplY3RQcm9wLCBpc0NvcmVDb21wb25lbnQsIGlzRm5FeHByZXNzaW9uLCBpc0ZuRXhwcmVzc2lvbkJyb3dzZXIsIGlzRm5FeHByZXNzaW9uTm9kZSwgaXNGdW5jdGlvblR5cGUsIGlzSW5EZXN0cnVjdHVyZUFzc2lnbm1lbnQsIGlzSW5OZXdFeHByZXNzaW9uLCBpc01lbWJlckV4cHJlc3Npb24sIGlzTWVtYmVyRXhwcmVzc2lvbkJyb3dzZXIsIGlzTWVtYmVyRXhwcmVzc2lvbk5vZGUsIGlzUmVmZXJlbmNlZElkZW50aWZpZXIsIGlzU2ltcGxlSWRlbnRpZmllciwgaXNTbG90T3V0bGV0LCBpc1N0YXRpY0FyZ09mLCBpc1N0YXRpY0V4cCwgaXNTdGF0aWNQcm9wZXJ0eSwgaXNTdGF0aWNQcm9wZXJ0eUtleSwgaXNUZW1wbGF0ZU5vZGUsIGlzVGV4dCQxIGFzIGlzVGV4dCwgaXNWU2xvdCwgbG9jU3R1Yiwgbm9vcERpcmVjdGl2ZVRyYW5zZm9ybSwgcHJvY2Vzc0V4cHJlc3Npb24sIHByb2Nlc3NGb3IsIHByb2Nlc3NJZiwgcHJvY2Vzc1Nsb3RPdXRsZXQsIHJlZ2lzdGVyUnVudGltZUhlbHBlcnMsIHJlc29sdmVDb21wb25lbnRUeXBlLCBzdHJpbmdpZnlFeHByZXNzaW9uLCB0b1ZhbGlkQXNzZXRJZCwgdHJhY2tTbG90U2NvcGVzLCB0cmFja1ZGb3JTbG90U2NvcGVzLCB0cmFuc2Zvcm0sIHRyYW5zZm9ybUJpbmQsIHRyYW5zZm9ybUVsZW1lbnQsIHRyYW5zZm9ybUV4cHJlc3Npb24sIHRyYW5zZm9ybU1vZGVsLCB0cmFuc2Zvcm1PbiwgdHJhdmVyc2VOb2RlLCB1bndyYXBUU05vZGUsIHdhbGtCbG9ja0RlY2xhcmF0aW9ucywgd2Fsa0Z1bmN0aW9uUGFyYW1zLCB3YWxrSWRlbnRpZmllcnMsIHdhcm5EZXByZWNhdGlvbiB9O1xyXG4iLCIvKipcclxuKiBAdnVlL2NvbXBpbGVyLWRvbSB2My41LjEzXHJcbiogKGMpIDIwMTgtcHJlc2VudCBZdXhpIChFdmFuKSBZb3UgYW5kIFZ1ZSBjb250cmlidXRvcnNcclxuKiBAbGljZW5zZSBNSVRcclxuKiovXHJcbmltcG9ydCB7IHJlZ2lzdGVyUnVudGltZUhlbHBlcnMsIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24sIGNyZWF0ZUNvbXBpbGVyRXJyb3IsIGNyZWF0ZU9iamVjdFByb3BlcnR5LCBnZXRDb25zdGFudFR5cGUsIGNyZWF0ZUNhbGxFeHByZXNzaW9uLCBUT19ESVNQTEFZX1NUUklORywgdHJhbnNmb3JtTW9kZWwgYXMgdHJhbnNmb3JtTW9kZWwkMSwgZmluZFByb3AsIGhhc0R5bmFtaWNLZXlWQmluZCwgZmluZERpciwgaXNTdGF0aWNBcmdPZiwgdHJhbnNmb3JtT24gYXMgdHJhbnNmb3JtT24kMSwgaXNTdGF0aWNFeHAsIGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbiwgY2hlY2tDb21wYXRFbmFibGVkLCBub29wRGlyZWN0aXZlVHJhbnNmb3JtLCBiYXNlQ29tcGlsZSwgYmFzZVBhcnNlIH0gZnJvbSAnQHZ1ZS9jb21waWxlci1jb3JlJztcclxuZXhwb3J0ICogZnJvbSAnQHZ1ZS9jb21waWxlci1jb3JlJztcclxuaW1wb3J0IHsgaXNWb2lkVGFnLCBpc0hUTUxUYWcsIGlzU1ZHVGFnLCBpc01hdGhNTFRhZywgcGFyc2VTdHJpbmdTdHlsZSwgY2FwaXRhbGl6ZSwgbWFrZU1hcCwgZXh0ZW5kIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xyXG5cclxuY29uc3QgVl9NT0RFTF9SQURJTyA9IFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYHZNb2RlbFJhZGlvYCA6IGBgKTtcclxuY29uc3QgVl9NT0RFTF9DSEVDS0JPWCA9IFN5bWJvbChcclxuICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYHZNb2RlbENoZWNrYm94YCA6IGBgXHJcbik7XHJcbmNvbnN0IFZfTU9ERUxfVEVYVCA9IFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYHZNb2RlbFRleHRgIDogYGApO1xyXG5jb25zdCBWX01PREVMX1NFTEVDVCA9IFN5bWJvbChcclxuICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYHZNb2RlbFNlbGVjdGAgOiBgYFxyXG4pO1xyXG5jb25zdCBWX01PREVMX0RZTkFNSUMgPSBTeW1ib2woXHJcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGB2TW9kZWxEeW5hbWljYCA6IGBgXHJcbik7XHJcbmNvbnN0IFZfT05fV0lUSF9NT0RJRklFUlMgPSBTeW1ib2woXHJcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGB2T25Nb2RpZmllcnNHdWFyZGAgOiBgYFxyXG4pO1xyXG5jb25zdCBWX09OX1dJVEhfS0VZUyA9IFN5bWJvbChcclxuICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYHZPbktleXNHdWFyZGAgOiBgYFxyXG4pO1xyXG5jb25zdCBWX1NIT1cgPSBTeW1ib2woISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGB2U2hvd2AgOiBgYCk7XHJcbmNvbnN0IFRSQU5TSVRJT04gPSBTeW1ib2woISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGBUcmFuc2l0aW9uYCA6IGBgKTtcclxuY29uc3QgVFJBTlNJVElPTl9HUk9VUCA9IFN5bWJvbChcclxuICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYFRyYW5zaXRpb25Hcm91cGAgOiBgYFxyXG4pO1xyXG5yZWdpc3RlclJ1bnRpbWVIZWxwZXJzKHtcclxuICBbVl9NT0RFTF9SQURJT106IGB2TW9kZWxSYWRpb2AsXHJcbiAgW1ZfTU9ERUxfQ0hFQ0tCT1hdOiBgdk1vZGVsQ2hlY2tib3hgLFxyXG4gIFtWX01PREVMX1RFWFRdOiBgdk1vZGVsVGV4dGAsXHJcbiAgW1ZfTU9ERUxfU0VMRUNUXTogYHZNb2RlbFNlbGVjdGAsXHJcbiAgW1ZfTU9ERUxfRFlOQU1JQ106IGB2TW9kZWxEeW5hbWljYCxcclxuICBbVl9PTl9XSVRIX01PRElGSUVSU106IGB3aXRoTW9kaWZpZXJzYCxcclxuICBbVl9PTl9XSVRIX0tFWVNdOiBgd2l0aEtleXNgLFxyXG4gIFtWX1NIT1ddOiBgdlNob3dgLFxyXG4gIFtUUkFOU0lUSU9OXTogYFRyYW5zaXRpb25gLFxyXG4gIFtUUkFOU0lUSU9OX0dST1VQXTogYFRyYW5zaXRpb25Hcm91cGBcclxufSk7XHJcblxyXG5sZXQgZGVjb2RlcjtcclxuZnVuY3Rpb24gZGVjb2RlSHRtbEJyb3dzZXIocmF3LCBhc0F0dHIgPSBmYWxzZSkge1xyXG4gIGlmICghZGVjb2Rlcikge1xyXG4gICAgZGVjb2RlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgfVxyXG4gIGlmIChhc0F0dHIpIHtcclxuICAgIGRlY29kZXIuaW5uZXJIVE1MID0gYDxkaXYgZm9vPVwiJHtyYXcucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIil9XCI+YDtcclxuICAgIHJldHVybiBkZWNvZGVyLmNoaWxkcmVuWzBdLmdldEF0dHJpYnV0ZShcImZvb1wiKTtcclxuICB9IGVsc2Uge1xyXG4gICAgZGVjb2Rlci5pbm5lckhUTUwgPSByYXc7XHJcbiAgICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudDtcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IHBhcnNlck9wdGlvbnMgPSB7XHJcbiAgcGFyc2VNb2RlOiBcImh0bWxcIixcclxuICBpc1ZvaWRUYWcsXHJcbiAgaXNOYXRpdmVUYWc6ICh0YWcpID0+IGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHVGFnKHRhZykgfHwgaXNNYXRoTUxUYWcodGFnKSxcclxuICBpc1ByZVRhZzogKHRhZykgPT4gdGFnID09PSBcInByZVwiLFxyXG4gIGlzSWdub3JlTmV3bGluZVRhZzogKHRhZykgPT4gdGFnID09PSBcInByZVwiIHx8IHRhZyA9PT0gXCJ0ZXh0YXJlYVwiLFxyXG4gIGRlY29kZUVudGl0aWVzOiBkZWNvZGVIdG1sQnJvd3NlciAsXHJcbiAgaXNCdWlsdEluQ29tcG9uZW50OiAodGFnKSA9PiB7XHJcbiAgICBpZiAodGFnID09PSBcIlRyYW5zaXRpb25cIiB8fCB0YWcgPT09IFwidHJhbnNpdGlvblwiKSB7XHJcbiAgICAgIHJldHVybiBUUkFOU0lUSU9OO1xyXG4gICAgfSBlbHNlIGlmICh0YWcgPT09IFwiVHJhbnNpdGlvbkdyb3VwXCIgfHwgdGFnID09PSBcInRyYW5zaXRpb24tZ3JvdXBcIikge1xyXG4gICAgICByZXR1cm4gVFJBTlNJVElPTl9HUk9VUDtcclxuICAgIH1cclxuICB9LFxyXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCN0cmVlLWNvbnN0cnVjdGlvbi1kaXNwYXRjaGVyXHJcbiAgZ2V0TmFtZXNwYWNlKHRhZywgcGFyZW50LCByb290TmFtZXNwYWNlKSB7XHJcbiAgICBsZXQgbnMgPSBwYXJlbnQgPyBwYXJlbnQubnMgOiByb290TmFtZXNwYWNlO1xyXG4gICAgaWYgKHBhcmVudCAmJiBucyA9PT0gMikge1xyXG4gICAgICBpZiAocGFyZW50LnRhZyA9PT0gXCJhbm5vdGF0aW9uLXhtbFwiKSB7XHJcbiAgICAgICAgaWYgKHRhZyA9PT0gXCJzdmdcIikge1xyXG4gICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXJlbnQucHJvcHMuc29tZShcclxuICAgICAgICAgIChhKSA9PiBhLnR5cGUgPT09IDYgJiYgYS5uYW1lID09PSBcImVuY29kaW5nXCIgJiYgYS52YWx1ZSAhPSBudWxsICYmIChhLnZhbHVlLmNvbnRlbnQgPT09IFwidGV4dC9odG1sXCIgfHwgYS52YWx1ZS5jb250ZW50ID09PSBcImFwcGxpY2F0aW9uL3hodG1sK3htbFwiKVxyXG4gICAgICAgICkpIHtcclxuICAgICAgICAgIG5zID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoL15tKD86W2lvbnNdfHRleHQpJC8udGVzdChwYXJlbnQudGFnKSAmJiB0YWcgIT09IFwibWdseXBoXCIgJiYgdGFnICE9PSBcIm1hbGlnbm1hcmtcIikge1xyXG4gICAgICAgIG5zID0gMDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChwYXJlbnQgJiYgbnMgPT09IDEpIHtcclxuICAgICAgaWYgKHBhcmVudC50YWcgPT09IFwiZm9yZWlnbk9iamVjdFwiIHx8IHBhcmVudC50YWcgPT09IFwiZGVzY1wiIHx8IHBhcmVudC50YWcgPT09IFwidGl0bGVcIikge1xyXG4gICAgICAgIG5zID0gMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG5zID09PSAwKSB7XHJcbiAgICAgIGlmICh0YWcgPT09IFwic3ZnXCIpIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGFnID09PSBcIm1hdGhcIikge1xyXG4gICAgICAgIHJldHVybiAyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnM7XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgdHJhbnNmb3JtU3R5bGUgPSAobm9kZSkgPT4ge1xyXG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcclxuICAgIG5vZGUucHJvcHMuZm9yRWFjaCgocCwgaSkgPT4ge1xyXG4gICAgICBpZiAocC50eXBlID09PSA2ICYmIHAubmFtZSA9PT0gXCJzdHlsZVwiICYmIHAudmFsdWUpIHtcclxuICAgICAgICBub2RlLnByb3BzW2ldID0ge1xyXG4gICAgICAgICAgdHlwZTogNyxcclxuICAgICAgICAgIG5hbWU6IGBiaW5kYCxcclxuICAgICAgICAgIGFyZzogY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgc3R5bGVgLCB0cnVlLCBwLmxvYyksXHJcbiAgICAgICAgICBleHA6IHBhcnNlSW5saW5lQ1NTKHAudmFsdWUuY29udGVudCwgcC5sb2MpLFxyXG4gICAgICAgICAgbW9kaWZpZXJzOiBbXSxcclxuICAgICAgICAgIGxvYzogcC5sb2NcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn07XHJcbmNvbnN0IHBhcnNlSW5saW5lQ1NTID0gKGNzc1RleHQsIGxvYykgPT4ge1xyXG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBwYXJzZVN0cmluZ1N0eWxlKGNzc1RleHQpO1xyXG4gIHJldHVybiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKFxyXG4gICAgSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZCksXHJcbiAgICBmYWxzZSxcclxuICAgIGxvYyxcclxuICAgIDNcclxuICApO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlRE9NQ29tcGlsZXJFcnJvcihjb2RlLCBsb2MpIHtcclxuICByZXR1cm4gY3JlYXRlQ29tcGlsZXJFcnJvcihcclxuICAgIGNvZGUsXHJcbiAgICBsb2MsXHJcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IGZhbHNlID8gRE9NRXJyb3JNZXNzYWdlcyA6IHZvaWQgMFxyXG4gICk7XHJcbn1cclxuY29uc3QgRE9NRXJyb3JDb2RlcyA9IHtcclxuICBcIlhfVl9IVE1MX05PX0VYUFJFU1NJT05cIjogNTMsXHJcbiAgXCI1M1wiOiBcIlhfVl9IVE1MX05PX0VYUFJFU1NJT05cIixcclxuICBcIlhfVl9IVE1MX1dJVEhfQ0hJTERSRU5cIjogNTQsXHJcbiAgXCI1NFwiOiBcIlhfVl9IVE1MX1dJVEhfQ0hJTERSRU5cIixcclxuICBcIlhfVl9URVhUX05PX0VYUFJFU1NJT05cIjogNTUsXHJcbiAgXCI1NVwiOiBcIlhfVl9URVhUX05PX0VYUFJFU1NJT05cIixcclxuICBcIlhfVl9URVhUX1dJVEhfQ0hJTERSRU5cIjogNTYsXHJcbiAgXCI1NlwiOiBcIlhfVl9URVhUX1dJVEhfQ0hJTERSRU5cIixcclxuICBcIlhfVl9NT0RFTF9PTl9JTlZBTElEX0VMRU1FTlRcIjogNTcsXHJcbiAgXCI1N1wiOiBcIlhfVl9NT0RFTF9PTl9JTlZBTElEX0VMRU1FTlRcIixcclxuICBcIlhfVl9NT0RFTF9BUkdfT05fRUxFTUVOVFwiOiA1OCxcclxuICBcIjU4XCI6IFwiWF9WX01PREVMX0FSR19PTl9FTEVNRU5UXCIsXHJcbiAgXCJYX1ZfTU9ERUxfT05fRklMRV9JTlBVVF9FTEVNRU5UXCI6IDU5LFxyXG4gIFwiNTlcIjogXCJYX1ZfTU9ERUxfT05fRklMRV9JTlBVVF9FTEVNRU5UXCIsXHJcbiAgXCJYX1ZfTU9ERUxfVU5ORUNFU1NBUllfVkFMVUVcIjogNjAsXHJcbiAgXCI2MFwiOiBcIlhfVl9NT0RFTF9VTk5FQ0VTU0FSWV9WQUxVRVwiLFxyXG4gIFwiWF9WX1NIT1dfTk9fRVhQUkVTU0lPTlwiOiA2MSxcclxuICBcIjYxXCI6IFwiWF9WX1NIT1dfTk9fRVhQUkVTU0lPTlwiLFxyXG4gIFwiWF9UUkFOU0lUSU9OX0lOVkFMSURfQ0hJTERSRU5cIjogNjIsXHJcbiAgXCI2MlwiOiBcIlhfVFJBTlNJVElPTl9JTlZBTElEX0NISUxEUkVOXCIsXHJcbiAgXCJYX0lHTk9SRURfU0lERV9FRkZFQ1RfVEFHXCI6IDYzLFxyXG4gIFwiNjNcIjogXCJYX0lHTk9SRURfU0lERV9FRkZFQ1RfVEFHXCIsXHJcbiAgXCJfX0VYVEVORF9QT0lOVF9fXCI6IDY0LFxyXG4gIFwiNjRcIjogXCJfX0VYVEVORF9QT0lOVF9fXCJcclxufTtcclxuY29uc3QgRE9NRXJyb3JNZXNzYWdlcyA9IHtcclxuICBbNTNdOiBgdi1odG1sIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxyXG4gIFs1NF06IGB2LWh0bWwgd2lsbCBvdmVycmlkZSBlbGVtZW50IGNoaWxkcmVuLmAsXHJcbiAgWzU1XTogYHYtdGV4dCBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICBbNTZdOiBgdi10ZXh0IHdpbGwgb3ZlcnJpZGUgZWxlbWVudCBjaGlsZHJlbi5gLFxyXG4gIFs1N106IGB2LW1vZGVsIGNhbiBvbmx5IGJlIHVzZWQgb24gPGlucHV0PiwgPHRleHRhcmVhPiBhbmQgPHNlbGVjdD4gZWxlbWVudHMuYCxcclxuICBbNThdOiBgdi1tb2RlbCBhcmd1bWVudCBpcyBub3Qgc3VwcG9ydGVkIG9uIHBsYWluIGVsZW1lbnRzLmAsXHJcbiAgWzU5XTogYHYtbW9kZWwgY2Fubm90IGJlIHVzZWQgb24gZmlsZSBpbnB1dHMgc2luY2UgdGhleSBhcmUgcmVhZC1vbmx5LiBVc2UgYSB2LW9uOmNoYW5nZSBsaXN0ZW5lciBpbnN0ZWFkLmAsXHJcbiAgWzYwXTogYFVubmVjZXNzYXJ5IHZhbHVlIGJpbmRpbmcgdXNlZCBhbG9uZ3NpZGUgdi1tb2RlbC4gSXQgd2lsbCBpbnRlcmZlcmUgd2l0aCB2LW1vZGVsJ3MgYmVoYXZpb3IuYCxcclxuICBbNjFdOiBgdi1zaG93IGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxyXG4gIFs2Ml06IGA8VHJhbnNpdGlvbj4gZXhwZWN0cyBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50IG9yIGNvbXBvbmVudC5gLFxyXG4gIFs2M106IGBUYWdzIHdpdGggc2lkZSBlZmZlY3QgKDxzY3JpcHQ+IGFuZCA8c3R5bGU+KSBhcmUgaWdub3JlZCBpbiBjbGllbnQgY29tcG9uZW50IHRlbXBsYXRlcy5gXHJcbn07XHJcblxyXG5jb25zdCB0cmFuc2Zvcm1WSHRtbCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICBjb25zdCB7IGV4cCwgbG9jIH0gPSBkaXI7XHJcbiAgaWYgKCFleHApIHtcclxuICAgIGNvbnRleHQub25FcnJvcihcclxuICAgICAgY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1MywgbG9jKVxyXG4gICAgKTtcclxuICB9XHJcbiAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICBjb250ZXh0Lm9uRXJyb3IoXHJcbiAgICAgIGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTQsIGxvYylcclxuICAgICk7XHJcbiAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7XHJcbiAgfVxyXG4gIHJldHVybiB7XHJcbiAgICBwcm9wczogW1xyXG4gICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShcclxuICAgICAgICBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGBpbm5lckhUTUxgLCB0cnVlLCBsb2MpLFxyXG4gICAgICAgIGV4cCB8fCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKFwiXCIsIHRydWUpXHJcbiAgICAgIClcclxuICAgIF1cclxuICB9O1xyXG59O1xyXG5cclxuY29uc3QgdHJhbnNmb3JtVlRleHQgPSAoZGlyLCBub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgY29uc3QgeyBleHAsIGxvYyB9ID0gZGlyO1xyXG4gIGlmICghZXhwKSB7XHJcbiAgICBjb250ZXh0Lm9uRXJyb3IoXHJcbiAgICAgIGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTUsIGxvYylcclxuICAgICk7XHJcbiAgfVxyXG4gIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgY29udGV4dC5vbkVycm9yKFxyXG4gICAgICBjcmVhdGVET01Db21waWxlckVycm9yKDU2LCBsb2MpXHJcbiAgICApO1xyXG4gICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwO1xyXG4gIH1cclxuICByZXR1cm4ge1xyXG4gICAgcHJvcHM6IFtcclxuICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoXHJcbiAgICAgICAgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgdGV4dENvbnRlbnRgLCB0cnVlKSxcclxuICAgICAgICBleHAgPyBnZXRDb25zdGFudFR5cGUoZXhwLCBjb250ZXh0KSA+IDAgPyBleHAgOiBjcmVhdGVDYWxsRXhwcmVzc2lvbihcclxuICAgICAgICAgIGNvbnRleHQuaGVscGVyU3RyaW5nKFRPX0RJU1BMQVlfU1RSSU5HKSxcclxuICAgICAgICAgIFtleHBdLFxyXG4gICAgICAgICAgbG9jXHJcbiAgICAgICAgKSA6IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oXCJcIiwgdHJ1ZSlcclxuICAgICAgKVxyXG4gICAgXVxyXG4gIH07XHJcbn07XHJcblxyXG5jb25zdCB0cmFuc2Zvcm1Nb2RlbCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICBjb25zdCBiYXNlUmVzdWx0ID0gdHJhbnNmb3JtTW9kZWwkMShkaXIsIG5vZGUsIGNvbnRleHQpO1xyXG4gIGlmICghYmFzZVJlc3VsdC5wcm9wcy5sZW5ndGggfHwgbm9kZS50YWdUeXBlID09PSAxKSB7XHJcbiAgICByZXR1cm4gYmFzZVJlc3VsdDtcclxuICB9XHJcbiAgaWYgKGRpci5hcmcpIHtcclxuICAgIGNvbnRleHQub25FcnJvcihcclxuICAgICAgY3JlYXRlRE9NQ29tcGlsZXJFcnJvcihcclxuICAgICAgICA1OCxcclxuICAgICAgICBkaXIuYXJnLmxvY1xyXG4gICAgICApXHJcbiAgICApO1xyXG4gIH1cclxuICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZWRWYWx1ZSgpIHtcclxuICAgIGNvbnN0IHZhbHVlID0gZmluZERpcihub2RlLCBcImJpbmRcIik7XHJcbiAgICBpZiAodmFsdWUgJiYgaXNTdGF0aWNBcmdPZih2YWx1ZS5hcmcsIFwidmFsdWVcIikpIHtcclxuICAgICAgY29udGV4dC5vbkVycm9yKFxyXG4gICAgICAgIGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoXHJcbiAgICAgICAgICA2MCxcclxuICAgICAgICAgIHZhbHVlLmxvY1xyXG4gICAgICAgIClcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcbiAgY29uc3QgeyB0YWcgfSA9IG5vZGU7XHJcbiAgY29uc3QgaXNDdXN0b21FbGVtZW50ID0gY29udGV4dC5pc0N1c3RvbUVsZW1lbnQodGFnKTtcclxuICBpZiAodGFnID09PSBcImlucHV0XCIgfHwgdGFnID09PSBcInRleHRhcmVhXCIgfHwgdGFnID09PSBcInNlbGVjdFwiIHx8IGlzQ3VzdG9tRWxlbWVudCkge1xyXG4gICAgbGV0IGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9URVhUO1xyXG4gICAgbGV0IGlzSW52YWxpZFR5cGUgPSBmYWxzZTtcclxuICAgIGlmICh0YWcgPT09IFwiaW5wdXRcIiB8fCBpc0N1c3RvbUVsZW1lbnQpIHtcclxuICAgICAgY29uc3QgdHlwZSA9IGZpbmRQcm9wKG5vZGUsIGB0eXBlYCk7XHJcbiAgICAgIGlmICh0eXBlKSB7XHJcbiAgICAgICAgaWYgKHR5cGUudHlwZSA9PT0gNykge1xyXG4gICAgICAgICAgZGlyZWN0aXZlVG9Vc2UgPSBWX01PREVMX0RZTkFNSUM7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlLnZhbHVlKSB7XHJcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUudmFsdWUuY29udGVudCkge1xyXG4gICAgICAgICAgICBjYXNlIFwicmFkaW9cIjpcclxuICAgICAgICAgICAgICBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfUkFESU87XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJjaGVja2JveFwiOlxyXG4gICAgICAgICAgICAgIGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9DSEVDS0JPWDtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImZpbGVcIjpcclxuICAgICAgICAgICAgICBpc0ludmFsaWRUeXBlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoXHJcbiAgICAgICAgICAgICAgICBjcmVhdGVET01Db21waWxlckVycm9yKFxyXG4gICAgICAgICAgICAgICAgICA1OSxcclxuICAgICAgICAgICAgICAgICAgZGlyLmxvY1xyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjaGVja0R1cGxpY2F0ZWRWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChoYXNEeW5hbWljS2V5VkJpbmQobm9kZSkpIHtcclxuICAgICAgICBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfRFlOQU1JQztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNoZWNrRHVwbGljYXRlZFZhbHVlKCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodGFnID09PSBcInNlbGVjdFwiKSB7XHJcbiAgICAgIGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9TRUxFQ1Q7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNoZWNrRHVwbGljYXRlZFZhbHVlKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzSW52YWxpZFR5cGUpIHtcclxuICAgICAgYmFzZVJlc3VsdC5uZWVkUnVudGltZSA9IGNvbnRleHQuaGVscGVyKGRpcmVjdGl2ZVRvVXNlKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgY29udGV4dC5vbkVycm9yKFxyXG4gICAgICBjcmVhdGVET01Db21waWxlckVycm9yKFxyXG4gICAgICAgIDU3LFxyXG4gICAgICAgIGRpci5sb2NcclxuICAgICAgKVxyXG4gICAgKTtcclxuICB9XHJcbiAgYmFzZVJlc3VsdC5wcm9wcyA9IGJhc2VSZXN1bHQucHJvcHMuZmlsdGVyKFxyXG4gICAgKHApID0+ICEocC5rZXkudHlwZSA9PT0gNCAmJiBwLmtleS5jb250ZW50ID09PSBcIm1vZGVsVmFsdWVcIilcclxuICApO1xyXG4gIHJldHVybiBiYXNlUmVzdWx0O1xyXG59O1xyXG5cclxuY29uc3QgaXNFdmVudE9wdGlvbk1vZGlmaWVyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoYHBhc3NpdmUsb25jZSxjYXB0dXJlYCk7XHJcbmNvbnN0IGlzTm9uS2V5TW9kaWZpZXIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcclxuICAvLyBldmVudCBwcm9wYWdhdGlvbiBtYW5hZ2VtZW50XHJcbiAgYHN0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QsbWlkZGxlYFxyXG4pO1xyXG5jb25zdCBtYXliZUtleU1vZGlmaWVyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXCJsZWZ0LHJpZ2h0XCIpO1xyXG5jb25zdCBpc0tleWJvYXJkRXZlbnQgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChgb25rZXl1cCxvbmtleWRvd24sb25rZXlwcmVzc2ApO1xyXG5jb25zdCByZXNvbHZlTW9kaWZpZXJzID0gKGtleSwgbW9kaWZpZXJzLCBjb250ZXh0LCBsb2MpID0+IHtcclxuICBjb25zdCBrZXlNb2RpZmllcnMgPSBbXTtcclxuICBjb25zdCBub25LZXlNb2RpZmllcnMgPSBbXTtcclxuICBjb25zdCBldmVudE9wdGlvbk1vZGlmaWVycyA9IFtdO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kaWZpZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBtb2RpZmllciA9IG1vZGlmaWVyc1tpXS5jb250ZW50O1xyXG4gICAgaWYgKG1vZGlmaWVyID09PSBcIm5hdGl2ZVwiICYmIGNoZWNrQ29tcGF0RW5hYmxlZChcclxuICAgICAgXCJDT01QSUxFUl9WX09OX05BVElWRVwiLFxyXG4gICAgICBjb250ZXh0LFxyXG4gICAgICBsb2NcclxuICAgICkpIHtcclxuICAgICAgZXZlbnRPcHRpb25Nb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICB9IGVsc2UgaWYgKGlzRXZlbnRPcHRpb25Nb2RpZmllcihtb2RpZmllcikpIHtcclxuICAgICAgZXZlbnRPcHRpb25Nb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAobWF5YmVLZXlNb2RpZmllcihtb2RpZmllcikpIHtcclxuICAgICAgICBpZiAoaXNTdGF0aWNFeHAoa2V5KSkge1xyXG4gICAgICAgICAgaWYgKGlzS2V5Ym9hcmRFdmVudChrZXkuY29udGVudC50b0xvd2VyQ2FzZSgpKSkge1xyXG4gICAgICAgICAgICBrZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBub25LZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGtleU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgICAgICAgIG5vbktleU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGlzTm9uS2V5TW9kaWZpZXIobW9kaWZpZXIpKSB7XHJcbiAgICAgICAgICBub25LZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGtleU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIGtleU1vZGlmaWVycyxcclxuICAgIG5vbktleU1vZGlmaWVycyxcclxuICAgIGV2ZW50T3B0aW9uTW9kaWZpZXJzXHJcbiAgfTtcclxufTtcclxuY29uc3QgdHJhbnNmb3JtQ2xpY2sgPSAoa2V5LCBldmVudCkgPT4ge1xyXG4gIGNvbnN0IGlzU3RhdGljQ2xpY2sgPSBpc1N0YXRpY0V4cChrZXkpICYmIGtleS5jb250ZW50LnRvTG93ZXJDYXNlKCkgPT09IFwib25jbGlja1wiO1xyXG4gIHJldHVybiBpc1N0YXRpY0NsaWNrID8gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihldmVudCwgdHJ1ZSkgOiBrZXkudHlwZSAhPT0gNCA/IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbXHJcbiAgICBgKGAsXHJcbiAgICBrZXksXHJcbiAgICBgKSA9PT0gXCJvbkNsaWNrXCIgPyBcIiR7ZXZlbnR9XCIgOiAoYCxcclxuICAgIGtleSxcclxuICAgIGApYFxyXG4gIF0pIDoga2V5O1xyXG59O1xyXG5jb25zdCB0cmFuc2Zvcm1PbiA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICByZXR1cm4gdHJhbnNmb3JtT24kMShkaXIsIG5vZGUsIGNvbnRleHQsIChiYXNlUmVzdWx0KSA9PiB7XHJcbiAgICBjb25zdCB7IG1vZGlmaWVycyB9ID0gZGlyO1xyXG4gICAgaWYgKCFtb2RpZmllcnMubGVuZ3RoKSByZXR1cm4gYmFzZVJlc3VsdDtcclxuICAgIGxldCB7IGtleSwgdmFsdWU6IGhhbmRsZXJFeHAgfSA9IGJhc2VSZXN1bHQucHJvcHNbMF07XHJcbiAgICBjb25zdCB7IGtleU1vZGlmaWVycywgbm9uS2V5TW9kaWZpZXJzLCBldmVudE9wdGlvbk1vZGlmaWVycyB9ID0gcmVzb2x2ZU1vZGlmaWVycyhrZXksIG1vZGlmaWVycywgY29udGV4dCwgZGlyLmxvYyk7XHJcbiAgICBpZiAobm9uS2V5TW9kaWZpZXJzLmluY2x1ZGVzKFwicmlnaHRcIikpIHtcclxuICAgICAga2V5ID0gdHJhbnNmb3JtQ2xpY2soa2V5LCBgb25Db250ZXh0bWVudWApO1xyXG4gICAgfVxyXG4gICAgaWYgKG5vbktleU1vZGlmaWVycy5pbmNsdWRlcyhcIm1pZGRsZVwiKSkge1xyXG4gICAgICBrZXkgPSB0cmFuc2Zvcm1DbGljayhrZXksIGBvbk1vdXNldXBgKTtcclxuICAgIH1cclxuICAgIGlmIChub25LZXlNb2RpZmllcnMubGVuZ3RoKSB7XHJcbiAgICAgIGhhbmRsZXJFeHAgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihWX09OX1dJVEhfTU9ESUZJRVJTKSwgW1xyXG4gICAgICAgIGhhbmRsZXJFeHAsXHJcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkobm9uS2V5TW9kaWZpZXJzKVxyXG4gICAgICBdKTtcclxuICAgIH1cclxuICAgIGlmIChrZXlNb2RpZmllcnMubGVuZ3RoICYmIC8vIGlmIGV2ZW50IG5hbWUgaXMgZHluYW1pYywgYWx3YXlzIHdyYXAgd2l0aCBrZXlzIGd1YXJkXHJcbiAgICAoIWlzU3RhdGljRXhwKGtleSkgfHwgaXNLZXlib2FyZEV2ZW50KGtleS5jb250ZW50LnRvTG93ZXJDYXNlKCkpKSkge1xyXG4gICAgICBoYW5kbGVyRXhwID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoVl9PTl9XSVRIX0tFWVMpLCBbXHJcbiAgICAgICAgaGFuZGxlckV4cCxcclxuICAgICAgICBKU09OLnN0cmluZ2lmeShrZXlNb2RpZmllcnMpXHJcbiAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgaWYgKGV2ZW50T3B0aW9uTW9kaWZpZXJzLmxlbmd0aCkge1xyXG4gICAgICBjb25zdCBtb2RpZmllclBvc3RmaXggPSBldmVudE9wdGlvbk1vZGlmaWVycy5tYXAoY2FwaXRhbGl6ZSkuam9pbihcIlwiKTtcclxuICAgICAga2V5ID0gaXNTdGF0aWNFeHAoa2V5KSA/IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYCR7a2V5LmNvbnRlbnR9JHttb2RpZmllclBvc3RmaXh9YCwgdHJ1ZSkgOiBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW2AoYCwga2V5LCBgKSArIFwiJHttb2RpZmllclBvc3RmaXh9XCJgXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBwcm9wczogW2NyZWF0ZU9iamVjdFByb3BlcnR5KGtleSwgaGFuZGxlckV4cCldXHJcbiAgICB9O1xyXG4gIH0pO1xyXG59O1xyXG5cclxuY29uc3QgdHJhbnNmb3JtU2hvdyA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICBjb25zdCB7IGV4cCwgbG9jIH0gPSBkaXI7XHJcbiAgaWYgKCFleHApIHtcclxuICAgIGNvbnRleHQub25FcnJvcihcclxuICAgICAgY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig2MSwgbG9jKVxyXG4gICAgKTtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIHByb3BzOiBbXSxcclxuICAgIG5lZWRSdW50aW1lOiBjb250ZXh0LmhlbHBlcihWX1NIT1cpXHJcbiAgfTtcclxufTtcclxuXHJcbmNvbnN0IHRyYW5zZm9ybVRyYW5zaXRpb24gPSAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gIGlmIChub2RlLnR5cGUgPT09IDEgJiYgbm9kZS50YWdUeXBlID09PSAxKSB7XHJcbiAgICBjb25zdCBjb21wb25lbnQgPSBjb250ZXh0LmlzQnVpbHRJbkNvbXBvbmVudChub2RlLnRhZyk7XHJcbiAgICBpZiAoY29tcG9uZW50ID09PSBUUkFOU0lUSU9OKSB7XHJcbiAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFub2RlLmNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFzTXVsdGlwbGVDaGlsZHJlbihub2RlKSkge1xyXG4gICAgICAgICAgY29udGV4dC5vbkVycm9yKFxyXG4gICAgICAgICAgICBjcmVhdGVET01Db21waWxlckVycm9yKFxyXG4gICAgICAgICAgICAgIDYyLFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiBub2RlLmNoaWxkcmVuWzBdLmxvYy5zdGFydCxcclxuICAgICAgICAgICAgICAgIGVuZDogbm9kZS5jaGlsZHJlbltub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDFdLmxvYy5lbmQsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2U6IFwiXCJcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlblswXTtcclxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gMSkge1xyXG4gICAgICAgICAgZm9yIChjb25zdCBwIG9mIGNoaWxkLnByb3BzKSB7XHJcbiAgICAgICAgICAgIGlmIChwLnR5cGUgPT09IDcgJiYgcC5uYW1lID09PSBcInNob3dcIikge1xyXG4gICAgICAgICAgICAgIG5vZGUucHJvcHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiA2LFxyXG4gICAgICAgICAgICAgICAgbmFtZTogXCJwZXJzaXN0ZWRcIixcclxuICAgICAgICAgICAgICAgIG5hbWVMb2M6IG5vZGUubG9jLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZvaWQgMCxcclxuICAgICAgICAgICAgICAgIGxvYzogbm9kZS5sb2NcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcbmZ1bmN0aW9uIGhhc011bHRpcGxlQ2hpbGRyZW4obm9kZSkge1xyXG4gIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4uZmlsdGVyKFxyXG4gICAgKGMpID0+IGMudHlwZSAhPT0gMyAmJiAhKGMudHlwZSA9PT0gMiAmJiAhYy5jb250ZW50LnRyaW0oKSlcclxuICApO1xyXG4gIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bMF07XHJcbiAgcmV0dXJuIGNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBjaGlsZC50eXBlID09PSAxMSB8fCBjaGlsZC50eXBlID09PSA5ICYmIGNoaWxkLmJyYW5jaGVzLnNvbWUoaGFzTXVsdGlwbGVDaGlsZHJlbik7XHJcbn1cclxuXHJcbmNvbnN0IGlnbm9yZVNpZGVFZmZlY3RUYWdzID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICBpZiAobm9kZS50eXBlID09PSAxICYmIG5vZGUudGFnVHlwZSA9PT0gMCAmJiAobm9kZS50YWcgPT09IFwic2NyaXB0XCIgfHwgbm9kZS50YWcgPT09IFwic3R5bGVcIikpIHtcclxuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY29udGV4dC5vbkVycm9yKFxyXG4gICAgICBjcmVhdGVET01Db21waWxlckVycm9yKFxyXG4gICAgICAgIDYzLFxyXG4gICAgICAgIG5vZGUubG9jXHJcbiAgICAgIClcclxuICAgICk7XHJcbiAgICBjb250ZXh0LnJlbW92ZU5vZGUoKTtcclxuICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBpc1ZhbGlkSFRNTE5lc3RpbmcocGFyZW50LCBjaGlsZCkge1xyXG4gIGlmIChwYXJlbnQgaW4gb25seVZhbGlkQ2hpbGRyZW4pIHtcclxuICAgIHJldHVybiBvbmx5VmFsaWRDaGlsZHJlbltwYXJlbnRdLmhhcyhjaGlsZCk7XHJcbiAgfVxyXG4gIGlmIChjaGlsZCBpbiBvbmx5VmFsaWRQYXJlbnRzKSB7XHJcbiAgICByZXR1cm4gb25seVZhbGlkUGFyZW50c1tjaGlsZF0uaGFzKHBhcmVudCk7XHJcbiAgfVxyXG4gIGlmIChwYXJlbnQgaW4ga25vd25JbnZhbGlkQ2hpbGRyZW4pIHtcclxuICAgIGlmIChrbm93bkludmFsaWRDaGlsZHJlbltwYXJlbnRdLmhhcyhjaGlsZCkpIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgaWYgKGNoaWxkIGluIGtub3duSW52YWxpZFBhcmVudHMpIHtcclxuICAgIGlmIChrbm93bkludmFsaWRQYXJlbnRzW2NoaWxkXS5oYXMocGFyZW50KSkgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5jb25zdCBoZWFkaW5ncyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImgxXCIsIFwiaDJcIiwgXCJoM1wiLCBcImg0XCIsIFwiaDVcIiwgXCJoNlwiXSk7XHJcbmNvbnN0IGVtcHR5U2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW10pO1xyXG5jb25zdCBvbmx5VmFsaWRDaGlsZHJlbiA9IHtcclxuICBoZWFkOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXHJcbiAgICBcImJhc2VcIixcclxuICAgIFwiYmFzZWZyb250XCIsXHJcbiAgICBcImJnc291bmRcIixcclxuICAgIFwibGlua1wiLFxyXG4gICAgXCJtZXRhXCIsXHJcbiAgICBcInRpdGxlXCIsXHJcbiAgICBcIm5vc2NyaXB0XCIsXHJcbiAgICBcIm5vZnJhbWVzXCIsXHJcbiAgICBcInN0eWxlXCIsXHJcbiAgICBcInNjcmlwdFwiLFxyXG4gICAgXCJ0ZW1wbGF0ZVwiXHJcbiAgXSksXHJcbiAgb3B0Z3JvdXA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcIm9wdGlvblwiXSksXHJcbiAgc2VsZWN0OiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJvcHRncm91cFwiLCBcIm9wdGlvblwiLCBcImhyXCJdKSxcclxuICAvLyB0YWJsZVxyXG4gIHRhYmxlOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJjYXB0aW9uXCIsIFwiY29sZ3JvdXBcIiwgXCJ0Ym9keVwiLCBcInRmb290XCIsIFwidGhlYWRcIl0pLFxyXG4gIHRyOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJ0ZFwiLCBcInRoXCJdKSxcclxuICBjb2xncm91cDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiY29sXCJdKSxcclxuICB0Ym9keTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1widHJcIl0pLFxyXG4gIHRoZWFkOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJ0clwiXSksXHJcbiAgdGZvb3Q6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInRyXCJdKSxcclxuICAvLyB0aGVzZSBlbGVtZW50cyBjYW4gbm90IGhhdmUgYW55IGNoaWxkcmVuIGVsZW1lbnRzXHJcbiAgc2NyaXB0OiBlbXB0eVNldCxcclxuICBpZnJhbWU6IGVtcHR5U2V0LFxyXG4gIG9wdGlvbjogZW1wdHlTZXQsXHJcbiAgdGV4dGFyZWE6IGVtcHR5U2V0LFxyXG4gIHN0eWxlOiBlbXB0eVNldCxcclxuICB0aXRsZTogZW1wdHlTZXRcclxufTtcclxuY29uc3Qgb25seVZhbGlkUGFyZW50cyA9IHtcclxuICAvLyBzZWN0aW9uc1xyXG4gIGh0bWw6IGVtcHR5U2V0LFxyXG4gIGJvZHk6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImh0bWxcIl0pLFxyXG4gIGhlYWQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImh0bWxcIl0pLFxyXG4gIC8vIHRhYmxlXHJcbiAgdGQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInRyXCJdKSxcclxuICBjb2xncm91cDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1widGFibGVcIl0pLFxyXG4gIGNhcHRpb246IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInRhYmxlXCJdKSxcclxuICB0Ym9keTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1widGFibGVcIl0pLFxyXG4gIHRmb290OiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJ0YWJsZVwiXSksXHJcbiAgY29sOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJjb2xncm91cFwiXSksXHJcbiAgdGg6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInRyXCJdKSxcclxuICB0aGVhZDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1widGFibGVcIl0pLFxyXG4gIHRyOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJ0Ym9keVwiLCBcInRoZWFkXCIsIFwidGZvb3RcIl0pLFxyXG4gIC8vIGRhdGEgbGlzdFxyXG4gIGRkOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJkbFwiLCBcImRpdlwiXSksXHJcbiAgZHQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImRsXCIsIFwiZGl2XCJdKSxcclxuICAvLyBvdGhlclxyXG4gIGZpZ2NhcHRpb246IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImZpZ3VyZVwiXSksXHJcbiAgLy8gbGk6IG5ldyBTZXQoW1widWxcIiwgXCJvbFwiXSksXHJcbiAgc3VtbWFyeTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiZGV0YWlsc1wiXSksXHJcbiAgYXJlYTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wibWFwXCJdKVxyXG59O1xyXG5jb25zdCBrbm93bkludmFsaWRDaGlsZHJlbiA9IHtcclxuICBwOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXHJcbiAgICBcImFkZHJlc3NcIixcclxuICAgIFwiYXJ0aWNsZVwiLFxyXG4gICAgXCJhc2lkZVwiLFxyXG4gICAgXCJibG9ja3F1b3RlXCIsXHJcbiAgICBcImNlbnRlclwiLFxyXG4gICAgXCJkZXRhaWxzXCIsXHJcbiAgICBcImRpYWxvZ1wiLFxyXG4gICAgXCJkaXJcIixcclxuICAgIFwiZGl2XCIsXHJcbiAgICBcImRsXCIsXHJcbiAgICBcImZpZWxkc2V0XCIsXHJcbiAgICBcImZpZ3VyZVwiLFxyXG4gICAgXCJmb290ZXJcIixcclxuICAgIFwiZm9ybVwiLFxyXG4gICAgXCJoMVwiLFxyXG4gICAgXCJoMlwiLFxyXG4gICAgXCJoM1wiLFxyXG4gICAgXCJoNFwiLFxyXG4gICAgXCJoNVwiLFxyXG4gICAgXCJoNlwiLFxyXG4gICAgXCJoZWFkZXJcIixcclxuICAgIFwiaGdyb3VwXCIsXHJcbiAgICBcImhyXCIsXHJcbiAgICBcImxpXCIsXHJcbiAgICBcIm1haW5cIixcclxuICAgIFwibmF2XCIsXHJcbiAgICBcIm1lbnVcIixcclxuICAgIFwib2xcIixcclxuICAgIFwicFwiLFxyXG4gICAgXCJwcmVcIixcclxuICAgIFwic2VjdGlvblwiLFxyXG4gICAgXCJ0YWJsZVwiLFxyXG4gICAgXCJ1bFwiXHJcbiAgXSksXHJcbiAgc3ZnOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXHJcbiAgICBcImJcIixcclxuICAgIFwiYmxvY2txdW90ZVwiLFxyXG4gICAgXCJiclwiLFxyXG4gICAgXCJjb2RlXCIsXHJcbiAgICBcImRkXCIsXHJcbiAgICBcImRpdlwiLFxyXG4gICAgXCJkbFwiLFxyXG4gICAgXCJkdFwiLFxyXG4gICAgXCJlbVwiLFxyXG4gICAgXCJlbWJlZFwiLFxyXG4gICAgXCJoMVwiLFxyXG4gICAgXCJoMlwiLFxyXG4gICAgXCJoM1wiLFxyXG4gICAgXCJoNFwiLFxyXG4gICAgXCJoNVwiLFxyXG4gICAgXCJoNlwiLFxyXG4gICAgXCJoclwiLFxyXG4gICAgXCJpXCIsXHJcbiAgICBcImltZ1wiLFxyXG4gICAgXCJsaVwiLFxyXG4gICAgXCJtZW51XCIsXHJcbiAgICBcIm1ldGFcIixcclxuICAgIFwib2xcIixcclxuICAgIFwicFwiLFxyXG4gICAgXCJwcmVcIixcclxuICAgIFwicnVieVwiLFxyXG4gICAgXCJzXCIsXHJcbiAgICBcInNtYWxsXCIsXHJcbiAgICBcInNwYW5cIixcclxuICAgIFwic3Ryb25nXCIsXHJcbiAgICBcInN1YlwiLFxyXG4gICAgXCJzdXBcIixcclxuICAgIFwidGFibGVcIixcclxuICAgIFwidVwiLFxyXG4gICAgXCJ1bFwiLFxyXG4gICAgXCJ2YXJcIlxyXG4gIF0pXHJcbn07XHJcbmNvbnN0IGtub3duSW52YWxpZFBhcmVudHMgPSB7XHJcbiAgYTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiYVwiXSksXHJcbiAgYnV0dG9uOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJidXR0b25cIl0pLFxyXG4gIGRkOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJkZFwiLCBcImR0XCJdKSxcclxuICBkdDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiZGRcIiwgXCJkdFwiXSksXHJcbiAgZm9ybTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiZm9ybVwiXSksXHJcbiAgbGk6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImxpXCJdKSxcclxuICBoMTogaGVhZGluZ3MsXHJcbiAgaDI6IGhlYWRpbmdzLFxyXG4gIGgzOiBoZWFkaW5ncyxcclxuICBoNDogaGVhZGluZ3MsXHJcbiAgaDU6IGhlYWRpbmdzLFxyXG4gIGg2OiBoZWFkaW5nc1xyXG59O1xyXG5cclxuY29uc3QgdmFsaWRhdGVIdG1sTmVzdGluZyA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSAmJiBub2RlLnRhZ1R5cGUgPT09IDAgJiYgY29udGV4dC5wYXJlbnQgJiYgY29udGV4dC5wYXJlbnQudHlwZSA9PT0gMSAmJiBjb250ZXh0LnBhcmVudC50YWdUeXBlID09PSAwICYmICFpc1ZhbGlkSFRNTE5lc3RpbmcoY29udGV4dC5wYXJlbnQudGFnLCBub2RlLnRhZykpIHtcclxuICAgIGNvbnN0IGVycm9yID0gbmV3IFN5bnRheEVycm9yKFxyXG4gICAgICBgPCR7bm9kZS50YWd9PiBjYW5ub3QgYmUgY2hpbGQgb2YgPCR7Y29udGV4dC5wYXJlbnQudGFnfT4sIGFjY29yZGluZyB0byBIVE1MIHNwZWNpZmljYXRpb25zLiBUaGlzIGNhbiBjYXVzZSBoeWRyYXRpb24gZXJyb3JzIG9yIHBvdGVudGlhbGx5IGRpc3J1cHQgZnV0dXJlIGZ1bmN0aW9uYWxpdHkuYFxyXG4gICAgKTtcclxuICAgIGVycm9yLmxvYyA9IG5vZGUubG9jO1xyXG4gICAgY29udGV4dC5vbldhcm4oZXJyb3IpO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IERPTU5vZGVUcmFuc2Zvcm1zID0gW1xyXG4gIHRyYW5zZm9ybVN0eWxlLFxyXG4gIC4uLiEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBbdHJhbnNmb3JtVHJhbnNpdGlvbiwgdmFsaWRhdGVIdG1sTmVzdGluZ10gOiBbXVxyXG5dO1xyXG5jb25zdCBET01EaXJlY3RpdmVUcmFuc2Zvcm1zID0ge1xyXG4gIGNsb2FrOiBub29wRGlyZWN0aXZlVHJhbnNmb3JtLFxyXG4gIGh0bWw6IHRyYW5zZm9ybVZIdG1sLFxyXG4gIHRleHQ6IHRyYW5zZm9ybVZUZXh0LFxyXG4gIG1vZGVsOiB0cmFuc2Zvcm1Nb2RlbCxcclxuICAvLyBvdmVycmlkZSBjb21waWxlci1jb3JlXHJcbiAgb246IHRyYW5zZm9ybU9uLFxyXG4gIC8vIG92ZXJyaWRlIGNvbXBpbGVyLWNvcmVcclxuICBzaG93OiB0cmFuc2Zvcm1TaG93XHJcbn07XHJcbmZ1bmN0aW9uIGNvbXBpbGUoc3JjLCBvcHRpb25zID0ge30pIHtcclxuICByZXR1cm4gYmFzZUNvbXBpbGUoXHJcbiAgICBzcmMsXHJcbiAgICBleHRlbmQoe30sIHBhcnNlck9wdGlvbnMsIG9wdGlvbnMsIHtcclxuICAgICAgbm9kZVRyYW5zZm9ybXM6IFtcclxuICAgICAgICAvLyBpZ25vcmUgPHNjcmlwdD4gYW5kIDx0YWc+XHJcbiAgICAgICAgLy8gdGhpcyBpcyBub3QgcHV0IGluc2lkZSBET01Ob2RlVHJhbnNmb3JtcyBiZWNhdXNlIHRoYXQgbGlzdCBpcyB1c2VkXHJcbiAgICAgICAgLy8gYnkgY29tcGlsZXItc3NyIHRvIGdlbmVyYXRlIHZub2RlIGZhbGxiYWNrIGJyYW5jaGVzXHJcbiAgICAgICAgaWdub3JlU2lkZUVmZmVjdFRhZ3MsXHJcbiAgICAgICAgLi4uRE9NTm9kZVRyYW5zZm9ybXMsXHJcbiAgICAgICAgLi4ub3B0aW9ucy5ub2RlVHJhbnNmb3JtcyB8fCBbXVxyXG4gICAgICBdLFxyXG4gICAgICBkaXJlY3RpdmVUcmFuc2Zvcm1zOiBleHRlbmQoXHJcbiAgICAgICAge30sXHJcbiAgICAgICAgRE9NRGlyZWN0aXZlVHJhbnNmb3JtcyxcclxuICAgICAgICBvcHRpb25zLmRpcmVjdGl2ZVRyYW5zZm9ybXMgfHwge31cclxuICAgICAgKSxcclxuICAgICAgdHJhbnNmb3JtSG9pc3Q6IG51bGwgXHJcbiAgICB9KVxyXG4gICk7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2UodGVtcGxhdGUsIG9wdGlvbnMgPSB7fSkge1xyXG4gIHJldHVybiBiYXNlUGFyc2UodGVtcGxhdGUsIGV4dGVuZCh7fSwgcGFyc2VyT3B0aW9ucywgb3B0aW9ucykpO1xyXG59XHJcblxyXG5leHBvcnQgeyBET01EaXJlY3RpdmVUcmFuc2Zvcm1zLCBET01FcnJvckNvZGVzLCBET01FcnJvck1lc3NhZ2VzLCBET01Ob2RlVHJhbnNmb3JtcywgVFJBTlNJVElPTiwgVFJBTlNJVElPTl9HUk9VUCwgVl9NT0RFTF9DSEVDS0JPWCwgVl9NT0RFTF9EWU5BTUlDLCBWX01PREVMX1JBRElPLCBWX01PREVMX1NFTEVDVCwgVl9NT0RFTF9URVhULCBWX09OX1dJVEhfS0VZUywgVl9PTl9XSVRIX01PRElGSUVSUywgVl9TSE9XLCBjb21waWxlLCBjcmVhdGVET01Db21waWxlckVycm9yLCBwYXJzZSwgcGFyc2VyT3B0aW9ucywgdHJhbnNmb3JtU3R5bGUgfTtcclxuIiwiLyoqXHJcbiogQHZ1ZS9yZWFjdGl2aXR5IHYzLjUuMTNcclxuKiAoYykgMjAxOC1wcmVzZW50IFl1eGkgKEV2YW4pIFlvdSBhbmQgVnVlIGNvbnRyaWJ1dG9yc1xyXG4qIEBsaWNlbnNlIE1JVFxyXG4qKi9cclxuaW1wb3J0IHsgaGFzQ2hhbmdlZCwgZXh0ZW5kLCBpc0FycmF5LCBpc0ludGVnZXJLZXksIGlzU3ltYm9sLCBpc01hcCwgaGFzT3duLCBpc09iamVjdCwgbWFrZU1hcCwgdG9SYXdUeXBlLCBjYXBpdGFsaXplLCBkZWYsIGlzRnVuY3Rpb24sIEVNUFRZX09CSiwgaXNTZXQsIGlzUGxhaW5PYmplY3QsIE5PT1AsIHJlbW92ZSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcclxuXHJcbmZ1bmN0aW9uIHdhcm4obXNnLCAuLi5hcmdzKSB7XHJcbiAgY29uc29sZS53YXJuKGBbVnVlIHdhcm5dICR7bXNnfWAsIC4uLmFyZ3MpO1xyXG59XHJcblxyXG5sZXQgYWN0aXZlRWZmZWN0U2NvcGU7XHJcbmNsYXNzIEVmZmVjdFNjb3BlIHtcclxuICBjb25zdHJ1Y3RvcihkZXRhY2hlZCA9IGZhbHNlKSB7XHJcbiAgICB0aGlzLmRldGFjaGVkID0gZGV0YWNoZWQ7XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgdGhpcy5lZmZlY3RzID0gW107XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICB0aGlzLmNsZWFudXBzID0gW107XHJcbiAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5wYXJlbnQgPSBhY3RpdmVFZmZlY3RTY29wZTtcclxuICAgIGlmICghZGV0YWNoZWQgJiYgYWN0aXZlRWZmZWN0U2NvcGUpIHtcclxuICAgICAgdGhpcy5pbmRleCA9IChhY3RpdmVFZmZlY3RTY29wZS5zY29wZXMgfHwgKGFjdGl2ZUVmZmVjdFNjb3BlLnNjb3BlcyA9IFtdKSkucHVzaChcclxuICAgICAgICB0aGlzXHJcbiAgICAgICkgLSAxO1xyXG4gICAgfVxyXG4gIH1cclxuICBnZXQgYWN0aXZlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcclxuICB9XHJcbiAgcGF1c2UoKSB7XHJcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XHJcbiAgICAgIHRoaXMuX2lzUGF1c2VkID0gdHJ1ZTtcclxuICAgICAgbGV0IGksIGw7XHJcbiAgICAgIGlmICh0aGlzLnNjb3Blcykge1xyXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLnNjb3Blcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgIHRoaXMuc2NvcGVzW2ldLnBhdXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmVmZmVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5lZmZlY3RzW2ldLnBhdXNlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgICogUmVzdW1lcyB0aGUgZWZmZWN0IHNjb3BlLCBpbmNsdWRpbmcgYWxsIGNoaWxkIHNjb3BlcyBhbmQgZWZmZWN0cy5cclxuICAgKi9cclxuICByZXN1bWUoKSB7XHJcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XHJcbiAgICAgIGlmICh0aGlzLl9pc1BhdXNlZCkge1xyXG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IGksIGw7XHJcbiAgICAgICAgaWYgKHRoaXMuc2NvcGVzKSB7XHJcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5zY29wZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2NvcGVzW2ldLnJlc3VtZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5lZmZlY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgdGhpcy5lZmZlY3RzW2ldLnJlc3VtZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBydW4oZm4pIHtcclxuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcclxuICAgICAgY29uc3QgY3VycmVudEVmZmVjdFNjb3BlID0gYWN0aXZlRWZmZWN0U2NvcGU7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBmbigpO1xyXG4gICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gY3VycmVudEVmZmVjdFNjb3BlO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgd2FybihgY2Fubm90IHJ1biBhbiBpbmFjdGl2ZSBlZmZlY3Qgc2NvcGUuYCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIG5vbi1kZXRhY2hlZCBzY29wZXNcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBvbigpIHtcclxuICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcztcclxuICB9XHJcbiAgLyoqXHJcbiAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIG9mZigpIHtcclxuICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcy5wYXJlbnQ7XHJcbiAgfVxyXG4gIHN0b3AoZnJvbVBhcmVudCkge1xyXG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xyXG4gICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgbGV0IGksIGw7XHJcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmVmZmVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5lZmZlY3RzW2ldLnN0b3AoKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmVmZmVjdHMubGVuZ3RoID0gMDtcclxuICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2xlYW51cHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhbnVwc1tpXSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuY2xlYW51cHMubGVuZ3RoID0gMDtcclxuICAgICAgaWYgKHRoaXMuc2NvcGVzKSB7XHJcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuc2NvcGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgdGhpcy5zY29wZXNbaV0uc3RvcCh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zY29wZXMubGVuZ3RoID0gMDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIXRoaXMuZGV0YWNoZWQgJiYgdGhpcy5wYXJlbnQgJiYgIWZyb21QYXJlbnQpIHtcclxuICAgICAgICBjb25zdCBsYXN0ID0gdGhpcy5wYXJlbnQuc2NvcGVzLnBvcCgpO1xyXG4gICAgICAgIGlmIChsYXN0ICYmIGxhc3QgIT09IHRoaXMpIHtcclxuICAgICAgICAgIHRoaXMucGFyZW50LnNjb3Blc1t0aGlzLmluZGV4XSA9IGxhc3Q7XHJcbiAgICAgICAgICBsYXN0LmluZGV4ID0gdGhpcy5pbmRleDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5wYXJlbnQgPSB2b2lkIDA7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGVmZmVjdFNjb3BlKGRldGFjaGVkKSB7XHJcbiAgcmV0dXJuIG5ldyBFZmZlY3RTY29wZShkZXRhY2hlZCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q3VycmVudFNjb3BlKCkge1xyXG4gIHJldHVybiBhY3RpdmVFZmZlY3RTY29wZTtcclxufVxyXG5mdW5jdGlvbiBvblNjb3BlRGlzcG9zZShmbiwgZmFpbFNpbGVudGx5ID0gZmFsc2UpIHtcclxuICBpZiAoYWN0aXZlRWZmZWN0U2NvcGUpIHtcclxuICAgIGFjdGl2ZUVmZmVjdFNjb3BlLmNsZWFudXBzLnB1c2goZm4pO1xyXG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhZmFpbFNpbGVudGx5KSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICBgb25TY29wZURpc3Bvc2UoKSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgZWZmZWN0IHNjb3BlIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC5gXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxubGV0IGFjdGl2ZVN1YjtcclxuY29uc3QgRWZmZWN0RmxhZ3MgPSB7XHJcbiAgXCJBQ1RJVkVcIjogMSxcclxuICBcIjFcIjogXCJBQ1RJVkVcIixcclxuICBcIlJVTk5JTkdcIjogMixcclxuICBcIjJcIjogXCJSVU5OSU5HXCIsXHJcbiAgXCJUUkFDS0lOR1wiOiA0LFxyXG4gIFwiNFwiOiBcIlRSQUNLSU5HXCIsXHJcbiAgXCJOT1RJRklFRFwiOiA4LFxyXG4gIFwiOFwiOiBcIk5PVElGSUVEXCIsXHJcbiAgXCJESVJUWVwiOiAxNixcclxuICBcIjE2XCI6IFwiRElSVFlcIixcclxuICBcIkFMTE9XX1JFQ1VSU0VcIjogMzIsXHJcbiAgXCIzMlwiOiBcIkFMTE9XX1JFQ1VSU0VcIixcclxuICBcIlBBVVNFRFwiOiA2NCxcclxuICBcIjY0XCI6IFwiUEFVU0VEXCJcclxufTtcclxuY29uc3QgcGF1c2VkUXVldWVFZmZlY3RzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XHJcbmNsYXNzIFJlYWN0aXZlRWZmZWN0IHtcclxuICBjb25zdHJ1Y3Rvcihmbikge1xyXG4gICAgdGhpcy5mbiA9IGZuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgdGhpcy5kZXBzID0gdm9pZCAwO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgdGhpcy5kZXBzVGFpbCA9IHZvaWQgMDtcclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZmxhZ3MgPSAxIHwgNDtcclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHRoaXMubmV4dCA9IHZvaWQgMDtcclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2xlYW51cCA9IHZvaWQgMDtcclxuICAgIHRoaXMuc2NoZWR1bGVyID0gdm9pZCAwO1xyXG4gICAgaWYgKGFjdGl2ZUVmZmVjdFNjb3BlICYmIGFjdGl2ZUVmZmVjdFNjb3BlLmFjdGl2ZSkge1xyXG4gICAgICBhY3RpdmVFZmZlY3RTY29wZS5lZmZlY3RzLnB1c2godGhpcyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHBhdXNlKCkge1xyXG4gICAgdGhpcy5mbGFncyB8PSA2NDtcclxuICB9XHJcbiAgcmVzdW1lKCkge1xyXG4gICAgaWYgKHRoaXMuZmxhZ3MgJiA2NCkge1xyXG4gICAgICB0aGlzLmZsYWdzICY9IH42NDtcclxuICAgICAgaWYgKHBhdXNlZFF1ZXVlRWZmZWN0cy5oYXModGhpcykpIHtcclxuICAgICAgICBwYXVzZWRRdWV1ZUVmZmVjdHMuZGVsZXRlKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcigpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIG5vdGlmeSgpIHtcclxuICAgIGlmICh0aGlzLmZsYWdzICYgMiAmJiAhKHRoaXMuZmxhZ3MgJiAzMikpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKCEodGhpcy5mbGFncyAmIDgpKSB7XHJcbiAgICAgIGJhdGNoKHRoaXMpO1xyXG4gICAgfVxyXG4gIH1cclxuICBydW4oKSB7XHJcbiAgICBpZiAoISh0aGlzLmZsYWdzICYgMSkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZm4oKTtcclxuICAgIH1cclxuICAgIHRoaXMuZmxhZ3MgfD0gMjtcclxuICAgIGNsZWFudXBFZmZlY3QodGhpcyk7XHJcbiAgICBwcmVwYXJlRGVwcyh0aGlzKTtcclxuICAgIGNvbnN0IHByZXZFZmZlY3QgPSBhY3RpdmVTdWI7XHJcbiAgICBjb25zdCBwcmV2U2hvdWxkVHJhY2sgPSBzaG91bGRUcmFjaztcclxuICAgIGFjdGl2ZVN1YiA9IHRoaXM7XHJcbiAgICBzaG91bGRUcmFjayA9IHRydWU7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gdGhpcy5mbigpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgYWN0aXZlU3ViICE9PSB0aGlzKSB7XHJcbiAgICAgICAgd2FybihcclxuICAgICAgICAgIFwiQWN0aXZlIGVmZmVjdCB3YXMgbm90IHJlc3RvcmVkIGNvcnJlY3RseSAtIHRoaXMgaXMgbGlrZWx5IGEgVnVlIGludGVybmFsIGJ1Zy5cIlxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgY2xlYW51cERlcHModGhpcyk7XHJcbiAgICAgIGFjdGl2ZVN1YiA9IHByZXZFZmZlY3Q7XHJcbiAgICAgIHNob3VsZFRyYWNrID0gcHJldlNob3VsZFRyYWNrO1xyXG4gICAgICB0aGlzLmZsYWdzICY9IH4yO1xyXG4gICAgfVxyXG4gIH1cclxuICBzdG9wKCkge1xyXG4gICAgaWYgKHRoaXMuZmxhZ3MgJiAxKSB7XHJcbiAgICAgIGZvciAobGV0IGxpbmsgPSB0aGlzLmRlcHM7IGxpbms7IGxpbmsgPSBsaW5rLm5leHREZXApIHtcclxuICAgICAgICByZW1vdmVTdWIobGluayk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5kZXBzID0gdGhpcy5kZXBzVGFpbCA9IHZvaWQgMDtcclxuICAgICAgY2xlYW51cEVmZmVjdCh0aGlzKTtcclxuICAgICAgdGhpcy5vblN0b3AgJiYgdGhpcy5vblN0b3AoKTtcclxuICAgICAgdGhpcy5mbGFncyAmPSB+MTtcclxuICAgIH1cclxuICB9XHJcbiAgdHJpZ2dlcigpIHtcclxuICAgIGlmICh0aGlzLmZsYWdzICYgNjQpIHtcclxuICAgICAgcGF1c2VkUXVldWVFZmZlY3RzLmFkZCh0aGlzKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5zY2hlZHVsZXIpIHtcclxuICAgICAgdGhpcy5zY2hlZHVsZXIoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMucnVuSWZEaXJ0eSgpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBydW5JZkRpcnR5KCkge1xyXG4gICAgaWYgKGlzRGlydHkodGhpcykpIHtcclxuICAgICAgdGhpcy5ydW4oKTtcclxuICAgIH1cclxuICB9XHJcbiAgZ2V0IGRpcnR5KCkge1xyXG4gICAgcmV0dXJuIGlzRGlydHkodGhpcyk7XHJcbiAgfVxyXG59XHJcbmxldCBiYXRjaERlcHRoID0gMDtcclxubGV0IGJhdGNoZWRTdWI7XHJcbmxldCBiYXRjaGVkQ29tcHV0ZWQ7XHJcbmZ1bmN0aW9uIGJhdGNoKHN1YiwgaXNDb21wdXRlZCA9IGZhbHNlKSB7XHJcbiAgc3ViLmZsYWdzIHw9IDg7XHJcbiAgaWYgKGlzQ29tcHV0ZWQpIHtcclxuICAgIHN1Yi5uZXh0ID0gYmF0Y2hlZENvbXB1dGVkO1xyXG4gICAgYmF0Y2hlZENvbXB1dGVkID0gc3ViO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBzdWIubmV4dCA9IGJhdGNoZWRTdWI7XHJcbiAgYmF0Y2hlZFN1YiA9IHN1YjtcclxufVxyXG5mdW5jdGlvbiBzdGFydEJhdGNoKCkge1xyXG4gIGJhdGNoRGVwdGgrKztcclxufVxyXG5mdW5jdGlvbiBlbmRCYXRjaCgpIHtcclxuICBpZiAoLS1iYXRjaERlcHRoID4gMCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAoYmF0Y2hlZENvbXB1dGVkKSB7XHJcbiAgICBsZXQgZSA9IGJhdGNoZWRDb21wdXRlZDtcclxuICAgIGJhdGNoZWRDb21wdXRlZCA9IHZvaWQgMDtcclxuICAgIHdoaWxlIChlKSB7XHJcbiAgICAgIGNvbnN0IG5leHQgPSBlLm5leHQ7XHJcbiAgICAgIGUubmV4dCA9IHZvaWQgMDtcclxuICAgICAgZS5mbGFncyAmPSB+ODtcclxuICAgICAgZSA9IG5leHQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGxldCBlcnJvcjtcclxuICB3aGlsZSAoYmF0Y2hlZFN1Yikge1xyXG4gICAgbGV0IGUgPSBiYXRjaGVkU3ViO1xyXG4gICAgYmF0Y2hlZFN1YiA9IHZvaWQgMDtcclxuICAgIHdoaWxlIChlKSB7XHJcbiAgICAgIGNvbnN0IG5leHQgPSBlLm5leHQ7XHJcbiAgICAgIGUubmV4dCA9IHZvaWQgMDtcclxuICAgICAgZS5mbGFncyAmPSB+ODtcclxuICAgICAgaWYgKGUuZmxhZ3MgJiAxKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIDtcclxuICAgICAgICAgIGUudHJpZ2dlcigpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgaWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGUgPSBuZXh0O1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG59XHJcbmZ1bmN0aW9uIHByZXBhcmVEZXBzKHN1Yikge1xyXG4gIGZvciAobGV0IGxpbmsgPSBzdWIuZGVwczsgbGluazsgbGluayA9IGxpbmsubmV4dERlcCkge1xyXG4gICAgbGluay52ZXJzaW9uID0gLTE7XHJcbiAgICBsaW5rLnByZXZBY3RpdmVMaW5rID0gbGluay5kZXAuYWN0aXZlTGluaztcclxuICAgIGxpbmsuZGVwLmFjdGl2ZUxpbmsgPSBsaW5rO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBjbGVhbnVwRGVwcyhzdWIpIHtcclxuICBsZXQgaGVhZDtcclxuICBsZXQgdGFpbCA9IHN1Yi5kZXBzVGFpbDtcclxuICBsZXQgbGluayA9IHRhaWw7XHJcbiAgd2hpbGUgKGxpbmspIHtcclxuICAgIGNvbnN0IHByZXYgPSBsaW5rLnByZXZEZXA7XHJcbiAgICBpZiAobGluay52ZXJzaW9uID09PSAtMSkge1xyXG4gICAgICBpZiAobGluayA9PT0gdGFpbCkgdGFpbCA9IHByZXY7XHJcbiAgICAgIHJlbW92ZVN1YihsaW5rKTtcclxuICAgICAgcmVtb3ZlRGVwKGxpbmspO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaGVhZCA9IGxpbms7XHJcbiAgICB9XHJcbiAgICBsaW5rLmRlcC5hY3RpdmVMaW5rID0gbGluay5wcmV2QWN0aXZlTGluaztcclxuICAgIGxpbmsucHJldkFjdGl2ZUxpbmsgPSB2b2lkIDA7XHJcbiAgICBsaW5rID0gcHJldjtcclxuICB9XHJcbiAgc3ViLmRlcHMgPSBoZWFkO1xyXG4gIHN1Yi5kZXBzVGFpbCA9IHRhaWw7XHJcbn1cclxuZnVuY3Rpb24gaXNEaXJ0eShzdWIpIHtcclxuICBmb3IgKGxldCBsaW5rID0gc3ViLmRlcHM7IGxpbms7IGxpbmsgPSBsaW5rLm5leHREZXApIHtcclxuICAgIGlmIChsaW5rLmRlcC52ZXJzaW9uICE9PSBsaW5rLnZlcnNpb24gfHwgbGluay5kZXAuY29tcHV0ZWQgJiYgKHJlZnJlc2hDb21wdXRlZChsaW5rLmRlcC5jb21wdXRlZCkgfHwgbGluay5kZXAudmVyc2lvbiAhPT0gbGluay52ZXJzaW9uKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKHN1Yi5fZGlydHkpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gcmVmcmVzaENvbXB1dGVkKGNvbXB1dGVkKSB7XHJcbiAgaWYgKGNvbXB1dGVkLmZsYWdzICYgNCAmJiAhKGNvbXB1dGVkLmZsYWdzICYgMTYpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGNvbXB1dGVkLmZsYWdzICY9IH4xNjtcclxuICBpZiAoY29tcHV0ZWQuZ2xvYmFsVmVyc2lvbiA9PT0gZ2xvYmFsVmVyc2lvbikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBjb21wdXRlZC5nbG9iYWxWZXJzaW9uID0gZ2xvYmFsVmVyc2lvbjtcclxuICBjb25zdCBkZXAgPSBjb21wdXRlZC5kZXA7XHJcbiAgY29tcHV0ZWQuZmxhZ3MgfD0gMjtcclxuICBpZiAoZGVwLnZlcnNpb24gPiAwICYmICFjb21wdXRlZC5pc1NTUiAmJiBjb21wdXRlZC5kZXBzICYmICFpc0RpcnR5KGNvbXB1dGVkKSkge1xyXG4gICAgY29tcHV0ZWQuZmxhZ3MgJj0gfjI7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGNvbnN0IHByZXZTdWIgPSBhY3RpdmVTdWI7XHJcbiAgY29uc3QgcHJldlNob3VsZFRyYWNrID0gc2hvdWxkVHJhY2s7XHJcbiAgYWN0aXZlU3ViID0gY29tcHV0ZWQ7XHJcbiAgc2hvdWxkVHJhY2sgPSB0cnVlO1xyXG4gIHRyeSB7XHJcbiAgICBwcmVwYXJlRGVwcyhjb21wdXRlZCk7XHJcbiAgICBjb25zdCB2YWx1ZSA9IGNvbXB1dGVkLmZuKGNvbXB1dGVkLl92YWx1ZSk7XHJcbiAgICBpZiAoZGVwLnZlcnNpb24gPT09IDAgfHwgaGFzQ2hhbmdlZCh2YWx1ZSwgY29tcHV0ZWQuX3ZhbHVlKSkge1xyXG4gICAgICBjb21wdXRlZC5fdmFsdWUgPSB2YWx1ZTtcclxuICAgICAgZGVwLnZlcnNpb24rKztcclxuICAgIH1cclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGRlcC52ZXJzaW9uKys7XHJcbiAgICB0aHJvdyBlcnI7XHJcbiAgfSBmaW5hbGx5IHtcclxuICAgIGFjdGl2ZVN1YiA9IHByZXZTdWI7XHJcbiAgICBzaG91bGRUcmFjayA9IHByZXZTaG91bGRUcmFjaztcclxuICAgIGNsZWFudXBEZXBzKGNvbXB1dGVkKTtcclxuICAgIGNvbXB1dGVkLmZsYWdzICY9IH4yO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiByZW1vdmVTdWIobGluaywgc29mdCA9IGZhbHNlKSB7XHJcbiAgY29uc3QgeyBkZXAsIHByZXZTdWIsIG5leHRTdWIgfSA9IGxpbms7XHJcbiAgaWYgKHByZXZTdWIpIHtcclxuICAgIHByZXZTdWIubmV4dFN1YiA9IG5leHRTdWI7XHJcbiAgICBsaW5rLnByZXZTdWIgPSB2b2lkIDA7XHJcbiAgfVxyXG4gIGlmIChuZXh0U3ViKSB7XHJcbiAgICBuZXh0U3ViLnByZXZTdWIgPSBwcmV2U3ViO1xyXG4gICAgbGluay5uZXh0U3ViID0gdm9pZCAwO1xyXG4gIH1cclxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBkZXAuc3Vic0hlYWQgPT09IGxpbmspIHtcclxuICAgIGRlcC5zdWJzSGVhZCA9IG5leHRTdWI7XHJcbiAgfVxyXG4gIGlmIChkZXAuc3VicyA9PT0gbGluaykge1xyXG4gICAgZGVwLnN1YnMgPSBwcmV2U3ViO1xyXG4gICAgaWYgKCFwcmV2U3ViICYmIGRlcC5jb21wdXRlZCkge1xyXG4gICAgICBkZXAuY29tcHV0ZWQuZmxhZ3MgJj0gfjQ7XHJcbiAgICAgIGZvciAobGV0IGwgPSBkZXAuY29tcHV0ZWQuZGVwczsgbDsgbCA9IGwubmV4dERlcCkge1xyXG4gICAgICAgIHJlbW92ZVN1YihsLCB0cnVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoIXNvZnQgJiYgIS0tZGVwLnNjICYmIGRlcC5tYXApIHtcclxuICAgIGRlcC5tYXAuZGVsZXRlKGRlcC5rZXkpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiByZW1vdmVEZXAobGluaykge1xyXG4gIGNvbnN0IHsgcHJldkRlcCwgbmV4dERlcCB9ID0gbGluaztcclxuICBpZiAocHJldkRlcCkge1xyXG4gICAgcHJldkRlcC5uZXh0RGVwID0gbmV4dERlcDtcclxuICAgIGxpbmsucHJldkRlcCA9IHZvaWQgMDtcclxuICB9XHJcbiAgaWYgKG5leHREZXApIHtcclxuICAgIG5leHREZXAucHJldkRlcCA9IHByZXZEZXA7XHJcbiAgICBsaW5rLm5leHREZXAgPSB2b2lkIDA7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGVmZmVjdChmbiwgb3B0aW9ucykge1xyXG4gIGlmIChmbi5lZmZlY3QgaW5zdGFuY2VvZiBSZWFjdGl2ZUVmZmVjdCkge1xyXG4gICAgZm4gPSBmbi5lZmZlY3QuZm47XHJcbiAgfVxyXG4gIGNvbnN0IGUgPSBuZXcgUmVhY3RpdmVFZmZlY3QoZm4pO1xyXG4gIGlmIChvcHRpb25zKSB7XHJcbiAgICBleHRlbmQoZSwgb3B0aW9ucyk7XHJcbiAgfVxyXG4gIHRyeSB7XHJcbiAgICBlLnJ1bigpO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgZS5zdG9wKCk7XHJcbiAgICB0aHJvdyBlcnI7XHJcbiAgfVxyXG4gIGNvbnN0IHJ1bm5lciA9IGUucnVuLmJpbmQoZSk7XHJcbiAgcnVubmVyLmVmZmVjdCA9IGU7XHJcbiAgcmV0dXJuIHJ1bm5lcjtcclxufVxyXG5mdW5jdGlvbiBzdG9wKHJ1bm5lcikge1xyXG4gIHJ1bm5lci5lZmZlY3Quc3RvcCgpO1xyXG59XHJcbmxldCBzaG91bGRUcmFjayA9IHRydWU7XHJcbmNvbnN0IHRyYWNrU3RhY2sgPSBbXTtcclxuZnVuY3Rpb24gcGF1c2VUcmFja2luZygpIHtcclxuICB0cmFja1N0YWNrLnB1c2goc2hvdWxkVHJhY2spO1xyXG4gIHNob3VsZFRyYWNrID0gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gZW5hYmxlVHJhY2tpbmcoKSB7XHJcbiAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcclxuICBzaG91bGRUcmFjayA9IHRydWU7XHJcbn1cclxuZnVuY3Rpb24gcmVzZXRUcmFja2luZygpIHtcclxuICBjb25zdCBsYXN0ID0gdHJhY2tTdGFjay5wb3AoKTtcclxuICBzaG91bGRUcmFjayA9IGxhc3QgPT09IHZvaWQgMCA/IHRydWUgOiBsYXN0O1xyXG59XHJcbmZ1bmN0aW9uIG9uRWZmZWN0Q2xlYW51cChmbiwgZmFpbFNpbGVudGx5ID0gZmFsc2UpIHtcclxuICBpZiAoYWN0aXZlU3ViIGluc3RhbmNlb2YgUmVhY3RpdmVFZmZlY3QpIHtcclxuICAgIGFjdGl2ZVN1Yi5jbGVhbnVwID0gZm47XHJcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFmYWlsU2lsZW50bHkpIHtcclxuICAgIHdhcm4oXHJcbiAgICAgIGBvbkVmZmVjdENsZWFudXAoKSB3YXMgY2FsbGVkIHdoZW4gdGhlcmUgd2FzIG5vIGFjdGl2ZSBlZmZlY3QgdG8gYXNzb2NpYXRlIHdpdGguYFxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gY2xlYW51cEVmZmVjdChlKSB7XHJcbiAgY29uc3QgeyBjbGVhbnVwIH0gPSBlO1xyXG4gIGUuY2xlYW51cCA9IHZvaWQgMDtcclxuICBpZiAoY2xlYW51cCkge1xyXG4gICAgY29uc3QgcHJldlN1YiA9IGFjdGl2ZVN1YjtcclxuICAgIGFjdGl2ZVN1YiA9IHZvaWQgMDtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNsZWFudXAoKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIGFjdGl2ZVN1YiA9IHByZXZTdWI7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5sZXQgZ2xvYmFsVmVyc2lvbiA9IDA7XHJcbmNsYXNzIExpbmsge1xyXG4gIGNvbnN0cnVjdG9yKHN1YiwgZGVwKSB7XHJcbiAgICB0aGlzLnN1YiA9IHN1YjtcclxuICAgIHRoaXMuZGVwID0gZGVwO1xyXG4gICAgdGhpcy52ZXJzaW9uID0gZGVwLnZlcnNpb247XHJcbiAgICB0aGlzLm5leHREZXAgPSB0aGlzLnByZXZEZXAgPSB0aGlzLm5leHRTdWIgPSB0aGlzLnByZXZTdWIgPSB0aGlzLnByZXZBY3RpdmVMaW5rID0gdm9pZCAwO1xyXG4gIH1cclxufVxyXG5jbGFzcyBEZXAge1xyXG4gIGNvbnN0cnVjdG9yKGNvbXB1dGVkKSB7XHJcbiAgICB0aGlzLmNvbXB1dGVkID0gY29tcHV0ZWQ7XHJcbiAgICB0aGlzLnZlcnNpb24gPSAwO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5rIGJldHdlZW4gdGhpcyBkZXAgYW5kIHRoZSBjdXJyZW50IGFjdGl2ZSBlZmZlY3RcclxuICAgICAqL1xyXG4gICAgdGhpcy5hY3RpdmVMaW5rID0gdm9pZCAwO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEb3VibHkgbGlua2VkIGxpc3QgcmVwcmVzZW50aW5nIHRoZSBzdWJzY3JpYmluZyBlZmZlY3RzICh0YWlsKVxyXG4gICAgICovXHJcbiAgICB0aGlzLnN1YnMgPSB2b2lkIDA7XHJcbiAgICAvKipcclxuICAgICAqIEZvciBvYmplY3QgcHJvcGVydHkgZGVwcyBjbGVhbnVwXHJcbiAgICAgKi9cclxuICAgIHRoaXMubWFwID0gdm9pZCAwO1xyXG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZXIgY291bnRlclxyXG4gICAgICovXHJcbiAgICB0aGlzLnNjID0gMDtcclxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgIHRoaXMuc3Vic0hlYWQgPSB2b2lkIDA7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHRyYWNrKGRlYnVnSW5mbykge1xyXG4gICAgaWYgKCFhY3RpdmVTdWIgfHwgIXNob3VsZFRyYWNrIHx8IGFjdGl2ZVN1YiA9PT0gdGhpcy5jb21wdXRlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgbGluayA9IHRoaXMuYWN0aXZlTGluaztcclxuICAgIGlmIChsaW5rID09PSB2b2lkIDAgfHwgbGluay5zdWIgIT09IGFjdGl2ZVN1Yikge1xyXG4gICAgICBsaW5rID0gdGhpcy5hY3RpdmVMaW5rID0gbmV3IExpbmsoYWN0aXZlU3ViLCB0aGlzKTtcclxuICAgICAgaWYgKCFhY3RpdmVTdWIuZGVwcykge1xyXG4gICAgICAgIGFjdGl2ZVN1Yi5kZXBzID0gYWN0aXZlU3ViLmRlcHNUYWlsID0gbGluaztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsaW5rLnByZXZEZXAgPSBhY3RpdmVTdWIuZGVwc1RhaWw7XHJcbiAgICAgICAgYWN0aXZlU3ViLmRlcHNUYWlsLm5leHREZXAgPSBsaW5rO1xyXG4gICAgICAgIGFjdGl2ZVN1Yi5kZXBzVGFpbCA9IGxpbms7XHJcbiAgICAgIH1cclxuICAgICAgYWRkU3ViKGxpbmspO1xyXG4gICAgfSBlbHNlIGlmIChsaW5rLnZlcnNpb24gPT09IC0xKSB7XHJcbiAgICAgIGxpbmsudmVyc2lvbiA9IHRoaXMudmVyc2lvbjtcclxuICAgICAgaWYgKGxpbmsubmV4dERlcCkge1xyXG4gICAgICAgIGNvbnN0IG5leHQgPSBsaW5rLm5leHREZXA7XHJcbiAgICAgICAgbmV4dC5wcmV2RGVwID0gbGluay5wcmV2RGVwO1xyXG4gICAgICAgIGlmIChsaW5rLnByZXZEZXApIHtcclxuICAgICAgICAgIGxpbmsucHJldkRlcC5uZXh0RGVwID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGluay5wcmV2RGVwID0gYWN0aXZlU3ViLmRlcHNUYWlsO1xyXG4gICAgICAgIGxpbmsubmV4dERlcCA9IHZvaWQgMDtcclxuICAgICAgICBhY3RpdmVTdWIuZGVwc1RhaWwubmV4dERlcCA9IGxpbms7XHJcbiAgICAgICAgYWN0aXZlU3ViLmRlcHNUYWlsID0gbGluaztcclxuICAgICAgICBpZiAoYWN0aXZlU3ViLmRlcHMgPT09IGxpbmspIHtcclxuICAgICAgICAgIGFjdGl2ZVN1Yi5kZXBzID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGFjdGl2ZVN1Yi5vblRyYWNrKSB7XHJcbiAgICAgIGFjdGl2ZVN1Yi5vblRyYWNrKFxyXG4gICAgICAgIGV4dGVuZChcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgZWZmZWN0OiBhY3RpdmVTdWJcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkZWJ1Z0luZm9cclxuICAgICAgICApXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGluaztcclxuICB9XHJcbiAgdHJpZ2dlcihkZWJ1Z0luZm8pIHtcclxuICAgIHRoaXMudmVyc2lvbisrO1xyXG4gICAgZ2xvYmFsVmVyc2lvbisrO1xyXG4gICAgdGhpcy5ub3RpZnkoZGVidWdJbmZvKTtcclxuICB9XHJcbiAgbm90aWZ5KGRlYnVnSW5mbykge1xyXG4gICAgc3RhcnRCYXRjaCgpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgICBmb3IgKGxldCBoZWFkID0gdGhpcy5zdWJzSGVhZDsgaGVhZDsgaGVhZCA9IGhlYWQubmV4dFN1Yikge1xyXG4gICAgICAgICAgaWYgKGhlYWQuc3ViLm9uVHJpZ2dlciAmJiAhKGhlYWQuc3ViLmZsYWdzICYgOCkpIHtcclxuICAgICAgICAgICAgaGVhZC5zdWIub25UcmlnZ2VyKFxyXG4gICAgICAgICAgICAgIGV4dGVuZChcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgZWZmZWN0OiBoZWFkLnN1YlxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGRlYnVnSW5mb1xyXG4gICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChsZXQgbGluayA9IHRoaXMuc3ViczsgbGluazsgbGluayA9IGxpbmsucHJldlN1Yikge1xyXG4gICAgICAgIGlmIChsaW5rLnN1Yi5ub3RpZnkoKSkge1xyXG4gICAgICAgICAgO1xyXG4gICAgICAgICAgbGluay5zdWIuZGVwLm5vdGlmeSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgZW5kQmF0Y2goKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZnVuY3Rpb24gYWRkU3ViKGxpbmspIHtcclxuICBsaW5rLmRlcC5zYysrO1xyXG4gIGlmIChsaW5rLnN1Yi5mbGFncyAmIDQpIHtcclxuICAgIGNvbnN0IGNvbXB1dGVkID0gbGluay5kZXAuY29tcHV0ZWQ7XHJcbiAgICBpZiAoY29tcHV0ZWQgJiYgIWxpbmsuZGVwLnN1YnMpIHtcclxuICAgICAgY29tcHV0ZWQuZmxhZ3MgfD0gNCB8IDE2O1xyXG4gICAgICBmb3IgKGxldCBsID0gY29tcHV0ZWQuZGVwczsgbDsgbCA9IGwubmV4dERlcCkge1xyXG4gICAgICAgIGFkZFN1YihsKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgY3VycmVudFRhaWwgPSBsaW5rLmRlcC5zdWJzO1xyXG4gICAgaWYgKGN1cnJlbnRUYWlsICE9PSBsaW5rKSB7XHJcbiAgICAgIGxpbmsucHJldlN1YiA9IGN1cnJlbnRUYWlsO1xyXG4gICAgICBpZiAoY3VycmVudFRhaWwpIGN1cnJlbnRUYWlsLm5leHRTdWIgPSBsaW5rO1xyXG4gICAgfVxyXG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbGluay5kZXAuc3Vic0hlYWQgPT09IHZvaWQgMCkge1xyXG4gICAgICBsaW5rLmRlcC5zdWJzSGVhZCA9IGxpbms7XHJcbiAgICB9XHJcbiAgICBsaW5rLmRlcC5zdWJzID0gbGluaztcclxuICB9XHJcbn1cclxuY29uc3QgdGFyZ2V0TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IElURVJBVEVfS0VZID0gU3ltYm9sKFxyXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBcIk9iamVjdCBpdGVyYXRlXCIgOiBcIlwiXHJcbik7XHJcbmNvbnN0IE1BUF9LRVlfSVRFUkFURV9LRVkgPSBTeW1ib2woXHJcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IFwiTWFwIGtleXMgaXRlcmF0ZVwiIDogXCJcIlxyXG4pO1xyXG5jb25zdCBBUlJBWV9JVEVSQVRFX0tFWSA9IFN5bWJvbChcclxuICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gXCJBcnJheSBpdGVyYXRlXCIgOiBcIlwiXHJcbik7XHJcbmZ1bmN0aW9uIHRyYWNrKHRhcmdldCwgdHlwZSwga2V5KSB7XHJcbiAgaWYgKHNob3VsZFRyYWNrICYmIGFjdGl2ZVN1Yikge1xyXG4gICAgbGV0IGRlcHNNYXAgPSB0YXJnZXRNYXAuZ2V0KHRhcmdldCk7XHJcbiAgICBpZiAoIWRlcHNNYXApIHtcclxuICAgICAgdGFyZ2V0TWFwLnNldCh0YXJnZXQsIGRlcHNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcclxuICAgIH1cclxuICAgIGxldCBkZXAgPSBkZXBzTWFwLmdldChrZXkpO1xyXG4gICAgaWYgKCFkZXApIHtcclxuICAgICAgZGVwc01hcC5zZXQoa2V5LCBkZXAgPSBuZXcgRGVwKCkpO1xyXG4gICAgICBkZXAubWFwID0gZGVwc01hcDtcclxuICAgICAgZGVwLmtleSA9IGtleTtcclxuICAgIH1cclxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgIGRlcC50cmFjayh7XHJcbiAgICAgICAgdGFyZ2V0LFxyXG4gICAgICAgIHR5cGUsXHJcbiAgICAgICAga2V5XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZGVwLnRyYWNrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyaWdnZXIodGFyZ2V0LCB0eXBlLCBrZXksIG5ld1ZhbHVlLCBvbGRWYWx1ZSwgb2xkVGFyZ2V0KSB7XHJcbiAgY29uc3QgZGVwc01hcCA9IHRhcmdldE1hcC5nZXQodGFyZ2V0KTtcclxuICBpZiAoIWRlcHNNYXApIHtcclxuICAgIGdsb2JhbFZlcnNpb24rKztcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgY29uc3QgcnVuID0gKGRlcCkgPT4ge1xyXG4gICAgaWYgKGRlcCkge1xyXG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICAgIGRlcC50cmlnZ2VyKHtcclxuICAgICAgICAgIHRhcmdldCxcclxuICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICBrZXksXHJcbiAgICAgICAgICBuZXdWYWx1ZSxcclxuICAgICAgICAgIG9sZFZhbHVlLFxyXG4gICAgICAgICAgb2xkVGFyZ2V0XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGVwLnRyaWdnZXIoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcbiAgc3RhcnRCYXRjaCgpO1xyXG4gIGlmICh0eXBlID09PSBcImNsZWFyXCIpIHtcclxuICAgIGRlcHNNYXAuZm9yRWFjaChydW4pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdCB0YXJnZXRJc0FycmF5ID0gaXNBcnJheSh0YXJnZXQpO1xyXG4gICAgY29uc3QgaXNBcnJheUluZGV4ID0gdGFyZ2V0SXNBcnJheSAmJiBpc0ludGVnZXJLZXkoa2V5KTtcclxuICAgIGlmICh0YXJnZXRJc0FycmF5ICYmIGtleSA9PT0gXCJsZW5ndGhcIikge1xyXG4gICAgICBjb25zdCBuZXdMZW5ndGggPSBOdW1iZXIobmV3VmFsdWUpO1xyXG4gICAgICBkZXBzTWFwLmZvckVhY2goKGRlcCwga2V5MikgPT4ge1xyXG4gICAgICAgIGlmIChrZXkyID09PSBcImxlbmd0aFwiIHx8IGtleTIgPT09IEFSUkFZX0lURVJBVEVfS0VZIHx8ICFpc1N5bWJvbChrZXkyKSAmJiBrZXkyID49IG5ld0xlbmd0aCkge1xyXG4gICAgICAgICAgcnVuKGRlcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChrZXkgIT09IHZvaWQgMCB8fCBkZXBzTWFwLmhhcyh2b2lkIDApKSB7XHJcbiAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KGtleSkpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc0FycmF5SW5kZXgpIHtcclxuICAgICAgICBydW4oZGVwc01hcC5nZXQoQVJSQVlfSVRFUkFURV9LRVkpKTtcclxuICAgICAgfVxyXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICBjYXNlIFwiYWRkXCI6XHJcbiAgICAgICAgICBpZiAoIXRhcmdldElzQXJyYXkpIHtcclxuICAgICAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XHJcbiAgICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5SW5kZXgpIHtcclxuICAgICAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KFwibGVuZ3RoXCIpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJkZWxldGVcIjpcclxuICAgICAgICAgIGlmICghdGFyZ2V0SXNBcnJheSkge1xyXG4gICAgICAgICAgICBydW4oZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcclxuICAgICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICBydW4oZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwic2V0XCI6XHJcbiAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICBydW4oZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGVuZEJhdGNoKCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0RGVwRnJvbVJlYWN0aXZlKG9iamVjdCwga2V5KSB7XHJcbiAgY29uc3QgZGVwTWFwID0gdGFyZ2V0TWFwLmdldChvYmplY3QpO1xyXG4gIHJldHVybiBkZXBNYXAgJiYgZGVwTWFwLmdldChrZXkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFjdGl2ZVJlYWRBcnJheShhcnJheSkge1xyXG4gIGNvbnN0IHJhdyA9IHRvUmF3KGFycmF5KTtcclxuICBpZiAocmF3ID09PSBhcnJheSkgcmV0dXJuIHJhdztcclxuICB0cmFjayhyYXcsIFwiaXRlcmF0ZVwiLCBBUlJBWV9JVEVSQVRFX0tFWSk7XHJcbiAgcmV0dXJuIGlzU2hhbGxvdyhhcnJheSkgPyByYXcgOiByYXcubWFwKHRvUmVhY3RpdmUpO1xyXG59XHJcbmZ1bmN0aW9uIHNoYWxsb3dSZWFkQXJyYXkoYXJyKSB7XHJcbiAgdHJhY2soYXJyID0gdG9SYXcoYXJyKSwgXCJpdGVyYXRlXCIsIEFSUkFZX0lURVJBVEVfS0VZKTtcclxuICByZXR1cm4gYXJyO1xyXG59XHJcbmNvbnN0IGFycmF5SW5zdHJ1bWVudGF0aW9ucyA9IHtcclxuICBfX3Byb3RvX186IG51bGwsXHJcbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcbiAgICByZXR1cm4gaXRlcmF0b3IodGhpcywgU3ltYm9sLml0ZXJhdG9yLCB0b1JlYWN0aXZlKTtcclxuICB9LFxyXG4gIGNvbmNhdCguLi5hcmdzKSB7XHJcbiAgICByZXR1cm4gcmVhY3RpdmVSZWFkQXJyYXkodGhpcykuY29uY2F0KFxyXG4gICAgICAuLi5hcmdzLm1hcCgoeCkgPT4gaXNBcnJheSh4KSA/IHJlYWN0aXZlUmVhZEFycmF5KHgpIDogeClcclxuICAgICk7XHJcbiAgfSxcclxuICBlbnRyaWVzKCkge1xyXG4gICAgcmV0dXJuIGl0ZXJhdG9yKHRoaXMsIFwiZW50cmllc1wiLCAodmFsdWUpID0+IHtcclxuICAgICAgdmFsdWVbMV0gPSB0b1JlYWN0aXZlKHZhbHVlWzFdKTtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfSk7XHJcbiAgfSxcclxuICBldmVyeShmbiwgdGhpc0FyZykge1xyXG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwiZXZlcnlcIiwgZm4sIHRoaXNBcmcsIHZvaWQgMCwgYXJndW1lbnRzKTtcclxuICB9LFxyXG4gIGZpbHRlcihmbiwgdGhpc0FyZykge1xyXG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwiZmlsdGVyXCIsIGZuLCB0aGlzQXJnLCAodikgPT4gdi5tYXAodG9SZWFjdGl2ZSksIGFyZ3VtZW50cyk7XHJcbiAgfSxcclxuICBmaW5kKGZuLCB0aGlzQXJnKSB7XHJcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJmaW5kXCIsIGZuLCB0aGlzQXJnLCB0b1JlYWN0aXZlLCBhcmd1bWVudHMpO1xyXG4gIH0sXHJcbiAgZmluZEluZGV4KGZuLCB0aGlzQXJnKSB7XHJcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJmaW5kSW5kZXhcIiwgZm4sIHRoaXNBcmcsIHZvaWQgMCwgYXJndW1lbnRzKTtcclxuICB9LFxyXG4gIGZpbmRMYXN0KGZuLCB0aGlzQXJnKSB7XHJcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJmaW5kTGFzdFwiLCBmbiwgdGhpc0FyZywgdG9SZWFjdGl2ZSwgYXJndW1lbnRzKTtcclxuICB9LFxyXG4gIGZpbmRMYXN0SW5kZXgoZm4sIHRoaXNBcmcpIHtcclxuICAgIHJldHVybiBhcHBseSh0aGlzLCBcImZpbmRMYXN0SW5kZXhcIiwgZm4sIHRoaXNBcmcsIHZvaWQgMCwgYXJndW1lbnRzKTtcclxuICB9LFxyXG4gIC8vIGZsYXQsIGZsYXRNYXAgY291bGQgYmVuZWZpdCBmcm9tIEFSUkFZX0lURVJBVEUgYnV0IGFyZSBub3Qgc3RyYWlnaHQtZm9yd2FyZCB0byBpbXBsZW1lbnRcclxuICBmb3JFYWNoKGZuLCB0aGlzQXJnKSB7XHJcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJmb3JFYWNoXCIsIGZuLCB0aGlzQXJnLCB2b2lkIDAsIGFyZ3VtZW50cyk7XHJcbiAgfSxcclxuICBpbmNsdWRlcyguLi5hcmdzKSB7XHJcbiAgICByZXR1cm4gc2VhcmNoUHJveHkodGhpcywgXCJpbmNsdWRlc1wiLCBhcmdzKTtcclxuICB9LFxyXG4gIGluZGV4T2YoLi4uYXJncykge1xyXG4gICAgcmV0dXJuIHNlYXJjaFByb3h5KHRoaXMsIFwiaW5kZXhPZlwiLCBhcmdzKTtcclxuICB9LFxyXG4gIGpvaW4oc2VwYXJhdG9yKSB7XHJcbiAgICByZXR1cm4gcmVhY3RpdmVSZWFkQXJyYXkodGhpcykuam9pbihzZXBhcmF0b3IpO1xyXG4gIH0sXHJcbiAgLy8ga2V5cygpIGl0ZXJhdG9yIG9ubHkgcmVhZHMgYGxlbmd0aGAsIG5vIG9wdGltaXNhdGlvbiByZXF1aXJlZFxyXG4gIGxhc3RJbmRleE9mKC4uLmFyZ3MpIHtcclxuICAgIHJldHVybiBzZWFyY2hQcm94eSh0aGlzLCBcImxhc3RJbmRleE9mXCIsIGFyZ3MpO1xyXG4gIH0sXHJcbiAgbWFwKGZuLCB0aGlzQXJnKSB7XHJcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJtYXBcIiwgZm4sIHRoaXNBcmcsIHZvaWQgMCwgYXJndW1lbnRzKTtcclxuICB9LFxyXG4gIHBvcCgpIHtcclxuICAgIHJldHVybiBub1RyYWNraW5nKHRoaXMsIFwicG9wXCIpO1xyXG4gIH0sXHJcbiAgcHVzaCguLi5hcmdzKSB7XHJcbiAgICByZXR1cm4gbm9UcmFja2luZyh0aGlzLCBcInB1c2hcIiwgYXJncyk7XHJcbiAgfSxcclxuICByZWR1Y2UoZm4sIC4uLmFyZ3MpIHtcclxuICAgIHJldHVybiByZWR1Y2UodGhpcywgXCJyZWR1Y2VcIiwgZm4sIGFyZ3MpO1xyXG4gIH0sXHJcbiAgcmVkdWNlUmlnaHQoZm4sIC4uLmFyZ3MpIHtcclxuICAgIHJldHVybiByZWR1Y2UodGhpcywgXCJyZWR1Y2VSaWdodFwiLCBmbiwgYXJncyk7XHJcbiAgfSxcclxuICBzaGlmdCgpIHtcclxuICAgIHJldHVybiBub1RyYWNraW5nKHRoaXMsIFwic2hpZnRcIik7XHJcbiAgfSxcclxuICAvLyBzbGljZSBjb3VsZCB1c2UgQVJSQVlfSVRFUkFURSBidXQgYWxzbyBzZWVtcyB0byBiZWcgZm9yIHJhbmdlIHRyYWNraW5nXHJcbiAgc29tZShmbiwgdGhpc0FyZykge1xyXG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwic29tZVwiLCBmbiwgdGhpc0FyZywgdm9pZCAwLCBhcmd1bWVudHMpO1xyXG4gIH0sXHJcbiAgc3BsaWNlKC4uLmFyZ3MpIHtcclxuICAgIHJldHVybiBub1RyYWNraW5nKHRoaXMsIFwic3BsaWNlXCIsIGFyZ3MpO1xyXG4gIH0sXHJcbiAgdG9SZXZlcnNlZCgpIHtcclxuICAgIHJldHVybiByZWFjdGl2ZVJlYWRBcnJheSh0aGlzKS50b1JldmVyc2VkKCk7XHJcbiAgfSxcclxuICB0b1NvcnRlZChjb21wYXJlcikge1xyXG4gICAgcmV0dXJuIHJlYWN0aXZlUmVhZEFycmF5KHRoaXMpLnRvU29ydGVkKGNvbXBhcmVyKTtcclxuICB9LFxyXG4gIHRvU3BsaWNlZCguLi5hcmdzKSB7XHJcbiAgICByZXR1cm4gcmVhY3RpdmVSZWFkQXJyYXkodGhpcykudG9TcGxpY2VkKC4uLmFyZ3MpO1xyXG4gIH0sXHJcbiAgdW5zaGlmdCguLi5hcmdzKSB7XHJcbiAgICByZXR1cm4gbm9UcmFja2luZyh0aGlzLCBcInVuc2hpZnRcIiwgYXJncyk7XHJcbiAgfSxcclxuICB2YWx1ZXMoKSB7XHJcbiAgICByZXR1cm4gaXRlcmF0b3IodGhpcywgXCJ2YWx1ZXNcIiwgdG9SZWFjdGl2ZSk7XHJcbiAgfVxyXG59O1xyXG5mdW5jdGlvbiBpdGVyYXRvcihzZWxmLCBtZXRob2QsIHdyYXBWYWx1ZSkge1xyXG4gIGNvbnN0IGFyciA9IHNoYWxsb3dSZWFkQXJyYXkoc2VsZik7XHJcbiAgY29uc3QgaXRlciA9IGFyclttZXRob2RdKCk7XHJcbiAgaWYgKGFyciAhPT0gc2VsZiAmJiAhaXNTaGFsbG93KHNlbGYpKSB7XHJcbiAgICBpdGVyLl9uZXh0ID0gaXRlci5uZXh0O1xyXG4gICAgaXRlci5uZXh0ID0gKCkgPT4ge1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBpdGVyLl9uZXh0KCk7XHJcbiAgICAgIGlmIChyZXN1bHQudmFsdWUpIHtcclxuICAgICAgICByZXN1bHQudmFsdWUgPSB3cmFwVmFsdWUocmVzdWx0LnZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICB9XHJcbiAgcmV0dXJuIGl0ZXI7XHJcbn1cclxuY29uc3QgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcclxuZnVuY3Rpb24gYXBwbHkoc2VsZiwgbWV0aG9kLCBmbiwgdGhpc0FyZywgd3JhcHBlZFJldEZuLCBhcmdzKSB7XHJcbiAgY29uc3QgYXJyID0gc2hhbGxvd1JlYWRBcnJheShzZWxmKTtcclxuICBjb25zdCBuZWVkc1dyYXAgPSBhcnIgIT09IHNlbGYgJiYgIWlzU2hhbGxvdyhzZWxmKTtcclxuICBjb25zdCBtZXRob2RGbiA9IGFyclttZXRob2RdO1xyXG4gIGlmIChtZXRob2RGbiAhPT0gYXJyYXlQcm90b1ttZXRob2RdKSB7XHJcbiAgICBjb25zdCByZXN1bHQyID0gbWV0aG9kRm4uYXBwbHkoc2VsZiwgYXJncyk7XHJcbiAgICByZXR1cm4gbmVlZHNXcmFwID8gdG9SZWFjdGl2ZShyZXN1bHQyKSA6IHJlc3VsdDI7XHJcbiAgfVxyXG4gIGxldCB3cmFwcGVkRm4gPSBmbjtcclxuICBpZiAoYXJyICE9PSBzZWxmKSB7XHJcbiAgICBpZiAobmVlZHNXcmFwKSB7XHJcbiAgICAgIHdyYXBwZWRGbiA9IGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgdG9SZWFjdGl2ZShpdGVtKSwgaW5kZXgsIHNlbGYpO1xyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIGlmIChmbi5sZW5ndGggPiAyKSB7XHJcbiAgICAgIHdyYXBwZWRGbiA9IGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgaXRlbSwgaW5kZXgsIHNlbGYpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuICBjb25zdCByZXN1bHQgPSBtZXRob2RGbi5jYWxsKGFyciwgd3JhcHBlZEZuLCB0aGlzQXJnKTtcclxuICByZXR1cm4gbmVlZHNXcmFwICYmIHdyYXBwZWRSZXRGbiA/IHdyYXBwZWRSZXRGbihyZXN1bHQpIDogcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIHJlZHVjZShzZWxmLCBtZXRob2QsIGZuLCBhcmdzKSB7XHJcbiAgY29uc3QgYXJyID0gc2hhbGxvd1JlYWRBcnJheShzZWxmKTtcclxuICBsZXQgd3JhcHBlZEZuID0gZm47XHJcbiAgaWYgKGFyciAhPT0gc2VsZikge1xyXG4gICAgaWYgKCFpc1NoYWxsb3coc2VsZikpIHtcclxuICAgICAgd3JhcHBlZEZuID0gZnVuY3Rpb24oYWNjLCBpdGVtLCBpbmRleCkge1xyXG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGFjYywgdG9SZWFjdGl2ZShpdGVtKSwgaW5kZXgsIHNlbGYpO1xyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIGlmIChmbi5sZW5ndGggPiAzKSB7XHJcbiAgICAgIHdyYXBwZWRGbiA9IGZ1bmN0aW9uKGFjYywgaXRlbSwgaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhY2MsIGl0ZW0sIGluZGV4LCBzZWxmKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGFyclttZXRob2RdKHdyYXBwZWRGbiwgLi4uYXJncyk7XHJcbn1cclxuZnVuY3Rpb24gc2VhcmNoUHJveHkoc2VsZiwgbWV0aG9kLCBhcmdzKSB7XHJcbiAgY29uc3QgYXJyID0gdG9SYXcoc2VsZik7XHJcbiAgdHJhY2soYXJyLCBcIml0ZXJhdGVcIiwgQVJSQVlfSVRFUkFURV9LRVkpO1xyXG4gIGNvbnN0IHJlcyA9IGFyclttZXRob2RdKC4uLmFyZ3MpO1xyXG4gIGlmICgocmVzID09PSAtMSB8fCByZXMgPT09IGZhbHNlKSAmJiBpc1Byb3h5KGFyZ3NbMF0pKSB7XHJcbiAgICBhcmdzWzBdID0gdG9SYXcoYXJnc1swXSk7XHJcbiAgICByZXR1cm4gYXJyW21ldGhvZF0oLi4uYXJncyk7XHJcbiAgfVxyXG4gIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gbm9UcmFja2luZyhzZWxmLCBtZXRob2QsIGFyZ3MgPSBbXSkge1xyXG4gIHBhdXNlVHJhY2tpbmcoKTtcclxuICBzdGFydEJhdGNoKCk7XHJcbiAgY29uc3QgcmVzID0gdG9SYXcoc2VsZilbbWV0aG9kXS5hcHBseShzZWxmLCBhcmdzKTtcclxuICBlbmRCYXRjaCgpO1xyXG4gIHJlc2V0VHJhY2tpbmcoKTtcclxuICByZXR1cm4gcmVzO1xyXG59XHJcblxyXG5jb25zdCBpc05vblRyYWNrYWJsZUtleXMgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChgX19wcm90b19fLF9fdl9pc1JlZixfX2lzVnVlYCk7XHJcbmNvbnN0IGJ1aWx0SW5TeW1ib2xzID0gbmV3IFNldChcclxuICAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoU3ltYm9sKS5maWx0ZXIoKGtleSkgPT4ga2V5ICE9PSBcImFyZ3VtZW50c1wiICYmIGtleSAhPT0gXCJjYWxsZXJcIikubWFwKChrZXkpID0+IFN5bWJvbFtrZXldKS5maWx0ZXIoaXNTeW1ib2wpXHJcbik7XHJcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KGtleSkge1xyXG4gIGlmICghaXNTeW1ib2woa2V5KSkga2V5ID0gU3RyaW5nKGtleSk7XHJcbiAgY29uc3Qgb2JqID0gdG9SYXcodGhpcyk7XHJcbiAgdHJhY2sob2JqLCBcImhhc1wiLCBrZXkpO1xyXG4gIHJldHVybiBvYmouaGFzT3duUHJvcGVydHkoa2V5KTtcclxufVxyXG5jbGFzcyBCYXNlUmVhY3RpdmVIYW5kbGVyIHtcclxuICBjb25zdHJ1Y3RvcihfaXNSZWFkb25seSA9IGZhbHNlLCBfaXNTaGFsbG93ID0gZmFsc2UpIHtcclxuICAgIHRoaXMuX2lzUmVhZG9ubHkgPSBfaXNSZWFkb25seTtcclxuICAgIHRoaXMuX2lzU2hhbGxvdyA9IF9pc1NoYWxsb3c7XHJcbiAgfVxyXG4gIGdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpIHtcclxuICAgIGlmIChrZXkgPT09IFwiX192X3NraXBcIikgcmV0dXJuIHRhcmdldFtcIl9fdl9za2lwXCJdO1xyXG4gICAgY29uc3QgaXNSZWFkb25seTIgPSB0aGlzLl9pc1JlYWRvbmx5LCBpc1NoYWxsb3cyID0gdGhpcy5faXNTaGFsbG93O1xyXG4gICAgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFjdGl2ZVwiKSB7XHJcbiAgICAgIHJldHVybiAhaXNSZWFkb25seTI7XHJcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiKSB7XHJcbiAgICAgIHJldHVybiBpc1JlYWRvbmx5MjtcclxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1NoYWxsb3dcIikge1xyXG4gICAgICByZXR1cm4gaXNTaGFsbG93MjtcclxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIikge1xyXG4gICAgICBpZiAocmVjZWl2ZXIgPT09IChpc1JlYWRvbmx5MiA/IGlzU2hhbGxvdzIgPyBzaGFsbG93UmVhZG9ubHlNYXAgOiByZWFkb25seU1hcCA6IGlzU2hhbGxvdzIgPyBzaGFsbG93UmVhY3RpdmVNYXAgOiByZWFjdGl2ZU1hcCkuZ2V0KHRhcmdldCkgfHwgLy8gcmVjZWl2ZXIgaXMgbm90IHRoZSByZWFjdGl2ZSBwcm94eSwgYnV0IGhhcyB0aGUgc2FtZSBwcm90b3R5cGVcclxuICAgICAgLy8gdGhpcyBtZWFucyB0aGUgcmVjZWl2ZXIgaXMgYSB1c2VyIHByb3h5IG9mIHRoZSByZWFjdGl2ZSBwcm94eVxyXG4gICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHJlY2VpdmVyKSkge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdGFyZ2V0SXNBcnJheSA9IGlzQXJyYXkodGFyZ2V0KTtcclxuICAgIGlmICghaXNSZWFkb25seTIpIHtcclxuICAgICAgbGV0IGZuO1xyXG4gICAgICBpZiAodGFyZ2V0SXNBcnJheSAmJiAoZm4gPSBhcnJheUluc3RydW1lbnRhdGlvbnNba2V5XSkpIHtcclxuICAgICAgICByZXR1cm4gZm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGtleSA9PT0gXCJoYXNPd25Qcm9wZXJ0eVwiKSB7XHJcbiAgICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXMgPSBSZWZsZWN0LmdldChcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBrZXksXHJcbiAgICAgIC8vIGlmIHRoaXMgaXMgYSBwcm94eSB3cmFwcGluZyBhIHJlZiwgcmV0dXJuIG1ldGhvZHMgdXNpbmcgdGhlIHJhdyByZWZcclxuICAgICAgLy8gYXMgcmVjZWl2ZXIgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGNhbGwgYHRvUmF3YCBvbiB0aGUgcmVmIGluIGFsbFxyXG4gICAgICAvLyBpdHMgY2xhc3MgbWV0aG9kc1xyXG4gICAgICBpc1JlZih0YXJnZXQpID8gdGFyZ2V0IDogcmVjZWl2ZXJcclxuICAgICk7XHJcbiAgICBpZiAoaXNTeW1ib2woa2V5KSA/IGJ1aWx0SW5TeW1ib2xzLmhhcyhrZXkpIDogaXNOb25UcmFja2FibGVLZXlzKGtleSkpIHtcclxuICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGlmICghaXNSZWFkb25seTIpIHtcclxuICAgICAgdHJhY2sodGFyZ2V0LCBcImdldFwiLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzU2hhbGxvdzIpIHtcclxuICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGlmIChpc1JlZihyZXMpKSB7XHJcbiAgICAgIHJldHVybiB0YXJnZXRJc0FycmF5ICYmIGlzSW50ZWdlcktleShrZXkpID8gcmVzIDogcmVzLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcclxuICAgICAgcmV0dXJuIGlzUmVhZG9ubHkyID8gcmVhZG9ubHkocmVzKSA6IHJlYWN0aXZlKHJlcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG4gIH1cclxufVxyXG5jbGFzcyBNdXRhYmxlUmVhY3RpdmVIYW5kbGVyIGV4dGVuZHMgQmFzZVJlYWN0aXZlSGFuZGxlciB7XHJcbiAgY29uc3RydWN0b3IoaXNTaGFsbG93MiA9IGZhbHNlKSB7XHJcbiAgICBzdXBlcihmYWxzZSwgaXNTaGFsbG93Mik7XHJcbiAgfVxyXG4gIHNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSB7XHJcbiAgICBsZXQgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcclxuICAgIGlmICghdGhpcy5faXNTaGFsbG93KSB7XHJcbiAgICAgIGNvbnN0IGlzT2xkVmFsdWVSZWFkb25seSA9IGlzUmVhZG9ubHkob2xkVmFsdWUpO1xyXG4gICAgICBpZiAoIWlzU2hhbGxvdyh2YWx1ZSkgJiYgIWlzUmVhZG9ubHkodmFsdWUpKSB7XHJcbiAgICAgICAgb2xkVmFsdWUgPSB0b1JhdyhvbGRWYWx1ZSk7XHJcbiAgICAgICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkgJiYgaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcclxuICAgICAgICBpZiAoaXNPbGRWYWx1ZVJlYWRvbmx5KSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG9sZFZhbHVlLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGhhZEtleSA9IGlzQXJyYXkodGFyZ2V0KSAmJiBpc0ludGVnZXJLZXkoa2V5KSA/IE51bWJlcihrZXkpIDwgdGFyZ2V0Lmxlbmd0aCA6IGhhc093bih0YXJnZXQsIGtleSk7XHJcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LnNldChcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBrZXksXHJcbiAgICAgIHZhbHVlLFxyXG4gICAgICBpc1JlZih0YXJnZXQpID8gdGFyZ2V0IDogcmVjZWl2ZXJcclxuICAgICk7XHJcbiAgICBpZiAodGFyZ2V0ID09PSB0b1JhdyhyZWNlaXZlcikpIHtcclxuICAgICAgaWYgKCFoYWRLZXkpIHtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiwga2V5LCB2YWx1ZSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsdWUpKSB7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwic2V0XCIsIGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbiAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcclxuICAgIGNvbnN0IGhhZEtleSA9IGhhc093bih0YXJnZXQsIGtleSk7XHJcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSk7XHJcbiAgICBpZiAocmVzdWx0ICYmIGhhZEtleSkge1xyXG4gICAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiwga2V5LCB2b2lkIDAsIG9sZFZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG4gIGhhcyh0YXJnZXQsIGtleSkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5oYXModGFyZ2V0LCBrZXkpO1xyXG4gICAgaWYgKCFpc1N5bWJvbChrZXkpIHx8ICFidWlsdEluU3ltYm9scy5oYXMoa2V5KSkge1xyXG4gICAgICB0cmFjayh0YXJnZXQsIFwiaGFzXCIsIGtleSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuICBvd25LZXlzKHRhcmdldCkge1xyXG4gICAgdHJhY2soXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgXCJpdGVyYXRlXCIsXHJcbiAgICAgIGlzQXJyYXkodGFyZ2V0KSA/IFwibGVuZ3RoXCIgOiBJVEVSQVRFX0tFWVxyXG4gICAgKTtcclxuICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcclxuICB9XHJcbn1cclxuY2xhc3MgUmVhZG9ubHlSZWFjdGl2ZUhhbmRsZXIgZXh0ZW5kcyBCYXNlUmVhY3RpdmVIYW5kbGVyIHtcclxuICBjb25zdHJ1Y3Rvcihpc1NoYWxsb3cyID0gZmFsc2UpIHtcclxuICAgIHN1cGVyKHRydWUsIGlzU2hhbGxvdzIpO1xyXG4gIH1cclxuICBzZXQodGFyZ2V0LCBrZXkpIHtcclxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgIHdhcm4oXHJcbiAgICAgICAgYFNldCBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLFxyXG4gICAgICAgIHRhcmdldFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XHJcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICB3YXJuKFxyXG4gICAgICAgIGBEZWxldGUgb3BlcmF0aW9uIG9uIGtleSBcIiR7U3RyaW5nKGtleSl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCxcclxuICAgICAgICB0YXJnZXRcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxufVxyXG5jb25zdCBtdXRhYmxlSGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE11dGFibGVSZWFjdGl2ZUhhbmRsZXIoKTtcclxuY29uc3QgcmVhZG9ubHlIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVhZG9ubHlSZWFjdGl2ZUhhbmRsZXIoKTtcclxuY29uc3Qgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE11dGFibGVSZWFjdGl2ZUhhbmRsZXIodHJ1ZSk7XHJcbmNvbnN0IHNoYWxsb3dSZWFkb25seUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBSZWFkb25seVJlYWN0aXZlSGFuZGxlcih0cnVlKTtcclxuXHJcbmNvbnN0IHRvU2hhbGxvdyA9ICh2YWx1ZSkgPT4gdmFsdWU7XHJcbmNvbnN0IGdldFByb3RvID0gKHYpID0+IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yodik7XHJcbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgaXNSZWFkb25seTIsIGlzU2hhbGxvdzIpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIl07XHJcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xyXG4gICAgY29uc3QgdGFyZ2V0SXNNYXAgPSBpc01hcChyYXdUYXJnZXQpO1xyXG4gICAgY29uc3QgaXNQYWlyID0gbWV0aG9kID09PSBcImVudHJpZXNcIiB8fCBtZXRob2QgPT09IFN5bWJvbC5pdGVyYXRvciAmJiB0YXJnZXRJc01hcDtcclxuICAgIGNvbnN0IGlzS2V5T25seSA9IG1ldGhvZCA9PT0gXCJrZXlzXCIgJiYgdGFyZ2V0SXNNYXA7XHJcbiAgICBjb25zdCBpbm5lckl0ZXJhdG9yID0gdGFyZ2V0W21ldGhvZF0oLi4uYXJncyk7XHJcbiAgICBjb25zdCB3cmFwID0gaXNTaGFsbG93MiA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkyID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XHJcbiAgICAhaXNSZWFkb25seTIgJiYgdHJhY2soXHJcbiAgICAgIHJhd1RhcmdldCxcclxuICAgICAgXCJpdGVyYXRlXCIsXHJcbiAgICAgIGlzS2V5T25seSA/IE1BUF9LRVlfSVRFUkFURV9LRVkgOiBJVEVSQVRFX0tFWVxyXG4gICAgKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIC8vIGl0ZXJhdG9yIHByb3RvY29sXHJcbiAgICAgIG5leHQoKSB7XHJcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XHJcbiAgICAgICAgcmV0dXJuIGRvbmUgPyB7IHZhbHVlLCBkb25lIH0gOiB7XHJcbiAgICAgICAgICB2YWx1ZTogaXNQYWlyID8gW3dyYXAodmFsdWVbMF0pLCB3cmFwKHZhbHVlWzFdKV0gOiB3cmFwKHZhbHVlKSxcclxuICAgICAgICAgIGRvbmVcclxuICAgICAgICB9O1xyXG4gICAgICB9LFxyXG4gICAgICAvLyBpdGVyYWJsZSBwcm90b2NvbFxyXG4gICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlYWRvbmx5TWV0aG9kKHR5cGUpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xyXG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgY29uc3Qga2V5ID0gYXJnc1swXSA/IGBvbiBrZXkgXCIke2FyZ3NbMF19XCIgYCA6IGBgO1xyXG4gICAgICB3YXJuKFxyXG4gICAgICAgIGAke2NhcGl0YWxpemUodHlwZSl9IG9wZXJhdGlvbiAke2tleX1mYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLFxyXG4gICAgICAgIHRvUmF3KHRoaXMpXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHlwZSA9PT0gXCJkZWxldGVcIiA/IGZhbHNlIDogdHlwZSA9PT0gXCJjbGVhclwiID8gdm9pZCAwIDogdGhpcztcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUluc3RydW1lbnRhdGlvbnMocmVhZG9ubHksIHNoYWxsb3cpIHtcclxuICBjb25zdCBpbnN0cnVtZW50YXRpb25zID0ge1xyXG4gICAgZ2V0KGtleSkge1xyXG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiXTtcclxuICAgICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcclxuICAgICAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcclxuICAgICAgaWYgKCFyZWFkb25seSkge1xyXG4gICAgICAgIGlmIChoYXNDaGFuZ2VkKGtleSwgcmF3S2V5KSkge1xyXG4gICAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIsIHJhd0tleSk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgeyBoYXMgfSA9IGdldFByb3RvKHJhd1RhcmdldCk7XHJcbiAgICAgIGNvbnN0IHdyYXAgPSBzaGFsbG93ID8gdG9TaGFsbG93IDogcmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcclxuICAgICAgaWYgKGhhcy5jYWxsKHJhd1RhcmdldCwga2V5KSkge1xyXG4gICAgICAgIHJldHVybiB3cmFwKHRhcmdldC5nZXQoa2V5KSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoaGFzLmNhbGwocmF3VGFyZ2V0LCByYXdLZXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChyYXdLZXkpKTtcclxuICAgICAgfSBlbHNlIGlmICh0YXJnZXQgIT09IHJhd1RhcmdldCkge1xyXG4gICAgICAgIHRhcmdldC5nZXQoa2V5KTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiXTtcclxuICAgICAgIXJlYWRvbmx5ICYmIHRyYWNrKHRvUmF3KHRhcmdldCksIFwiaXRlcmF0ZVwiLCBJVEVSQVRFX0tFWSk7XHJcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIFwic2l6ZVwiLCB0YXJnZXQpO1xyXG4gICAgfSxcclxuICAgIGhhcyhrZXkpIHtcclxuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIl07XHJcbiAgICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XHJcbiAgICAgIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XHJcbiAgICAgIGlmICghcmVhZG9ubHkpIHtcclxuICAgICAgICBpZiAoaGFzQ2hhbmdlZChrZXksIHJhd0tleSkpIHtcclxuICAgICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiwga2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiLCByYXdLZXkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBrZXkgPT09IHJhd0tleSA/IHRhcmdldC5oYXMoa2V5KSA6IHRhcmdldC5oYXMoa2V5KSB8fCB0YXJnZXQuaGFzKHJhd0tleSk7XHJcbiAgICB9LFxyXG4gICAgZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xyXG4gICAgICBjb25zdCBvYnNlcnZlZCA9IHRoaXM7XHJcbiAgICAgIGNvbnN0IHRhcmdldCA9IG9ic2VydmVkW1wiX192X3Jhd1wiXTtcclxuICAgICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcclxuICAgICAgY29uc3Qgd3JhcCA9IHNoYWxsb3cgPyB0b1NoYWxsb3cgOiByZWFkb25seSA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xyXG4gICAgICAhcmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcIml0ZXJhdGVcIiwgSVRFUkFURV9LRVkpO1xyXG4gICAgICByZXR1cm4gdGFyZ2V0LmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcclxuICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB3cmFwKHZhbHVlKSwgd3JhcChrZXkpLCBvYnNlcnZlZCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgZXh0ZW5kKFxyXG4gICAgaW5zdHJ1bWVudGF0aW9ucyxcclxuICAgIHJlYWRvbmx5ID8ge1xyXG4gICAgICBhZGQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiYWRkXCIpLFxyXG4gICAgICBzZXQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwic2V0XCIpLFxyXG4gICAgICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiZGVsZXRlXCIpLFxyXG4gICAgICBjbGVhcjogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJjbGVhclwiKVxyXG4gICAgfSA6IHtcclxuICAgICAgYWRkKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCFzaGFsbG93ICYmICFpc1NoYWxsb3codmFsdWUpICYmICFpc1JlYWRvbmx5KHZhbHVlKSkge1xyXG4gICAgICAgICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xyXG4gICAgICAgIGNvbnN0IHByb3RvID0gZ2V0UHJvdG8odGFyZ2V0KTtcclxuICAgICAgICBjb25zdCBoYWRLZXkgPSBwcm90by5oYXMuY2FsbCh0YXJnZXQsIHZhbHVlKTtcclxuICAgICAgICBpZiAoIWhhZEtleSkge1xyXG4gICAgICAgICAgdGFyZ2V0LmFkZCh2YWx1ZSk7XHJcbiAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiwgdmFsdWUsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCFzaGFsbG93ICYmICFpc1NoYWxsb3codmFsdWUpICYmICFpc1JlYWRvbmx5KHZhbHVlKSkge1xyXG4gICAgICAgICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xyXG4gICAgICAgIGNvbnN0IHsgaGFzLCBnZXQgfSA9IGdldFByb3RvKHRhcmdldCk7XHJcbiAgICAgICAgbGV0IGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcclxuICAgICAgICBpZiAoIWhhZEtleSkge1xyXG4gICAgICAgICAga2V5ID0gdG9SYXcoa2V5KTtcclxuICAgICAgICAgIGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcclxuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IGdldC5jYWxsKHRhcmdldCwga2V5KTtcclxuICAgICAgICB0YXJnZXQuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgICAgIGlmICghaGFkS2V5KSB7XHJcbiAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiwga2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBvbGRWYWx1ZSkpIHtcclxuICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9LFxyXG4gICAgICBkZWxldGUoa2V5KSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XHJcbiAgICAgICAgY29uc3QgeyBoYXMsIGdldCB9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcclxuICAgICAgICBsZXQgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xyXG4gICAgICAgIGlmICghaGFkS2V5KSB7XHJcbiAgICAgICAgICBrZXkgPSB0b1JhdyhrZXkpO1xyXG4gICAgICAgICAgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICAgICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gZ2V0ID8gZ2V0LmNhbGwodGFyZ2V0LCBrZXkpIDogdm9pZCAwO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRhcmdldC5kZWxldGUoa2V5KTtcclxuICAgICAgICBpZiAoaGFkS2V5KSB7XHJcbiAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiwga2V5LCB2b2lkIDAsIG9sZFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfSxcclxuICAgICAgY2xlYXIoKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XHJcbiAgICAgICAgY29uc3QgaGFkSXRlbXMgPSB0YXJnZXQuc2l6ZSAhPT0gMDtcclxuICAgICAgICBjb25zdCBvbGRUYXJnZXQgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gaXNNYXAodGFyZ2V0KSA/IG5ldyBNYXAodGFyZ2V0KSA6IG5ldyBTZXQodGFyZ2V0KSA6IHZvaWQgMDtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0YXJnZXQuY2xlYXIoKTtcclxuICAgICAgICBpZiAoaGFkSXRlbXMpIHtcclxuICAgICAgICAgIHRyaWdnZXIoXHJcbiAgICAgICAgICAgIHRhcmdldCxcclxuICAgICAgICAgICAgXCJjbGVhclwiLFxyXG4gICAgICAgICAgICB2b2lkIDAsXHJcbiAgICAgICAgICAgIHZvaWQgMCxcclxuICAgICAgICAgICAgb2xkVGFyZ2V0XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgKTtcclxuICBjb25zdCBpdGVyYXRvck1ldGhvZHMgPSBbXHJcbiAgICBcImtleXNcIixcclxuICAgIFwidmFsdWVzXCIsXHJcbiAgICBcImVudHJpZXNcIixcclxuICAgIFN5bWJvbC5pdGVyYXRvclxyXG4gIF07XHJcbiAgaXRlcmF0b3JNZXRob2RzLmZvckVhY2goKG1ldGhvZCkgPT4ge1xyXG4gICAgaW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCByZWFkb25seSwgc2hhbGxvdyk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIGluc3RydW1lbnRhdGlvbnM7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGlzUmVhZG9ubHkyLCBzaGFsbG93KSB7XHJcbiAgY29uc3QgaW5zdHJ1bWVudGF0aW9ucyA9IGNyZWF0ZUluc3RydW1lbnRhdGlvbnMoaXNSZWFkb25seTIsIHNoYWxsb3cpO1xyXG4gIHJldHVybiAodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSA9PiB7XHJcbiAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIpIHtcclxuICAgICAgcmV0dXJuICFpc1JlYWRvbmx5MjtcclxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWRvbmx5XCIpIHtcclxuICAgICAgcmV0dXJuIGlzUmVhZG9ubHkyO1xyXG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiKSB7XHJcbiAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVmbGVjdC5nZXQoXHJcbiAgICAgIGhhc093bihpbnN0cnVtZW50YXRpb25zLCBrZXkpICYmIGtleSBpbiB0YXJnZXQgPyBpbnN0cnVtZW50YXRpb25zIDogdGFyZ2V0LFxyXG4gICAgICBrZXksXHJcbiAgICAgIHJlY2VpdmVyXHJcbiAgICApO1xyXG4gIH07XHJcbn1cclxuY29uc3QgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcclxuICBnZXQ6IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoZmFsc2UsIGZhbHNlKVxyXG59O1xyXG5jb25zdCBzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xyXG4gIGdldDogLyogQF9fUFVSRV9fICovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgdHJ1ZSlcclxufTtcclxuY29uc3QgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XHJcbiAgZ2V0OiAvKiBAX19QVVJFX18gKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKHRydWUsIGZhbHNlKVxyXG59O1xyXG5jb25zdCBzaGFsbG93UmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XHJcbiAgZ2V0OiAvKiBAX19QVVJFX18gKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKHRydWUsIHRydWUpXHJcbn07XHJcbmZ1bmN0aW9uIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpIHtcclxuICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xyXG4gIGlmIChyYXdLZXkgIT09IGtleSAmJiBoYXMuY2FsbCh0YXJnZXQsIHJhd0tleSkpIHtcclxuICAgIGNvbnN0IHR5cGUgPSB0b1Jhd1R5cGUodGFyZ2V0KTtcclxuICAgIHdhcm4oXHJcbiAgICAgIGBSZWFjdGl2ZSAke3R5cGV9IGNvbnRhaW5zIGJvdGggdGhlIHJhdyBhbmQgcmVhY3RpdmUgdmVyc2lvbnMgb2YgdGhlIHNhbWUgb2JqZWN0JHt0eXBlID09PSBgTWFwYCA/IGAgYXMga2V5c2AgOiBgYH0sIHdoaWNoIGNhbiBsZWFkIHRvIGluY29uc2lzdGVuY2llcy4gQXZvaWQgZGlmZmVyZW50aWF0aW5nIGJldHdlZW4gdGhlIHJhdyBhbmQgcmVhY3RpdmUgdmVyc2lvbnMgb2YgYW4gb2JqZWN0IGFuZCBvbmx5IHVzZSB0aGUgcmVhY3RpdmUgdmVyc2lvbiBpZiBwb3NzaWJsZS5gXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuY29uc3QgcmVhY3RpdmVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcclxuY29uc3Qgc2hhbGxvd1JlYWN0aXZlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IHJlYWRvbmx5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IHNoYWxsb3dSZWFkb25seU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xyXG5mdW5jdGlvbiB0YXJnZXRUeXBlTWFwKHJhd1R5cGUpIHtcclxuICBzd2l0Y2ggKHJhd1R5cGUpIHtcclxuICAgIGNhc2UgXCJPYmplY3RcIjpcclxuICAgIGNhc2UgXCJBcnJheVwiOlxyXG4gICAgICByZXR1cm4gMSAvKiBDT01NT04gKi87XHJcbiAgICBjYXNlIFwiTWFwXCI6XHJcbiAgICBjYXNlIFwiU2V0XCI6XHJcbiAgICBjYXNlIFwiV2Vha01hcFwiOlxyXG4gICAgY2FzZSBcIldlYWtTZXRcIjpcclxuICAgICAgcmV0dXJuIDIgLyogQ09MTEVDVElPTiAqLztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiAwIC8qIElOVkFMSUQgKi87XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFRhcmdldFR5cGUodmFsdWUpIHtcclxuICByZXR1cm4gdmFsdWVbXCJfX3Zfc2tpcFwiXSB8fCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgPyAwIC8qIElOVkFMSUQgKi8gOiB0YXJnZXRUeXBlTWFwKHRvUmF3VHlwZSh2YWx1ZSkpO1xyXG59XHJcbmZ1bmN0aW9uIHJlYWN0aXZlKHRhcmdldCkge1xyXG4gIGlmIChpc1JlYWRvbmx5KHRhcmdldCkpIHtcclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgfVxyXG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdChcclxuICAgIHRhcmdldCxcclxuICAgIGZhbHNlLFxyXG4gICAgbXV0YWJsZUhhbmRsZXJzLFxyXG4gICAgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycyxcclxuICAgIHJlYWN0aXZlTWFwXHJcbiAgKTtcclxufVxyXG5mdW5jdGlvbiBzaGFsbG93UmVhY3RpdmUodGFyZ2V0KSB7XHJcbiAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KFxyXG4gICAgdGFyZ2V0LFxyXG4gICAgZmFsc2UsXHJcbiAgICBzaGFsbG93UmVhY3RpdmVIYW5kbGVycyxcclxuICAgIHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMsXHJcbiAgICBzaGFsbG93UmVhY3RpdmVNYXBcclxuICApO1xyXG59XHJcbmZ1bmN0aW9uIHJlYWRvbmx5KHRhcmdldCkge1xyXG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdChcclxuICAgIHRhcmdldCxcclxuICAgIHRydWUsXHJcbiAgICByZWFkb25seUhhbmRsZXJzLFxyXG4gICAgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsXHJcbiAgICByZWFkb25seU1hcFxyXG4gICk7XHJcbn1cclxuZnVuY3Rpb24gc2hhbGxvd1JlYWRvbmx5KHRhcmdldCkge1xyXG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdChcclxuICAgIHRhcmdldCxcclxuICAgIHRydWUsXHJcbiAgICBzaGFsbG93UmVhZG9ubHlIYW5kbGVycyxcclxuICAgIHNoYWxsb3dSZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyxcclxuICAgIHNoYWxsb3dSZWFkb25seU1hcFxyXG4gICk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBpc1JlYWRvbmx5MiwgYmFzZUhhbmRsZXJzLCBjb2xsZWN0aW9uSGFuZGxlcnMsIHByb3h5TWFwKSB7XHJcbiAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XHJcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICB3YXJuKFxyXG4gICAgICAgIGB2YWx1ZSBjYW5ub3QgYmUgbWFkZSAke2lzUmVhZG9ubHkyID8gXCJyZWFkb25seVwiIDogXCJyZWFjdGl2ZVwifTogJHtTdHJpbmcoXHJcbiAgICAgICAgICB0YXJnZXRcclxuICAgICAgICApfWBcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgfVxyXG4gIGlmICh0YXJnZXRbXCJfX3ZfcmF3XCJdICYmICEoaXNSZWFkb25seTIgJiYgdGFyZ2V0W1wiX192X2lzUmVhY3RpdmVcIl0pKSB7XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG4gIH1cclxuICBjb25zdCBleGlzdGluZ1Byb3h5ID0gcHJveHlNYXAuZ2V0KHRhcmdldCk7XHJcbiAgaWYgKGV4aXN0aW5nUHJveHkpIHtcclxuICAgIHJldHVybiBleGlzdGluZ1Byb3h5O1xyXG4gIH1cclxuICBjb25zdCB0YXJnZXRUeXBlID0gZ2V0VGFyZ2V0VHlwZSh0YXJnZXQpO1xyXG4gIGlmICh0YXJnZXRUeXBlID09PSAwIC8qIElOVkFMSUQgKi8pIHtcclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgfVxyXG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KFxyXG4gICAgdGFyZ2V0LFxyXG4gICAgdGFyZ2V0VHlwZSA9PT0gMiAvKiBDT0xMRUNUSU9OICovID8gY29sbGVjdGlvbkhhbmRsZXJzIDogYmFzZUhhbmRsZXJzXHJcbiAgKTtcclxuICBwcm94eU1hcC5zZXQodGFyZ2V0LCBwcm94eSk7XHJcbiAgcmV0dXJuIHByb3h5O1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVhY3RpdmUodmFsdWUpIHtcclxuICBpZiAoaXNSZWFkb25seSh2YWx1ZSkpIHtcclxuICAgIHJldHVybiBpc1JlYWN0aXZlKHZhbHVlW1wiX192X3Jhd1wiXSk7XHJcbiAgfVxyXG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1JlYWN0aXZlXCJdKTtcclxufVxyXG5mdW5jdGlvbiBpc1JlYWRvbmx5KHZhbHVlKSB7XHJcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhZG9ubHlcIl0pO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2hhbGxvdyh2YWx1ZSkge1xyXG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1NoYWxsb3dcIl0pO1xyXG59XHJcbmZ1bmN0aW9uIGlzUHJveHkodmFsdWUpIHtcclxuICByZXR1cm4gdmFsdWUgPyAhIXZhbHVlW1wiX192X3Jhd1wiXSA6IGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIHRvUmF3KG9ic2VydmVkKSB7XHJcbiAgY29uc3QgcmF3ID0gb2JzZXJ2ZWQgJiYgb2JzZXJ2ZWRbXCJfX3ZfcmF3XCJdO1xyXG4gIHJldHVybiByYXcgPyB0b1JhdyhyYXcpIDogb2JzZXJ2ZWQ7XHJcbn1cclxuZnVuY3Rpb24gbWFya1Jhdyh2YWx1ZSkge1xyXG4gIGlmICghaGFzT3duKHZhbHVlLCBcIl9fdl9za2lwXCIpICYmIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpKSB7XHJcbiAgICBkZWYodmFsdWUsIFwiX192X3NraXBcIiwgdHJ1ZSk7XHJcbiAgfVxyXG4gIHJldHVybiB2YWx1ZTtcclxufVxyXG5jb25zdCB0b1JlYWN0aXZlID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgPyByZWFjdGl2ZSh2YWx1ZSkgOiB2YWx1ZTtcclxuY29uc3QgdG9SZWFkb25seSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpID8gcmVhZG9ubHkodmFsdWUpIDogdmFsdWU7XHJcblxyXG5mdW5jdGlvbiBpc1JlZihyKSB7XHJcbiAgcmV0dXJuIHIgPyByW1wiX192X2lzUmVmXCJdID09PSB0cnVlIDogZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gcmVmKHZhbHVlKSB7XHJcbiAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgZmFsc2UpO1xyXG59XHJcbmZ1bmN0aW9uIHNoYWxsb3dSZWYodmFsdWUpIHtcclxuICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCB0cnVlKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSZWYocmF3VmFsdWUsIHNoYWxsb3cpIHtcclxuICBpZiAoaXNSZWYocmF3VmFsdWUpKSB7XHJcbiAgICByZXR1cm4gcmF3VmFsdWU7XHJcbiAgfVxyXG4gIHJldHVybiBuZXcgUmVmSW1wbChyYXdWYWx1ZSwgc2hhbGxvdyk7XHJcbn1cclxuY2xhc3MgUmVmSW1wbCB7XHJcbiAgY29uc3RydWN0b3IodmFsdWUsIGlzU2hhbGxvdzIpIHtcclxuICAgIHRoaXMuZGVwID0gbmV3IERlcCgpO1xyXG4gICAgdGhpc1tcIl9fdl9pc1JlZlwiXSA9IHRydWU7XHJcbiAgICB0aGlzW1wiX192X2lzU2hhbGxvd1wiXSA9IGZhbHNlO1xyXG4gICAgdGhpcy5fcmF3VmFsdWUgPSBpc1NoYWxsb3cyID8gdmFsdWUgOiB0b1Jhdyh2YWx1ZSk7XHJcbiAgICB0aGlzLl92YWx1ZSA9IGlzU2hhbGxvdzIgPyB2YWx1ZSA6IHRvUmVhY3RpdmUodmFsdWUpO1xyXG4gICAgdGhpc1tcIl9fdl9pc1NoYWxsb3dcIl0gPSBpc1NoYWxsb3cyO1xyXG4gIH1cclxuICBnZXQgdmFsdWUoKSB7XHJcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICB0aGlzLmRlcC50cmFjayh7XHJcbiAgICAgICAgdGFyZ2V0OiB0aGlzLFxyXG4gICAgICAgIHR5cGU6IFwiZ2V0XCIsXHJcbiAgICAgICAga2V5OiBcInZhbHVlXCJcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmRlcC50cmFjaygpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xyXG4gIH1cclxuICBzZXQgdmFsdWUobmV3VmFsdWUpIHtcclxuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fcmF3VmFsdWU7XHJcbiAgICBjb25zdCB1c2VEaXJlY3RWYWx1ZSA9IHRoaXNbXCJfX3ZfaXNTaGFsbG93XCJdIHx8IGlzU2hhbGxvdyhuZXdWYWx1ZSkgfHwgaXNSZWFkb25seShuZXdWYWx1ZSk7XHJcbiAgICBuZXdWYWx1ZSA9IHVzZURpcmVjdFZhbHVlID8gbmV3VmFsdWUgOiB0b1JhdyhuZXdWYWx1ZSk7XHJcbiAgICBpZiAoaGFzQ2hhbmdlZChuZXdWYWx1ZSwgb2xkVmFsdWUpKSB7XHJcbiAgICAgIHRoaXMuX3Jhd1ZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICAgIHRoaXMuX3ZhbHVlID0gdXNlRGlyZWN0VmFsdWUgPyBuZXdWYWx1ZSA6IHRvUmVhY3RpdmUobmV3VmFsdWUpO1xyXG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICAgIHRoaXMuZGVwLnRyaWdnZXIoe1xyXG4gICAgICAgICAgdGFyZ2V0OiB0aGlzLFxyXG4gICAgICAgICAgdHlwZTogXCJzZXRcIixcclxuICAgICAgICAgIGtleTogXCJ2YWx1ZVwiLFxyXG4gICAgICAgICAgbmV3VmFsdWUsXHJcbiAgICAgICAgICBvbGRWYWx1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZGVwLnRyaWdnZXIoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5mdW5jdGlvbiB0cmlnZ2VyUmVmKHJlZjIpIHtcclxuICBpZiAocmVmMi5kZXApIHtcclxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgIHJlZjIuZGVwLnRyaWdnZXIoe1xyXG4gICAgICAgIHRhcmdldDogcmVmMixcclxuICAgICAgICB0eXBlOiBcInNldFwiLFxyXG4gICAgICAgIGtleTogXCJ2YWx1ZVwiLFxyXG4gICAgICAgIG5ld1ZhbHVlOiByZWYyLl92YWx1ZVxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlZjIuZGVwLnRyaWdnZXIoKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZnVuY3Rpb24gdW5yZWYocmVmMikge1xyXG4gIHJldHVybiBpc1JlZihyZWYyKSA/IHJlZjIudmFsdWUgOiByZWYyO1xyXG59XHJcbmZ1bmN0aW9uIHRvVmFsdWUoc291cmNlKSB7XHJcbiAgcmV0dXJuIGlzRnVuY3Rpb24oc291cmNlKSA/IHNvdXJjZSgpIDogdW5yZWYoc291cmNlKTtcclxufVxyXG5jb25zdCBzaGFsbG93VW53cmFwSGFuZGxlcnMgPSB7XHJcbiAgZ2V0OiAodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSA9PiBrZXkgPT09IFwiX192X3Jhd1wiID8gdGFyZ2V0IDogdW5yZWYoUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSksXHJcbiAgc2V0OiAodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikgPT4ge1xyXG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcclxuICAgIGlmIChpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xyXG4gICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcbmZ1bmN0aW9uIHByb3h5UmVmcyhvYmplY3RXaXRoUmVmcykge1xyXG4gIHJldHVybiBpc1JlYWN0aXZlKG9iamVjdFdpdGhSZWZzKSA/IG9iamVjdFdpdGhSZWZzIDogbmV3IFByb3h5KG9iamVjdFdpdGhSZWZzLCBzaGFsbG93VW53cmFwSGFuZGxlcnMpO1xyXG59XHJcbmNsYXNzIEN1c3RvbVJlZkltcGwge1xyXG4gIGNvbnN0cnVjdG9yKGZhY3RvcnkpIHtcclxuICAgIHRoaXNbXCJfX3ZfaXNSZWZcIl0gPSB0cnVlO1xyXG4gICAgdGhpcy5fdmFsdWUgPSB2b2lkIDA7XHJcbiAgICBjb25zdCBkZXAgPSB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcclxuICAgIGNvbnN0IHsgZ2V0LCBzZXQgfSA9IGZhY3RvcnkoZGVwLnRyYWNrLmJpbmQoZGVwKSwgZGVwLnRyaWdnZXIuYmluZChkZXApKTtcclxuICAgIHRoaXMuX2dldCA9IGdldDtcclxuICAgIHRoaXMuX3NldCA9IHNldDtcclxuICB9XHJcbiAgZ2V0IHZhbHVlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlID0gdGhpcy5fZ2V0KCk7XHJcbiAgfVxyXG4gIHNldCB2YWx1ZShuZXdWYWwpIHtcclxuICAgIHRoaXMuX3NldChuZXdWYWwpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBjdXN0b21SZWYoZmFjdG9yeSkge1xyXG4gIHJldHVybiBuZXcgQ3VzdG9tUmVmSW1wbChmYWN0b3J5KTtcclxufVxyXG5mdW5jdGlvbiB0b1JlZnMob2JqZWN0KSB7XHJcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzUHJveHkob2JqZWN0KSkge1xyXG4gICAgd2FybihgdG9SZWZzKCkgZXhwZWN0cyBhIHJlYWN0aXZlIG9iamVjdCBidXQgcmVjZWl2ZWQgYSBwbGFpbiBvbmUuYCk7XHJcbiAgfVxyXG4gIGNvbnN0IHJldCA9IGlzQXJyYXkob2JqZWN0KSA/IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKSA6IHt9O1xyXG4gIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xyXG4gICAgcmV0W2tleV0gPSBwcm9wZXJ0eVRvUmVmKG9iamVjdCwga2V5KTtcclxuICB9XHJcbiAgcmV0dXJuIHJldDtcclxufVxyXG5jbGFzcyBPYmplY3RSZWZJbXBsIHtcclxuICBjb25zdHJ1Y3Rvcihfb2JqZWN0LCBfa2V5LCBfZGVmYXVsdFZhbHVlKSB7XHJcbiAgICB0aGlzLl9vYmplY3QgPSBfb2JqZWN0O1xyXG4gICAgdGhpcy5fa2V5ID0gX2tleTtcclxuICAgIHRoaXMuX2RlZmF1bHRWYWx1ZSA9IF9kZWZhdWx0VmFsdWU7XHJcbiAgICB0aGlzW1wiX192X2lzUmVmXCJdID0gdHJ1ZTtcclxuICAgIHRoaXMuX3ZhbHVlID0gdm9pZCAwO1xyXG4gIH1cclxuICBnZXQgdmFsdWUoKSB7XHJcbiAgICBjb25zdCB2YWwgPSB0aGlzLl9vYmplY3RbdGhpcy5fa2V5XTtcclxuICAgIHJldHVybiB0aGlzLl92YWx1ZSA9IHZhbCA9PT0gdm9pZCAwID8gdGhpcy5fZGVmYXVsdFZhbHVlIDogdmFsO1xyXG4gIH1cclxuICBzZXQgdmFsdWUobmV3VmFsKSB7XHJcbiAgICB0aGlzLl9vYmplY3RbdGhpcy5fa2V5XSA9IG5ld1ZhbDtcclxuICB9XHJcbiAgZ2V0IGRlcCgpIHtcclxuICAgIHJldHVybiBnZXREZXBGcm9tUmVhY3RpdmUodG9SYXcodGhpcy5fb2JqZWN0KSwgdGhpcy5fa2V5KTtcclxuICB9XHJcbn1cclxuY2xhc3MgR2V0dGVyUmVmSW1wbCB7XHJcbiAgY29uc3RydWN0b3IoX2dldHRlcikge1xyXG4gICAgdGhpcy5fZ2V0dGVyID0gX2dldHRlcjtcclxuICAgIHRoaXNbXCJfX3ZfaXNSZWZcIl0gPSB0cnVlO1xyXG4gICAgdGhpc1tcIl9fdl9pc1JlYWRvbmx5XCJdID0gdHJ1ZTtcclxuICAgIHRoaXMuX3ZhbHVlID0gdm9pZCAwO1xyXG4gIH1cclxuICBnZXQgdmFsdWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSB0aGlzLl9nZXR0ZXIoKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gdG9SZWYoc291cmNlLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xyXG4gIGlmIChpc1JlZihzb3VyY2UpKSB7XHJcbiAgICByZXR1cm4gc291cmNlO1xyXG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XHJcbiAgICByZXR1cm4gbmV3IEdldHRlclJlZkltcGwoc291cmNlKTtcclxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHNvdXJjZSkgJiYgYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgIHJldHVybiBwcm9wZXJ0eVRvUmVmKHNvdXJjZSwga2V5LCBkZWZhdWx0VmFsdWUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gcmVmKHNvdXJjZSk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHByb3BlcnR5VG9SZWYoc291cmNlLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xyXG4gIGNvbnN0IHZhbCA9IHNvdXJjZVtrZXldO1xyXG4gIHJldHVybiBpc1JlZih2YWwpID8gdmFsIDogbmV3IE9iamVjdFJlZkltcGwoc291cmNlLCBrZXksIGRlZmF1bHRWYWx1ZSk7XHJcbn1cclxuXHJcbmNsYXNzIENvbXB1dGVkUmVmSW1wbCB7XHJcbiAgY29uc3RydWN0b3IoZm4sIHNldHRlciwgaXNTU1IpIHtcclxuICAgIHRoaXMuZm4gPSBmbjtcclxuICAgIHRoaXMuc2V0dGVyID0gc2V0dGVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgdGhpcy5fdmFsdWUgPSB2b2lkIDA7XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICB0aGlzLmRlcCA9IG5ldyBEZXAodGhpcyk7XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XHJcbiAgICAvLyBUT0RPIGlzb2xhdGVkRGVjbGFyYXRpb25zIFwiX192X2lzUmVhZG9ubHlcIlxyXG4gICAgLy8gQSBjb21wdXRlZCBpcyBhbHNvIGEgc3Vic2NyaWJlciB0aGF0IHRyYWNrcyBvdGhlciBkZXBzXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICB0aGlzLmRlcHMgPSB2b2lkIDA7XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICB0aGlzLmRlcHNUYWlsID0gdm9pZCAwO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgdGhpcy5mbGFncyA9IDE2O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgdGhpcy5nbG9iYWxWZXJzaW9uID0gZ2xvYmFsVmVyc2lvbiAtIDE7XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICB0aGlzLm5leHQgPSB2b2lkIDA7XHJcbiAgICAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdFxyXG4gICAgdGhpcy5lZmZlY3QgPSB0aGlzO1xyXG4gICAgdGhpc1tcIl9fdl9pc1JlYWRvbmx5XCJdID0gIXNldHRlcjtcclxuICAgIHRoaXMuaXNTU1IgPSBpc1NTUjtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgbm90aWZ5KCkge1xyXG4gICAgdGhpcy5mbGFncyB8PSAxNjtcclxuICAgIGlmICghKHRoaXMuZmxhZ3MgJiA4KSAmJiAvLyBhdm9pZCBpbmZpbml0ZSBzZWxmIHJlY3Vyc2lvblxyXG4gICAgYWN0aXZlU3ViICE9PSB0aGlzKSB7XHJcbiAgICAgIGJhdGNoKHRoaXMsIHRydWUpO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkgO1xyXG4gIH1cclxuICBnZXQgdmFsdWUoKSB7XHJcbiAgICBjb25zdCBsaW5rID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHRoaXMuZGVwLnRyYWNrKHtcclxuICAgICAgdGFyZ2V0OiB0aGlzLFxyXG4gICAgICB0eXBlOiBcImdldFwiLFxyXG4gICAgICBrZXk6IFwidmFsdWVcIlxyXG4gICAgfSkgOiB0aGlzLmRlcC50cmFjaygpO1xyXG4gICAgcmVmcmVzaENvbXB1dGVkKHRoaXMpO1xyXG4gICAgaWYgKGxpbmspIHtcclxuICAgICAgbGluay52ZXJzaW9uID0gdGhpcy5kZXAudmVyc2lvbjtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcclxuICB9XHJcbiAgc2V0IHZhbHVlKG5ld1ZhbHVlKSB7XHJcbiAgICBpZiAodGhpcy5zZXR0ZXIpIHtcclxuICAgICAgdGhpcy5zZXR0ZXIobmV3VmFsdWUpO1xyXG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgIHdhcm4oXCJXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCB2YWx1ZSBpcyByZWFkb25seVwiKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZnVuY3Rpb24gY29tcHV0ZWQoZ2V0dGVyT3JPcHRpb25zLCBkZWJ1Z09wdGlvbnMsIGlzU1NSID0gZmFsc2UpIHtcclxuICBsZXQgZ2V0dGVyO1xyXG4gIGxldCBzZXR0ZXI7XHJcbiAgaWYgKGlzRnVuY3Rpb24oZ2V0dGVyT3JPcHRpb25zKSkge1xyXG4gICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBnZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuZ2V0O1xyXG4gICAgc2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLnNldDtcclxuICB9XHJcbiAgY29uc3QgY1JlZiA9IG5ldyBDb21wdXRlZFJlZkltcGwoZ2V0dGVyLCBzZXR0ZXIsIGlzU1NSKTtcclxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBkZWJ1Z09wdGlvbnMgJiYgIWlzU1NSKSB7XHJcbiAgICBjUmVmLm9uVHJhY2sgPSBkZWJ1Z09wdGlvbnMub25UcmFjaztcclxuICAgIGNSZWYub25UcmlnZ2VyID0gZGVidWdPcHRpb25zLm9uVHJpZ2dlcjtcclxuICB9XHJcbiAgcmV0dXJuIGNSZWY7XHJcbn1cclxuXHJcbmNvbnN0IFRyYWNrT3BUeXBlcyA9IHtcclxuICBcIkdFVFwiOiBcImdldFwiLFxyXG4gIFwiSEFTXCI6IFwiaGFzXCIsXHJcbiAgXCJJVEVSQVRFXCI6IFwiaXRlcmF0ZVwiXHJcbn07XHJcbmNvbnN0IFRyaWdnZXJPcFR5cGVzID0ge1xyXG4gIFwiU0VUXCI6IFwic2V0XCIsXHJcbiAgXCJBRERcIjogXCJhZGRcIixcclxuICBcIkRFTEVURVwiOiBcImRlbGV0ZVwiLFxyXG4gIFwiQ0xFQVJcIjogXCJjbGVhclwiXHJcbn07XHJcbmNvbnN0IFJlYWN0aXZlRmxhZ3MgPSB7XHJcbiAgXCJTS0lQXCI6IFwiX192X3NraXBcIixcclxuICBcIklTX1JFQUNUSVZFXCI6IFwiX192X2lzUmVhY3RpdmVcIixcclxuICBcIklTX1JFQURPTkxZXCI6IFwiX192X2lzUmVhZG9ubHlcIixcclxuICBcIklTX1NIQUxMT1dcIjogXCJfX3ZfaXNTaGFsbG93XCIsXHJcbiAgXCJSQVdcIjogXCJfX3ZfcmF3XCIsXHJcbiAgXCJJU19SRUZcIjogXCJfX3ZfaXNSZWZcIlxyXG59O1xyXG5cclxuY29uc3QgV2F0Y2hFcnJvckNvZGVzID0ge1xyXG4gIFwiV0FUQ0hfR0VUVEVSXCI6IDIsXHJcbiAgXCIyXCI6IFwiV0FUQ0hfR0VUVEVSXCIsXHJcbiAgXCJXQVRDSF9DQUxMQkFDS1wiOiAzLFxyXG4gIFwiM1wiOiBcIldBVENIX0NBTExCQUNLXCIsXHJcbiAgXCJXQVRDSF9DTEVBTlVQXCI6IDQsXHJcbiAgXCI0XCI6IFwiV0FUQ0hfQ0xFQU5VUFwiXHJcbn07XHJcbmNvbnN0IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA9IHt9O1xyXG5jb25zdCBjbGVhbnVwTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XHJcbmxldCBhY3RpdmVXYXRjaGVyID0gdm9pZCAwO1xyXG5mdW5jdGlvbiBnZXRDdXJyZW50V2F0Y2hlcigpIHtcclxuICByZXR1cm4gYWN0aXZlV2F0Y2hlcjtcclxufVxyXG5mdW5jdGlvbiBvbldhdGNoZXJDbGVhbnVwKGNsZWFudXBGbiwgZmFpbFNpbGVudGx5ID0gZmFsc2UsIG93bmVyID0gYWN0aXZlV2F0Y2hlcikge1xyXG4gIGlmIChvd25lcikge1xyXG4gICAgbGV0IGNsZWFudXBzID0gY2xlYW51cE1hcC5nZXQob3duZXIpO1xyXG4gICAgaWYgKCFjbGVhbnVwcykgY2xlYW51cE1hcC5zZXQob3duZXIsIGNsZWFudXBzID0gW10pO1xyXG4gICAgY2xlYW51cHMucHVzaChjbGVhbnVwRm4pO1xyXG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhZmFpbFNpbGVudGx5KSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICBgb25XYXRjaGVyQ2xlYW51cCgpIHdhcyBjYWxsZWQgd2hlbiB0aGVyZSB3YXMgbm8gYWN0aXZlIHdhdGNoZXIgdG8gYXNzb2NpYXRlIHdpdGguYFxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucyA9IEVNUFRZX09CSikge1xyXG4gIGNvbnN0IHsgaW1tZWRpYXRlLCBkZWVwLCBvbmNlLCBzY2hlZHVsZXIsIGF1Z21lbnRKb2IsIGNhbGwgfSA9IG9wdGlvbnM7XHJcbiAgY29uc3Qgd2FybkludmFsaWRTb3VyY2UgPSAocykgPT4ge1xyXG4gICAgKG9wdGlvbnMub25XYXJuIHx8IHdhcm4pKFxyXG4gICAgICBgSW52YWxpZCB3YXRjaCBzb3VyY2U6IGAsXHJcbiAgICAgIHMsXHJcbiAgICAgIGBBIHdhdGNoIHNvdXJjZSBjYW4gb25seSBiZSBhIGdldHRlci9lZmZlY3QgZnVuY3Rpb24sIGEgcmVmLCBhIHJlYWN0aXZlIG9iamVjdCwgb3IgYW4gYXJyYXkgb2YgdGhlc2UgdHlwZXMuYFxyXG4gICAgKTtcclxuICB9O1xyXG4gIGNvbnN0IHJlYWN0aXZlR2V0dGVyID0gKHNvdXJjZTIpID0+IHtcclxuICAgIGlmIChkZWVwKSByZXR1cm4gc291cmNlMjtcclxuICAgIGlmIChpc1NoYWxsb3coc291cmNlMikgfHwgZGVlcCA9PT0gZmFsc2UgfHwgZGVlcCA9PT0gMClcclxuICAgICAgcmV0dXJuIHRyYXZlcnNlKHNvdXJjZTIsIDEpO1xyXG4gICAgcmV0dXJuIHRyYXZlcnNlKHNvdXJjZTIpO1xyXG4gIH07XHJcbiAgbGV0IGVmZmVjdDtcclxuICBsZXQgZ2V0dGVyO1xyXG4gIGxldCBjbGVhbnVwO1xyXG4gIGxldCBib3VuZENsZWFudXA7XHJcbiAgbGV0IGZvcmNlVHJpZ2dlciA9IGZhbHNlO1xyXG4gIGxldCBpc011bHRpU291cmNlID0gZmFsc2U7XHJcbiAgaWYgKGlzUmVmKHNvdXJjZSkpIHtcclxuICAgIGdldHRlciA9ICgpID0+IHNvdXJjZS52YWx1ZTtcclxuICAgIGZvcmNlVHJpZ2dlciA9IGlzU2hhbGxvdyhzb3VyY2UpO1xyXG4gIH0gZWxzZSBpZiAoaXNSZWFjdGl2ZShzb3VyY2UpKSB7XHJcbiAgICBnZXR0ZXIgPSAoKSA9PiByZWFjdGl2ZUdldHRlcihzb3VyY2UpO1xyXG4gICAgZm9yY2VUcmlnZ2VyID0gdHJ1ZTtcclxuICB9IGVsc2UgaWYgKGlzQXJyYXkoc291cmNlKSkge1xyXG4gICAgaXNNdWx0aVNvdXJjZSA9IHRydWU7XHJcbiAgICBmb3JjZVRyaWdnZXIgPSBzb3VyY2Uuc29tZSgocykgPT4gaXNSZWFjdGl2ZShzKSB8fCBpc1NoYWxsb3cocykpO1xyXG4gICAgZ2V0dGVyID0gKCkgPT4gc291cmNlLm1hcCgocykgPT4ge1xyXG4gICAgICBpZiAoaXNSZWYocykpIHtcclxuICAgICAgICByZXR1cm4gcy52YWx1ZTtcclxuICAgICAgfSBlbHNlIGlmIChpc1JlYWN0aXZlKHMpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlYWN0aXZlR2V0dGVyKHMpO1xyXG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocykpIHtcclxuICAgICAgICByZXR1cm4gY2FsbCA/IGNhbGwocywgMikgOiBzKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuSW52YWxpZFNvdXJjZShzKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHNvdXJjZSkpIHtcclxuICAgIGlmIChjYikge1xyXG4gICAgICBnZXR0ZXIgPSBjYWxsID8gKCkgPT4gY2FsbChzb3VyY2UsIDIpIDogc291cmNlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZ2V0dGVyID0gKCkgPT4ge1xyXG4gICAgICAgIGlmIChjbGVhbnVwKSB7XHJcbiAgICAgICAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjbGVhbnVwKCk7XHJcbiAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRFZmZlY3QgPSBhY3RpdmVXYXRjaGVyO1xyXG4gICAgICAgIGFjdGl2ZVdhdGNoZXIgPSBlZmZlY3Q7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHJldHVybiBjYWxsID8gY2FsbChzb3VyY2UsIDMsIFtib3VuZENsZWFudXBdKSA6IHNvdXJjZShib3VuZENsZWFudXApO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICBhY3RpdmVXYXRjaGVyID0gY3VycmVudEVmZmVjdDtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGdldHRlciA9IE5PT1A7XHJcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm5JbnZhbGlkU291cmNlKHNvdXJjZSk7XHJcbiAgfVxyXG4gIGlmIChjYiAmJiBkZWVwKSB7XHJcbiAgICBjb25zdCBiYXNlR2V0dGVyID0gZ2V0dGVyO1xyXG4gICAgY29uc3QgZGVwdGggPSBkZWVwID09PSB0cnVlID8gSW5maW5pdHkgOiBkZWVwO1xyXG4gICAgZ2V0dGVyID0gKCkgPT4gdHJhdmVyc2UoYmFzZUdldHRlcigpLCBkZXB0aCk7XHJcbiAgfVxyXG4gIGNvbnN0IHNjb3BlID0gZ2V0Q3VycmVudFNjb3BlKCk7XHJcbiAgY29uc3Qgd2F0Y2hIYW5kbGUgPSAoKSA9PiB7XHJcbiAgICBlZmZlY3Quc3RvcCgpO1xyXG4gICAgaWYgKHNjb3BlICYmIHNjb3BlLmFjdGl2ZSkge1xyXG4gICAgICByZW1vdmUoc2NvcGUuZWZmZWN0cywgZWZmZWN0KTtcclxuICAgIH1cclxuICB9O1xyXG4gIGlmIChvbmNlICYmIGNiKSB7XHJcbiAgICBjb25zdCBfY2IgPSBjYjtcclxuICAgIGNiID0gKC4uLmFyZ3MpID0+IHtcclxuICAgICAgX2NiKC4uLmFyZ3MpO1xyXG4gICAgICB3YXRjaEhhbmRsZSgpO1xyXG4gICAgfTtcclxuICB9XHJcbiAgbGV0IG9sZFZhbHVlID0gaXNNdWx0aVNvdXJjZSA/IG5ldyBBcnJheShzb3VyY2UubGVuZ3RoKS5maWxsKElOSVRJQUxfV0FUQ0hFUl9WQUxVRSkgOiBJTklUSUFMX1dBVENIRVJfVkFMVUU7XHJcbiAgY29uc3Qgam9iID0gKGltbWVkaWF0ZUZpcnN0UnVuKSA9PiB7XHJcbiAgICBpZiAoIShlZmZlY3QuZmxhZ3MgJiAxKSB8fCAhZWZmZWN0LmRpcnR5ICYmICFpbW1lZGlhdGVGaXJzdFJ1bikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoY2IpIHtcclxuICAgICAgY29uc3QgbmV3VmFsdWUgPSBlZmZlY3QucnVuKCk7XHJcbiAgICAgIGlmIChkZWVwIHx8IGZvcmNlVHJpZ2dlciB8fCAoaXNNdWx0aVNvdXJjZSA/IG5ld1ZhbHVlLnNvbWUoKHYsIGkpID0+IGhhc0NoYW5nZWQodiwgb2xkVmFsdWVbaV0pKSA6IGhhc0NoYW5nZWQobmV3VmFsdWUsIG9sZFZhbHVlKSkpIHtcclxuICAgICAgICBpZiAoY2xlYW51cCkge1xyXG4gICAgICAgICAgY2xlYW51cCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjdXJyZW50V2F0Y2hlciA9IGFjdGl2ZVdhdGNoZXI7XHJcbiAgICAgICAgYWN0aXZlV2F0Y2hlciA9IGVmZmVjdDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgYXJncyA9IFtcclxuICAgICAgICAgICAgbmV3VmFsdWUsXHJcbiAgICAgICAgICAgIC8vIHBhc3MgdW5kZWZpbmVkIGFzIHRoZSBvbGQgdmFsdWUgd2hlbiBpdCdzIGNoYW5nZWQgZm9yIHRoZSBmaXJzdCB0aW1lXHJcbiAgICAgICAgICAgIG9sZFZhbHVlID09PSBJTklUSUFMX1dBVENIRVJfVkFMVUUgPyB2b2lkIDAgOiBpc011bHRpU291cmNlICYmIG9sZFZhbHVlWzBdID09PSBJTklUSUFMX1dBVENIRVJfVkFMVUUgPyBbXSA6IG9sZFZhbHVlLFxyXG4gICAgICAgICAgICBib3VuZENsZWFudXBcclxuICAgICAgICAgIF07XHJcbiAgICAgICAgICBjYWxsID8gY2FsbChjYiwgMywgYXJncykgOiAoXHJcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICAgICAgY2IoLi4uYXJncylcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBvbGRWYWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICBhY3RpdmVXYXRjaGVyID0gY3VycmVudFdhdGNoZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlZmZlY3QucnVuKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBpZiAoYXVnbWVudEpvYikge1xyXG4gICAgYXVnbWVudEpvYihqb2IpO1xyXG4gIH1cclxuICBlZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoZ2V0dGVyKTtcclxuICBlZmZlY3Quc2NoZWR1bGVyID0gc2NoZWR1bGVyID8gKCkgPT4gc2NoZWR1bGVyKGpvYiwgZmFsc2UpIDogam9iO1xyXG4gIGJvdW5kQ2xlYW51cCA9IChmbikgPT4gb25XYXRjaGVyQ2xlYW51cChmbiwgZmFsc2UsIGVmZmVjdCk7XHJcbiAgY2xlYW51cCA9IGVmZmVjdC5vblN0b3AgPSAoKSA9PiB7XHJcbiAgICBjb25zdCBjbGVhbnVwcyA9IGNsZWFudXBNYXAuZ2V0KGVmZmVjdCk7XHJcbiAgICBpZiAoY2xlYW51cHMpIHtcclxuICAgICAgaWYgKGNhbGwpIHtcclxuICAgICAgICBjYWxsKGNsZWFudXBzLCA0KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGNsZWFudXAyIG9mIGNsZWFudXBzKSBjbGVhbnVwMigpO1xyXG4gICAgICB9XHJcbiAgICAgIGNsZWFudXBNYXAuZGVsZXRlKGVmZmVjdCk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgZWZmZWN0Lm9uVHJhY2sgPSBvcHRpb25zLm9uVHJhY2s7XHJcbiAgICBlZmZlY3Qub25UcmlnZ2VyID0gb3B0aW9ucy5vblRyaWdnZXI7XHJcbiAgfVxyXG4gIGlmIChjYikge1xyXG4gICAgaWYgKGltbWVkaWF0ZSkge1xyXG4gICAgICBqb2IodHJ1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBvbGRWYWx1ZSA9IGVmZmVjdC5ydW4oKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKHNjaGVkdWxlcikge1xyXG4gICAgc2NoZWR1bGVyKGpvYi5iaW5kKG51bGwsIHRydWUpLCB0cnVlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgZWZmZWN0LnJ1bigpO1xyXG4gIH1cclxuICB3YXRjaEhhbmRsZS5wYXVzZSA9IGVmZmVjdC5wYXVzZS5iaW5kKGVmZmVjdCk7XHJcbiAgd2F0Y2hIYW5kbGUucmVzdW1lID0gZWZmZWN0LnJlc3VtZS5iaW5kKGVmZmVjdCk7XHJcbiAgd2F0Y2hIYW5kbGUuc3RvcCA9IHdhdGNoSGFuZGxlO1xyXG4gIHJldHVybiB3YXRjaEhhbmRsZTtcclxufVxyXG5mdW5jdGlvbiB0cmF2ZXJzZSh2YWx1ZSwgZGVwdGggPSBJbmZpbml0eSwgc2Vlbikge1xyXG4gIGlmIChkZXB0aCA8PSAwIHx8ICFpc09iamVjdCh2YWx1ZSkgfHwgdmFsdWVbXCJfX3Zfc2tpcFwiXSkge1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH1cclxuICBzZWVuID0gc2VlbiB8fCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xyXG4gIGlmIChzZWVuLmhhcyh2YWx1ZSkpIHtcclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcbiAgc2Vlbi5hZGQodmFsdWUpO1xyXG4gIGRlcHRoLS07XHJcbiAgaWYgKGlzUmVmKHZhbHVlKSkge1xyXG4gICAgdHJhdmVyc2UodmFsdWUudmFsdWUsIGRlcHRoLCBzZWVuKTtcclxuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHRyYXZlcnNlKHZhbHVlW2ldLCBkZXB0aCwgc2Vlbik7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChpc1NldCh2YWx1ZSkgfHwgaXNNYXAodmFsdWUpKSB7XHJcbiAgICB2YWx1ZS5mb3JFYWNoKCh2KSA9PiB7XHJcbiAgICAgIHRyYXZlcnNlKHYsIGRlcHRoLCBzZWVuKTtcclxuICAgIH0pO1xyXG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XHJcbiAgICAgIHRyYXZlcnNlKHZhbHVlW2tleV0sIGRlcHRoLCBzZWVuKTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpKSB7XHJcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsIGtleSkpIHtcclxuICAgICAgICB0cmF2ZXJzZSh2YWx1ZVtrZXldLCBkZXB0aCwgc2Vlbik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHZhbHVlO1xyXG59XHJcblxyXG5leHBvcnQgeyBBUlJBWV9JVEVSQVRFX0tFWSwgRWZmZWN0RmxhZ3MsIEVmZmVjdFNjb3BlLCBJVEVSQVRFX0tFWSwgTUFQX0tFWV9JVEVSQVRFX0tFWSwgUmVhY3RpdmVFZmZlY3QsIFJlYWN0aXZlRmxhZ3MsIFRyYWNrT3BUeXBlcywgVHJpZ2dlck9wVHlwZXMsIFdhdGNoRXJyb3JDb2RlcywgY29tcHV0ZWQsIGN1c3RvbVJlZiwgZWZmZWN0LCBlZmZlY3RTY29wZSwgZW5hYmxlVHJhY2tpbmcsIGdldEN1cnJlbnRTY29wZSwgZ2V0Q3VycmVudFdhdGNoZXIsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBpc1NoYWxsb3csIG1hcmtSYXcsIG9uRWZmZWN0Q2xlYW51cCwgb25TY29wZURpc3Bvc2UsIG9uV2F0Y2hlckNsZWFudXAsIHBhdXNlVHJhY2tpbmcsIHByb3h5UmVmcywgcmVhY3RpdmUsIHJlYWN0aXZlUmVhZEFycmF5LCByZWFkb25seSwgcmVmLCByZXNldFRyYWNraW5nLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkQXJyYXksIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgc3RvcCwgdG9SYXcsIHRvUmVhY3RpdmUsIHRvUmVhZG9ubHksIHRvUmVmLCB0b1JlZnMsIHRvVmFsdWUsIHRyYWNrLCB0cmF2ZXJzZSwgdHJpZ2dlciwgdHJpZ2dlclJlZiwgdW5yZWYsIHdhdGNoIH07XHJcbiIsIi8qKlxyXG4qIEB2dWUvcnVudGltZS1jb3JlIHYzLjUuMTNcclxuKiAoYykgMjAxOC1wcmVzZW50IFl1eGkgKEV2YW4pIFlvdSBhbmQgVnVlIGNvbnRyaWJ1dG9yc1xyXG4qIEBsaWNlbnNlIE1JVFxyXG4qKi9cclxuaW1wb3J0IHsgcGF1c2VUcmFja2luZywgcmVzZXRUcmFja2luZywgaXNSZWYsIHRvUmF3LCB0cmF2ZXJzZSwgc2hhbGxvd1JlZiwgcmVhZG9ubHksIGlzUmVhY3RpdmUsIHJlZiwgaXNTaGFsbG93LCBzaGFsbG93UmVhZEFycmF5LCB0b1JlYWN0aXZlLCBzaGFsbG93UmVhZG9ubHksIHRyYWNrLCByZWFjdGl2ZSwgc2hhbGxvd1JlYWN0aXZlLCB0cmlnZ2VyLCBSZWFjdGl2ZUVmZmVjdCwgd2F0Y2ggYXMgd2F0Y2gkMSwgY3VzdG9tUmVmLCBpc1Byb3h5LCBwcm94eVJlZnMsIG1hcmtSYXcsIEVmZmVjdFNjb3BlLCBjb21wdXRlZCBhcyBjb21wdXRlZCQxLCBpc1JlYWRvbmx5IH0gZnJvbSAnQHZ1ZS9yZWFjdGl2aXR5JztcclxuZXhwb3J0IHsgRWZmZWN0U2NvcGUsIFJlYWN0aXZlRWZmZWN0LCBUcmFja09wVHlwZXMsIFRyaWdnZXJPcFR5cGVzLCBjdXN0b21SZWYsIGVmZmVjdCwgZWZmZWN0U2NvcGUsIGdldEN1cnJlbnRTY29wZSwgZ2V0Q3VycmVudFdhdGNoZXIsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBpc1NoYWxsb3csIG1hcmtSYXcsIG9uU2NvcGVEaXNwb3NlLCBvbldhdGNoZXJDbGVhbnVwLCBwcm94eVJlZnMsIHJlYWN0aXZlLCByZWFkb25seSwgcmVmLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgc3RvcCwgdG9SYXcsIHRvUmVmLCB0b1JlZnMsIHRvVmFsdWUsIHRyaWdnZXJSZWYsIHVucmVmIH0gZnJvbSAnQHZ1ZS9yZWFjdGl2aXR5JztcclxuaW1wb3J0IHsgaXNTdHJpbmcsIGlzRnVuY3Rpb24sIGlzUHJvbWlzZSwgaXNBcnJheSwgRU1QVFlfT0JKLCBOT09QLCBnZXRHbG9iYWxUaGlzLCBleHRlbmQsIGlzQnVpbHRJbkRpcmVjdGl2ZSwgaGFzT3duLCByZW1vdmUsIGRlZiwgaXNPbiwgaXNSZXNlcnZlZFByb3AsIG5vcm1hbGl6ZUNsYXNzLCBzdHJpbmdpZnlTdHlsZSwgbm9ybWFsaXplU3R5bGUsIGlzS25vd25TdmdBdHRyLCBpc0Jvb2xlYW5BdHRyLCBpc0tub3duSHRtbEF0dHIsIGluY2x1ZGVCb29sZWFuQXR0ciwgaXNSZW5kZXJhYmxlQXR0clZhbHVlLCBnZXRFc2NhcGVkQ3NzVmFyTmFtZSwgaXNPYmplY3QsIGlzUmVnRXhwLCBpbnZva2VBcnJheUZucywgdG9IYW5kbGVyS2V5LCBjYXBpdGFsaXplLCBjYW1lbGl6ZSwgaXNTeW1ib2wsIGlzR2xvYmFsbHlBbGxvd2VkLCBOTywgaHlwaGVuYXRlLCBFTVBUWV9BUlIsIHRvUmF3VHlwZSwgbWFrZU1hcCwgaGFzQ2hhbmdlZCwgbG9vc2VUb051bWJlciwgaXNNb2RlbExpc3RlbmVyLCB0b051bWJlciB9IGZyb20gJ0B2dWUvc2hhcmVkJztcclxuZXhwb3J0IHsgY2FtZWxpemUsIGNhcGl0YWxpemUsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVQcm9wcywgbm9ybWFsaXplU3R5bGUsIHRvRGlzcGxheVN0cmluZywgdG9IYW5kbGVyS2V5IH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xyXG5cclxuY29uc3Qgc3RhY2sgPSBbXTtcclxuZnVuY3Rpb24gcHVzaFdhcm5pbmdDb250ZXh0KHZub2RlKSB7XHJcbiAgc3RhY2sucHVzaCh2bm9kZSk7XHJcbn1cclxuZnVuY3Rpb24gcG9wV2FybmluZ0NvbnRleHQoKSB7XHJcbiAgc3RhY2sucG9wKCk7XHJcbn1cclxubGV0IGlzV2FybmluZyA9IGZhbHNlO1xyXG5mdW5jdGlvbiB3YXJuJDEobXNnLCAuLi5hcmdzKSB7XHJcbiAgaWYgKGlzV2FybmluZykgcmV0dXJuO1xyXG4gIGlzV2FybmluZyA9IHRydWU7XHJcbiAgcGF1c2VUcmFja2luZygpO1xyXG4gIGNvbnN0IGluc3RhbmNlID0gc3RhY2subGVuZ3RoID8gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0uY29tcG9uZW50IDogbnVsbDtcclxuICBjb25zdCBhcHBXYXJuSGFuZGxlciA9IGluc3RhbmNlICYmIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLndhcm5IYW5kbGVyO1xyXG4gIGNvbnN0IHRyYWNlID0gZ2V0Q29tcG9uZW50VHJhY2UoKTtcclxuICBpZiAoYXBwV2FybkhhbmRsZXIpIHtcclxuICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhcclxuICAgICAgYXBwV2FybkhhbmRsZXIsXHJcbiAgICAgIGluc3RhbmNlLFxyXG4gICAgICAxMSxcclxuICAgICAgW1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgICAgIG1zZyArIGFyZ3MubWFwKChhKSA9PiB7XHJcbiAgICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IGEudG9TdHJpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGEpKSAhPSBudWxsID8gX2IgOiBKU09OLnN0cmluZ2lmeShhKTtcclxuICAgICAgICB9KS5qb2luKFwiXCIpLFxyXG4gICAgICAgIGluc3RhbmNlICYmIGluc3RhbmNlLnByb3h5LFxyXG4gICAgICAgIHRyYWNlLm1hcChcclxuICAgICAgICAgICh7IHZub2RlIH0pID0+IGBhdCA8JHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCB2bm9kZS50eXBlKX0+YFxyXG4gICAgICAgICkuam9pbihcIlxcblwiKSxcclxuICAgICAgICB0cmFjZVxyXG4gICAgICBdXHJcbiAgICApO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdCB3YXJuQXJncyA9IFtgW1Z1ZSB3YXJuXTogJHttc2d9YCwgLi4uYXJnc107XHJcbiAgICBpZiAodHJhY2UubGVuZ3RoICYmIC8vIGF2b2lkIHNwYW1taW5nIGNvbnNvbGUgZHVyaW5nIHRlc3RzXHJcbiAgICB0cnVlKSB7XHJcbiAgICAgIHdhcm5BcmdzLnB1c2goYFxyXG5gLCAuLi5mb3JtYXRUcmFjZSh0cmFjZSkpO1xyXG4gICAgfVxyXG4gICAgY29uc29sZS53YXJuKC4uLndhcm5BcmdzKTtcclxuICB9XHJcbiAgcmVzZXRUcmFja2luZygpO1xyXG4gIGlzV2FybmluZyA9IGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGdldENvbXBvbmVudFRyYWNlKCkge1xyXG4gIGxldCBjdXJyZW50Vk5vZGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcclxuICBpZiAoIWN1cnJlbnRWTm9kZSkge1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuICBjb25zdCBub3JtYWxpemVkU3RhY2sgPSBbXTtcclxuICB3aGlsZSAoY3VycmVudFZOb2RlKSB7XHJcbiAgICBjb25zdCBsYXN0ID0gbm9ybWFsaXplZFN0YWNrWzBdO1xyXG4gICAgaWYgKGxhc3QgJiYgbGFzdC52bm9kZSA9PT0gY3VycmVudFZOb2RlKSB7XHJcbiAgICAgIGxhc3QucmVjdXJzZUNvdW50Kys7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBub3JtYWxpemVkU3RhY2sucHVzaCh7XHJcbiAgICAgICAgdm5vZGU6IGN1cnJlbnRWTm9kZSxcclxuICAgICAgICByZWN1cnNlQ291bnQ6IDBcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYXJlbnRJbnN0YW5jZSA9IGN1cnJlbnRWTm9kZS5jb21wb25lbnQgJiYgY3VycmVudFZOb2RlLmNvbXBvbmVudC5wYXJlbnQ7XHJcbiAgICBjdXJyZW50Vk5vZGUgPSBwYXJlbnRJbnN0YW5jZSAmJiBwYXJlbnRJbnN0YW5jZS52bm9kZTtcclxuICB9XHJcbiAgcmV0dXJuIG5vcm1hbGl6ZWRTdGFjaztcclxufVxyXG5mdW5jdGlvbiBmb3JtYXRUcmFjZSh0cmFjZSkge1xyXG4gIGNvbnN0IGxvZ3MgPSBbXTtcclxuICB0cmFjZS5mb3JFYWNoKChlbnRyeSwgaSkgPT4ge1xyXG4gICAgbG9ncy5wdXNoKC4uLmkgPT09IDAgPyBbXSA6IFtgXHJcbmBdLCAuLi5mb3JtYXRUcmFjZUVudHJ5KGVudHJ5KSk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIGxvZ3M7XHJcbn1cclxuZnVuY3Rpb24gZm9ybWF0VHJhY2VFbnRyeSh7IHZub2RlLCByZWN1cnNlQ291bnQgfSkge1xyXG4gIGNvbnN0IHBvc3RmaXggPSByZWN1cnNlQ291bnQgPiAwID8gYC4uLiAoJHtyZWN1cnNlQ291bnR9IHJlY3Vyc2l2ZSBjYWxscylgIDogYGA7XHJcbiAgY29uc3QgaXNSb290ID0gdm5vZGUuY29tcG9uZW50ID8gdm5vZGUuY29tcG9uZW50LnBhcmVudCA9PSBudWxsIDogZmFsc2U7XHJcbiAgY29uc3Qgb3BlbiA9IGAgYXQgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZShcclxuICAgIHZub2RlLmNvbXBvbmVudCxcclxuICAgIHZub2RlLnR5cGUsXHJcbiAgICBpc1Jvb3RcclxuICApfWA7XHJcbiAgY29uc3QgY2xvc2UgPSBgPmAgKyBwb3N0Zml4O1xyXG4gIHJldHVybiB2bm9kZS5wcm9wcyA/IFtvcGVuLCAuLi5mb3JtYXRQcm9wcyh2bm9kZS5wcm9wcyksIGNsb3NlXSA6IFtvcGVuICsgY2xvc2VdO1xyXG59XHJcbmZ1bmN0aW9uIGZvcm1hdFByb3BzKHByb3BzKSB7XHJcbiAgY29uc3QgcmVzID0gW107XHJcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcclxuICBrZXlzLnNsaWNlKDAsIDMpLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgcmVzLnB1c2goLi4uZm9ybWF0UHJvcChrZXksIHByb3BzW2tleV0pKTtcclxuICB9KTtcclxuICBpZiAoa2V5cy5sZW5ndGggPiAzKSB7XHJcbiAgICByZXMucHVzaChgIC4uLmApO1xyXG4gIH1cclxuICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIGZvcm1hdFByb3Aoa2V5LCB2YWx1ZSwgcmF3KSB7XHJcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XHJcbiAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT0ke3ZhbHVlfWBdO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIgfHwgdmFsdWUgPT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09JHt2YWx1ZX1gXTtcclxuICB9IGVsc2UgaWYgKGlzUmVmKHZhbHVlKSkge1xyXG4gICAgdmFsdWUgPSBmb3JtYXRQcm9wKGtleSwgdG9SYXcodmFsdWUudmFsdWUpLCB0cnVlKTtcclxuICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PVJlZjxgLCB2YWx1ZSwgYD5gXTtcclxuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICByZXR1cm4gW2Ake2tleX09Zm4ke3ZhbHVlLm5hbWUgPyBgPCR7dmFsdWUubmFtZX0+YCA6IGBgfWBdO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcclxuICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PWAsIHZhbHVlXTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyKHZhbCwgdHlwZSkge1xyXG4gIGlmICghISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkgcmV0dXJuO1xyXG4gIGlmICh2YWwgPT09IHZvaWQgMCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCAhPT0gXCJudW1iZXJcIikge1xyXG4gICAgd2FybiQxKGAke3R5cGV9IGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbCl9LmApO1xyXG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xyXG4gICAgd2FybiQxKGAke3R5cGV9IGlzIE5hTiAtIHRoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC5gKTtcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IEVycm9yQ29kZXMgPSB7XHJcbiAgXCJTRVRVUF9GVU5DVElPTlwiOiAwLFxyXG4gIFwiMFwiOiBcIlNFVFVQX0ZVTkNUSU9OXCIsXHJcbiAgXCJSRU5ERVJfRlVOQ1RJT05cIjogMSxcclxuICBcIjFcIjogXCJSRU5ERVJfRlVOQ1RJT05cIixcclxuICBcIk5BVElWRV9FVkVOVF9IQU5ETEVSXCI6IDUsXHJcbiAgXCI1XCI6IFwiTkFUSVZFX0VWRU5UX0hBTkRMRVJcIixcclxuICBcIkNPTVBPTkVOVF9FVkVOVF9IQU5ETEVSXCI6IDYsXHJcbiAgXCI2XCI6IFwiQ09NUE9ORU5UX0VWRU5UX0hBTkRMRVJcIixcclxuICBcIlZOT0RFX0hPT0tcIjogNyxcclxuICBcIjdcIjogXCJWTk9ERV9IT09LXCIsXHJcbiAgXCJESVJFQ1RJVkVfSE9PS1wiOiA4LFxyXG4gIFwiOFwiOiBcIkRJUkVDVElWRV9IT09LXCIsXHJcbiAgXCJUUkFOU0lUSU9OX0hPT0tcIjogOSxcclxuICBcIjlcIjogXCJUUkFOU0lUSU9OX0hPT0tcIixcclxuICBcIkFQUF9FUlJPUl9IQU5ETEVSXCI6IDEwLFxyXG4gIFwiMTBcIjogXCJBUFBfRVJST1JfSEFORExFUlwiLFxyXG4gIFwiQVBQX1dBUk5fSEFORExFUlwiOiAxMSxcclxuICBcIjExXCI6IFwiQVBQX1dBUk5fSEFORExFUlwiLFxyXG4gIFwiRlVOQ1RJT05fUkVGXCI6IDEyLFxyXG4gIFwiMTJcIjogXCJGVU5DVElPTl9SRUZcIixcclxuICBcIkFTWU5DX0NPTVBPTkVOVF9MT0FERVJcIjogMTMsXHJcbiAgXCIxM1wiOiBcIkFTWU5DX0NPTVBPTkVOVF9MT0FERVJcIixcclxuICBcIlNDSEVEVUxFUlwiOiAxNCxcclxuICBcIjE0XCI6IFwiU0NIRURVTEVSXCIsXHJcbiAgXCJDT01QT05FTlRfVVBEQVRFXCI6IDE1LFxyXG4gIFwiMTVcIjogXCJDT01QT05FTlRfVVBEQVRFXCIsXHJcbiAgXCJBUFBfVU5NT1VOVF9DTEVBTlVQXCI6IDE2LFxyXG4gIFwiMTZcIjogXCJBUFBfVU5NT1VOVF9DTEVBTlVQXCJcclxufTtcclxuY29uc3QgRXJyb3JUeXBlU3RyaW5ncyQxID0ge1xyXG4gIFtcInNwXCJdOiBcInNlcnZlclByZWZldGNoIGhvb2tcIixcclxuICBbXCJiY1wiXTogXCJiZWZvcmVDcmVhdGUgaG9va1wiLFxyXG4gIFtcImNcIl06IFwiY3JlYXRlZCBob29rXCIsXHJcbiAgW1wiYm1cIl06IFwiYmVmb3JlTW91bnQgaG9va1wiLFxyXG4gIFtcIm1cIl06IFwibW91bnRlZCBob29rXCIsXHJcbiAgW1wiYnVcIl06IFwiYmVmb3JlVXBkYXRlIGhvb2tcIixcclxuICBbXCJ1XCJdOiBcInVwZGF0ZWRcIixcclxuICBbXCJidW1cIl06IFwiYmVmb3JlVW5tb3VudCBob29rXCIsXHJcbiAgW1widW1cIl06IFwidW5tb3VudGVkIGhvb2tcIixcclxuICBbXCJhXCJdOiBcImFjdGl2YXRlZCBob29rXCIsXHJcbiAgW1wiZGFcIl06IFwiZGVhY3RpdmF0ZWQgaG9va1wiLFxyXG4gIFtcImVjXCJdOiBcImVycm9yQ2FwdHVyZWQgaG9va1wiLFxyXG4gIFtcInJ0Y1wiXTogXCJyZW5kZXJUcmFja2VkIGhvb2tcIixcclxuICBbXCJydGdcIl06IFwicmVuZGVyVHJpZ2dlcmVkIGhvb2tcIixcclxuICBbMF06IFwic2V0dXAgZnVuY3Rpb25cIixcclxuICBbMV06IFwicmVuZGVyIGZ1bmN0aW9uXCIsXHJcbiAgWzJdOiBcIndhdGNoZXIgZ2V0dGVyXCIsXHJcbiAgWzNdOiBcIndhdGNoZXIgY2FsbGJhY2tcIixcclxuICBbNF06IFwid2F0Y2hlciBjbGVhbnVwIGZ1bmN0aW9uXCIsXHJcbiAgWzVdOiBcIm5hdGl2ZSBldmVudCBoYW5kbGVyXCIsXHJcbiAgWzZdOiBcImNvbXBvbmVudCBldmVudCBoYW5kbGVyXCIsXHJcbiAgWzddOiBcInZub2RlIGhvb2tcIixcclxuICBbOF06IFwiZGlyZWN0aXZlIGhvb2tcIixcclxuICBbOV06IFwidHJhbnNpdGlvbiBob29rXCIsXHJcbiAgWzEwXTogXCJhcHAgZXJyb3JIYW5kbGVyXCIsXHJcbiAgWzExXTogXCJhcHAgd2FybkhhbmRsZXJcIixcclxuICBbMTJdOiBcInJlZiBmdW5jdGlvblwiLFxyXG4gIFsxM106IFwiYXN5bmMgY29tcG9uZW50IGxvYWRlclwiLFxyXG4gIFsxNF06IFwic2NoZWR1bGVyIGZsdXNoXCIsXHJcbiAgWzE1XTogXCJjb21wb25lbnQgdXBkYXRlXCIsXHJcbiAgWzE2XTogXCJhcHAgdW5tb3VudCBjbGVhbnVwIGZ1bmN0aW9uXCJcclxufTtcclxuZnVuY3Rpb24gY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncykge1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gYXJncyA/IGZuKC4uLmFyZ3MpIDogZm4oKTtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpIHtcclxuICBpZiAoaXNGdW5jdGlvbihmbikpIHtcclxuICAgIGNvbnN0IHJlcyA9IGNhbGxXaXRoRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpO1xyXG4gICAgaWYgKHJlcyAmJiBpc1Byb21pc2UocmVzKSkge1xyXG4gICAgICByZXMuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbiAgfVxyXG4gIGlmIChpc0FycmF5KGZuKSkge1xyXG4gICAgY29uc3QgdmFsdWVzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhbHVlcy5wdXNoKGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGZuW2ldLCBpbnN0YW5jZSwgdHlwZSwgYXJncykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlcztcclxuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgIHdhcm4kMShcclxuICAgICAgYEludmFsaWQgdmFsdWUgdHlwZSBwYXNzZWQgdG8gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoKTogJHt0eXBlb2YgZm59YFxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSwgdGhyb3dJbkRldiA9IHRydWUpIHtcclxuICBjb25zdCBjb250ZXh0Vk5vZGUgPSBpbnN0YW5jZSA/IGluc3RhbmNlLnZub2RlIDogbnVsbDtcclxuICBjb25zdCB7IGVycm9ySGFuZGxlciwgdGhyb3dVbmhhbmRsZWRFcnJvckluUHJvZHVjdGlvbiB9ID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcgfHwgRU1QVFlfT0JKO1xyXG4gIGlmIChpbnN0YW5jZSkge1xyXG4gICAgbGV0IGN1ciA9IGluc3RhbmNlLnBhcmVudDtcclxuICAgIGNvbnN0IGV4cG9zZWRJbnN0YW5jZSA9IGluc3RhbmNlLnByb3h5O1xyXG4gICAgY29uc3QgZXJyb3JJbmZvID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IEVycm9yVHlwZVN0cmluZ3MkMVt0eXBlXSA6IGBodHRwczovL3Z1ZWpzLm9yZy9lcnJvci1yZWZlcmVuY2UvI3J1bnRpbWUtJHt0eXBlfWA7XHJcbiAgICB3aGlsZSAoY3VyKSB7XHJcbiAgICAgIGNvbnN0IGVycm9yQ2FwdHVyZWRIb29rcyA9IGN1ci5lYztcclxuICAgICAgaWYgKGVycm9yQ2FwdHVyZWRIb29rcykge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXJyb3JDYXB0dXJlZEhvb2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAoZXJyb3JDYXB0dXJlZEhvb2tzW2ldKGVyciwgZXhwb3NlZEluc3RhbmNlLCBlcnJvckluZm8pID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGN1ciA9IGN1ci5wYXJlbnQ7XHJcbiAgICB9XHJcbiAgICBpZiAoZXJyb3JIYW5kbGVyKSB7XHJcbiAgICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGVycm9ySGFuZGxlciwgbnVsbCwgMTAsIFtcclxuICAgICAgICBlcnIsXHJcbiAgICAgICAgZXhwb3NlZEluc3RhbmNlLFxyXG4gICAgICAgIGVycm9ySW5mb1xyXG4gICAgICBdKTtcclxuICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgfVxyXG4gIGxvZ0Vycm9yKGVyciwgdHlwZSwgY29udGV4dFZOb2RlLCB0aHJvd0luRGV2LCB0aHJvd1VuaGFuZGxlZEVycm9ySW5Qcm9kdWN0aW9uKTtcclxufVxyXG5mdW5jdGlvbiBsb2dFcnJvcihlcnIsIHR5cGUsIGNvbnRleHRWTm9kZSwgdGhyb3dJbkRldiA9IHRydWUsIHRocm93SW5Qcm9kID0gZmFsc2UpIHtcclxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgY29uc3QgaW5mbyA9IEVycm9yVHlwZVN0cmluZ3MkMVt0eXBlXTtcclxuICAgIGlmIChjb250ZXh0Vk5vZGUpIHtcclxuICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KGNvbnRleHRWTm9kZSk7XHJcbiAgICB9XHJcbiAgICB3YXJuJDEoYFVuaGFuZGxlZCBlcnJvciR7aW5mbyA/IGAgZHVyaW5nIGV4ZWN1dGlvbiBvZiAke2luZm99YCA6IGBgfWApO1xyXG4gICAgaWYgKGNvbnRleHRWTm9kZSkge1xyXG4gICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRocm93SW5EZXYpIHtcclxuICAgICAgdGhyb3cgZXJyO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAodGhyb3dJblByb2QpIHtcclxuICAgIHRocm93IGVycjtcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xyXG4gIH1cclxufVxyXG5cclxuY29uc3QgcXVldWUgPSBbXTtcclxubGV0IGZsdXNoSW5kZXggPSAtMTtcclxuY29uc3QgcGVuZGluZ1Bvc3RGbHVzaENicyA9IFtdO1xyXG5sZXQgYWN0aXZlUG9zdEZsdXNoQ2JzID0gbnVsbDtcclxubGV0IHBvc3RGbHVzaEluZGV4ID0gMDtcclxuY29uc3QgcmVzb2x2ZWRQcm9taXNlID0gLyogQF9fUFVSRV9fICovIFByb21pc2UucmVzb2x2ZSgpO1xyXG5sZXQgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XHJcbmNvbnN0IFJFQ1VSU0lPTl9MSU1JVCA9IDEwMDtcclxuZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcclxuICBjb25zdCBwID0gY3VycmVudEZsdXNoUHJvbWlzZSB8fCByZXNvbHZlZFByb21pc2U7XHJcbiAgcmV0dXJuIGZuID8gcC50aGVuKHRoaXMgPyBmbi5iaW5kKHRoaXMpIDogZm4pIDogcDtcclxufVxyXG5mdW5jdGlvbiBmaW5kSW5zZXJ0aW9uSW5kZXgoaWQpIHtcclxuICBsZXQgc3RhcnQgPSBmbHVzaEluZGV4ICsgMTtcclxuICBsZXQgZW5kID0gcXVldWUubGVuZ3RoO1xyXG4gIHdoaWxlIChzdGFydCA8IGVuZCkge1xyXG4gICAgY29uc3QgbWlkZGxlID0gc3RhcnQgKyBlbmQgPj4+IDE7XHJcbiAgICBjb25zdCBtaWRkbGVKb2IgPSBxdWV1ZVttaWRkbGVdO1xyXG4gICAgY29uc3QgbWlkZGxlSm9iSWQgPSBnZXRJZChtaWRkbGVKb2IpO1xyXG4gICAgaWYgKG1pZGRsZUpvYklkIDwgaWQgfHwgbWlkZGxlSm9iSWQgPT09IGlkICYmIG1pZGRsZUpvYi5mbGFncyAmIDIpIHtcclxuICAgICAgc3RhcnQgPSBtaWRkbGUgKyAxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZW5kID0gbWlkZGxlO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gc3RhcnQ7XHJcbn1cclxuZnVuY3Rpb24gcXVldWVKb2Ioam9iKSB7XHJcbiAgaWYgKCEoam9iLmZsYWdzICYgMSkpIHtcclxuICAgIGNvbnN0IGpvYklkID0gZ2V0SWQoam9iKTtcclxuICAgIGNvbnN0IGxhc3RKb2IgPSBxdWV1ZVtxdWV1ZS5sZW5ndGggLSAxXTtcclxuICAgIGlmICghbGFzdEpvYiB8fCAvLyBmYXN0IHBhdGggd2hlbiB0aGUgam9iIGlkIGlzIGxhcmdlciB0aGFuIHRoZSB0YWlsXHJcbiAgICAhKGpvYi5mbGFncyAmIDIpICYmIGpvYklkID49IGdldElkKGxhc3RKb2IpKSB7XHJcbiAgICAgIHF1ZXVlLnB1c2goam9iKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHF1ZXVlLnNwbGljZShmaW5kSW5zZXJ0aW9uSW5kZXgoam9iSWQpLCAwLCBqb2IpO1xyXG4gICAgfVxyXG4gICAgam9iLmZsYWdzIHw9IDE7XHJcbiAgICBxdWV1ZUZsdXNoKCk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlRmx1c2goKSB7XHJcbiAgaWYgKCFjdXJyZW50Rmx1c2hQcm9taXNlKSB7XHJcbiAgICBjdXJyZW50Rmx1c2hQcm9taXNlID0gcmVzb2x2ZWRQcm9taXNlLnRoZW4oZmx1c2hKb2JzKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gcXVldWVQb3N0Rmx1c2hDYihjYikge1xyXG4gIGlmICghaXNBcnJheShjYikpIHtcclxuICAgIGlmIChhY3RpdmVQb3N0Rmx1c2hDYnMgJiYgY2IuaWQgPT09IC0xKSB7XHJcbiAgICAgIGFjdGl2ZVBvc3RGbHVzaENicy5zcGxpY2UocG9zdEZsdXNoSW5kZXggKyAxLCAwLCBjYik7XHJcbiAgICB9IGVsc2UgaWYgKCEoY2IuZmxhZ3MgJiAxKSkge1xyXG4gICAgICBwZW5kaW5nUG9zdEZsdXNoQ2JzLnB1c2goY2IpO1xyXG4gICAgICBjYi5mbGFncyB8PSAxO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBwZW5kaW5nUG9zdEZsdXNoQ2JzLnB1c2goLi4uY2IpO1xyXG4gIH1cclxuICBxdWV1ZUZsdXNoKCk7XHJcbn1cclxuZnVuY3Rpb24gZmx1c2hQcmVGbHVzaENicyhpbnN0YW5jZSwgc2VlbiwgaSA9IGZsdXNoSW5kZXggKyAxKSB7XHJcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgIHNlZW4gPSBzZWVuIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XHJcbiAgfVxyXG4gIGZvciAoOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGNiID0gcXVldWVbaV07XHJcbiAgICBpZiAoY2IgJiYgY2IuZmxhZ3MgJiAyKSB7XHJcbiAgICAgIGlmIChpbnN0YW5jZSAmJiBjYi5pZCAhPT0gaW5zdGFuY2UudWlkKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGNiKSkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHF1ZXVlLnNwbGljZShpLCAxKTtcclxuICAgICAgaS0tO1xyXG4gICAgICBpZiAoY2IuZmxhZ3MgJiA0KSB7XHJcbiAgICAgICAgY2IuZmxhZ3MgJj0gfjE7XHJcbiAgICAgIH1cclxuICAgICAgY2IoKTtcclxuICAgICAgaWYgKCEoY2IuZmxhZ3MgJiA0KSkge1xyXG4gICAgICAgIGNiLmZsYWdzICY9IH4xO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGZsdXNoUG9zdEZsdXNoQ2JzKHNlZW4pIHtcclxuICBpZiAocGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGgpIHtcclxuICAgIGNvbnN0IGRlZHVwZWQgPSBbLi4ubmV3IFNldChwZW5kaW5nUG9zdEZsdXNoQ2JzKV0uc29ydChcclxuICAgICAgKGEsIGIpID0+IGdldElkKGEpIC0gZ2V0SWQoYilcclxuICAgICk7XHJcbiAgICBwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCA9IDA7XHJcbiAgICBpZiAoYWN0aXZlUG9zdEZsdXNoQ2JzKSB7XHJcbiAgICAgIGFjdGl2ZVBvc3RGbHVzaENicy5wdXNoKC4uLmRlZHVwZWQpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBkZWR1cGVkO1xyXG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgc2VlbiA9IHNlZW4gfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIGZvciAocG9zdEZsdXNoSW5kZXggPSAwOyBwb3N0Rmx1c2hJbmRleCA8IGFjdGl2ZVBvc3RGbHVzaENicy5sZW5ndGg7IHBvc3RGbHVzaEluZGV4KyspIHtcclxuICAgICAgY29uc3QgY2IgPSBhY3RpdmVQb3N0Rmx1c2hDYnNbcG9zdEZsdXNoSW5kZXhdO1xyXG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgY2IpKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNiLmZsYWdzICYgNCkge1xyXG4gICAgICAgIGNiLmZsYWdzICY9IH4xO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghKGNiLmZsYWdzICYgOCkpIGNiKCk7XHJcbiAgICAgIGNiLmZsYWdzICY9IH4xO1xyXG4gICAgfVxyXG4gICAgYWN0aXZlUG9zdEZsdXNoQ2JzID0gbnVsbDtcclxuICAgIHBvc3RGbHVzaEluZGV4ID0gMDtcclxuICB9XHJcbn1cclxuY29uc3QgZ2V0SWQgPSAoam9iKSA9PiBqb2IuaWQgPT0gbnVsbCA/IGpvYi5mbGFncyAmIDIgPyAtMSA6IEluZmluaXR5IDogam9iLmlkO1xyXG5mdW5jdGlvbiBmbHVzaEpvYnMoc2Vlbikge1xyXG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICBzZWVuID0gc2VlbiB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xyXG4gIH1cclxuICBjb25zdCBjaGVjayA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyAoam9iKSA9PiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2Vlbiwgam9iKSA6IE5PT1A7XHJcbiAgdHJ5IHtcclxuICAgIGZvciAoZmx1c2hJbmRleCA9IDA7IGZsdXNoSW5kZXggPCBxdWV1ZS5sZW5ndGg7IGZsdXNoSW5kZXgrKykge1xyXG4gICAgICBjb25zdCBqb2IgPSBxdWV1ZVtmbHVzaEluZGV4XTtcclxuICAgICAgaWYgKGpvYiAmJiAhKGpvYi5mbGFncyAmIDgpKSB7XHJcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY2hlY2soam9iKSkge1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChqb2IuZmxhZ3MgJiA0KSB7XHJcbiAgICAgICAgICBqb2IuZmxhZ3MgJj0gfjE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhcclxuICAgICAgICAgIGpvYixcclxuICAgICAgICAgIGpvYi5pLFxyXG4gICAgICAgICAgam9iLmkgPyAxNSA6IDE0XHJcbiAgICAgICAgKTtcclxuICAgICAgICBpZiAoIShqb2IuZmxhZ3MgJiA0KSkge1xyXG4gICAgICAgICAgam9iLmZsYWdzICY9IH4xO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZmluYWxseSB7XHJcbiAgICBmb3IgKDsgZmx1c2hJbmRleCA8IHF1ZXVlLmxlbmd0aDsgZmx1c2hJbmRleCsrKSB7XHJcbiAgICAgIGNvbnN0IGpvYiA9IHF1ZXVlW2ZsdXNoSW5kZXhdO1xyXG4gICAgICBpZiAoam9iKSB7XHJcbiAgICAgICAgam9iLmZsYWdzICY9IH4xO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmbHVzaEluZGV4ID0gLTE7XHJcbiAgICBxdWV1ZS5sZW5ndGggPSAwO1xyXG4gICAgZmx1c2hQb3N0Rmx1c2hDYnMoc2Vlbik7XHJcbiAgICBjdXJyZW50Rmx1c2hQcm9taXNlID0gbnVsbDtcclxuICAgIGlmIChxdWV1ZS5sZW5ndGggfHwgcGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGgpIHtcclxuICAgICAgZmx1c2hKb2JzKHNlZW4pO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgZm4pIHtcclxuICBjb25zdCBjb3VudCA9IHNlZW4uZ2V0KGZuKSB8fCAwO1xyXG4gIGlmIChjb3VudCA+IFJFQ1VSU0lPTl9MSU1JVCkge1xyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBmbi5pO1xyXG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGluc3RhbmNlICYmIGdldENvbXBvbmVudE5hbWUoaW5zdGFuY2UudHlwZSk7XHJcbiAgICBoYW5kbGVFcnJvcihcclxuICAgICAgYE1heGltdW0gcmVjdXJzaXZlIHVwZGF0ZXMgZXhjZWVkZWQke2NvbXBvbmVudE5hbWUgPyBgIGluIGNvbXBvbmVudCA8JHtjb21wb25lbnROYW1lfT5gIDogYGB9LiBUaGlzIG1lYW5zIHlvdSBoYXZlIGEgcmVhY3RpdmUgZWZmZWN0IHRoYXQgaXMgbXV0YXRpbmcgaXRzIG93biBkZXBlbmRlbmNpZXMgYW5kIHRodXMgcmVjdXJzaXZlbHkgdHJpZ2dlcmluZyBpdHNlbGYuIFBvc3NpYmxlIHNvdXJjZXMgaW5jbHVkZSBjb21wb25lbnQgdGVtcGxhdGUsIHJlbmRlciBmdW5jdGlvbiwgdXBkYXRlZCBob29rIG9yIHdhdGNoZXIgc291cmNlIGZ1bmN0aW9uLmAsXHJcbiAgICAgIG51bGwsXHJcbiAgICAgIDEwXHJcbiAgICApO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIHNlZW4uc2V0KGZuLCBjb3VudCArIDEpO1xyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxubGV0IGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcclxuY29uc3QgaG1yRGlydHlDb21wb25lbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcclxuaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfSE1SX1JVTlRJTUVfXyA9IHtcclxuICAgIGNyZWF0ZVJlY29yZDogdHJ5V3JhcChjcmVhdGVSZWNvcmQpLFxyXG4gICAgcmVyZW5kZXI6IHRyeVdyYXAocmVyZW5kZXIpLFxyXG4gICAgcmVsb2FkOiB0cnlXcmFwKHJlbG9hZClcclxuICB9O1xyXG59XHJcbmNvbnN0IG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XHJcbmZ1bmN0aW9uIHJlZ2lzdGVySE1SKGluc3RhbmNlKSB7XHJcbiAgY29uc3QgaWQgPSBpbnN0YW5jZS50eXBlLl9faG1ySWQ7XHJcbiAgbGV0IHJlY29yZCA9IG1hcC5nZXQoaWQpO1xyXG4gIGlmICghcmVjb3JkKSB7XHJcbiAgICBjcmVhdGVSZWNvcmQoaWQsIGluc3RhbmNlLnR5cGUpO1xyXG4gICAgcmVjb3JkID0gbWFwLmdldChpZCk7XHJcbiAgfVxyXG4gIHJlY29yZC5pbnN0YW5jZXMuYWRkKGluc3RhbmNlKTtcclxufVxyXG5mdW5jdGlvbiB1bnJlZ2lzdGVySE1SKGluc3RhbmNlKSB7XHJcbiAgbWFwLmdldChpbnN0YW5jZS50eXBlLl9faG1ySWQpLmluc3RhbmNlcy5kZWxldGUoaW5zdGFuY2UpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlY29yZChpZCwgaW5pdGlhbERlZikge1xyXG4gIGlmIChtYXAuaGFzKGlkKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBtYXAuc2V0KGlkLCB7XHJcbiAgICBpbml0aWFsRGVmOiBub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbml0aWFsRGVmKSxcclxuICAgIGluc3RhbmNlczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxyXG4gIH0pO1xyXG4gIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gIHJldHVybiBpc0NsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkgPyBjb21wb25lbnQuX192Y2NPcHRzIDogY29tcG9uZW50O1xyXG59XHJcbmZ1bmN0aW9uIHJlcmVuZGVyKGlkLCBuZXdSZW5kZXIpIHtcclxuICBjb25zdCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcclxuICBpZiAoIXJlY29yZCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICByZWNvcmQuaW5pdGlhbERlZi5yZW5kZXIgPSBuZXdSZW5kZXI7XHJcbiAgWy4uLnJlY29yZC5pbnN0YW5jZXNdLmZvckVhY2goKGluc3RhbmNlKSA9PiB7XHJcbiAgICBpZiAobmV3UmVuZGVyKSB7XHJcbiAgICAgIGluc3RhbmNlLnJlbmRlciA9IG5ld1JlbmRlcjtcclxuICAgICAgbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5zdGFuY2UudHlwZSkucmVuZGVyID0gbmV3UmVuZGVyO1xyXG4gICAgfVxyXG4gICAgaW5zdGFuY2UucmVuZGVyQ2FjaGUgPSBbXTtcclxuICAgIGlzSG1yVXBkYXRpbmcgPSB0cnVlO1xyXG4gICAgaW5zdGFuY2UudXBkYXRlKCk7XHJcbiAgICBpc0htclVwZGF0aW5nID0gZmFsc2U7XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVsb2FkKGlkLCBuZXdDb21wKSB7XHJcbiAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XHJcbiAgaWYgKCFyZWNvcmQpIHJldHVybjtcclxuICBuZXdDb21wID0gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQobmV3Q29tcCk7XHJcbiAgdXBkYXRlQ29tcG9uZW50RGVmKHJlY29yZC5pbml0aWFsRGVmLCBuZXdDb21wKTtcclxuICBjb25zdCBpbnN0YW5jZXMgPSBbLi4ucmVjb3JkLmluc3RhbmNlc107XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzW2ldO1xyXG4gICAgY29uc3Qgb2xkQ29tcCA9IG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluc3RhbmNlLnR5cGUpO1xyXG4gICAgbGV0IGRpcnR5SW5zdGFuY2VzID0gaG1yRGlydHlDb21wb25lbnRzLmdldChvbGRDb21wKTtcclxuICAgIGlmICghZGlydHlJbnN0YW5jZXMpIHtcclxuICAgICAgaWYgKG9sZENvbXAgIT09IHJlY29yZC5pbml0aWFsRGVmKSB7XHJcbiAgICAgICAgdXBkYXRlQ29tcG9uZW50RGVmKG9sZENvbXAsIG5ld0NvbXApO1xyXG4gICAgICB9XHJcbiAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5zZXQob2xkQ29tcCwgZGlydHlJbnN0YW5jZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcclxuICAgIH1cclxuICAgIGRpcnR5SW5zdGFuY2VzLmFkZChpbnN0YW5jZSk7XHJcbiAgICBpbnN0YW5jZS5hcHBDb250ZXh0LnByb3BzQ2FjaGUuZGVsZXRlKGluc3RhbmNlLnR5cGUpO1xyXG4gICAgaW5zdGFuY2UuYXBwQ29udGV4dC5lbWl0c0NhY2hlLmRlbGV0ZShpbnN0YW5jZS50eXBlKTtcclxuICAgIGluc3RhbmNlLmFwcENvbnRleHQub3B0aW9uc0NhY2hlLmRlbGV0ZShpbnN0YW5jZS50eXBlKTtcclxuICAgIGlmIChpbnN0YW5jZS5jZVJlbG9hZCkge1xyXG4gICAgICBkaXJ0eUluc3RhbmNlcy5hZGQoaW5zdGFuY2UpO1xyXG4gICAgICBpbnN0YW5jZS5jZVJlbG9hZChuZXdDb21wLnN0eWxlcyk7XHJcbiAgICAgIGRpcnR5SW5zdGFuY2VzLmRlbGV0ZShpbnN0YW5jZSk7XHJcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLnBhcmVudCkge1xyXG4gICAgICBxdWV1ZUpvYigoKSA9PiB7XHJcbiAgICAgICAgaXNIbXJVcGRhdGluZyA9IHRydWU7XHJcbiAgICAgICAgaW5zdGFuY2UucGFyZW50LnVwZGF0ZSgpO1xyXG4gICAgICAgIGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICBkaXJ0eUluc3RhbmNlcy5kZWxldGUoaW5zdGFuY2UpO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5yZWxvYWQpIHtcclxuICAgICAgaW5zdGFuY2UuYXBwQ29udGV4dC5yZWxvYWQoKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgXCJbSE1SXSBSb290IG9yIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UgbW9kaWZpZWQuIEZ1bGwgcmVsb2FkIHJlcXVpcmVkLlwiXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICBpZiAoaW5zdGFuY2Uucm9vdC5jZSAmJiBpbnN0YW5jZSAhPT0gaW5zdGFuY2Uucm9vdCkge1xyXG4gICAgICBpbnN0YW5jZS5yb290LmNlLl9yZW1vdmVDaGlsZFN0eWxlKG9sZENvbXApO1xyXG4gICAgfVxyXG4gIH1cclxuICBxdWV1ZVBvc3RGbHVzaENiKCgpID0+IHtcclxuICAgIGhtckRpcnR5Q29tcG9uZW50cy5jbGVhcigpO1xyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudERlZihvbGRDb21wLCBuZXdDb21wKSB7XHJcbiAgZXh0ZW5kKG9sZENvbXAsIG5ld0NvbXApO1xyXG4gIGZvciAoY29uc3Qga2V5IGluIG9sZENvbXApIHtcclxuICAgIGlmIChrZXkgIT09IFwiX19maWxlXCIgJiYgIShrZXkgaW4gbmV3Q29tcCkpIHtcclxuICAgICAgZGVsZXRlIG9sZENvbXBba2V5XTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZnVuY3Rpb24gdHJ5V3JhcChmbikge1xyXG4gIHJldHVybiAoaWQsIGFyZykgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgcmV0dXJuIGZuKGlkLCBhcmcpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xyXG4gICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgYFtITVJdIFNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyBWdWUgY29tcG9uZW50IGhvdC1yZWxvYWQuIEZ1bGwgcmVsb2FkIHJlcXVpcmVkLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG5sZXQgZGV2dG9vbHMkMTtcclxubGV0IGJ1ZmZlciA9IFtdO1xyXG5sZXQgZGV2dG9vbHNOb3RJbnN0YWxsZWQgPSBmYWxzZTtcclxuZnVuY3Rpb24gZW1pdCQxKGV2ZW50LCAuLi5hcmdzKSB7XHJcbiAgaWYgKGRldnRvb2xzJDEpIHtcclxuICAgIGRldnRvb2xzJDEuZW1pdChldmVudCwgLi4uYXJncyk7XHJcbiAgfSBlbHNlIGlmICghZGV2dG9vbHNOb3RJbnN0YWxsZWQpIHtcclxuICAgIGJ1ZmZlci5wdXNoKHsgZXZlbnQsIGFyZ3MgfSk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHNldERldnRvb2xzSG9vayQxKGhvb2ssIHRhcmdldCkge1xyXG4gIHZhciBfYSwgX2I7XHJcbiAgZGV2dG9vbHMkMSA9IGhvb2s7XHJcbiAgaWYgKGRldnRvb2xzJDEpIHtcclxuICAgIGRldnRvb2xzJDEuZW5hYmxlZCA9IHRydWU7XHJcbiAgICBidWZmZXIuZm9yRWFjaCgoeyBldmVudCwgYXJncyB9KSA9PiBkZXZ0b29scyQxLmVtaXQoZXZlbnQsIC4uLmFyZ3MpKTtcclxuICAgIGJ1ZmZlciA9IFtdO1xyXG4gIH0gZWxzZSBpZiAoXHJcbiAgICAvLyBoYW5kbGUgbGF0ZSBkZXZ0b29scyBpbmplY3Rpb24gLSBvbmx5IGRvIHRoaXMgaWYgd2UgYXJlIGluIGFuIGFjdHVhbFxyXG4gICAgLy8gYnJvd3NlciBlbnZpcm9ubWVudCB0byBhdm9pZCB0aGUgdGltZXIgaGFuZGxlIHN0YWxsaW5nIHRlc3QgcnVubmVyIGV4aXRcclxuICAgIC8vICgjNDgxNSlcclxuICAgIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgLy8gc29tZSBlbnZzIG1vY2sgd2luZG93IGJ1dCBub3QgZnVsbHlcclxuICAgIHdpbmRvdy5IVE1MRWxlbWVudCAmJiAvLyBhbHNvIGV4Y2x1ZGUganNkb21cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgISgoX2IgPSAoX2EgPSB3aW5kb3cubmF2aWdhdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EudXNlckFnZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2IuaW5jbHVkZXMoXCJqc2RvbVwiKSlcclxuICApIHtcclxuICAgIGNvbnN0IHJlcGxheSA9IHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fID0gdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gfHwgW107XHJcbiAgICByZXBsYXkucHVzaCgobmV3SG9vaykgPT4ge1xyXG4gICAgICBzZXREZXZ0b29sc0hvb2skMShuZXdIb29rLCB0YXJnZXQpO1xyXG4gICAgfSk7XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgaWYgKCFkZXZ0b29scyQxKSB7XHJcbiAgICAgICAgdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gPSBudWxsO1xyXG4gICAgICAgIGRldnRvb2xzTm90SW5zdGFsbGVkID0gdHJ1ZTtcclxuICAgICAgICBidWZmZXIgPSBbXTtcclxuICAgICAgfVxyXG4gICAgfSwgM2UzKTtcclxuICB9IGVsc2Uge1xyXG4gICAgZGV2dG9vbHNOb3RJbnN0YWxsZWQgPSB0cnVlO1xyXG4gICAgYnVmZmVyID0gW107XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGRldnRvb2xzSW5pdEFwcChhcHAsIHZlcnNpb24pIHtcclxuICBlbWl0JDEoXCJhcHA6aW5pdFwiIC8qIEFQUF9JTklUICovLCBhcHAsIHZlcnNpb24sIHtcclxuICAgIEZyYWdtZW50LFxyXG4gICAgVGV4dCxcclxuICAgIENvbW1lbnQsXHJcbiAgICBTdGF0aWNcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBkZXZ0b29sc1VubW91bnRBcHAoYXBwKSB7XHJcbiAgZW1pdCQxKFwiYXBwOnVubW91bnRcIiAvKiBBUFBfVU5NT1VOVCAqLywgYXBwKTtcclxufVxyXG5jb25zdCBkZXZ0b29sc0NvbXBvbmVudEFkZGVkID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDphZGRlZFwiIC8qIENPTVBPTkVOVF9BRERFRCAqLyk7XHJcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXCJjb21wb25lbnQ6dXBkYXRlZFwiIC8qIENPTVBPTkVOVF9VUERBVEVEICovKTtcclxuY29uc3QgX2RldnRvb2xzQ29tcG9uZW50UmVtb3ZlZCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXHJcbiAgXCJjb21wb25lbnQ6cmVtb3ZlZFwiIC8qIENPTVBPTkVOVF9SRU1PVkVEICovXHJcbik7XHJcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZCA9IChjb21wb25lbnQpID0+IHtcclxuICBpZiAoZGV2dG9vbHMkMSAmJiB0eXBlb2YgZGV2dG9vbHMkMS5jbGVhbnVwQnVmZmVyID09PSBcImZ1bmN0aW9uXCIgJiYgLy8gcmVtb3ZlIHRoZSBjb21wb25lbnQgaWYgaXQgd2Fzbid0IGJ1ZmZlcmVkXHJcbiAgIWRldnRvb2xzJDEuY2xlYW51cEJ1ZmZlcihjb21wb25lbnQpKSB7XHJcbiAgICBfZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkKGNvbXBvbmVudCk7XHJcbiAgfVxyXG59O1xyXG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cclxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cclxuZnVuY3Rpb24gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKGhvb2spIHtcclxuICByZXR1cm4gKGNvbXBvbmVudCkgPT4ge1xyXG4gICAgZW1pdCQxKFxyXG4gICAgICBob29rLFxyXG4gICAgICBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsXHJcbiAgICAgIGNvbXBvbmVudC51aWQsXHJcbiAgICAgIGNvbXBvbmVudC5wYXJlbnQgPyBjb21wb25lbnQucGFyZW50LnVpZCA6IHZvaWQgMCxcclxuICAgICAgY29tcG9uZW50XHJcbiAgICApO1xyXG4gIH07XHJcbn1cclxuY29uc3QgZGV2dG9vbHNQZXJmU3RhcnQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soXCJwZXJmOnN0YXJ0XCIgLyogUEVSRk9STUFOQ0VfU1RBUlQgKi8pO1xyXG5jb25zdCBkZXZ0b29sc1BlcmZFbmQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soXCJwZXJmOmVuZFwiIC8qIFBFUkZPUk1BTkNFX0VORCAqLyk7XHJcbmZ1bmN0aW9uIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKGhvb2spIHtcclxuICByZXR1cm4gKGNvbXBvbmVudCwgdHlwZSwgdGltZSkgPT4ge1xyXG4gICAgZW1pdCQxKGhvb2ssIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LnVpZCwgY29tcG9uZW50LCB0eXBlLCB0aW1lKTtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGRldnRvb2xzQ29tcG9uZW50RW1pdChjb21wb25lbnQsIGV2ZW50LCBwYXJhbXMpIHtcclxuICBlbWl0JDEoXHJcbiAgICBcImNvbXBvbmVudDplbWl0XCIgLyogQ09NUE9ORU5UX0VNSVQgKi8sXHJcbiAgICBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsXHJcbiAgICBjb21wb25lbnQsXHJcbiAgICBldmVudCxcclxuICAgIHBhcmFtc1xyXG4gICk7XHJcbn1cclxuXHJcbmxldCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xyXG5sZXQgY3VycmVudFNjb3BlSWQgPSBudWxsO1xyXG5mdW5jdGlvbiBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaW5zdGFuY2UpIHtcclxuICBjb25zdCBwcmV2ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xyXG4gIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IGluc3RhbmNlO1xyXG4gIGN1cnJlbnRTY29wZUlkID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UudHlwZS5fX3Njb3BlSWQgfHwgbnVsbDtcclxuICByZXR1cm4gcHJldjtcclxufVxyXG5mdW5jdGlvbiBwdXNoU2NvcGVJZChpZCkge1xyXG4gIGN1cnJlbnRTY29wZUlkID0gaWQ7XHJcbn1cclxuZnVuY3Rpb24gcG9wU2NvcGVJZCgpIHtcclxuICBjdXJyZW50U2NvcGVJZCA9IG51bGw7XHJcbn1cclxuY29uc3Qgd2l0aFNjb3BlSWQgPSAoX2lkKSA9PiB3aXRoQ3R4O1xyXG5mdW5jdGlvbiB3aXRoQ3R4KGZuLCBjdHggPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsIGlzTm9uU2NvcGVkU2xvdCkge1xyXG4gIGlmICghY3R4KSByZXR1cm4gZm47XHJcbiAgaWYgKGZuLl9uKSB7XHJcbiAgICByZXR1cm4gZm47XHJcbiAgfVxyXG4gIGNvbnN0IHJlbmRlckZuV2l0aENvbnRleHQgPSAoLi4uYXJncykgPT4ge1xyXG4gICAgaWYgKHJlbmRlckZuV2l0aENvbnRleHQuX2QpIHtcclxuICAgICAgc2V0QmxvY2tUcmFja2luZygtMSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcmV2SW5zdGFuY2UgPSBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoY3R4KTtcclxuICAgIGxldCByZXM7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXMgPSBmbiguLi5hcmdzKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2SW5zdGFuY2UpO1xyXG4gICAgICBpZiAocmVuZGVyRm5XaXRoQ29udGV4dC5fZCkge1xyXG4gICAgICAgIHNldEJsb2NrVHJhY2tpbmcoMSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICBkZXZ0b29sc0NvbXBvbmVudFVwZGF0ZWQoY3R4KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbiAgfTtcclxuICByZW5kZXJGbldpdGhDb250ZXh0Ll9uID0gdHJ1ZTtcclxuICByZW5kZXJGbldpdGhDb250ZXh0Ll9jID0gdHJ1ZTtcclxuICByZW5kZXJGbldpdGhDb250ZXh0Ll9kID0gdHJ1ZTtcclxuICByZXR1cm4gcmVuZGVyRm5XaXRoQ29udGV4dDtcclxufVxyXG5cclxuZnVuY3Rpb24gdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWUpIHtcclxuICBpZiAoaXNCdWlsdEluRGlyZWN0aXZlKG5hbWUpKSB7XHJcbiAgICB3YXJuJDEoXCJEbyBub3QgdXNlIGJ1aWx0LWluIGRpcmVjdGl2ZSBpZHMgYXMgY3VzdG9tIGRpcmVjdGl2ZSBpZDogXCIgKyBuYW1lKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gd2l0aERpcmVjdGl2ZXModm5vZGUsIGRpcmVjdGl2ZXMpIHtcclxuICBpZiAoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID09PSBudWxsKSB7XHJcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShgd2l0aERpcmVjdGl2ZXMgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgcmVuZGVyIGZ1bmN0aW9ucy5gKTtcclxuICAgIHJldHVybiB2bm9kZTtcclxuICB9XHJcbiAgY29uc3QgaW5zdGFuY2UgPSBnZXRDb21wb25lbnRQdWJsaWNJbnN0YW5jZShjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpO1xyXG4gIGNvbnN0IGJpbmRpbmdzID0gdm5vZGUuZGlycyB8fCAodm5vZGUuZGlycyA9IFtdKTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcmVjdGl2ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGxldCBbZGlyLCB2YWx1ZSwgYXJnLCBtb2RpZmllcnMgPSBFTVBUWV9PQkpdID0gZGlyZWN0aXZlc1tpXTtcclxuICAgIGlmIChkaXIpIHtcclxuICAgICAgaWYgKGlzRnVuY3Rpb24oZGlyKSkge1xyXG4gICAgICAgIGRpciA9IHtcclxuICAgICAgICAgIG1vdW50ZWQ6IGRpcixcclxuICAgICAgICAgIHVwZGF0ZWQ6IGRpclxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGRpci5kZWVwKSB7XHJcbiAgICAgICAgdHJhdmVyc2UodmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICAgIGJpbmRpbmdzLnB1c2goe1xyXG4gICAgICAgIGRpcixcclxuICAgICAgICBpbnN0YW5jZSxcclxuICAgICAgICB2YWx1ZSxcclxuICAgICAgICBvbGRWYWx1ZTogdm9pZCAwLFxyXG4gICAgICAgIGFyZyxcclxuICAgICAgICBtb2RpZmllcnNcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB2bm9kZTtcclxufVxyXG5mdW5jdGlvbiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBwcmV2Vk5vZGUsIGluc3RhbmNlLCBuYW1lKSB7XHJcbiAgY29uc3QgYmluZGluZ3MgPSB2bm9kZS5kaXJzO1xyXG4gIGNvbnN0IG9sZEJpbmRpbmdzID0gcHJldlZOb2RlICYmIHByZXZWTm9kZS5kaXJzO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcclxuICAgIGlmIChvbGRCaW5kaW5ncykge1xyXG4gICAgICBiaW5kaW5nLm9sZFZhbHVlID0gb2xkQmluZGluZ3NbaV0udmFsdWU7XHJcbiAgICB9XHJcbiAgICBsZXQgaG9vayA9IGJpbmRpbmcuZGlyW25hbWVdO1xyXG4gICAgaWYgKGhvb2spIHtcclxuICAgICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgOCwgW1xyXG4gICAgICAgIHZub2RlLmVsLFxyXG4gICAgICAgIGJpbmRpbmcsXHJcbiAgICAgICAgdm5vZGUsXHJcbiAgICAgICAgcHJldlZOb2RlXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBUZWxlcG9ydEVuZEtleSA9IFN5bWJvbChcIl92dGVcIik7XHJcbmNvbnN0IGlzVGVsZXBvcnQgPSAodHlwZSkgPT4gdHlwZS5fX2lzVGVsZXBvcnQ7XHJcbmNvbnN0IGlzVGVsZXBvcnREaXNhYmxlZCA9IChwcm9wcykgPT4gcHJvcHMgJiYgKHByb3BzLmRpc2FibGVkIHx8IHByb3BzLmRpc2FibGVkID09PSBcIlwiKTtcclxuY29uc3QgaXNUZWxlcG9ydERlZmVycmVkID0gKHByb3BzKSA9PiBwcm9wcyAmJiAocHJvcHMuZGVmZXIgfHwgcHJvcHMuZGVmZXIgPT09IFwiXCIpO1xyXG5jb25zdCBpc1RhcmdldFNWRyA9ICh0YXJnZXQpID0+IHR5cGVvZiBTVkdFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQ7XHJcbmNvbnN0IGlzVGFyZ2V0TWF0aE1MID0gKHRhcmdldCkgPT4gdHlwZW9mIE1hdGhNTEVsZW1lbnQgPT09IFwiZnVuY3Rpb25cIiAmJiB0YXJnZXQgaW5zdGFuY2VvZiBNYXRoTUxFbGVtZW50O1xyXG5jb25zdCByZXNvbHZlVGFyZ2V0ID0gKHByb3BzLCBzZWxlY3QpID0+IHtcclxuICBjb25zdCB0YXJnZXRTZWxlY3RvciA9IHByb3BzICYmIHByb3BzLnRvO1xyXG4gIGlmIChpc1N0cmluZyh0YXJnZXRTZWxlY3RvcikpIHtcclxuICAgIGlmICghc2VsZWN0KSB7XHJcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKFxyXG4gICAgICAgIGBDdXJyZW50IHJlbmRlcmVyIGRvZXMgbm90IHN1cHBvcnQgc3RyaW5nIHRhcmdldCBmb3IgVGVsZXBvcnRzLiAobWlzc2luZyBxdWVyeVNlbGVjdG9yIHJlbmRlcmVyIG9wdGlvbilgXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgdGFyZ2V0ID0gc2VsZWN0KHRhcmdldFNlbGVjdG9yKTtcclxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIXRhcmdldCAmJiAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xyXG4gICAgICAgIHdhcm4kMShcclxuICAgICAgICAgIGBGYWlsZWQgdG8gbG9jYXRlIFRlbGVwb3J0IHRhcmdldCB3aXRoIHNlbGVjdG9yIFwiJHt0YXJnZXRTZWxlY3Rvcn1cIi4gTm90ZSB0aGUgdGFyZ2V0IGVsZW1lbnQgbXVzdCBleGlzdCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkIC0gaS5lLiB0aGUgdGFyZ2V0IGNhbm5vdCBiZSByZW5kZXJlZCBieSB0aGUgY29tcG9uZW50IGl0c2VsZiwgYW5kIGlkZWFsbHkgc2hvdWxkIGJlIG91dHNpZGUgb2YgdGhlIGVudGlyZSBWdWUgY29tcG9uZW50IHRyZWUuYFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIXRhcmdldFNlbGVjdG9yICYmICFpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XHJcbiAgICAgIHdhcm4kMShgSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQ6ICR7dGFyZ2V0U2VsZWN0b3J9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0U2VsZWN0b3I7XHJcbiAgfVxyXG59O1xyXG5jb25zdCBUZWxlcG9ydEltcGwgPSB7XHJcbiAgbmFtZTogXCJUZWxlcG9ydFwiLFxyXG4gIF9faXNUZWxlcG9ydDogdHJ1ZSxcclxuICBwcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIGludGVybmFscykge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBtYzogbW91bnRDaGlsZHJlbixcclxuICAgICAgcGM6IHBhdGNoQ2hpbGRyZW4sXHJcbiAgICAgIHBiYzogcGF0Y2hCbG9ja0NoaWxkcmVuLFxyXG4gICAgICBvOiB7IGluc2VydCwgcXVlcnlTZWxlY3RvciwgY3JlYXRlVGV4dCwgY3JlYXRlQ29tbWVudCB9XHJcbiAgICB9ID0gaW50ZXJuYWxzO1xyXG4gICAgY29uc3QgZGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjIucHJvcHMpO1xyXG4gICAgbGV0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuIH0gPSBuMjtcclxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSG1yVXBkYXRpbmcpIHtcclxuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XHJcbiAgICAgIGR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICBjb25zdCBwbGFjZWhvbGRlciA9IG4yLmVsID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGNyZWF0ZUNvbW1lbnQoXCJ0ZWxlcG9ydCBzdGFydFwiKSA6IGNyZWF0ZVRleHQoXCJcIik7XHJcbiAgICAgIGNvbnN0IG1haW5BbmNob3IgPSBuMi5hbmNob3IgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gY3JlYXRlQ29tbWVudChcInRlbGVwb3J0IGVuZFwiKSA6IGNyZWF0ZVRleHQoXCJcIik7XHJcbiAgICAgIGluc2VydChwbGFjZWhvbGRlciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICBpbnNlcnQobWFpbkFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICBjb25zdCBtb3VudCA9IChjb250YWluZXIyLCBhbmNob3IyKSA9PiB7XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XHJcbiAgICAgICAgICBpZiAocGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC5pc0NFKSB7XHJcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudC5jZS5fdGVsZXBvcnRUYXJnZXQgPSBjb250YWluZXIyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbW91bnRDaGlsZHJlbihcclxuICAgICAgICAgICAgY2hpbGRyZW4sXHJcbiAgICAgICAgICAgIGNvbnRhaW5lcjIsXHJcbiAgICAgICAgICAgIGFuY2hvcjIsXHJcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcclxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcclxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxyXG4gICAgICAgICAgICBvcHRpbWl6ZWRcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICBjb25zdCBtb3VudFRvVGFyZ2V0ID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG4yLnRhcmdldCA9IHJlc29sdmVUYXJnZXQobjIucHJvcHMsIHF1ZXJ5U2VsZWN0b3IpO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldEFuY2hvciA9IHByZXBhcmVBbmNob3IodGFyZ2V0LCBuMiwgY3JlYXRlVGV4dCwgaW5zZXJ0KTtcclxuICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICBpZiAobmFtZXNwYWNlICE9PSBcInN2Z1wiICYmIGlzVGFyZ2V0U1ZHKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgbmFtZXNwYWNlID0gXCJzdmdcIjtcclxuICAgICAgICAgIH0gZWxzZSBpZiAobmFtZXNwYWNlICE9PSBcIm1hdGhtbFwiICYmIGlzVGFyZ2V0TWF0aE1MKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgbmFtZXNwYWNlID0gXCJtYXRobWxcIjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICghZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgbW91bnQodGFyZ2V0LCB0YXJnZXRBbmNob3IpO1xyXG4gICAgICAgICAgICB1cGRhdGVDc3NWYXJzKG4yLCBmYWxzZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFkaXNhYmxlZCkge1xyXG4gICAgICAgICAgd2FybiQxKFxyXG4gICAgICAgICAgICBcIkludmFsaWQgVGVsZXBvcnQgdGFyZ2V0IG9uIG1vdW50OlwiLFxyXG4gICAgICAgICAgICB0YXJnZXQsXHJcbiAgICAgICAgICAgIGAoJHt0eXBlb2YgdGFyZ2V0fSlgXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgaWYgKGRpc2FibGVkKSB7XHJcbiAgICAgICAgbW91bnQoY29udGFpbmVyLCBtYWluQW5jaG9yKTtcclxuICAgICAgICB1cGRhdGVDc3NWYXJzKG4yLCB0cnVlKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNUZWxlcG9ydERlZmVycmVkKG4yLnByb3BzKSkge1xyXG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICBtb3VudFRvVGFyZ2V0KCk7XHJcbiAgICAgICAgICBuMi5lbC5fX2lzTW91bnRlZCA9IHRydWU7XHJcbiAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG1vdW50VG9UYXJnZXQoKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGlzVGVsZXBvcnREZWZlcnJlZChuMi5wcm9wcykgJiYgIW4xLmVsLl9faXNNb3VudGVkKSB7XHJcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgIFRlbGVwb3J0SW1wbC5wcm9jZXNzKFxyXG4gICAgICAgICAgICBuMSxcclxuICAgICAgICAgICAgbjIsXHJcbiAgICAgICAgICAgIGNvbnRhaW5lcixcclxuICAgICAgICAgICAgYW5jaG9yLFxyXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxyXG4gICAgICAgICAgICBuYW1lc3BhY2UsXHJcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcclxuICAgICAgICAgICAgb3B0aW1pemVkLFxyXG4gICAgICAgICAgICBpbnRlcm5hbHNcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBkZWxldGUgbjEuZWwuX19pc01vdW50ZWQ7XHJcbiAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBuMi5lbCA9IG4xLmVsO1xyXG4gICAgICBuMi50YXJnZXRTdGFydCA9IG4xLnRhcmdldFN0YXJ0O1xyXG4gICAgICBjb25zdCBtYWluQW5jaG9yID0gbjIuYW5jaG9yID0gbjEuYW5jaG9yO1xyXG4gICAgICBjb25zdCB0YXJnZXQgPSBuMi50YXJnZXQgPSBuMS50YXJnZXQ7XHJcbiAgICAgIGNvbnN0IHRhcmdldEFuY2hvciA9IG4yLnRhcmdldEFuY2hvciA9IG4xLnRhcmdldEFuY2hvcjtcclxuICAgICAgY29uc3Qgd2FzRGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjEucHJvcHMpO1xyXG4gICAgICBjb25zdCBjdXJyZW50Q29udGFpbmVyID0gd2FzRGlzYWJsZWQgPyBjb250YWluZXIgOiB0YXJnZXQ7XHJcbiAgICAgIGNvbnN0IGN1cnJlbnRBbmNob3IgPSB3YXNEaXNhYmxlZCA/IG1haW5BbmNob3IgOiB0YXJnZXRBbmNob3I7XHJcbiAgICAgIGlmIChuYW1lc3BhY2UgPT09IFwic3ZnXCIgfHwgaXNUYXJnZXRTVkcodGFyZ2V0KSkge1xyXG4gICAgICAgIG5hbWVzcGFjZSA9IFwic3ZnXCI7XHJcbiAgICAgIH0gZWxzZSBpZiAobmFtZXNwYWNlID09PSBcIm1hdGhtbFwiIHx8IGlzVGFyZ2V0TWF0aE1MKHRhcmdldCkpIHtcclxuICAgICAgICBuYW1lc3BhY2UgPSBcIm1hdGhtbFwiO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcclxuICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4oXHJcbiAgICAgICAgICBuMS5keW5hbWljQ2hpbGRyZW4sXHJcbiAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4sXHJcbiAgICAgICAgICBjdXJyZW50Q29udGFpbmVyLFxyXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgICAgICBuYW1lc3BhY2UsXHJcbiAgICAgICAgICBzbG90U2NvcGVJZHNcclxuICAgICAgICApO1xyXG4gICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yLCB0cnVlKTtcclxuICAgICAgfSBlbHNlIGlmICghb3B0aW1pemVkKSB7XHJcbiAgICAgICAgcGF0Y2hDaGlsZHJlbihcclxuICAgICAgICAgIG4xLFxyXG4gICAgICAgICAgbjIsXHJcbiAgICAgICAgICBjdXJyZW50Q29udGFpbmVyLFxyXG4gICAgICAgICAgY3VycmVudEFuY2hvcixcclxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcclxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxyXG4gICAgICAgICAgbmFtZXNwYWNlLFxyXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxyXG4gICAgICAgICAgZmFsc2VcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChkaXNhYmxlZCkge1xyXG4gICAgICAgIGlmICghd2FzRGlzYWJsZWQpIHtcclxuICAgICAgICAgIG1vdmVUZWxlcG9ydChcclxuICAgICAgICAgICAgbjIsXHJcbiAgICAgICAgICAgIGNvbnRhaW5lcixcclxuICAgICAgICAgICAgbWFpbkFuY2hvcixcclxuICAgICAgICAgICAgaW50ZXJuYWxzLFxyXG4gICAgICAgICAgICAxXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAobjIucHJvcHMgJiYgbjEucHJvcHMgJiYgbjIucHJvcHMudG8gIT09IG4xLnByb3BzLnRvKSB7XHJcbiAgICAgICAgICAgIG4yLnByb3BzLnRvID0gbjEucHJvcHMudG87XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICgobjIucHJvcHMgJiYgbjIucHJvcHMudG8pICE9PSAobjEucHJvcHMgJiYgbjEucHJvcHMudG8pKSB7XHJcbiAgICAgICAgICBjb25zdCBuZXh0VGFyZ2V0ID0gbjIudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChcclxuICAgICAgICAgICAgbjIucHJvcHMsXHJcbiAgICAgICAgICAgIHF1ZXJ5U2VsZWN0b3JcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBpZiAobmV4dFRhcmdldCkge1xyXG4gICAgICAgICAgICBtb3ZlVGVsZXBvcnQoXHJcbiAgICAgICAgICAgICAgbjIsXHJcbiAgICAgICAgICAgICAgbmV4dFRhcmdldCxcclxuICAgICAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICAgIGludGVybmFscyxcclxuICAgICAgICAgICAgICAwXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgICAgICAgd2FybiQxKFxyXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gdXBkYXRlOlwiLFxyXG4gICAgICAgICAgICAgIHRhcmdldCxcclxuICAgICAgICAgICAgICBgKCR7dHlwZW9mIHRhcmdldH0pYFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAod2FzRGlzYWJsZWQpIHtcclxuICAgICAgICAgIG1vdmVUZWxlcG9ydChcclxuICAgICAgICAgICAgbjIsXHJcbiAgICAgICAgICAgIHRhcmdldCxcclxuICAgICAgICAgICAgdGFyZ2V0QW5jaG9yLFxyXG4gICAgICAgICAgICBpbnRlcm5hbHMsXHJcbiAgICAgICAgICAgIDFcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHVwZGF0ZUNzc1ZhcnMobjIsIGRpc2FibGVkKTtcclxuICAgIH1cclxuICB9LFxyXG4gIHJlbW92ZSh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgeyB1bTogdW5tb3VudCwgbzogeyByZW1vdmU6IGhvc3RSZW1vdmUgfSB9LCBkb1JlbW92ZSkge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBzaGFwZUZsYWcsXHJcbiAgICAgIGNoaWxkcmVuLFxyXG4gICAgICBhbmNob3IsXHJcbiAgICAgIHRhcmdldFN0YXJ0LFxyXG4gICAgICB0YXJnZXRBbmNob3IsXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgcHJvcHNcclxuICAgIH0gPSB2bm9kZTtcclxuICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgaG9zdFJlbW92ZSh0YXJnZXRTdGFydCk7XHJcbiAgICAgIGhvc3RSZW1vdmUodGFyZ2V0QW5jaG9yKTtcclxuICAgIH1cclxuICAgIGRvUmVtb3ZlICYmIGhvc3RSZW1vdmUoYW5jaG9yKTtcclxuICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xyXG4gICAgICBjb25zdCBzaG91bGRSZW1vdmUgPSBkb1JlbW92ZSB8fCAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKTtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgdW5tb3VudChcclxuICAgICAgICAgIGNoaWxkLFxyXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgICAgICBzaG91bGRSZW1vdmUsXHJcbiAgICAgICAgICAhIWNoaWxkLmR5bmFtaWNDaGlsZHJlblxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG4gIG1vdmU6IG1vdmVUZWxlcG9ydCxcclxuICBoeWRyYXRlOiBoeWRyYXRlVGVsZXBvcnRcclxufTtcclxuZnVuY3Rpb24gbW92ZVRlbGVwb3J0KHZub2RlLCBjb250YWluZXIsIHBhcmVudEFuY2hvciwgeyBvOiB7IGluc2VydCB9LCBtOiBtb3ZlIH0sIG1vdmVUeXBlID0gMikge1xyXG4gIGlmIChtb3ZlVHlwZSA9PT0gMCkge1xyXG4gICAgaW5zZXJ0KHZub2RlLnRhcmdldEFuY2hvciwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xyXG4gIH1cclxuICBjb25zdCB7IGVsLCBhbmNob3IsIHNoYXBlRmxhZywgY2hpbGRyZW4sIHByb3BzIH0gPSB2bm9kZTtcclxuICBjb25zdCBpc1Jlb3JkZXIgPSBtb3ZlVHlwZSA9PT0gMjtcclxuICBpZiAoaXNSZW9yZGVyKSB7XHJcbiAgICBpbnNlcnQoZWwsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcclxuICB9XHJcbiAgaWYgKCFpc1Jlb3JkZXIgfHwgaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xyXG4gICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBtb3ZlKFxyXG4gICAgICAgICAgY2hpbGRyZW5baV0sXHJcbiAgICAgICAgICBjb250YWluZXIsXHJcbiAgICAgICAgICBwYXJlbnRBbmNob3IsXHJcbiAgICAgICAgICAyXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoaXNSZW9yZGVyKSB7XHJcbiAgICBpbnNlcnQoYW5jaG9yLCBjb250YWluZXIsIHBhcmVudEFuY2hvcik7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGh5ZHJhdGVUZWxlcG9ydChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHtcclxuICBvOiB7IG5leHRTaWJsaW5nLCBwYXJlbnROb2RlLCBxdWVyeVNlbGVjdG9yLCBpbnNlcnQsIGNyZWF0ZVRleHQgfVxyXG59LCBoeWRyYXRlQ2hpbGRyZW4pIHtcclxuICBjb25zdCB0YXJnZXQgPSB2bm9kZS50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KFxyXG4gICAgdm5vZGUucHJvcHMsXHJcbiAgICBxdWVyeVNlbGVjdG9yXHJcbiAgKTtcclxuICBpZiAodGFyZ2V0KSB7XHJcbiAgICBjb25zdCBkaXNhYmxlZCA9IGlzVGVsZXBvcnREaXNhYmxlZCh2bm9kZS5wcm9wcyk7XHJcbiAgICBjb25zdCB0YXJnZXROb2RlID0gdGFyZ2V0Ll9scGEgfHwgdGFyZ2V0LmZpcnN0Q2hpbGQ7XHJcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTYpIHtcclxuICAgICAgaWYgKGRpc2FibGVkKSB7XHJcbiAgICAgICAgdm5vZGUuYW5jaG9yID0gaHlkcmF0ZUNoaWxkcmVuKFxyXG4gICAgICAgICAgbmV4dFNpYmxpbmcobm9kZSksXHJcbiAgICAgICAgICB2bm9kZSxcclxuICAgICAgICAgIHBhcmVudE5vZGUobm9kZSksXHJcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcclxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcclxuICAgICAgICAgIG9wdGltaXplZFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdm5vZGUudGFyZ2V0U3RhcnQgPSB0YXJnZXROb2RlO1xyXG4gICAgICAgIHZub2RlLnRhcmdldEFuY2hvciA9IHRhcmdldE5vZGUgJiYgbmV4dFNpYmxpbmcodGFyZ2V0Tm9kZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdm5vZGUuYW5jaG9yID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgbGV0IHRhcmdldEFuY2hvciA9IHRhcmdldE5vZGU7XHJcbiAgICAgICAgd2hpbGUgKHRhcmdldEFuY2hvcikge1xyXG4gICAgICAgICAgaWYgKHRhcmdldEFuY2hvciAmJiB0YXJnZXRBbmNob3Iubm9kZVR5cGUgPT09IDgpIHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldEFuY2hvci5kYXRhID09PSBcInRlbGVwb3J0IHN0YXJ0IGFuY2hvclwiKSB7XHJcbiAgICAgICAgICAgICAgdm5vZGUudGFyZ2V0U3RhcnQgPSB0YXJnZXRBbmNob3I7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0QW5jaG9yLmRhdGEgPT09IFwidGVsZXBvcnQgYW5jaG9yXCIpIHtcclxuICAgICAgICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgPSB0YXJnZXRBbmNob3I7XHJcbiAgICAgICAgICAgICAgdGFyZ2V0Ll9scGEgPSB2bm9kZS50YXJnZXRBbmNob3IgJiYgbmV4dFNpYmxpbmcodm5vZGUudGFyZ2V0QW5jaG9yKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGFyZ2V0QW5jaG9yID0gbmV4dFNpYmxpbmcodGFyZ2V0QW5jaG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF2bm9kZS50YXJnZXRBbmNob3IpIHtcclxuICAgICAgICAgIHByZXBhcmVBbmNob3IodGFyZ2V0LCB2bm9kZSwgY3JlYXRlVGV4dCwgaW5zZXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaHlkcmF0ZUNoaWxkcmVuKFxyXG4gICAgICAgICAgdGFyZ2V0Tm9kZSAmJiBuZXh0U2libGluZyh0YXJnZXROb2RlKSxcclxuICAgICAgICAgIHZub2RlLFxyXG4gICAgICAgICAgdGFyZ2V0LFxyXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXHJcbiAgICAgICAgICBvcHRpbWl6ZWRcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVDc3NWYXJzKHZub2RlLCBkaXNhYmxlZCk7XHJcbiAgfVxyXG4gIHJldHVybiB2bm9kZS5hbmNob3IgJiYgbmV4dFNpYmxpbmcodm5vZGUuYW5jaG9yKTtcclxufVxyXG5jb25zdCBUZWxlcG9ydCA9IFRlbGVwb3J0SW1wbDtcclxuZnVuY3Rpb24gdXBkYXRlQ3NzVmFycyh2bm9kZSwgaXNEaXNhYmxlZCkge1xyXG4gIGNvbnN0IGN0eCA9IHZub2RlLmN0eDtcclxuICBpZiAoY3R4ICYmIGN0eC51dCkge1xyXG4gICAgbGV0IG5vZGUsIGFuY2hvcjtcclxuICAgIGlmIChpc0Rpc2FibGVkKSB7XHJcbiAgICAgIG5vZGUgPSB2bm9kZS5lbDtcclxuICAgICAgYW5jaG9yID0gdm5vZGUuYW5jaG9yO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbm9kZSA9IHZub2RlLnRhcmdldFN0YXJ0O1xyXG4gICAgICBhbmNob3IgPSB2bm9kZS50YXJnZXRBbmNob3I7XHJcbiAgICB9XHJcbiAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9PSBhbmNob3IpIHtcclxuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIG5vZGUuc2V0QXR0cmlidXRlKFwiZGF0YS12LW93bmVyXCIsIGN0eC51aWQpO1xyXG4gICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcclxuICAgIH1cclxuICAgIGN0eC51dCgpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBwcmVwYXJlQW5jaG9yKHRhcmdldCwgdm5vZGUsIGNyZWF0ZVRleHQsIGluc2VydCkge1xyXG4gIGNvbnN0IHRhcmdldFN0YXJ0ID0gdm5vZGUudGFyZ2V0U3RhcnQgPSBjcmVhdGVUZXh0KFwiXCIpO1xyXG4gIGNvbnN0IHRhcmdldEFuY2hvciA9IHZub2RlLnRhcmdldEFuY2hvciA9IGNyZWF0ZVRleHQoXCJcIik7XHJcbiAgdGFyZ2V0U3RhcnRbVGVsZXBvcnRFbmRLZXldID0gdGFyZ2V0QW5jaG9yO1xyXG4gIGlmICh0YXJnZXQpIHtcclxuICAgIGluc2VydCh0YXJnZXRTdGFydCwgdGFyZ2V0KTtcclxuICAgIGluc2VydCh0YXJnZXRBbmNob3IsIHRhcmdldCk7XHJcbiAgfVxyXG4gIHJldHVybiB0YXJnZXRBbmNob3I7XHJcbn1cclxuXHJcbmNvbnN0IGxlYXZlQ2JLZXkgPSBTeW1ib2woXCJfbGVhdmVDYlwiKTtcclxuY29uc3QgZW50ZXJDYktleSA9IFN5bWJvbChcIl9lbnRlckNiXCIpO1xyXG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uU3RhdGUoKSB7XHJcbiAgY29uc3Qgc3RhdGUgPSB7XHJcbiAgICBpc01vdW50ZWQ6IGZhbHNlLFxyXG4gICAgaXNMZWF2aW5nOiBmYWxzZSxcclxuICAgIGlzVW5tb3VudGluZzogZmFsc2UsXHJcbiAgICBsZWF2aW5nVk5vZGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXHJcbiAgfTtcclxuICBvbk1vdW50ZWQoKCkgPT4ge1xyXG4gICAgc3RhdGUuaXNNb3VudGVkID0gdHJ1ZTtcclxuICB9KTtcclxuICBvbkJlZm9yZVVubW91bnQoKCkgPT4ge1xyXG4gICAgc3RhdGUuaXNVbm1vdW50aW5nID0gdHJ1ZTtcclxuICB9KTtcclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuY29uc3QgVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IgPSBbRnVuY3Rpb24sIEFycmF5XTtcclxuY29uc3QgQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSB7XHJcbiAgbW9kZTogU3RyaW5nLFxyXG4gIGFwcGVhcjogQm9vbGVhbixcclxuICBwZXJzaXN0ZWQ6IEJvb2xlYW4sXHJcbiAgLy8gZW50ZXJcclxuICBvbkJlZm9yZUVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICBvbkVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICBvbkFmdGVyRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gIG9uRW50ZXJDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gIC8vIGxlYXZlXHJcbiAgb25CZWZvcmVMZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgb25MZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgb25BZnRlckxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICBvbkxlYXZlQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAvLyBhcHBlYXJcclxuICBvbkJlZm9yZUFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgb25BcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gIG9uQWZ0ZXJBcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gIG9uQXBwZWFyQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvclxyXG59O1xyXG5jb25zdCByZWN1cnNpdmVHZXRTdWJ0cmVlID0gKGluc3RhbmNlKSA9PiB7XHJcbiAgY29uc3Qgc3ViVHJlZSA9IGluc3RhbmNlLnN1YlRyZWU7XHJcbiAgcmV0dXJuIHN1YlRyZWUuY29tcG9uZW50ID8gcmVjdXJzaXZlR2V0U3VidHJlZShzdWJUcmVlLmNvbXBvbmVudCkgOiBzdWJUcmVlO1xyXG59O1xyXG5jb25zdCBCYXNlVHJhbnNpdGlvbkltcGwgPSB7XHJcbiAgbmFtZTogYEJhc2VUcmFuc2l0aW9uYCxcclxuICBwcm9wczogQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsXHJcbiAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgIGNvbnN0IHN0YXRlID0gdXNlVHJhbnNpdGlvblN0YXRlKCk7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgJiYgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKHNsb3RzLmRlZmF1bHQoKSwgdHJ1ZSk7XHJcbiAgICAgIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBjaGlsZCA9IGZpbmROb25Db21tZW50Q2hpbGQoY2hpbGRyZW4pO1xyXG4gICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcclxuICAgICAgY29uc3QgeyBtb2RlIH0gPSByYXdQcm9wcztcclxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbW9kZSAmJiBtb2RlICE9PSBcImluLW91dFwiICYmIG1vZGUgIT09IFwib3V0LWluXCIgJiYgbW9kZSAhPT0gXCJkZWZhdWx0XCIpIHtcclxuICAgICAgICB3YXJuJDEoYGludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICR7bW9kZX1gKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc3RhdGUuaXNMZWF2aW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGlubmVyQ2hpbGQgPSBnZXRJbm5lckNoaWxkJDEoY2hpbGQpO1xyXG4gICAgICBpZiAoIWlubmVyQ2hpbGQpIHtcclxuICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IGVudGVySG9va3MgPSByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKFxyXG4gICAgICAgIGlubmVyQ2hpbGQsXHJcbiAgICAgICAgcmF3UHJvcHMsXHJcbiAgICAgICAgc3RhdGUsXHJcbiAgICAgICAgaW5zdGFuY2UsXHJcbiAgICAgICAgLy8gIzExMDYxLCBlbnN1cmUgZW50ZXJIb29rcyBpcyBmcmVzaCBhZnRlciBjbG9uZVxyXG4gICAgICAgIChob29rcykgPT4gZW50ZXJIb29rcyA9IGhvb2tzXHJcbiAgICAgICk7XHJcbiAgICAgIGlmIChpbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcclxuICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3MoaW5uZXJDaGlsZCwgZW50ZXJIb29rcyk7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IG9sZElubmVyQ2hpbGQgPSBpbnN0YW5jZS5zdWJUcmVlICYmIGdldElubmVyQ2hpbGQkMShpbnN0YW5jZS5zdWJUcmVlKTtcclxuICAgICAgaWYgKG9sZElubmVyQ2hpbGQgJiYgb2xkSW5uZXJDaGlsZC50eXBlICE9PSBDb21tZW50ICYmICFpc1NhbWVWTm9kZVR5cGUoaW5uZXJDaGlsZCwgb2xkSW5uZXJDaGlsZCkgJiYgcmVjdXJzaXZlR2V0U3VidHJlZShpbnN0YW5jZSkudHlwZSAhPT0gQ29tbWVudCkge1xyXG4gICAgICAgIGxldCBsZWF2aW5nSG9va3MgPSByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKFxyXG4gICAgICAgICAgb2xkSW5uZXJDaGlsZCxcclxuICAgICAgICAgIHJhd1Byb3BzLFxyXG4gICAgICAgICAgc3RhdGUsXHJcbiAgICAgICAgICBpbnN0YW5jZVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKG9sZElubmVyQ2hpbGQsIGxlYXZpbmdIb29rcyk7XHJcbiAgICAgICAgaWYgKG1vZGUgPT09IFwib3V0LWluXCIgJiYgaW5uZXJDaGlsZC50eXBlICE9PSBDb21tZW50KSB7XHJcbiAgICAgICAgICBzdGF0ZS5pc0xlYXZpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgbGVhdmluZ0hvb2tzLmFmdGVyTGVhdmUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHN0YXRlLmlzTGVhdmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoIShpbnN0YW5jZS5qb2IuZmxhZ3MgJiA4KSkge1xyXG4gICAgICAgICAgICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlbGV0ZSBsZWF2aW5nSG9va3MuYWZ0ZXJMZWF2ZTtcclxuICAgICAgICAgICAgb2xkSW5uZXJDaGlsZCA9IHZvaWQgMDtcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSBcImluLW91dFwiICYmIGlubmVyQ2hpbGQudHlwZSAhPT0gQ29tbWVudCkge1xyXG4gICAgICAgICAgbGVhdmluZ0hvb2tzLmRlbGF5TGVhdmUgPSAoZWwsIGVhcmx5UmVtb3ZlLCBkZWxheWVkTGVhdmUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShcclxuICAgICAgICAgICAgICBzdGF0ZSxcclxuICAgICAgICAgICAgICBvbGRJbm5lckNoaWxkXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGxlYXZpbmdWTm9kZXNDYWNoZVtTdHJpbmcob2xkSW5uZXJDaGlsZC5rZXkpXSA9IG9sZElubmVyQ2hpbGQ7XHJcbiAgICAgICAgICAgIGVsW2xlYXZlQ2JLZXldID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgIGVhcmx5UmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgZWxbbGVhdmVDYktleV0gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgZGVsZXRlIGVudGVySG9va3MuZGVsYXllZExlYXZlO1xyXG4gICAgICAgICAgICAgIG9sZElubmVyQ2hpbGQgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGVudGVySG9va3MuZGVsYXllZExlYXZlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgIGRlbGF5ZWRMZWF2ZSgpO1xyXG4gICAgICAgICAgICAgIGRlbGV0ZSBlbnRlckhvb2tzLmRlbGF5ZWRMZWF2ZTtcclxuICAgICAgICAgICAgICBvbGRJbm5lckNoaWxkID0gdm9pZCAwO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgb2xkSW5uZXJDaGlsZCA9IHZvaWQgMDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAob2xkSW5uZXJDaGlsZCkge1xyXG4gICAgICAgIG9sZElubmVyQ2hpbGQgPSB2b2lkIDA7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgfTtcclxuICB9XHJcbn07XHJcbmZ1bmN0aW9uIGZpbmROb25Db21tZW50Q2hpbGQoY2hpbGRyZW4pIHtcclxuICBsZXQgY2hpbGQgPSBjaGlsZHJlblswXTtcclxuICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xyXG4gICAgbGV0IGhhc0ZvdW5kID0gZmFsc2U7XHJcbiAgICBmb3IgKGNvbnN0IGMgb2YgY2hpbGRyZW4pIHtcclxuICAgICAgaWYgKGMudHlwZSAhPT0gQ29tbWVudCkge1xyXG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGhhc0ZvdW5kKSB7XHJcbiAgICAgICAgICB3YXJuJDEoXHJcbiAgICAgICAgICAgIFwiPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudCBvciBjb21wb25lbnQuIFVzZSA8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLlwiXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNoaWxkID0gYztcclxuICAgICAgICBoYXNGb3VuZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKCEhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gY2hpbGQ7XHJcbn1cclxuY29uc3QgQmFzZVRyYW5zaXRpb24gPSBCYXNlVHJhbnNpdGlvbkltcGw7XHJcbmZ1bmN0aW9uIGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoc3RhdGUsIHZub2RlKSB7XHJcbiAgY29uc3QgeyBsZWF2aW5nVk5vZGVzIH0gPSBzdGF0ZTtcclxuICBsZXQgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gbGVhdmluZ1ZOb2Rlcy5nZXQodm5vZGUudHlwZSk7XHJcbiAgaWYgKCFsZWF2aW5nVk5vZGVzQ2FjaGUpIHtcclxuICAgIGxlYXZpbmdWTm9kZXNDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgbGVhdmluZ1ZOb2Rlcy5zZXQodm5vZGUudHlwZSwgbGVhdmluZ1ZOb2Rlc0NhY2hlKTtcclxuICB9XHJcbiAgcmV0dXJuIGxlYXZpbmdWTm9kZXNDYWNoZTtcclxufVxyXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKHZub2RlLCBwcm9wcywgc3RhdGUsIGluc3RhbmNlLCBwb3N0Q2xvbmUpIHtcclxuICBjb25zdCB7XHJcbiAgICBhcHBlYXIsXHJcbiAgICBtb2RlLFxyXG4gICAgcGVyc2lzdGVkID0gZmFsc2UsXHJcbiAgICBvbkJlZm9yZUVudGVyLFxyXG4gICAgb25FbnRlcixcclxuICAgIG9uQWZ0ZXJFbnRlcixcclxuICAgIG9uRW50ZXJDYW5jZWxsZWQsXHJcbiAgICBvbkJlZm9yZUxlYXZlLFxyXG4gICAgb25MZWF2ZSxcclxuICAgIG9uQWZ0ZXJMZWF2ZSxcclxuICAgIG9uTGVhdmVDYW5jZWxsZWQsXHJcbiAgICBvbkJlZm9yZUFwcGVhcixcclxuICAgIG9uQXBwZWFyLFxyXG4gICAgb25BZnRlckFwcGVhcixcclxuICAgIG9uQXBwZWFyQ2FuY2VsbGVkXHJcbiAgfSA9IHByb3BzO1xyXG4gIGNvbnN0IGtleSA9IFN0cmluZyh2bm9kZS5rZXkpO1xyXG4gIGNvbnN0IGxlYXZpbmdWTm9kZXNDYWNoZSA9IGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoc3RhdGUsIHZub2RlKTtcclxuICBjb25zdCBjYWxsSG9vayA9IChob29rLCBhcmdzKSA9PiB7XHJcbiAgICBob29rICYmIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxyXG4gICAgICBob29rLFxyXG4gICAgICBpbnN0YW5jZSxcclxuICAgICAgOSxcclxuICAgICAgYXJnc1xyXG4gICAgKTtcclxuICB9O1xyXG4gIGNvbnN0IGNhbGxBc3luY0hvb2sgPSAoaG9vaywgYXJncykgPT4ge1xyXG4gICAgY29uc3QgZG9uZSA9IGFyZ3NbMV07XHJcbiAgICBjYWxsSG9vayhob29rLCBhcmdzKTtcclxuICAgIGlmIChpc0FycmF5KGhvb2spKSB7XHJcbiAgICAgIGlmIChob29rLmV2ZXJ5KChob29rMikgPT4gaG9vazIubGVuZ3RoIDw9IDEpKSBkb25lKCk7XHJcbiAgICB9IGVsc2UgaWYgKGhvb2subGVuZ3RoIDw9IDEpIHtcclxuICAgICAgZG9uZSgpO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgY29uc3QgaG9va3MgPSB7XHJcbiAgICBtb2RlLFxyXG4gICAgcGVyc2lzdGVkLFxyXG4gICAgYmVmb3JlRW50ZXIoZWwpIHtcclxuICAgICAgbGV0IGhvb2sgPSBvbkJlZm9yZUVudGVyO1xyXG4gICAgICBpZiAoIXN0YXRlLmlzTW91bnRlZCkge1xyXG4gICAgICAgIGlmIChhcHBlYXIpIHtcclxuICAgICAgICAgIGhvb2sgPSBvbkJlZm9yZUFwcGVhciB8fCBvbkJlZm9yZUVudGVyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChlbFtsZWF2ZUNiS2V5XSkge1xyXG4gICAgICAgIGVsW2xlYXZlQ2JLZXldKFxyXG4gICAgICAgICAgdHJ1ZVxyXG4gICAgICAgICAgLyogY2FuY2VsbGVkICovXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBsZWF2aW5nVk5vZGUgPSBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5XTtcclxuICAgICAgaWYgKGxlYXZpbmdWTm9kZSAmJiBpc1NhbWVWTm9kZVR5cGUodm5vZGUsIGxlYXZpbmdWTm9kZSkgJiYgbGVhdmluZ1ZOb2RlLmVsW2xlYXZlQ2JLZXldKSB7XHJcbiAgICAgICAgbGVhdmluZ1ZOb2RlLmVsW2xlYXZlQ2JLZXldKCk7XHJcbiAgICAgIH1cclxuICAgICAgY2FsbEhvb2soaG9vaywgW2VsXSk7XHJcbiAgICB9LFxyXG4gICAgZW50ZXIoZWwpIHtcclxuICAgICAgbGV0IGhvb2sgPSBvbkVudGVyO1xyXG4gICAgICBsZXQgYWZ0ZXJIb29rID0gb25BZnRlckVudGVyO1xyXG4gICAgICBsZXQgY2FuY2VsSG9vayA9IG9uRW50ZXJDYW5jZWxsZWQ7XHJcbiAgICAgIGlmICghc3RhdGUuaXNNb3VudGVkKSB7XHJcbiAgICAgICAgaWYgKGFwcGVhcikge1xyXG4gICAgICAgICAgaG9vayA9IG9uQXBwZWFyIHx8IG9uRW50ZXI7XHJcbiAgICAgICAgICBhZnRlckhvb2sgPSBvbkFmdGVyQXBwZWFyIHx8IG9uQWZ0ZXJFbnRlcjtcclxuICAgICAgICAgIGNhbmNlbEhvb2sgPSBvbkFwcGVhckNhbmNlbGxlZCB8fCBvbkVudGVyQ2FuY2VsbGVkO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcclxuICAgICAgY29uc3QgZG9uZSA9IGVsW2VudGVyQ2JLZXldID0gKGNhbmNlbGxlZCkgPT4ge1xyXG4gICAgICAgIGlmIChjYWxsZWQpIHJldHVybjtcclxuICAgICAgICBjYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHtcclxuICAgICAgICAgIGNhbGxIb29rKGNhbmNlbEhvb2ssIFtlbF0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjYWxsSG9vayhhZnRlckhvb2ssIFtlbF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaG9va3MuZGVsYXllZExlYXZlKSB7XHJcbiAgICAgICAgICBob29rcy5kZWxheWVkTGVhdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxbZW50ZXJDYktleV0gPSB2b2lkIDA7XHJcbiAgICAgIH07XHJcbiAgICAgIGlmIChob29rKSB7XHJcbiAgICAgICAgY2FsbEFzeW5jSG9vayhob29rLCBbZWwsIGRvbmVdKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkb25lKCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBsZWF2ZShlbCwgcmVtb3ZlKSB7XHJcbiAgICAgIGNvbnN0IGtleTIgPSBTdHJpbmcodm5vZGUua2V5KTtcclxuICAgICAgaWYgKGVsW2VudGVyQ2JLZXldKSB7XHJcbiAgICAgICAgZWxbZW50ZXJDYktleV0oXHJcbiAgICAgICAgICB0cnVlXHJcbiAgICAgICAgICAvKiBjYW5jZWxsZWQgKi9cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzdGF0ZS5pc1VubW91bnRpbmcpIHtcclxuICAgICAgICByZXR1cm4gcmVtb3ZlKCk7XHJcbiAgICAgIH1cclxuICAgICAgY2FsbEhvb2sob25CZWZvcmVMZWF2ZSwgW2VsXSk7XHJcbiAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcclxuICAgICAgY29uc3QgZG9uZSA9IGVsW2xlYXZlQ2JLZXldID0gKGNhbmNlbGxlZCkgPT4ge1xyXG4gICAgICAgIGlmIChjYWxsZWQpIHJldHVybjtcclxuICAgICAgICBjYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgIHJlbW92ZSgpO1xyXG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHtcclxuICAgICAgICAgIGNhbGxIb29rKG9uTGVhdmVDYW5jZWxsZWQsIFtlbF0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjYWxsSG9vayhvbkFmdGVyTGVhdmUsIFtlbF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbFtsZWF2ZUNiS2V5XSA9IHZvaWQgMDtcclxuICAgICAgICBpZiAobGVhdmluZ1ZOb2Rlc0NhY2hlW2tleTJdID09PSB2bm9kZSkge1xyXG4gICAgICAgICAgZGVsZXRlIGxlYXZpbmdWTm9kZXNDYWNoZVtrZXkyXTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICAgIGxlYXZpbmdWTm9kZXNDYWNoZVtrZXkyXSA9IHZub2RlO1xyXG4gICAgICBpZiAob25MZWF2ZSkge1xyXG4gICAgICAgIGNhbGxBc3luY0hvb2sob25MZWF2ZSwgW2VsLCBkb25lXSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZG9uZSgpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgY2xvbmUodm5vZGUyKSB7XHJcbiAgICAgIGNvbnN0IGhvb2tzMiA9IHJlc29sdmVUcmFuc2l0aW9uSG9va3MoXHJcbiAgICAgICAgdm5vZGUyLFxyXG4gICAgICAgIHByb3BzLFxyXG4gICAgICAgIHN0YXRlLFxyXG4gICAgICAgIGluc3RhbmNlLFxyXG4gICAgICAgIHBvc3RDbG9uZVxyXG4gICAgICApO1xyXG4gICAgICBpZiAocG9zdENsb25lKSBwb3N0Q2xvbmUoaG9va3MyKTtcclxuICAgICAgcmV0dXJuIGhvb2tzMjtcclxuICAgIH1cclxuICB9O1xyXG4gIHJldHVybiBob29rcztcclxufVxyXG5mdW5jdGlvbiBlbXB0eVBsYWNlaG9sZGVyKHZub2RlKSB7XHJcbiAgaWYgKGlzS2VlcEFsaXZlKHZub2RlKSkge1xyXG4gICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcclxuICAgIHZub2RlLmNoaWxkcmVuID0gbnVsbDtcclxuICAgIHJldHVybiB2bm9kZTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0SW5uZXJDaGlsZCQxKHZub2RlKSB7XHJcbiAgaWYgKCFpc0tlZXBBbGl2ZSh2bm9kZSkpIHtcclxuICAgIGlmIChpc1RlbGVwb3J0KHZub2RlLnR5cGUpICYmIHZub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgIHJldHVybiBmaW5kTm9uQ29tbWVudENoaWxkKHZub2RlLmNoaWxkcmVuKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2bm9kZTtcclxuICB9XHJcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdm5vZGUuY29tcG9uZW50KSB7XHJcbiAgICByZXR1cm4gdm5vZGUuY29tcG9uZW50LnN1YlRyZWU7XHJcbiAgfVxyXG4gIGNvbnN0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiB9ID0gdm5vZGU7XHJcbiAgaWYgKGNoaWxkcmVuKSB7XHJcbiAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcclxuICAgICAgcmV0dXJuIGNoaWxkcmVuWzBdO1xyXG4gICAgfVxyXG4gICAgaWYgKHNoYXBlRmxhZyAmIDMyICYmIGlzRnVuY3Rpb24oY2hpbGRyZW4uZGVmYXVsdCkpIHtcclxuICAgICAgcmV0dXJuIGNoaWxkcmVuLmRlZmF1bHQoKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZnVuY3Rpb24gc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLCBob29rcykge1xyXG4gIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA2ICYmIHZub2RlLmNvbXBvbmVudCkge1xyXG4gICAgdm5vZGUudHJhbnNpdGlvbiA9IGhvb2tzO1xyXG4gICAgc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLCBob29rcyk7XHJcbiAgfSBlbHNlIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjgpIHtcclxuICAgIHZub2RlLnNzQ29udGVudC50cmFuc2l0aW9uID0gaG9va3MuY2xvbmUodm5vZGUuc3NDb250ZW50KTtcclxuICAgIHZub2RlLnNzRmFsbGJhY2sudHJhbnNpdGlvbiA9IGhvb2tzLmNsb25lKHZub2RlLnNzRmFsbGJhY2spO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2bm9kZS50cmFuc2l0aW9uID0gaG9va3M7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihjaGlsZHJlbiwga2VlcENvbW1lbnQgPSBmYWxzZSwgcGFyZW50S2V5KSB7XHJcbiAgbGV0IHJldCA9IFtdO1xyXG4gIGxldCBrZXllZEZyYWdtZW50Q291bnQgPSAwO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgIGxldCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgY29uc3Qga2V5ID0gcGFyZW50S2V5ID09IG51bGwgPyBjaGlsZC5rZXkgOiBTdHJpbmcocGFyZW50S2V5KSArIFN0cmluZyhjaGlsZC5rZXkgIT0gbnVsbCA/IGNoaWxkLmtleSA6IGkpO1xyXG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IEZyYWdtZW50KSB7XHJcbiAgICAgIGlmIChjaGlsZC5wYXRjaEZsYWcgJiAxMjgpIGtleWVkRnJhZ21lbnRDb3VudCsrO1xyXG4gICAgICByZXQgPSByZXQuY29uY2F0KFxyXG4gICAgICAgIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihjaGlsZC5jaGlsZHJlbiwga2VlcENvbW1lbnQsIGtleSlcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSBpZiAoa2VlcENvbW1lbnQgfHwgY2hpbGQudHlwZSAhPT0gQ29tbWVudCkge1xyXG4gICAgICByZXQucHVzaChrZXkgIT0gbnVsbCA/IGNsb25lVk5vZGUoY2hpbGQsIHsga2V5IH0pIDogY2hpbGQpO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoa2V5ZWRGcmFnbWVudENvdW50ID4gMSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgcmV0W2ldLnBhdGNoRmxhZyA9IC0yO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmV0O1xyXG59XHJcblxyXG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cclxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cclxuZnVuY3Rpb24gZGVmaW5lQ29tcG9uZW50KG9wdGlvbnMsIGV4dHJhT3B0aW9ucykge1xyXG4gIHJldHVybiBpc0Z1bmN0aW9uKG9wdGlvbnMpID8gKFxyXG4gICAgLy8gIzgyMzY6IGV4dGVuZCBjYWxsIGFuZCBvcHRpb25zLm5hbWUgYWNjZXNzIGFyZSBjb25zaWRlcmVkIHNpZGUtZWZmZWN0c1xyXG4gICAgLy8gYnkgUm9sbHVwLCBzbyB3ZSBoYXZlIHRvIHdyYXAgaXQgaW4gYSBwdXJlLWFubm90YXRlZCBJSUZFLlxyXG4gICAgLyogQF9fUFVSRV9fICovICgoKSA9PiBleHRlbmQoeyBuYW1lOiBvcHRpb25zLm5hbWUgfSwgZXh0cmFPcHRpb25zLCB7IHNldHVwOiBvcHRpb25zIH0pKSgpXHJcbiAgKSA6IG9wdGlvbnM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVzZUlkKCkge1xyXG4gIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICBpZiAoaSkge1xyXG4gICAgcmV0dXJuIChpLmFwcENvbnRleHQuY29uZmlnLmlkUHJlZml4IHx8IFwidlwiKSArIFwiLVwiICsgaS5pZHNbMF0gKyBpLmlkc1sxXSsrO1xyXG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgd2FybiQxKFxyXG4gICAgICBgdXNlSWQoKSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC5gXHJcbiAgICApO1xyXG4gIH1cclxuICByZXR1cm4gXCJcIjtcclxufVxyXG5mdW5jdGlvbiBtYXJrQXN5bmNCb3VuZGFyeShpbnN0YW5jZSkge1xyXG4gIGluc3RhbmNlLmlkcyA9IFtpbnN0YW5jZS5pZHNbMF0gKyBpbnN0YW5jZS5pZHNbMl0rKyArIFwiLVwiLCAwLCAwXTtcclxufVxyXG5cclxuY29uc3Qga25vd25UZW1wbGF0ZVJlZnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcclxuZnVuY3Rpb24gdXNlVGVtcGxhdGVSZWYoa2V5KSB7XHJcbiAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gIGNvbnN0IHIgPSBzaGFsbG93UmVmKG51bGwpO1xyXG4gIGlmIChpKSB7XHJcbiAgICBjb25zdCByZWZzID0gaS5yZWZzID09PSBFTVBUWV9PQkogPyBpLnJlZnMgPSB7fSA6IGkucmVmcztcclxuICAgIGxldCBkZXNjO1xyXG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgKGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHJlZnMsIGtleSkpICYmICFkZXNjLmNvbmZpZ3VyYWJsZSkge1xyXG4gICAgICB3YXJuJDEoYHVzZVRlbXBsYXRlUmVmKCcke2tleX0nKSBhbHJlYWR5IGV4aXN0cy5gKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZWZzLCBrZXksIHtcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGdldDogKCkgPT4gci52YWx1ZSxcclxuICAgICAgICBzZXQ6ICh2YWwpID0+IHIudmFsdWUgPSB2YWxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICB3YXJuJDEoXHJcbiAgICAgIGB1c2VUZW1wbGF0ZVJlZigpIGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UgdG8gYmUgYXNzb2NpYXRlZCB3aXRoLmBcclxuICAgICk7XHJcbiAgfVxyXG4gIGNvbnN0IHJldCA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyByZWFkb25seShyKSA6IHI7XHJcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgIGtub3duVGVtcGxhdGVSZWZzLmFkZChyZXQpO1xyXG4gIH1cclxuICByZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRSZWYocmF3UmVmLCBvbGRSYXdSZWYsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSwgaXNVbm1vdW50ID0gZmFsc2UpIHtcclxuICBpZiAoaXNBcnJheShyYXdSZWYpKSB7XHJcbiAgICByYXdSZWYuZm9yRWFjaChcclxuICAgICAgKHIsIGkpID0+IHNldFJlZihcclxuICAgICAgICByLFxyXG4gICAgICAgIG9sZFJhd1JlZiAmJiAoaXNBcnJheShvbGRSYXdSZWYpID8gb2xkUmF3UmVmW2ldIDogb2xkUmF3UmVmKSxcclxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcclxuICAgICAgICB2bm9kZSxcclxuICAgICAgICBpc1VubW91bnRcclxuICAgICAgKVxyXG4gICAgKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKGlzQXN5bmNXcmFwcGVyKHZub2RlKSAmJiAhaXNVbm1vdW50KSB7XHJcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNTEyICYmIHZub2RlLnR5cGUuX19hc3luY1Jlc29sdmVkICYmIHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLmNvbXBvbmVudCkge1xyXG4gICAgICBzZXRSZWYocmF3UmVmLCBvbGRSYXdSZWYsIHBhcmVudFN1c3BlbnNlLCB2bm9kZS5jb21wb25lbnQuc3ViVHJlZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGNvbnN0IHJlZlZhbHVlID0gdm5vZGUuc2hhcGVGbGFnICYgNCA/IGdldENvbXBvbmVudFB1YmxpY0luc3RhbmNlKHZub2RlLmNvbXBvbmVudCkgOiB2bm9kZS5lbDtcclxuICBjb25zdCB2YWx1ZSA9IGlzVW5tb3VudCA/IG51bGwgOiByZWZWYWx1ZTtcclxuICBjb25zdCB7IGk6IG93bmVyLCByOiByZWYgfSA9IHJhd1JlZjtcclxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhb3duZXIpIHtcclxuICAgIHdhcm4kMShcclxuICAgICAgYE1pc3NpbmcgcmVmIG93bmVyIGNvbnRleHQuIHJlZiBjYW5ub3QgYmUgdXNlZCBvbiBob2lzdGVkIHZub2Rlcy4gQSB2bm9kZSB3aXRoIHJlZiBtdXN0IGJlIGNyZWF0ZWQgaW5zaWRlIHRoZSByZW5kZXIgZnVuY3Rpb24uYFxyXG4gICAgKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgY29uc3Qgb2xkUmVmID0gb2xkUmF3UmVmICYmIG9sZFJhd1JlZi5yO1xyXG4gIGNvbnN0IHJlZnMgPSBvd25lci5yZWZzID09PSBFTVBUWV9PQkogPyBvd25lci5yZWZzID0ge30gOiBvd25lci5yZWZzO1xyXG4gIGNvbnN0IHNldHVwU3RhdGUgPSBvd25lci5zZXR1cFN0YXRlO1xyXG4gIGNvbnN0IHJhd1NldHVwU3RhdGUgPSB0b1JhdyhzZXR1cFN0YXRlKTtcclxuICBjb25zdCBjYW5TZXRTZXR1cFJlZiA9IHNldHVwU3RhdGUgPT09IEVNUFRZX09CSiA/ICgpID0+IGZhbHNlIDogKGtleSkgPT4ge1xyXG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgaWYgKGhhc093bihyYXdTZXR1cFN0YXRlLCBrZXkpICYmICFpc1JlZihyYXdTZXR1cFN0YXRlW2tleV0pKSB7XHJcbiAgICAgICAgd2FybiQxKFxyXG4gICAgICAgICAgYFRlbXBsYXRlIHJlZiBcIiR7a2V5fVwiIHVzZWQgb24gYSBub24tcmVmIHZhbHVlLiBJdCB3aWxsIG5vdCB3b3JrIGluIHRoZSBwcm9kdWN0aW9uIGJ1aWxkLmBcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChrbm93blRlbXBsYXRlUmVmcy5oYXMocmF3U2V0dXBTdGF0ZVtrZXldKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhhc093bihyYXdTZXR1cFN0YXRlLCBrZXkpO1xyXG4gIH07XHJcbiAgaWYgKG9sZFJlZiAhPSBudWxsICYmIG9sZFJlZiAhPT0gcmVmKSB7XHJcbiAgICBpZiAoaXNTdHJpbmcob2xkUmVmKSkge1xyXG4gICAgICByZWZzW29sZFJlZl0gPSBudWxsO1xyXG4gICAgICBpZiAoY2FuU2V0U2V0dXBSZWYob2xkUmVmKSkge1xyXG4gICAgICAgIHNldHVwU3RhdGVbb2xkUmVmXSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoaXNSZWYob2xkUmVmKSkge1xyXG4gICAgICBvbGRSZWYudmFsdWUgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoaXNGdW5jdGlvbihyZWYpKSB7XHJcbiAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcocmVmLCBvd25lciwgMTIsIFt2YWx1ZSwgcmVmc10pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdCBfaXNTdHJpbmcgPSBpc1N0cmluZyhyZWYpO1xyXG4gICAgY29uc3QgX2lzUmVmID0gaXNSZWYocmVmKTtcclxuICAgIGlmIChfaXNTdHJpbmcgfHwgX2lzUmVmKSB7XHJcbiAgICAgIGNvbnN0IGRvU2V0ID0gKCkgPT4ge1xyXG4gICAgICAgIGlmIChyYXdSZWYuZikge1xyXG4gICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBfaXNTdHJpbmcgPyBjYW5TZXRTZXR1cFJlZihyZWYpID8gc2V0dXBTdGF0ZVtyZWZdIDogcmVmc1tyZWZdIDogcmVmLnZhbHVlO1xyXG4gICAgICAgICAgaWYgKGlzVW5tb3VudCkge1xyXG4gICAgICAgICAgICBpc0FycmF5KGV4aXN0aW5nKSAmJiByZW1vdmUoZXhpc3RpbmcsIHJlZlZhbHVlKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghaXNBcnJheShleGlzdGluZykpIHtcclxuICAgICAgICAgICAgICBpZiAoX2lzU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICByZWZzW3JlZl0gPSBbcmVmVmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhblNldFNldHVwUmVmKHJlZikpIHtcclxuICAgICAgICAgICAgICAgICAgc2V0dXBTdGF0ZVtyZWZdID0gcmVmc1tyZWZdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZWYudmFsdWUgPSBbcmVmVmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJhd1JlZi5rKSByZWZzW3Jhd1JlZi5rXSA9IHJlZi52YWx1ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWV4aXN0aW5nLmluY2x1ZGVzKHJlZlZhbHVlKSkge1xyXG4gICAgICAgICAgICAgIGV4aXN0aW5nLnB1c2gocmVmVmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChfaXNTdHJpbmcpIHtcclxuICAgICAgICAgIHJlZnNbcmVmXSA9IHZhbHVlO1xyXG4gICAgICAgICAgaWYgKGNhblNldFNldHVwUmVmKHJlZikpIHtcclxuICAgICAgICAgICAgc2V0dXBTdGF0ZVtyZWZdID0gdmFsdWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChfaXNSZWYpIHtcclxuICAgICAgICAgIHJlZi52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgaWYgKHJhd1JlZi5rKSByZWZzW3Jhd1JlZi5rXSA9IHZhbHVlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICAgICAgd2FybiQxKFwiSW52YWxpZCB0ZW1wbGF0ZSByZWYgdHlwZTpcIiwgcmVmLCBgKCR7dHlwZW9mIHJlZn0pYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICBkb1NldC5pZCA9IC0xO1xyXG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChkb1NldCwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRvU2V0KCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICB3YXJuJDEoXCJJbnZhbGlkIHRlbXBsYXRlIHJlZiB0eXBlOlwiLCByZWYsIGAoJHt0eXBlb2YgcmVmfSlgKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmxldCBoYXNMb2dnZWRNaXNtYXRjaEVycm9yID0gZmFsc2U7XHJcbmNvbnN0IGxvZ01pc21hdGNoRXJyb3IgPSAoKSA9PiB7XHJcbiAgaWYgKGhhc0xvZ2dlZE1pc21hdGNoRXJyb3IpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgY29uc29sZS5lcnJvcihcIkh5ZHJhdGlvbiBjb21wbGV0ZWQgYnV0IGNvbnRhaW5zIG1pc21hdGNoZXMuXCIpO1xyXG4gIGhhc0xvZ2dlZE1pc21hdGNoRXJyb3IgPSB0cnVlO1xyXG59O1xyXG5jb25zdCBpc1NWR0NvbnRhaW5lciA9IChjb250YWluZXIpID0+IGNvbnRhaW5lci5uYW1lc3BhY2VVUkkuaW5jbHVkZXMoXCJzdmdcIikgJiYgY29udGFpbmVyLnRhZ05hbWUgIT09IFwiZm9yZWlnbk9iamVjdFwiO1xyXG5jb25zdCBpc01hdGhNTENvbnRhaW5lciA9IChjb250YWluZXIpID0+IGNvbnRhaW5lci5uYW1lc3BhY2VVUkkuaW5jbHVkZXMoXCJNYXRoTUxcIik7XHJcbmNvbnN0IGdldENvbnRhaW5lclR5cGUgPSAoY29udGFpbmVyKSA9PiB7XHJcbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gMSkgcmV0dXJuIHZvaWQgMDtcclxuICBpZiAoaXNTVkdDb250YWluZXIoY29udGFpbmVyKSkgcmV0dXJuIFwic3ZnXCI7XHJcbiAgaWYgKGlzTWF0aE1MQ29udGFpbmVyKGNvbnRhaW5lcikpIHJldHVybiBcIm1hdGhtbFwiO1xyXG4gIHJldHVybiB2b2lkIDA7XHJcbn07XHJcbmNvbnN0IGlzQ29tbWVudCA9IChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSA4O1xyXG5mdW5jdGlvbiBjcmVhdGVIeWRyYXRpb25GdW5jdGlvbnMocmVuZGVyZXJJbnRlcm5hbHMpIHtcclxuICBjb25zdCB7XHJcbiAgICBtdDogbW91bnRDb21wb25lbnQsXHJcbiAgICBwOiBwYXRjaCxcclxuICAgIG86IHtcclxuICAgICAgcGF0Y2hQcm9wLFxyXG4gICAgICBjcmVhdGVUZXh0LFxyXG4gICAgICBuZXh0U2libGluZyxcclxuICAgICAgcGFyZW50Tm9kZSxcclxuICAgICAgcmVtb3ZlLFxyXG4gICAgICBpbnNlcnQsXHJcbiAgICAgIGNyZWF0ZUNvbW1lbnRcclxuICAgIH1cclxuICB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XHJcbiAgY29uc3QgaHlkcmF0ZSA9ICh2bm9kZSwgY29udGFpbmVyKSA9PiB7XHJcbiAgICBpZiAoIWNvbnRhaW5lci5oYXNDaGlsZE5vZGVzKCkpIHtcclxuICAgICAgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSAmJiB3YXJuJDEoXHJcbiAgICAgICAgYEF0dGVtcHRpbmcgdG8gaHlkcmF0ZSBleGlzdGluZyBtYXJrdXAgYnV0IGNvbnRhaW5lciBpcyBlbXB0eS4gUGVyZm9ybWluZyBmdWxsIG1vdW50IGluc3RlYWQuYFxyXG4gICAgICApO1xyXG4gICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyKTtcclxuICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcclxuICAgICAgY29udGFpbmVyLl92bm9kZSA9IHZub2RlO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBoeWRyYXRlTm9kZShjb250YWluZXIuZmlyc3RDaGlsZCwgdm5vZGUsIG51bGwsIG51bGwsIG51bGwpO1xyXG4gICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcclxuICAgIGNvbnRhaW5lci5fdm5vZGUgPSB2bm9kZTtcclxuICB9O1xyXG4gIGNvbnN0IGh5ZHJhdGVOb2RlID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XHJcbiAgICBvcHRpbWl6ZWQgPSBvcHRpbWl6ZWQgfHwgISF2bm9kZS5keW5hbWljQ2hpbGRyZW47XHJcbiAgICBjb25zdCBpc0ZyYWdtZW50U3RhcnQgPSBpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSBcIltcIjtcclxuICAgIGNvbnN0IG9uTWlzbWF0Y2ggPSAoKSA9PiBoYW5kbGVNaXNtYXRjaChcclxuICAgICAgbm9kZSxcclxuICAgICAgdm5vZGUsXHJcbiAgICAgIHBhcmVudENvbXBvbmVudCxcclxuICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgIHNsb3RTY29wZUlkcyxcclxuICAgICAgaXNGcmFnbWVudFN0YXJ0XHJcbiAgICApO1xyXG4gICAgY29uc3QgeyB0eXBlLCByZWYsIHNoYXBlRmxhZywgcGF0Y2hGbGFnIH0gPSB2bm9kZTtcclxuICAgIGxldCBkb21UeXBlID0gbm9kZS5ub2RlVHlwZTtcclxuICAgIHZub2RlLmVsID0gbm9kZTtcclxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICBkZWYobm9kZSwgXCJfX3Zub2RlXCIsIHZub2RlLCB0cnVlKTtcclxuICAgICAgZGVmKG5vZGUsIFwiX192dWVQYXJlbnRDb21wb25lbnRcIiwgcGFyZW50Q29tcG9uZW50LCB0cnVlKTtcclxuICAgIH1cclxuICAgIGlmIChwYXRjaEZsYWcgPT09IC0yKSB7XHJcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xyXG4gICAgICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgbGV0IG5leHROb2RlID0gbnVsbDtcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICBjYXNlIFRleHQ6XHJcbiAgICAgICAgaWYgKGRvbVR5cGUgIT09IDMpIHtcclxuICAgICAgICAgIGlmICh2bm9kZS5jaGlsZHJlbiA9PT0gXCJcIikge1xyXG4gICAgICAgICAgICBpbnNlcnQodm5vZGUuZWwgPSBjcmVhdGVUZXh0KFwiXCIpLCBwYXJlbnROb2RlKG5vZGUpLCBub2RlKTtcclxuICAgICAgICAgICAgbmV4dE5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmIChub2RlLmRhdGEgIT09IHZub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgd2FybiQxKFxyXG4gICAgICAgICAgICAgIGBIeWRyYXRpb24gdGV4dCBtaXNtYXRjaCBpbmAsXHJcbiAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLFxyXG4gICAgICAgICAgICAgIGBcclxuICAtIHJlbmRlcmVkIG9uIHNlcnZlcjogJHtKU09OLnN0cmluZ2lmeShcclxuICAgICAgICAgICAgICAgIG5vZGUuZGF0YVxyXG4gICAgICAgICAgICAgICl9XHJcbiAgLSBleHBlY3RlZCBvbiBjbGllbnQ6ICR7SlNPTi5zdHJpbmdpZnkodm5vZGUuY2hpbGRyZW4pfWBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xyXG4gICAgICAgICAgICBub2RlLmRhdGEgPSB2bm9kZS5jaGlsZHJlbjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIENvbW1lbnQ6XHJcbiAgICAgICAgaWYgKGlzVGVtcGxhdGVOb2RlKG5vZGUpKSB7XHJcbiAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgcmVwbGFjZU5vZGUoXHJcbiAgICAgICAgICAgIHZub2RlLmVsID0gbm9kZS5jb250ZW50LmZpcnN0Q2hpbGQsXHJcbiAgICAgICAgICAgIG5vZGUsXHJcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGRvbVR5cGUgIT09IDggfHwgaXNGcmFnbWVudFN0YXJ0KSB7XHJcbiAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgU3RhdGljOlxyXG4gICAgICAgIGlmIChpc0ZyYWdtZW50U3RhcnQpIHtcclxuICAgICAgICAgIG5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgIGRvbVR5cGUgPSBub2RlLm5vZGVUeXBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZG9tVHlwZSA9PT0gMSB8fCBkb21UeXBlID09PSAzKSB7XHJcbiAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGU7XHJcbiAgICAgICAgICBjb25zdCBuZWVkVG9BZG9wdENvbnRlbnQgPSAhdm5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2bm9kZS5zdGF0aWNDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChuZWVkVG9BZG9wdENvbnRlbnQpXHJcbiAgICAgICAgICAgICAgdm5vZGUuY2hpbGRyZW4gKz0gbmV4dE5vZGUubm9kZVR5cGUgPT09IDEgPyBuZXh0Tm9kZS5vdXRlckhUTUwgOiBuZXh0Tm9kZS5kYXRhO1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gdm5vZGUuc3RhdGljQ291bnQgLSAxKSB7XHJcbiAgICAgICAgICAgICAgdm5vZGUuYW5jaG9yID0gbmV4dE5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhuZXh0Tm9kZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gaXNGcmFnbWVudFN0YXJ0ID8gbmV4dFNpYmxpbmcobmV4dE5vZGUpIDogbmV4dE5vZGU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG9uTWlzbWF0Y2goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRnJhZ21lbnQ6XHJcbiAgICAgICAgaWYgKCFpc0ZyYWdtZW50U3RhcnQpIHtcclxuICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuZXh0Tm9kZSA9IGh5ZHJhdGVGcmFnbWVudChcclxuICAgICAgICAgICAgbm9kZSxcclxuICAgICAgICAgICAgdm5vZGUsXHJcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcclxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcclxuICAgICAgICAgICAgb3B0aW1pemVkXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMSkge1xyXG4gICAgICAgICAgaWYgKChkb21UeXBlICE9PSAxIHx8IHZub2RlLnR5cGUudG9Mb3dlckNhc2UoKSAhPT0gbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpICYmICFpc1RlbXBsYXRlTm9kZShub2RlKSkge1xyXG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5leHROb2RlID0gaHlkcmF0ZUVsZW1lbnQoXHJcbiAgICAgICAgICAgICAgbm9kZSxcclxuICAgICAgICAgICAgICB2bm9kZSxcclxuICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxyXG4gICAgICAgICAgICAgIG9wdGltaXplZFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgNikge1xyXG4gICAgICAgICAgdm5vZGUuc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzO1xyXG4gICAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcclxuICAgICAgICAgIGlmIChpc0ZyYWdtZW50U3RhcnQpIHtcclxuICAgICAgICAgICAgbmV4dE5vZGUgPSBsb2NhdGVDbG9zaW5nQW5jaG9yKG5vZGUpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSBcInRlbGVwb3J0IHN0YXJ0XCIpIHtcclxuICAgICAgICAgICAgbmV4dE5vZGUgPSBsb2NhdGVDbG9zaW5nQW5jaG9yKG5vZGUsIG5vZGUuZGF0YSwgXCJ0ZWxlcG9ydCBlbmRcIik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbW91bnRDb21wb25lbnQoXHJcbiAgICAgICAgICAgIHZub2RlLFxyXG4gICAgICAgICAgICBjb250YWluZXIsXHJcbiAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcclxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgICAgICAgIGdldENvbnRhaW5lclR5cGUoY29udGFpbmVyKSxcclxuICAgICAgICAgICAgb3B0aW1pemVkXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgaWYgKGlzQXN5bmNXcmFwcGVyKHZub2RlKSAmJiAhdm5vZGUudHlwZS5fX2FzeW5jUmVzb2x2ZWQpIHtcclxuICAgICAgICAgICAgbGV0IHN1YlRyZWU7XHJcbiAgICAgICAgICAgIGlmIChpc0ZyYWdtZW50U3RhcnQpIHtcclxuICAgICAgICAgICAgICBzdWJUcmVlID0gY3JlYXRlVk5vZGUoRnJhZ21lbnQpO1xyXG4gICAgICAgICAgICAgIHN1YlRyZWUuYW5jaG9yID0gbmV4dE5vZGUgPyBuZXh0Tm9kZS5wcmV2aW91c1NpYmxpbmcgOiBjb250YWluZXIubGFzdENoaWxkO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHN1YlRyZWUgPSBub2RlLm5vZGVUeXBlID09PSAzID8gY3JlYXRlVGV4dFZOb2RlKFwiXCIpIDogY3JlYXRlVk5vZGUoXCJkaXZcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3ViVHJlZS5lbCA9IG5vZGU7XHJcbiAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudC5zdWJUcmVlID0gc3ViVHJlZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XHJcbiAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gOCkge1xyXG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5leHROb2RlID0gdm5vZGUudHlwZS5oeWRyYXRlKFxyXG4gICAgICAgICAgICAgIG5vZGUsXHJcbiAgICAgICAgICAgICAgdm5vZGUsXHJcbiAgICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxyXG4gICAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcclxuICAgICAgICAgICAgICBvcHRpbWl6ZWQsXHJcbiAgICAgICAgICAgICAgcmVuZGVyZXJJbnRlcm5hbHMsXHJcbiAgICAgICAgICAgICAgaHlkcmF0ZUNoaWxkcmVuXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiAxMjgpIHtcclxuICAgICAgICAgIG5leHROb2RlID0gdm5vZGUudHlwZS5oeWRyYXRlKFxyXG4gICAgICAgICAgICBub2RlLFxyXG4gICAgICAgICAgICB2bm9kZSxcclxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcclxuICAgICAgICAgICAgZ2V0Q29udGFpbmVyVHlwZShwYXJlbnROb2RlKG5vZGUpKSxcclxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxyXG4gICAgICAgICAgICBvcHRpbWl6ZWQsXHJcbiAgICAgICAgICAgIHJlbmRlcmVySW50ZXJuYWxzLFxyXG4gICAgICAgICAgICBoeWRyYXRlTm9kZVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSB7XHJcbiAgICAgICAgICB3YXJuJDEoXCJJbnZhbGlkIEhvc3RWTm9kZSB0eXBlOlwiLCB0eXBlLCBgKCR7dHlwZW9mIHR5cGV9KWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChyZWYgIT0gbnVsbCkge1xyXG4gICAgICBzZXRSZWYocmVmLCBudWxsLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5leHROb2RlO1xyXG4gIH07XHJcbiAgY29uc3QgaHlkcmF0ZUVsZW1lbnQgPSAoZWwsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgb3B0aW1pemVkID0gb3B0aW1pemVkIHx8ICEhdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xyXG4gICAgY29uc3QgeyB0eXBlLCBwcm9wcywgcGF0Y2hGbGFnLCBzaGFwZUZsYWcsIGRpcnMsIHRyYW5zaXRpb24gfSA9IHZub2RlO1xyXG4gICAgY29uc3QgZm9yY2VQYXRjaCA9IHR5cGUgPT09IFwiaW5wdXRcIiB8fCB0eXBlID09PSBcIm9wdGlvblwiO1xyXG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgZm9yY2VQYXRjaCB8fCBwYXRjaEZsYWcgIT09IC0xKSB7XHJcbiAgICAgIGlmIChkaXJzKSB7XHJcbiAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcImNyZWF0ZWRcIik7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzID0gZmFsc2U7XHJcbiAgICAgIGlmIChpc1RlbXBsYXRlTm9kZShlbCkpIHtcclxuICAgICAgICBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyA9IG5lZWRUcmFuc2l0aW9uKFxyXG4gICAgICAgICAgbnVsbCxcclxuICAgICAgICAgIC8vIG5vIG5lZWQgY2hlY2sgcGFyZW50U3VzcGVuc2UgaW4gaHlkcmF0aW9uXHJcbiAgICAgICAgICB0cmFuc2l0aW9uXHJcbiAgICAgICAgKSAmJiBwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LnZub2RlLnByb3BzICYmIHBhcmVudENvbXBvbmVudC52bm9kZS5wcm9wcy5hcHBlYXI7XHJcbiAgICAgICAgY29uc3QgY29udGVudCA9IGVsLmNvbnRlbnQuZmlyc3RDaGlsZDtcclxuICAgICAgICBpZiAobmVlZENhbGxUcmFuc2l0aW9uSG9va3MpIHtcclxuICAgICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoY29udGVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcGxhY2VOb2RlKGNvbnRlbnQsIGVsLCBwYXJlbnRDb21wb25lbnQpO1xyXG4gICAgICAgIHZub2RlLmVsID0gZWwgPSBjb250ZW50O1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAmJiAvLyBza2lwIGlmIGVsZW1lbnQgaGFzIGlubmVySFRNTCAvIHRleHRDb250ZW50XHJcbiAgICAgICEocHJvcHMgJiYgKHByb3BzLmlubmVySFRNTCB8fCBwcm9wcy50ZXh0Q29udGVudCkpKSB7XHJcbiAgICAgICAgbGV0IG5leHQgPSBoeWRyYXRlQ2hpbGRyZW4oXHJcbiAgICAgICAgICBlbC5maXJzdENoaWxkLFxyXG4gICAgICAgICAgdm5vZGUsXHJcbiAgICAgICAgICBlbCxcclxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcclxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxyXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxyXG4gICAgICAgICAgb3B0aW1pemVkXHJcbiAgICAgICAgKTtcclxuICAgICAgICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XHJcbiAgICAgICAgd2hpbGUgKG5leHQpIHtcclxuICAgICAgICAgIGlmICghaXNNaXNtYXRjaEFsbG93ZWQoZWwsIDEgLyogQ0hJTERSRU4gKi8pKSB7XHJcbiAgICAgICAgICAgIGlmICgoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmICFoYXNXYXJuZWQpIHtcclxuICAgICAgICAgICAgICB3YXJuJDEoXHJcbiAgICAgICAgICAgICAgICBgSHlkcmF0aW9uIGNoaWxkcmVuIG1pc21hdGNoIG9uYCxcclxuICAgICAgICAgICAgICAgIGVsLFxyXG4gICAgICAgICAgICAgICAgYFxyXG5TZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBtb3JlIGNoaWxkIG5vZGVzIHRoYW4gY2xpZW50IHZkb20uYFxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgaGFzV2FybmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsb2dNaXNtYXRjaEVycm9yKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb25zdCBjdXIgPSBuZXh0O1xyXG4gICAgICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICByZW1vdmUoY3VyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgOCkge1xyXG4gICAgICAgIGxldCBjbGllbnRUZXh0ID0gdm5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgaWYgKGNsaWVudFRleHRbMF0gPT09IFwiXFxuXCIgJiYgKGVsLnRhZ05hbWUgPT09IFwiUFJFXCIgfHwgZWwudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiKSkge1xyXG4gICAgICAgICAgY2xpZW50VGV4dCA9IGNsaWVudFRleHQuc2xpY2UoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbC50ZXh0Q29udGVudCAhPT0gY2xpZW50VGV4dCkge1xyXG4gICAgICAgICAgaWYgKCFpc01pc21hdGNoQWxsb3dlZChlbCwgMCAvKiBURVhUICovKSkge1xyXG4gICAgICAgICAgICAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmIHdhcm4kMShcclxuICAgICAgICAgICAgICBgSHlkcmF0aW9uIHRleHQgY29udGVudCBtaXNtYXRjaCBvbmAsXHJcbiAgICAgICAgICAgICAgZWwsXHJcbiAgICAgICAgICAgICAgYFxyXG4gIC0gcmVuZGVyZWQgb24gc2VydmVyOiAke2VsLnRleHRDb250ZW50fVxyXG4gIC0gZXhwZWN0ZWQgb24gY2xpZW50OiAke3Zub2RlLmNoaWxkcmVufWBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWwudGV4dENvbnRlbnQgPSB2bm9kZS5jaGlsZHJlbjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHByb3BzKSB7XHJcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fIHx8IGZvcmNlUGF0Y2ggfHwgIW9wdGltaXplZCB8fCBwYXRjaEZsYWcgJiAoMTYgfCAzMikpIHtcclxuICAgICAgICAgIGNvbnN0IGlzQ3VzdG9tRWxlbWVudCA9IGVsLnRhZ05hbWUuaW5jbHVkZXMoXCItXCIpO1xyXG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgaWYgKCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgLy8gIzExMTg5IHNraXAgaWYgdGhpcyBub2RlIGhhcyBkaXJlY3RpdmVzIHRoYXQgaGF2ZSBjcmVhdGVkIGhvb2tzXHJcbiAgICAgICAgICAgIC8vIGFzIGl0IGNvdWxkIGhhdmUgbXV0YXRlZCB0aGUgRE9NIGluIGFueSBwb3NzaWJsZSB3YXlcclxuICAgICAgICAgICAgIShkaXJzICYmIGRpcnMuc29tZSgoZCkgPT4gZC5kaXIuY3JlYXRlZCkpICYmIHByb3BIYXNNaXNtYXRjaChlbCwga2V5LCBwcm9wc1trZXldLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50KSkge1xyXG4gICAgICAgICAgICAgIGxvZ01pc21hdGNoRXJyb3IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZm9yY2VQYXRjaCAmJiAoa2V5LmVuZHNXaXRoKFwidmFsdWVcIikgfHwga2V5ID09PSBcImluZGV0ZXJtaW5hdGVcIikgfHwgaXNPbihrZXkpICYmICFpc1Jlc2VydmVkUHJvcChrZXkpIHx8IC8vIGZvcmNlIGh5ZHJhdGUgdi1iaW5kIHdpdGggLnByb3AgbW9kaWZpZXJzXHJcbiAgICAgICAgICAgIGtleVswXSA9PT0gXCIuXCIgfHwgaXNDdXN0b21FbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgcGF0Y2hQcm9wKGVsLCBrZXksIG51bGwsIHByb3BzW2tleV0sIHZvaWQgMCwgcGFyZW50Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAocHJvcHMub25DbGljaykge1xyXG4gICAgICAgICAgcGF0Y2hQcm9wKFxyXG4gICAgICAgICAgICBlbCxcclxuICAgICAgICAgICAgXCJvbkNsaWNrXCIsXHJcbiAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgIHByb3BzLm9uQ2xpY2ssXHJcbiAgICAgICAgICAgIHZvaWQgMCxcclxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocGF0Y2hGbGFnICYgNCAmJiBpc1JlYWN0aXZlKHByb3BzLnN0eWxlKSkge1xyXG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMuc3R5bGUpIHByb3BzLnN0eWxlW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGxldCB2bm9kZUhvb2tzO1xyXG4gICAgICBpZiAodm5vZGVIb29rcyA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkge1xyXG4gICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2tzLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZGlycykge1xyXG4gICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJiZWZvcmVNb3VudFwiKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoKHZub2RlSG9va3MgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlTW91bnRlZCkgfHwgZGlycyB8fCBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcykge1xyXG4gICAgICAgIHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlKCgpID0+IHtcclxuICAgICAgICAgIHZub2RlSG9va3MgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9va3MsIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgJiYgdHJhbnNpdGlvbi5lbnRlcihlbCk7XHJcbiAgICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJtb3VudGVkXCIpO1xyXG4gICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVsLm5leHRTaWJsaW5nO1xyXG4gIH07XHJcbiAgY29uc3QgaHlkcmF0ZUNoaWxkcmVuID0gKG5vZGUsIHBhcmVudFZOb2RlLCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICBvcHRpbWl6ZWQgPSBvcHRpbWl6ZWQgfHwgISFwYXJlbnRWTm9kZS5keW5hbWljQ2hpbGRyZW47XHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFZOb2RlLmNoaWxkcmVuO1xyXG4gICAgY29uc3QgbCA9IGNoaWxkcmVuLmxlbmd0aDtcclxuICAgIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHZub2RlID0gb3B0aW1pemVkID8gY2hpbGRyZW5baV0gOiBjaGlsZHJlbltpXSA9IG5vcm1hbGl6ZVZOb2RlKGNoaWxkcmVuW2ldKTtcclxuICAgICAgY29uc3QgaXNUZXh0ID0gdm5vZGUudHlwZSA9PT0gVGV4dDtcclxuICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICBpZiAoaXNUZXh0ICYmICFvcHRpbWl6ZWQpIHtcclxuICAgICAgICAgIGlmIChpICsgMSA8IGwgJiYgbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baSArIDFdKS50eXBlID09PSBUZXh0KSB7XHJcbiAgICAgICAgICAgIGluc2VydChcclxuICAgICAgICAgICAgICBjcmVhdGVUZXh0KFxyXG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhLnNsaWNlKHZub2RlLmNoaWxkcmVuLmxlbmd0aClcclxuICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgIGNvbnRhaW5lcixcclxuICAgICAgICAgICAgICBuZXh0U2libGluZyhub2RlKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBub2RlLmRhdGEgPSB2bm9kZS5jaGlsZHJlbjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZSA9IGh5ZHJhdGVOb2RlKFxyXG4gICAgICAgICAgbm9kZSxcclxuICAgICAgICAgIHZub2RlLFxyXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXHJcbiAgICAgICAgICBvcHRpbWl6ZWRcclxuICAgICAgICApO1xyXG4gICAgICB9IGVsc2UgaWYgKGlzVGV4dCAmJiAhdm5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgICBpbnNlcnQodm5vZGUuZWwgPSBjcmVhdGVUZXh0KFwiXCIpLCBjb250YWluZXIpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICghaXNNaXNtYXRjaEFsbG93ZWQoY29udGFpbmVyLCAxIC8qIENISUxEUkVOICovKSkge1xyXG4gICAgICAgICAgaWYgKCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgIWhhc1dhcm5lZCkge1xyXG4gICAgICAgICAgICB3YXJuJDEoXHJcbiAgICAgICAgICAgICAgYEh5ZHJhdGlvbiBjaGlsZHJlbiBtaXNtYXRjaCBvbmAsXHJcbiAgICAgICAgICAgICAgY29udGFpbmVyLFxyXG4gICAgICAgICAgICAgIGBcclxuU2VydmVyIHJlbmRlcmVkIGVsZW1lbnQgY29udGFpbnMgZmV3ZXIgY2hpbGQgbm9kZXMgdGhhbiBjbGllbnQgdmRvbS5gXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBsb2dNaXNtYXRjaEVycm9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhdGNoKFxyXG4gICAgICAgICAgbnVsbCxcclxuICAgICAgICAgIHZub2RlLFxyXG4gICAgICAgICAgY29udGFpbmVyLFxyXG4gICAgICAgICAgbnVsbCxcclxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcclxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxyXG4gICAgICAgICAgZ2V0Q29udGFpbmVyVHlwZShjb250YWluZXIpLFxyXG4gICAgICAgICAgc2xvdFNjb3BlSWRzXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vZGU7XHJcbiAgfTtcclxuICBjb25zdCBoeWRyYXRlRnJhZ21lbnQgPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICBjb25zdCB7IHNsb3RTY29wZUlkczogZnJhZ21lbnRTbG90U2NvcGVJZHMgfSA9IHZub2RlO1xyXG4gICAgaWYgKGZyYWdtZW50U2xvdFNjb3BlSWRzKSB7XHJcbiAgICAgIHNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcyA/IHNsb3RTY29wZUlkcy5jb25jYXQoZnJhZ21lbnRTbG90U2NvcGVJZHMpIDogZnJhZ21lbnRTbG90U2NvcGVJZHM7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xyXG4gICAgY29uc3QgbmV4dCA9IGh5ZHJhdGVDaGlsZHJlbihcclxuICAgICAgbmV4dFNpYmxpbmcobm9kZSksXHJcbiAgICAgIHZub2RlLFxyXG4gICAgICBjb250YWluZXIsXHJcbiAgICAgIHBhcmVudENvbXBvbmVudCxcclxuICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgIHNsb3RTY29wZUlkcyxcclxuICAgICAgb3B0aW1pemVkXHJcbiAgICApO1xyXG4gICAgaWYgKG5leHQgJiYgaXNDb21tZW50KG5leHQpICYmIG5leHQuZGF0YSA9PT0gXCJdXCIpIHtcclxuICAgICAgcmV0dXJuIG5leHRTaWJsaW5nKHZub2RlLmFuY2hvciA9IG5leHQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xyXG4gICAgICBpbnNlcnQodm5vZGUuYW5jaG9yID0gY3JlYXRlQ29tbWVudChgXWApLCBjb250YWluZXIsIG5leHQpO1xyXG4gICAgICByZXR1cm4gbmV4dDtcclxuICAgIH1cclxuICB9O1xyXG4gIGNvbnN0IGhhbmRsZU1pc21hdGNoID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIGlzRnJhZ21lbnQpID0+IHtcclxuICAgIGlmICghaXNNaXNtYXRjaEFsbG93ZWQobm9kZS5wYXJlbnRFbGVtZW50LCAxIC8qIENISUxEUkVOICovKSkge1xyXG4gICAgICAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmIHdhcm4kMShcclxuICAgICAgICBgSHlkcmF0aW9uIG5vZGUgbWlzbWF0Y2g6XHJcbi0gcmVuZGVyZWQgb24gc2VydmVyOmAsXHJcbiAgICAgICAgbm9kZSxcclxuICAgICAgICBub2RlLm5vZGVUeXBlID09PSAzID8gYCh0ZXh0KWAgOiBpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSBcIltcIiA/IGAoc3RhcnQgb2YgZnJhZ21lbnQpYCA6IGBgLFxyXG4gICAgICAgIGBcclxuLSBleHBlY3RlZCBvbiBjbGllbnQ6YCxcclxuICAgICAgICB2bm9kZS50eXBlXHJcbiAgICAgICk7XHJcbiAgICAgIGxvZ01pc21hdGNoRXJyb3IoKTtcclxuICAgIH1cclxuICAgIHZub2RlLmVsID0gbnVsbDtcclxuICAgIGlmIChpc0ZyYWdtZW50KSB7XHJcbiAgICAgIGNvbnN0IGVuZCA9IGxvY2F0ZUNsb3NpbmdBbmNob3Iobm9kZSk7XHJcbiAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgY29uc3QgbmV4dDIgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICBpZiAobmV4dDIgJiYgbmV4dDIgIT09IGVuZCkge1xyXG4gICAgICAgICAgcmVtb3ZlKG5leHQyKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBuZXh0ID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xyXG4gICAgcmVtb3ZlKG5vZGUpO1xyXG4gICAgcGF0Y2goXHJcbiAgICAgIG51bGwsXHJcbiAgICAgIHZub2RlLFxyXG4gICAgICBjb250YWluZXIsXHJcbiAgICAgIG5leHQsXHJcbiAgICAgIHBhcmVudENvbXBvbmVudCxcclxuICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgIGdldENvbnRhaW5lclR5cGUoY29udGFpbmVyKSxcclxuICAgICAgc2xvdFNjb3BlSWRzXHJcbiAgICApO1xyXG4gICAgaWYgKHBhcmVudENvbXBvbmVudCkge1xyXG4gICAgICBwYXJlbnRDb21wb25lbnQudm5vZGUuZWwgPSB2bm9kZS5lbDtcclxuICAgICAgdXBkYXRlSE9DSG9zdEVsKHBhcmVudENvbXBvbmVudCwgdm5vZGUuZWwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5leHQ7XHJcbiAgfTtcclxuICBjb25zdCBsb2NhdGVDbG9zaW5nQW5jaG9yID0gKG5vZGUsIG9wZW4gPSBcIltcIiwgY2xvc2UgPSBcIl1cIikgPT4ge1xyXG4gICAgbGV0IG1hdGNoID0gMDtcclxuICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgIG5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgaWYgKG5vZGUgJiYgaXNDb21tZW50KG5vZGUpKSB7XHJcbiAgICAgICAgaWYgKG5vZGUuZGF0YSA9PT0gb3BlbikgbWF0Y2grKztcclxuICAgICAgICBpZiAobm9kZS5kYXRhID09PSBjbG9zZSkge1xyXG4gICAgICAgICAgaWYgKG1hdGNoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1hdGNoLS07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9kZTtcclxuICB9O1xyXG4gIGNvbnN0IHJlcGxhY2VOb2RlID0gKG5ld05vZGUsIG9sZE5vZGUsIHBhcmVudENvbXBvbmVudCkgPT4ge1xyXG4gICAgY29uc3QgcGFyZW50Tm9kZTIgPSBvbGROb2RlLnBhcmVudE5vZGU7XHJcbiAgICBpZiAocGFyZW50Tm9kZTIpIHtcclxuICAgICAgcGFyZW50Tm9kZTIucmVwbGFjZUNoaWxkKG5ld05vZGUsIG9sZE5vZGUpO1xyXG4gICAgfVxyXG4gICAgbGV0IHBhcmVudCA9IHBhcmVudENvbXBvbmVudDtcclxuICAgIHdoaWxlIChwYXJlbnQpIHtcclxuICAgICAgaWYgKHBhcmVudC52bm9kZS5lbCA9PT0gb2xkTm9kZSkge1xyXG4gICAgICAgIHBhcmVudC52bm9kZS5lbCA9IHBhcmVudC5zdWJUcmVlLmVsID0gbmV3Tm9kZTtcclxuICAgICAgfVxyXG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgfVxyXG4gIH07XHJcbiAgY29uc3QgaXNUZW1wbGF0ZU5vZGUgPSAobm9kZSkgPT4ge1xyXG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgbm9kZS50YWdOYW1lID09PSBcIlRFTVBMQVRFXCI7XHJcbiAgfTtcclxuICByZXR1cm4gW2h5ZHJhdGUsIGh5ZHJhdGVOb2RlXTtcclxufVxyXG5mdW5jdGlvbiBwcm9wSGFzTWlzbWF0Y2goZWwsIGtleSwgY2xpZW50VmFsdWUsIHZub2RlLCBpbnN0YW5jZSkge1xyXG4gIGxldCBtaXNtYXRjaFR5cGU7XHJcbiAgbGV0IG1pc21hdGNoS2V5O1xyXG4gIGxldCBhY3R1YWw7XHJcbiAgbGV0IGV4cGVjdGVkO1xyXG4gIGlmIChrZXkgPT09IFwiY2xhc3NcIikge1xyXG4gICAgYWN0dWFsID0gZWwuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIik7XHJcbiAgICBleHBlY3RlZCA9IG5vcm1hbGl6ZUNsYXNzKGNsaWVudFZhbHVlKTtcclxuICAgIGlmICghaXNTZXRFcXVhbCh0b0NsYXNzU2V0KGFjdHVhbCB8fCBcIlwiKSwgdG9DbGFzc1NldChleHBlY3RlZCkpKSB7XHJcbiAgICAgIG1pc21hdGNoVHlwZSA9IDIgLyogQ0xBU1MgKi87XHJcbiAgICAgIG1pc21hdGNoS2V5ID0gYGNsYXNzYDtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzdHlsZVwiKSB7XHJcbiAgICBhY3R1YWwgPSBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSB8fCBcIlwiO1xyXG4gICAgZXhwZWN0ZWQgPSBpc1N0cmluZyhjbGllbnRWYWx1ZSkgPyBjbGllbnRWYWx1ZSA6IHN0cmluZ2lmeVN0eWxlKG5vcm1hbGl6ZVN0eWxlKGNsaWVudFZhbHVlKSk7XHJcbiAgICBjb25zdCBhY3R1YWxNYXAgPSB0b1N0eWxlTWFwKGFjdHVhbCk7XHJcbiAgICBjb25zdCBleHBlY3RlZE1hcCA9IHRvU3R5bGVNYXAoZXhwZWN0ZWQpO1xyXG4gICAgaWYgKHZub2RlLmRpcnMpIHtcclxuICAgICAgZm9yIChjb25zdCB7IGRpciwgdmFsdWUgfSBvZiB2bm9kZS5kaXJzKSB7XHJcbiAgICAgICAgaWYgKGRpci5uYW1lID09PSBcInNob3dcIiAmJiAhdmFsdWUpIHtcclxuICAgICAgICAgIGV4cGVjdGVkTWFwLnNldChcImRpc3BsYXlcIiwgXCJub25lXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgIHJlc29sdmVDc3NWYXJzKGluc3RhbmNlLCB2bm9kZSwgZXhwZWN0ZWRNYXApO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc01hcEVxdWFsKGFjdHVhbE1hcCwgZXhwZWN0ZWRNYXApKSB7XHJcbiAgICAgIG1pc21hdGNoVHlwZSA9IDMgLyogU1RZTEUgKi87XHJcbiAgICAgIG1pc21hdGNoS2V5ID0gXCJzdHlsZVwiO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoZWwgaW5zdGFuY2VvZiBTVkdFbGVtZW50ICYmIGlzS25vd25TdmdBdHRyKGtleSkgfHwgZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiAoaXNCb29sZWFuQXR0cihrZXkpIHx8IGlzS25vd25IdG1sQXR0cihrZXkpKSkge1xyXG4gICAgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xyXG4gICAgICBhY3R1YWwgPSBlbC5oYXNBdHRyaWJ1dGUoa2V5KTtcclxuICAgICAgZXhwZWN0ZWQgPSBpbmNsdWRlQm9vbGVhbkF0dHIoY2xpZW50VmFsdWUpO1xyXG4gICAgfSBlbHNlIGlmIChjbGllbnRWYWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgIGFjdHVhbCA9IGVsLmhhc0F0dHJpYnV0ZShrZXkpO1xyXG4gICAgICBleHBlY3RlZCA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZShrZXkpKSB7XHJcbiAgICAgICAgYWN0dWFsID0gZWwuZ2V0QXR0cmlidXRlKGtleSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInZhbHVlXCIgJiYgZWwudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiKSB7XHJcbiAgICAgICAgYWN0dWFsID0gZWwudmFsdWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWN0dWFsID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgZXhwZWN0ZWQgPSBpc1JlbmRlcmFibGVBdHRyVmFsdWUoY2xpZW50VmFsdWUpID8gU3RyaW5nKGNsaWVudFZhbHVlKSA6IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcclxuICAgICAgbWlzbWF0Y2hUeXBlID0gNCAvKiBBVFRSSUJVVEUgKi87XHJcbiAgICAgIG1pc21hdGNoS2V5ID0ga2V5O1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAobWlzbWF0Y2hUeXBlICE9IG51bGwgJiYgIWlzTWlzbWF0Y2hBbGxvd2VkKGVsLCBtaXNtYXRjaFR5cGUpKSB7XHJcbiAgICBjb25zdCBmb3JtYXQgPSAodikgPT4gdiA9PT0gZmFsc2UgPyBgKG5vdCByZW5kZXJlZClgIDogYCR7bWlzbWF0Y2hLZXl9PVwiJHt2fVwiYDtcclxuICAgIGNvbnN0IHByZVNlZ21lbnQgPSBgSHlkcmF0aW9uICR7TWlzbWF0Y2hUeXBlU3RyaW5nW21pc21hdGNoVHlwZV19IG1pc21hdGNoIG9uYDtcclxuICAgIGNvbnN0IHBvc3RTZWdtZW50ID0gYFxyXG4gIC0gcmVuZGVyZWQgb24gc2VydmVyOiAke2Zvcm1hdChhY3R1YWwpfVxyXG4gIC0gZXhwZWN0ZWQgb24gY2xpZW50OiAke2Zvcm1hdChleHBlY3RlZCl9XHJcbiAgTm90ZTogdGhpcyBtaXNtYXRjaCBpcyBjaGVjay1vbmx5LiBUaGUgRE9NIHdpbGwgbm90IGJlIHJlY3RpZmllZCBpbiBwcm9kdWN0aW9uIGR1ZSB0byBwZXJmb3JtYW5jZSBvdmVyaGVhZC5cclxuICBZb3Ugc2hvdWxkIGZpeCB0aGUgc291cmNlIG9mIHRoZSBtaXNtYXRjaC5gO1xyXG4gICAge1xyXG4gICAgICB3YXJuJDEocHJlU2VnbWVudCwgZWwsIHBvc3RTZWdtZW50KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gdG9DbGFzc1NldChzdHIpIHtcclxuICByZXR1cm4gbmV3IFNldChzdHIudHJpbSgpLnNwbGl0KC9cXHMrLykpO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2V0RXF1YWwoYSwgYikge1xyXG4gIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBmb3IgKGNvbnN0IHMgb2YgYSkge1xyXG4gICAgaWYgKCFiLmhhcyhzKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIHRvU3R5bGVNYXAoc3RyKSB7XHJcbiAgY29uc3Qgc3R5bGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xyXG4gIGZvciAoY29uc3QgaXRlbSBvZiBzdHIuc3BsaXQoXCI7XCIpKSB7XHJcbiAgICBsZXQgW2tleSwgdmFsdWVdID0gaXRlbS5zcGxpdChcIjpcIik7XHJcbiAgICBrZXkgPSBrZXkudHJpbSgpO1xyXG4gICAgdmFsdWUgPSB2YWx1ZSAmJiB2YWx1ZS50cmltKCk7XHJcbiAgICBpZiAoa2V5ICYmIHZhbHVlKSB7XHJcbiAgICAgIHN0eWxlTWFwLnNldChrZXksIHZhbHVlKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHN0eWxlTWFwO1xyXG59XHJcbmZ1bmN0aW9uIGlzTWFwRXF1YWwoYSwgYikge1xyXG4gIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBhKSB7XHJcbiAgICBpZiAodmFsdWUgIT09IGIuZ2V0KGtleSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiByZXNvbHZlQ3NzVmFycyhpbnN0YW5jZSwgdm5vZGUsIGV4cGVjdGVkTWFwKSB7XHJcbiAgY29uc3Qgcm9vdCA9IGluc3RhbmNlLnN1YlRyZWU7XHJcbiAgaWYgKGluc3RhbmNlLmdldENzc1ZhcnMgJiYgKHZub2RlID09PSByb290IHx8IHJvb3QgJiYgcm9vdC50eXBlID09PSBGcmFnbWVudCAmJiByb290LmNoaWxkcmVuLmluY2x1ZGVzKHZub2RlKSkpIHtcclxuICAgIGNvbnN0IGNzc1ZhcnMgPSBpbnN0YW5jZS5nZXRDc3NWYXJzKCk7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjc3NWYXJzKSB7XHJcbiAgICAgIGV4cGVjdGVkTWFwLnNldChcclxuICAgICAgICBgLS0ke2dldEVzY2FwZWRDc3NWYXJOYW1lKGtleSwgZmFsc2UpfWAsXHJcbiAgICAgICAgU3RyaW5nKGNzc1ZhcnNba2V5XSlcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKHZub2RlID09PSByb290ICYmIGluc3RhbmNlLnBhcmVudCkge1xyXG4gICAgcmVzb2x2ZUNzc1ZhcnMoaW5zdGFuY2UucGFyZW50LCBpbnN0YW5jZS52bm9kZSwgZXhwZWN0ZWRNYXApO1xyXG4gIH1cclxufVxyXG5jb25zdCBhbGxvd01pc21hdGNoQXR0ciA9IFwiZGF0YS1hbGxvdy1taXNtYXRjaFwiO1xyXG5jb25zdCBNaXNtYXRjaFR5cGVTdHJpbmcgPSB7XHJcbiAgWzAgLyogVEVYVCAqL106IFwidGV4dFwiLFxyXG4gIFsxIC8qIENISUxEUkVOICovXTogXCJjaGlsZHJlblwiLFxyXG4gIFsyIC8qIENMQVNTICovXTogXCJjbGFzc1wiLFxyXG4gIFszIC8qIFNUWUxFICovXTogXCJzdHlsZVwiLFxyXG4gIFs0IC8qIEFUVFJJQlVURSAqL106IFwiYXR0cmlidXRlXCJcclxufTtcclxuZnVuY3Rpb24gaXNNaXNtYXRjaEFsbG93ZWQoZWwsIGFsbG93ZWRUeXBlKSB7XHJcbiAgaWYgKGFsbG93ZWRUeXBlID09PSAwIC8qIFRFWFQgKi8gfHwgYWxsb3dlZFR5cGUgPT09IDEgLyogQ0hJTERSRU4gKi8pIHtcclxuICAgIHdoaWxlIChlbCAmJiAhZWwuaGFzQXR0cmlidXRlKGFsbG93TWlzbWF0Y2hBdHRyKSkge1xyXG4gICAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNvbnN0IGFsbG93ZWRBdHRyID0gZWwgJiYgZWwuZ2V0QXR0cmlidXRlKGFsbG93TWlzbWF0Y2hBdHRyKTtcclxuICBpZiAoYWxsb3dlZEF0dHIgPT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0gZWxzZSBpZiAoYWxsb3dlZEF0dHIgPT09IFwiXCIpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdCBsaXN0ID0gYWxsb3dlZEF0dHIuc3BsaXQoXCIsXCIpO1xyXG4gICAgaWYgKGFsbG93ZWRUeXBlID09PSAwIC8qIFRFWFQgKi8gJiYgbGlzdC5pbmNsdWRlcyhcImNoaWxkcmVuXCIpKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFsbG93ZWRBdHRyLnNwbGl0KFwiLFwiKS5pbmNsdWRlcyhNaXNtYXRjaFR5cGVTdHJpbmdbYWxsb3dlZFR5cGVdKTtcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IHJlcXVlc3RJZGxlQ2FsbGJhY2sgPSBnZXRHbG9iYWxUaGlzKCkucmVxdWVzdElkbGVDYWxsYmFjayB8fCAoKGNiKSA9PiBzZXRUaW1lb3V0KGNiLCAxKSk7XHJcbmNvbnN0IGNhbmNlbElkbGVDYWxsYmFjayA9IGdldEdsb2JhbFRoaXMoKS5jYW5jZWxJZGxlQ2FsbGJhY2sgfHwgKChpZCkgPT4gY2xlYXJUaW1lb3V0KGlkKSk7XHJcbmNvbnN0IGh5ZHJhdGVPbklkbGUgPSAodGltZW91dCA9IDFlNCkgPT4gKGh5ZHJhdGUpID0+IHtcclxuICBjb25zdCBpZCA9IHJlcXVlc3RJZGxlQ2FsbGJhY2soaHlkcmF0ZSwgeyB0aW1lb3V0IH0pO1xyXG4gIHJldHVybiAoKSA9PiBjYW5jZWxJZGxlQ2FsbGJhY2soaWQpO1xyXG59O1xyXG5mdW5jdGlvbiBlbGVtZW50SXNWaXNpYmxlSW5WaWV3cG9ydChlbCkge1xyXG4gIGNvbnN0IHsgdG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0IH0gPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICBjb25zdCB7IGlubmVySGVpZ2h0LCBpbm5lcldpZHRoIH0gPSB3aW5kb3c7XHJcbiAgcmV0dXJuICh0b3AgPiAwICYmIHRvcCA8IGlubmVySGVpZ2h0IHx8IGJvdHRvbSA+IDAgJiYgYm90dG9tIDwgaW5uZXJIZWlnaHQpICYmIChsZWZ0ID4gMCAmJiBsZWZ0IDwgaW5uZXJXaWR0aCB8fCByaWdodCA+IDAgJiYgcmlnaHQgPCBpbm5lcldpZHRoKTtcclxufVxyXG5jb25zdCBoeWRyYXRlT25WaXNpYmxlID0gKG9wdHMpID0+IChoeWRyYXRlLCBmb3JFYWNoKSA9PiB7XHJcbiAgY29uc3Qgb2IgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcclxuICAgIGZvciAoY29uc3QgZSBvZiBlbnRyaWVzKSB7XHJcbiAgICAgIGlmICghZS5pc0ludGVyc2VjdGluZykgY29udGludWU7XHJcbiAgICAgIG9iLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgaHlkcmF0ZSgpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9LCBvcHRzKTtcclxuICBmb3JFYWNoKChlbCkgPT4ge1xyXG4gICAgaWYgKCEoZWwgaW5zdGFuY2VvZiBFbGVtZW50KSkgcmV0dXJuO1xyXG4gICAgaWYgKGVsZW1lbnRJc1Zpc2libGVJblZpZXdwb3J0KGVsKSkge1xyXG4gICAgICBoeWRyYXRlKCk7XHJcbiAgICAgIG9iLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgb2Iub2JzZXJ2ZShlbCk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuICgpID0+IG9iLmRpc2Nvbm5lY3QoKTtcclxufTtcclxuY29uc3QgaHlkcmF0ZU9uTWVkaWFRdWVyeSA9IChxdWVyeSkgPT4gKGh5ZHJhdGUpID0+IHtcclxuICBpZiAocXVlcnkpIHtcclxuICAgIGNvbnN0IG1xbCA9IG1hdGNoTWVkaWEocXVlcnkpO1xyXG4gICAgaWYgKG1xbC5tYXRjaGVzKSB7XHJcbiAgICAgIGh5ZHJhdGUoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG1xbC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGh5ZHJhdGUsIHsgb25jZTogdHJ1ZSB9KTtcclxuICAgICAgcmV0dXJuICgpID0+IG1xbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGh5ZHJhdGUpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuY29uc3QgaHlkcmF0ZU9uSW50ZXJhY3Rpb24gPSAoaW50ZXJhY3Rpb25zID0gW10pID0+IChoeWRyYXRlLCBmb3JFYWNoKSA9PiB7XHJcbiAgaWYgKGlzU3RyaW5nKGludGVyYWN0aW9ucykpIGludGVyYWN0aW9ucyA9IFtpbnRlcmFjdGlvbnNdO1xyXG4gIGxldCBoYXNIeWRyYXRlZCA9IGZhbHNlO1xyXG4gIGNvbnN0IGRvSHlkcmF0ZSA9IChlKSA9PiB7XHJcbiAgICBpZiAoIWhhc0h5ZHJhdGVkKSB7XHJcbiAgICAgIGhhc0h5ZHJhdGVkID0gdHJ1ZTtcclxuICAgICAgdGVhcmRvd24oKTtcclxuICAgICAgaHlkcmF0ZSgpO1xyXG4gICAgICBlLnRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBlLmNvbnN0cnVjdG9yKGUudHlwZSwgZSkpO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgY29uc3QgdGVhcmRvd24gPSAoKSA9PiB7XHJcbiAgICBmb3JFYWNoKChlbCkgPT4ge1xyXG4gICAgICBmb3IgKGNvbnN0IGkgb2YgaW50ZXJhY3Rpb25zKSB7XHJcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihpLCBkb0h5ZHJhdGUpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9O1xyXG4gIGZvckVhY2goKGVsKSA9PiB7XHJcbiAgICBmb3IgKGNvbnN0IGkgb2YgaW50ZXJhY3Rpb25zKSB7XHJcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoaSwgZG9IeWRyYXRlLCB7IG9uY2U6IHRydWUgfSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHRlYXJkb3duO1xyXG59O1xyXG5mdW5jdGlvbiBmb3JFYWNoRWxlbWVudChub2RlLCBjYikge1xyXG4gIGlmIChpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSBcIltcIikge1xyXG4gICAgbGV0IGRlcHRoID0gMTtcclxuICAgIGxldCBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcclxuICAgIHdoaWxlIChuZXh0KSB7XHJcbiAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09PSAxKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY2IobmV4dCk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChpc0NvbW1lbnQobmV4dCkpIHtcclxuICAgICAgICBpZiAobmV4dC5kYXRhID09PSBcIl1cIikge1xyXG4gICAgICAgICAgaWYgKC0tZGVwdGggPT09IDApIGJyZWFrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobmV4dC5kYXRhID09PSBcIltcIikge1xyXG4gICAgICAgICAgZGVwdGgrKztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGNiKG5vZGUpO1xyXG4gIH1cclxufVxyXG5cclxuY29uc3QgaXNBc3luY1dyYXBwZXIgPSAoaSkgPT4gISFpLnR5cGUuX19hc3luY0xvYWRlcjtcclxuLyohICNfX05PX1NJREVfRUZGRUNUU19fICovXHJcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXHJcbmZ1bmN0aW9uIGRlZmluZUFzeW5jQ29tcG9uZW50KHNvdXJjZSkge1xyXG4gIGlmIChpc0Z1bmN0aW9uKHNvdXJjZSkpIHtcclxuICAgIHNvdXJjZSA9IHsgbG9hZGVyOiBzb3VyY2UgfTtcclxuICB9XHJcbiAgY29uc3Qge1xyXG4gICAgbG9hZGVyLFxyXG4gICAgbG9hZGluZ0NvbXBvbmVudCxcclxuICAgIGVycm9yQ29tcG9uZW50LFxyXG4gICAgZGVsYXkgPSAyMDAsXHJcbiAgICBoeWRyYXRlOiBoeWRyYXRlU3RyYXRlZ3ksXHJcbiAgICB0aW1lb3V0LFxyXG4gICAgLy8gdW5kZWZpbmVkID0gbmV2ZXIgdGltZXMgb3V0XHJcbiAgICBzdXNwZW5zaWJsZSA9IHRydWUsXHJcbiAgICBvbkVycm9yOiB1c2VyT25FcnJvclxyXG4gIH0gPSBzb3VyY2U7XHJcbiAgbGV0IHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcclxuICBsZXQgcmVzb2x2ZWRDb21wO1xyXG4gIGxldCByZXRyaWVzID0gMDtcclxuICBjb25zdCByZXRyeSA9ICgpID0+IHtcclxuICAgIHJldHJpZXMrKztcclxuICAgIHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcclxuICAgIHJldHVybiBsb2FkKCk7XHJcbiAgfTtcclxuICBjb25zdCBsb2FkID0gKCkgPT4ge1xyXG4gICAgbGV0IHRoaXNSZXF1ZXN0O1xyXG4gICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0IHx8ICh0aGlzUmVxdWVzdCA9IHBlbmRpbmdSZXF1ZXN0ID0gbG9hZGVyKCkuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICBlcnIgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyKSk7XHJcbiAgICAgIGlmICh1c2VyT25FcnJvcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICBjb25zdCB1c2VyUmV0cnkgPSAoKSA9PiByZXNvbHZlKHJldHJ5KCkpO1xyXG4gICAgICAgICAgY29uc3QgdXNlckZhaWwgPSAoKSA9PiByZWplY3QoZXJyKTtcclxuICAgICAgICAgIHVzZXJPbkVycm9yKGVyciwgdXNlclJldHJ5LCB1c2VyRmFpbCwgcmV0cmllcyArIDEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IGVycjtcclxuICAgICAgfVxyXG4gICAgfSkudGhlbigoY29tcCkgPT4ge1xyXG4gICAgICBpZiAodGhpc1JlcXVlc3QgIT09IHBlbmRpbmdSZXF1ZXN0ICYmIHBlbmRpbmdSZXF1ZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0O1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFjb21wKSB7XHJcbiAgICAgICAgd2FybiQxKFxyXG4gICAgICAgICAgYEFzeW5jIGNvbXBvbmVudCBsb2FkZXIgcmVzb2x2ZWQgdG8gdW5kZWZpbmVkLiBJZiB5b3UgYXJlIHVzaW5nIHJldHJ5KCksIG1ha2Ugc3VyZSB0byByZXR1cm4gaXRzIHJldHVybiB2YWx1ZS5gXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY29tcCAmJiAoY29tcC5fX2VzTW9kdWxlIHx8IGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gXCJNb2R1bGVcIikpIHtcclxuICAgICAgICBjb21wID0gY29tcC5kZWZhdWx0O1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNvbXAgJiYgIWlzT2JqZWN0KGNvbXApICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFzeW5jIGNvbXBvbmVudCBsb2FkIHJlc3VsdDogJHtjb21wfWApO1xyXG4gICAgICB9XHJcbiAgICAgIHJlc29sdmVkQ29tcCA9IGNvbXA7XHJcbiAgICAgIHJldHVybiBjb21wO1xyXG4gICAgfSkpO1xyXG4gIH07XHJcbiAgcmV0dXJuIGRlZmluZUNvbXBvbmVudCh7XHJcbiAgICBuYW1lOiBcIkFzeW5jQ29tcG9uZW50V3JhcHBlclwiLFxyXG4gICAgX19hc3luY0xvYWRlcjogbG9hZCxcclxuICAgIF9fYXN5bmNIeWRyYXRlKGVsLCBpbnN0YW5jZSwgaHlkcmF0ZSkge1xyXG4gICAgICBjb25zdCBkb0h5ZHJhdGUgPSBoeWRyYXRlU3RyYXRlZ3kgPyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdGVhcmRvd24gPSBoeWRyYXRlU3RyYXRlZ3koXHJcbiAgICAgICAgICBoeWRyYXRlLFxyXG4gICAgICAgICAgKGNiKSA9PiBmb3JFYWNoRWxlbWVudChlbCwgY2IpXHJcbiAgICAgICAgKTtcclxuICAgICAgICBpZiAodGVhcmRvd24pIHtcclxuICAgICAgICAgIChpbnN0YW5jZS5idW0gfHwgKGluc3RhbmNlLmJ1bSA9IFtdKSkucHVzaCh0ZWFyZG93bik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IDogaHlkcmF0ZTtcclxuICAgICAgaWYgKHJlc29sdmVkQ29tcCkge1xyXG4gICAgICAgIGRvSHlkcmF0ZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxvYWQoKS50aGVuKCgpID0+ICFpbnN0YW5jZS5pc1VubW91bnRlZCAmJiBkb0h5ZHJhdGUoKSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBnZXQgX19hc3luY1Jlc29sdmVkKCkge1xyXG4gICAgICByZXR1cm4gcmVzb2x2ZWRDb21wO1xyXG4gICAgfSxcclxuICAgIHNldHVwKCkge1xyXG4gICAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcclxuICAgICAgbWFya0FzeW5jQm91bmRhcnkoaW5zdGFuY2UpO1xyXG4gICAgICBpZiAocmVzb2x2ZWRDb21wKSB7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IGNyZWF0ZUlubmVyQ29tcChyZXNvbHZlZENvbXAsIGluc3RhbmNlKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBvbkVycm9yID0gKGVycikgPT4ge1xyXG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcclxuICAgICAgICBoYW5kbGVFcnJvcihcclxuICAgICAgICAgIGVycixcclxuICAgICAgICAgIGluc3RhbmNlLFxyXG4gICAgICAgICAgMTMsXHJcbiAgICAgICAgICAhZXJyb3JDb21wb25lbnRcclxuICAgICAgICApO1xyXG4gICAgICB9O1xyXG4gICAgICBpZiAoc3VzcGVuc2libGUgJiYgaW5zdGFuY2Uuc3VzcGVuc2UgfHwgaXNJblNTUkNvbXBvbmVudFNldHVwKSB7XHJcbiAgICAgICAgcmV0dXJuIGxvYWQoKS50aGVuKChjb21wKSA9PiB7XHJcbiAgICAgICAgICByZXR1cm4gKCkgPT4gY3JlYXRlSW5uZXJDb21wKGNvbXAsIGluc3RhbmNlKTtcclxuICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgICAgICBvbkVycm9yKGVycik7XHJcbiAgICAgICAgICByZXR1cm4gKCkgPT4gZXJyb3JDb21wb25lbnQgPyBjcmVhdGVWTm9kZShlcnJvckNvbXBvbmVudCwge1xyXG4gICAgICAgICAgICBlcnJvcjogZXJyXHJcbiAgICAgICAgICB9KSA6IG51bGw7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgbG9hZGVkID0gcmVmKGZhbHNlKTtcclxuICAgICAgY29uc3QgZXJyb3IgPSByZWYoKTtcclxuICAgICAgY29uc3QgZGVsYXllZCA9IHJlZighIWRlbGF5KTtcclxuICAgICAgaWYgKGRlbGF5KSB7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICBkZWxheWVkLnZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgfSwgZGVsYXkpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIGlmICghbG9hZGVkLnZhbHVlICYmICFlcnJvci52YWx1ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICAgYEFzeW5jIGNvbXBvbmVudCB0aW1lZCBvdXQgYWZ0ZXIgJHt0aW1lb3V0fW1zLmBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgb25FcnJvcihlcnIpO1xyXG4gICAgICAgICAgICBlcnJvci52YWx1ZSA9IGVycjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LCB0aW1lb3V0KTtcclxuICAgICAgfVxyXG4gICAgICBsb2FkKCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgbG9hZGVkLnZhbHVlID0gdHJ1ZTtcclxuICAgICAgICBpZiAoaW5zdGFuY2UucGFyZW50ICYmIGlzS2VlcEFsaXZlKGluc3RhbmNlLnBhcmVudC52bm9kZSkpIHtcclxuICAgICAgICAgIGluc3RhbmNlLnBhcmVudC51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAgICBvbkVycm9yKGVycik7XHJcbiAgICAgICAgZXJyb3IudmFsdWUgPSBlcnI7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIGlmIChsb2FkZWQudmFsdWUgJiYgcmVzb2x2ZWRDb21wKSB7XHJcbiAgICAgICAgICByZXR1cm4gY3JlYXRlSW5uZXJDb21wKHJlc29sdmVkQ29tcCwgaW5zdGFuY2UpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3IudmFsdWUgJiYgZXJyb3JDb21wb25lbnQpIHtcclxuICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShlcnJvckNvbXBvbmVudCwge1xyXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IudmFsdWVcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobG9hZGluZ0NvbXBvbmVudCAmJiAhZGVsYXllZC52YWx1ZSkge1xyXG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKGxvYWRpbmdDb21wb25lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJbm5lckNvbXAoY29tcCwgcGFyZW50KSB7XHJcbiAgY29uc3QgeyByZWY6IHJlZjIsIHByb3BzLCBjaGlsZHJlbiwgY2UgfSA9IHBhcmVudC52bm9kZTtcclxuICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKGNvbXAsIHByb3BzLCBjaGlsZHJlbik7XHJcbiAgdm5vZGUucmVmID0gcmVmMjtcclxuICB2bm9kZS5jZSA9IGNlO1xyXG4gIGRlbGV0ZSBwYXJlbnQudm5vZGUuY2U7XHJcbiAgcmV0dXJuIHZub2RlO1xyXG59XHJcblxyXG5jb25zdCBpc0tlZXBBbGl2ZSA9ICh2bm9kZSkgPT4gdm5vZGUudHlwZS5fX2lzS2VlcEFsaXZlO1xyXG5jb25zdCBLZWVwQWxpdmVJbXBsID0ge1xyXG4gIG5hbWU6IGBLZWVwQWxpdmVgLFxyXG4gIC8vIE1hcmtlciBmb3Igc3BlY2lhbCBoYW5kbGluZyBpbnNpZGUgdGhlIHJlbmRlcmVyLiBXZSBhcmUgbm90IHVzaW5nIGEgPT09XHJcbiAgLy8gY2hlY2sgZGlyZWN0bHkgb24gS2VlcEFsaXZlIGluIHRoZSByZW5kZXJlciwgYmVjYXVzZSBpbXBvcnRpbmcgaXQgZGlyZWN0bHlcclxuICAvLyB3b3VsZCBwcmV2ZW50IGl0IGZyb20gYmVpbmcgdHJlZS1zaGFrZW4uXHJcbiAgX19pc0tlZXBBbGl2ZTogdHJ1ZSxcclxuICBwcm9wczoge1xyXG4gICAgaW5jbHVkZTogW1N0cmluZywgUmVnRXhwLCBBcnJheV0sXHJcbiAgICBleGNsdWRlOiBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XSxcclxuICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxyXG4gIH0sXHJcbiAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgIGNvbnN0IHNoYXJlZENvbnRleHQgPSBpbnN0YW5jZS5jdHg7XHJcbiAgICBpZiAoIXNoYXJlZENvbnRleHQucmVuZGVyZXIpIHtcclxuICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgJiYgc2xvdHMuZGVmYXVsdCgpO1xyXG4gICAgICAgIHJldHVybiBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgPyBjaGlsZHJlblswXSA6IGNoaWxkcmVuO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xyXG4gICAgY29uc3Qga2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XHJcbiAgICBsZXQgY3VycmVudCA9IG51bGw7XHJcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgaW5zdGFuY2UuX192X2NhY2hlID0gY2FjaGU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYXJlbnRTdXNwZW5zZSA9IGluc3RhbmNlLnN1c3BlbnNlO1xyXG4gICAgY29uc3Qge1xyXG4gICAgICByZW5kZXJlcjoge1xyXG4gICAgICAgIHA6IHBhdGNoLFxyXG4gICAgICAgIG06IG1vdmUsXHJcbiAgICAgICAgdW06IF91bm1vdW50LFxyXG4gICAgICAgIG86IHsgY3JlYXRlRWxlbWVudCB9XHJcbiAgICAgIH1cclxuICAgIH0gPSBzaGFyZWRDb250ZXh0O1xyXG4gICAgY29uc3Qgc3RvcmFnZUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICBzaGFyZWRDb250ZXh0LmFjdGl2YXRlID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgbmFtZXNwYWNlLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgY29uc3QgaW5zdGFuY2UyID0gdm5vZGUuY29tcG9uZW50O1xyXG4gICAgICBtb3ZlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgMCwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICBwYXRjaChcclxuICAgICAgICBpbnN0YW5jZTIudm5vZGUsXHJcbiAgICAgICAgdm5vZGUsXHJcbiAgICAgICAgY29udGFpbmVyLFxyXG4gICAgICAgIGFuY2hvcixcclxuICAgICAgICBpbnN0YW5jZTIsXHJcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgICAgbmFtZXNwYWNlLFxyXG4gICAgICAgIHZub2RlLnNsb3RTY29wZUlkcyxcclxuICAgICAgICBvcHRpbWl6ZWRcclxuICAgICAgKTtcclxuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpbnN0YW5jZTIuaXNEZWFjdGl2YXRlZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChpbnN0YW5jZTIuYSkge1xyXG4gICAgICAgICAgaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UyLmEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB2bm9kZUhvb2sgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5vblZub2RlTW91bnRlZDtcclxuICAgICAgICBpZiAodm5vZGVIb29rKSB7XHJcbiAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBpbnN0YW5jZTIucGFyZW50LCB2bm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UyKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHNoYXJlZENvbnRleHQuZGVhY3RpdmF0ZSA9ICh2bm9kZSkgPT4ge1xyXG4gICAgICBjb25zdCBpbnN0YW5jZTIgPSB2bm9kZS5jb21wb25lbnQ7XHJcbiAgICAgIGludmFsaWRhdGVNb3VudChpbnN0YW5jZTIubSk7XHJcbiAgICAgIGludmFsaWRhdGVNb3VudChpbnN0YW5jZTIuYSk7XHJcbiAgICAgIG1vdmUodm5vZGUsIHN0b3JhZ2VDb250YWluZXIsIG51bGwsIDEsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoaW5zdGFuY2UyLmRhKSB7XHJcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhpbnN0YW5jZTIuZGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB2bm9kZUhvb2sgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5vblZub2RlVW5tb3VudGVkO1xyXG4gICAgICAgIGlmICh2bm9kZUhvb2spIHtcclxuICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIGluc3RhbmNlMi5wYXJlbnQsIHZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zdGFuY2UyLmlzRGVhY3RpdmF0ZWQgPSB0cnVlO1xyXG4gICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UyKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIHVubW91bnQodm5vZGUpIHtcclxuICAgICAgcmVzZXRTaGFwZUZsYWcodm5vZGUpO1xyXG4gICAgICBfdW5tb3VudCh2bm9kZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHBydW5lQ2FjaGUoZmlsdGVyKSB7XHJcbiAgICAgIGNhY2hlLmZvckVhY2goKHZub2RlLCBrZXkpID0+IHtcclxuICAgICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh2bm9kZS50eXBlKTtcclxuICAgICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XHJcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5KGtleSkge1xyXG4gICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoa2V5KTtcclxuICAgICAgaWYgKGNhY2hlZCAmJiAoIWN1cnJlbnQgfHwgIWlzU2FtZVZOb2RlVHlwZShjYWNoZWQsIGN1cnJlbnQpKSkge1xyXG4gICAgICAgIHVubW91bnQoY2FjaGVkKTtcclxuICAgICAgfSBlbHNlIGlmIChjdXJyZW50KSB7XHJcbiAgICAgICAgcmVzZXRTaGFwZUZsYWcoY3VycmVudCk7XHJcbiAgICAgIH1cclxuICAgICAgY2FjaGUuZGVsZXRlKGtleSk7XHJcbiAgICAgIGtleXMuZGVsZXRlKGtleSk7XHJcbiAgICB9XHJcbiAgICB3YXRjaChcclxuICAgICAgKCkgPT4gW3Byb3BzLmluY2x1ZGUsIHByb3BzLmV4Y2x1ZGVdLFxyXG4gICAgICAoW2luY2x1ZGUsIGV4Y2x1ZGVdKSA9PiB7XHJcbiAgICAgICAgaW5jbHVkZSAmJiBwcnVuZUNhY2hlKChuYW1lKSA9PiBtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKTtcclxuICAgICAgICBleGNsdWRlICYmIHBydW5lQ2FjaGUoKG5hbWUpID0+ICFtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKTtcclxuICAgICAgfSxcclxuICAgICAgLy8gcHJ1bmUgcG9zdC1yZW5kZXIgYWZ0ZXIgYGN1cnJlbnRgIGhhcyBiZWVuIHVwZGF0ZWRcclxuICAgICAgeyBmbHVzaDogXCJwb3N0XCIsIGRlZXA6IHRydWUgfVxyXG4gICAgKTtcclxuICAgIGxldCBwZW5kaW5nQ2FjaGVLZXkgPSBudWxsO1xyXG4gICAgY29uc3QgY2FjaGVTdWJ0cmVlID0gKCkgPT4ge1xyXG4gICAgICBpZiAocGVuZGluZ0NhY2hlS2V5ICE9IG51bGwpIHtcclxuICAgICAgICBpZiAoaXNTdXNwZW5zZShpbnN0YW5jZS5zdWJUcmVlLnR5cGUpKSB7XHJcbiAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICBjYWNoZS5zZXQocGVuZGluZ0NhY2hlS2V5LCBnZXRJbm5lckNoaWxkKGluc3RhbmNlLnN1YlRyZWUpKTtcclxuICAgICAgICAgIH0sIGluc3RhbmNlLnN1YlRyZWUuc3VzcGVuc2UpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjYWNoZS5zZXQocGVuZGluZ0NhY2hlS2V5LCBnZXRJbm5lckNoaWxkKGluc3RhbmNlLnN1YlRyZWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBvbk1vdW50ZWQoY2FjaGVTdWJ0cmVlKTtcclxuICAgIG9uVXBkYXRlZChjYWNoZVN1YnRyZWUpO1xyXG4gICAgb25CZWZvcmVVbm1vdW50KCgpID0+IHtcclxuICAgICAgY2FjaGUuZm9yRWFjaCgoY2FjaGVkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBzdWJUcmVlLCBzdXNwZW5zZSB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgY29uc3Qgdm5vZGUgPSBnZXRJbm5lckNoaWxkKHN1YlRyZWUpO1xyXG4gICAgICAgIGlmIChjYWNoZWQudHlwZSA9PT0gdm5vZGUudHlwZSAmJiBjYWNoZWQua2V5ID09PSB2bm9kZS5rZXkpIHtcclxuICAgICAgICAgIHJlc2V0U2hhcGVGbGFnKHZub2RlKTtcclxuICAgICAgICAgIGNvbnN0IGRhID0gdm5vZGUuY29tcG9uZW50LmRhO1xyXG4gICAgICAgICAgZGEgJiYgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGRhLCBzdXNwZW5zZSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVubW91bnQoY2FjaGVkKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIHBlbmRpbmdDYWNoZUtleSA9IG51bGw7XHJcbiAgICAgIGlmICghc2xvdHMuZGVmYXVsdCkge1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50ID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQoKTtcclxuICAgICAgY29uc3QgcmF3Vk5vZGUgPSBjaGlsZHJlblswXTtcclxuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICAgICAgd2FybiQxKGBLZWVwQWxpdmUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgY29tcG9uZW50IGNoaWxkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50ID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gY2hpbGRyZW47XHJcbiAgICAgIH0gZWxzZSBpZiAoIWlzVk5vZGUocmF3Vk5vZGUpIHx8ICEocmF3Vk5vZGUuc2hhcGVGbGFnICYgNCkgJiYgIShyYXdWTm9kZS5zaGFwZUZsYWcgJiAxMjgpKSB7XHJcbiAgICAgICAgY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHJhd1ZOb2RlO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCB2bm9kZSA9IGdldElubmVyQ2hpbGQocmF3Vk5vZGUpO1xyXG4gICAgICBpZiAodm5vZGUudHlwZSA9PT0gQ29tbWVudCkge1xyXG4gICAgICAgIGN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgIHJldHVybiB2bm9kZTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBjb21wID0gdm5vZGUudHlwZTtcclxuICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoXHJcbiAgICAgICAgaXNBc3luY1dyYXBwZXIodm5vZGUpID8gdm5vZGUudHlwZS5fX2FzeW5jUmVzb2x2ZWQgfHwge30gOiBjb21wXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnN0IHsgaW5jbHVkZSwgZXhjbHVkZSwgbWF4IH0gPSBwcm9wcztcclxuICAgICAgaWYgKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSB8fCBleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSkge1xyXG4gICAgICAgIHZub2RlLnNoYXBlRmxhZyAmPSB+MjU2O1xyXG4gICAgICAgIGN1cnJlbnQgPSB2bm9kZTtcclxuICAgICAgICByZXR1cm4gcmF3Vk5vZGU7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qga2V5ID0gdm5vZGUua2V5ID09IG51bGwgPyBjb21wIDogdm5vZGUua2V5O1xyXG4gICAgICBjb25zdCBjYWNoZWRWTm9kZSA9IGNhY2hlLmdldChrZXkpO1xyXG4gICAgICBpZiAodm5vZGUuZWwpIHtcclxuICAgICAgICB2bm9kZSA9IGNsb25lVk5vZGUodm5vZGUpO1xyXG4gICAgICAgIGlmIChyYXdWTm9kZS5zaGFwZUZsYWcgJiAxMjgpIHtcclxuICAgICAgICAgIHJhd1ZOb2RlLnNzQ29udGVudCA9IHZub2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBwZW5kaW5nQ2FjaGVLZXkgPSBrZXk7XHJcbiAgICAgIGlmIChjYWNoZWRWTm9kZSkge1xyXG4gICAgICAgIHZub2RlLmVsID0gY2FjaGVkVk5vZGUuZWw7XHJcbiAgICAgICAgdm5vZGUuY29tcG9uZW50ID0gY2FjaGVkVk5vZGUuY29tcG9uZW50O1xyXG4gICAgICAgIGlmICh2bm9kZS50cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUsIHZub2RlLnRyYW5zaXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2bm9kZS5zaGFwZUZsYWcgfD0gNTEyO1xyXG4gICAgICAgIGtleXMuZGVsZXRlKGtleSk7XHJcbiAgICAgICAga2V5cy5hZGQoa2V5KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBrZXlzLmFkZChrZXkpO1xyXG4gICAgICAgIGlmIChtYXggJiYga2V5cy5zaXplID4gcGFyc2VJbnQobWF4LCAxMCkpIHtcclxuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShrZXlzLnZhbHVlcygpLm5leHQoKS52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHZub2RlLnNoYXBlRmxhZyB8PSAyNTY7XHJcbiAgICAgIGN1cnJlbnQgPSB2bm9kZTtcclxuICAgICAgcmV0dXJuIGlzU3VzcGVuc2UocmF3Vk5vZGUudHlwZSkgPyByYXdWTm9kZSA6IHZub2RlO1xyXG4gICAgfTtcclxuICB9XHJcbn07XHJcbmNvbnN0IEtlZXBBbGl2ZSA9IEtlZXBBbGl2ZUltcGw7XHJcbmZ1bmN0aW9uIG1hdGNoZXMocGF0dGVybiwgbmFtZSkge1xyXG4gIGlmIChpc0FycmF5KHBhdHRlcm4pKSB7XHJcbiAgICByZXR1cm4gcGF0dGVybi5zb21lKChwKSA9PiBtYXRjaGVzKHAsIG5hbWUpKTtcclxuICB9IGVsc2UgaWYgKGlzU3RyaW5nKHBhdHRlcm4pKSB7XHJcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdChcIixcIikuaW5jbHVkZXMobmFtZSk7XHJcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xyXG4gICAgcGF0dGVybi5sYXN0SW5kZXggPSAwO1xyXG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKTtcclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIG9uQWN0aXZhdGVkKGhvb2ssIHRhcmdldCkge1xyXG4gIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCBcImFcIiwgdGFyZ2V0KTtcclxufVxyXG5mdW5jdGlvbiBvbkRlYWN0aXZhdGVkKGhvb2ssIHRhcmdldCkge1xyXG4gIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCBcImRhXCIsIHRhcmdldCk7XHJcbn1cclxuZnVuY3Rpb24gcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIHR5cGUsIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkge1xyXG4gIGNvbnN0IHdyYXBwZWRIb29rID0gaG9vay5fX3dkYyB8fCAoaG9vay5fX3dkYyA9ICgpID0+IHtcclxuICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0O1xyXG4gICAgd2hpbGUgKGN1cnJlbnQpIHtcclxuICAgICAgaWYgKGN1cnJlbnQuaXNEZWFjdGl2YXRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaG9vaygpO1xyXG4gIH0pO1xyXG4gIGluamVjdEhvb2sodHlwZSwgd3JhcHBlZEhvb2ssIHRhcmdldCk7XHJcbiAgaWYgKHRhcmdldCkge1xyXG4gICAgbGV0IGN1cnJlbnQgPSB0YXJnZXQucGFyZW50O1xyXG4gICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudC5wYXJlbnQpIHtcclxuICAgICAgaWYgKGlzS2VlcEFsaXZlKGN1cnJlbnQucGFyZW50LnZub2RlKSkge1xyXG4gICAgICAgIGluamVjdFRvS2VlcEFsaXZlUm9vdCh3cmFwcGVkSG9vaywgdHlwZSwgdGFyZ2V0LCBjdXJyZW50KTtcclxuICAgICAgfVxyXG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGluamVjdFRvS2VlcEFsaXZlUm9vdChob29rLCB0eXBlLCB0YXJnZXQsIGtlZXBBbGl2ZVJvb3QpIHtcclxuICBjb25zdCBpbmplY3RlZCA9IGluamVjdEhvb2soXHJcbiAgICB0eXBlLFxyXG4gICAgaG9vayxcclxuICAgIGtlZXBBbGl2ZVJvb3QsXHJcbiAgICB0cnVlXHJcbiAgICAvKiBwcmVwZW5kICovXHJcbiAgKTtcclxuICBvblVubW91bnRlZCgoKSA9PiB7XHJcbiAgICByZW1vdmUoa2VlcEFsaXZlUm9vdFt0eXBlXSwgaW5qZWN0ZWQpO1xyXG4gIH0sIHRhcmdldCk7XHJcbn1cclxuZnVuY3Rpb24gcmVzZXRTaGFwZUZsYWcodm5vZGUpIHtcclxuICB2bm9kZS5zaGFwZUZsYWcgJj0gfjI1NjtcclxuICB2bm9kZS5zaGFwZUZsYWcgJj0gfjUxMjtcclxufVxyXG5mdW5jdGlvbiBnZXRJbm5lckNoaWxkKHZub2RlKSB7XHJcbiAgcmV0dXJuIHZub2RlLnNoYXBlRmxhZyAmIDEyOCA/IHZub2RlLnNzQ29udGVudCA6IHZub2RlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbmplY3RIb29rKHR5cGUsIGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSwgcHJlcGVuZCA9IGZhbHNlKSB7XHJcbiAgaWYgKHRhcmdldCkge1xyXG4gICAgY29uc3QgaG9va3MgPSB0YXJnZXRbdHlwZV0gfHwgKHRhcmdldFt0eXBlXSA9IFtdKTtcclxuICAgIGNvbnN0IHdyYXBwZWRIb29rID0gaG9vay5fX3dlaCB8fCAoaG9vay5fX3dlaCA9ICguLi5hcmdzKSA9PiB7XHJcbiAgICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgICAgY29uc3QgcmVzZXQgPSBzZXRDdXJyZW50SW5zdGFuY2UodGFyZ2V0KTtcclxuICAgICAgY29uc3QgcmVzID0gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgdGFyZ2V0LCB0eXBlLCBhcmdzKTtcclxuICAgICAgcmVzZXQoKTtcclxuICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICByZXR1cm4gcmVzO1xyXG4gICAgfSk7XHJcbiAgICBpZiAocHJlcGVuZCkge1xyXG4gICAgICBob29rcy51bnNoaWZ0KHdyYXBwZWRIb29rKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGhvb2tzLnB1c2god3JhcHBlZEhvb2spO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHdyYXBwZWRIb29rO1xyXG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgY29uc3QgYXBpTmFtZSA9IHRvSGFuZGxlcktleShFcnJvclR5cGVTdHJpbmdzJDFbdHlwZV0ucmVwbGFjZSgvIGhvb2skLywgXCJcIikpO1xyXG4gICAgd2FybiQxKFxyXG4gICAgICBgJHthcGlOYW1lfSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC4gTGlmZWN5Y2xlIGluamVjdGlvbiBBUElzIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGV4ZWN1dGlvbiBvZiBzZXR1cCgpLmAgKyAoYCBJZiB5b3UgYXJlIHVzaW5nIGFzeW5jIHNldHVwKCksIG1ha2Ugc3VyZSB0byByZWdpc3RlciBsaWZlY3ljbGUgaG9va3MgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdCBzdGF0ZW1lbnQuYCApXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5jb25zdCBjcmVhdGVIb29rID0gKGxpZmVjeWNsZSkgPT4gKGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkgPT4ge1xyXG4gIGlmICghaXNJblNTUkNvbXBvbmVudFNldHVwIHx8IGxpZmVjeWNsZSA9PT0gXCJzcFwiKSB7XHJcbiAgICBpbmplY3RIb29rKGxpZmVjeWNsZSwgKC4uLmFyZ3MpID0+IGhvb2soLi4uYXJncyksIHRhcmdldCk7XHJcbiAgfVxyXG59O1xyXG5jb25zdCBvbkJlZm9yZU1vdW50ID0gY3JlYXRlSG9vayhcImJtXCIpO1xyXG5jb25zdCBvbk1vdW50ZWQgPSBjcmVhdGVIb29rKFwibVwiKTtcclxuY29uc3Qgb25CZWZvcmVVcGRhdGUgPSBjcmVhdGVIb29rKFxyXG4gIFwiYnVcIlxyXG4pO1xyXG5jb25zdCBvblVwZGF0ZWQgPSBjcmVhdGVIb29rKFwidVwiKTtcclxuY29uc3Qgb25CZWZvcmVVbm1vdW50ID0gY3JlYXRlSG9vayhcclxuICBcImJ1bVwiXHJcbik7XHJcbmNvbnN0IG9uVW5tb3VudGVkID0gY3JlYXRlSG9vayhcInVtXCIpO1xyXG5jb25zdCBvblNlcnZlclByZWZldGNoID0gY3JlYXRlSG9vayhcclxuICBcInNwXCJcclxuKTtcclxuY29uc3Qgb25SZW5kZXJUcmlnZ2VyZWQgPSBjcmVhdGVIb29rKFwicnRnXCIpO1xyXG5jb25zdCBvblJlbmRlclRyYWNrZWQgPSBjcmVhdGVIb29rKFwicnRjXCIpO1xyXG5mdW5jdGlvbiBvbkVycm9yQ2FwdHVyZWQoaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSB7XHJcbiAgaW5qZWN0SG9vayhcImVjXCIsIGhvb2ssIHRhcmdldCk7XHJcbn1cclxuXHJcbmNvbnN0IENPTVBPTkVOVFMgPSBcImNvbXBvbmVudHNcIjtcclxuY29uc3QgRElSRUNUSVZFUyA9IFwiZGlyZWN0aXZlc1wiO1xyXG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50KG5hbWUsIG1heWJlU2VsZlJlZmVyZW5jZSkge1xyXG4gIHJldHVybiByZXNvbHZlQXNzZXQoQ09NUE9ORU5UUywgbmFtZSwgdHJ1ZSwgbWF5YmVTZWxmUmVmZXJlbmNlKSB8fCBuYW1lO1xyXG59XHJcbmNvbnN0IE5VTExfRFlOQU1JQ19DT01QT05FTlQgPSBTeW1ib2wuZm9yKFwidi1uZGNcIik7XHJcbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gIGlmIChpc1N0cmluZyhjb21wb25lbnQpKSB7XHJcbiAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KENPTVBPTkVOVFMsIGNvbXBvbmVudCwgZmFsc2UpIHx8IGNvbXBvbmVudDtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGNvbXBvbmVudCB8fCBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiByZXNvbHZlRGlyZWN0aXZlKG5hbWUpIHtcclxuICByZXR1cm4gcmVzb2x2ZUFzc2V0KERJUkVDVElWRVMsIG5hbWUpO1xyXG59XHJcbmZ1bmN0aW9uIHJlc29sdmVBc3NldCh0eXBlLCBuYW1lLCB3YXJuTWlzc2luZyA9IHRydWUsIG1heWJlU2VsZlJlZmVyZW5jZSA9IGZhbHNlKSB7XHJcbiAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfHwgY3VycmVudEluc3RhbmNlO1xyXG4gIGlmIChpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcclxuICAgIGlmICh0eXBlID09PSBDT01QT05FTlRTKSB7XHJcbiAgICAgIGNvbnN0IHNlbGZOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShcclxuICAgICAgICBDb21wb25lbnQsXHJcbiAgICAgICAgZmFsc2VcclxuICAgICAgKTtcclxuICAgICAgaWYgKHNlbGZOYW1lICYmIChzZWxmTmFtZSA9PT0gbmFtZSB8fCBzZWxmTmFtZSA9PT0gY2FtZWxpemUobmFtZSkgfHwgc2VsZk5hbWUgPT09IGNhcGl0YWxpemUoY2FtZWxpemUobmFtZSkpKSkge1xyXG4gICAgICAgIHJldHVybiBDb21wb25lbnQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHJlcyA9IChcclxuICAgICAgLy8gbG9jYWwgcmVnaXN0cmF0aW9uXHJcbiAgICAgIC8vIGNoZWNrIGluc3RhbmNlW3R5cGVdIGZpcnN0IHdoaWNoIGlzIHJlc29sdmVkIGZvciBvcHRpb25zIEFQSVxyXG4gICAgICByZXNvbHZlKGluc3RhbmNlW3R5cGVdIHx8IENvbXBvbmVudFt0eXBlXSwgbmFtZSkgfHwgLy8gZ2xvYmFsIHJlZ2lzdHJhdGlvblxyXG4gICAgICByZXNvbHZlKGluc3RhbmNlLmFwcENvbnRleHRbdHlwZV0sIG5hbWUpXHJcbiAgICApO1xyXG4gICAgaWYgKCFyZXMgJiYgbWF5YmVTZWxmUmVmZXJlbmNlKSB7XHJcbiAgICAgIHJldHVybiBDb21wb25lbnQ7XHJcbiAgICB9XHJcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XHJcbiAgICAgIGNvbnN0IGV4dHJhID0gdHlwZSA9PT0gQ09NUE9ORU5UUyA/IGBcclxuSWYgdGhpcyBpcyBhIG5hdGl2ZSBjdXN0b20gZWxlbWVudCwgbWFrZSBzdXJlIHRvIGV4Y2x1ZGUgaXQgZnJvbSBjb21wb25lbnQgcmVzb2x1dGlvbiB2aWEgY29tcGlsZXJPcHRpb25zLmlzQ3VzdG9tRWxlbWVudC5gIDogYGA7XHJcbiAgICAgIHdhcm4kMShgRmFpbGVkIHRvIHJlc29sdmUgJHt0eXBlLnNsaWNlKDAsIC0xKX06ICR7bmFtZX0ke2V4dHJhfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgIHdhcm4kMShcclxuICAgICAgYHJlc29sdmUke2NhcGl0YWxpemUodHlwZS5zbGljZSgwLCAtMSkpfSBjYW4gb25seSBiZSB1c2VkIGluIHJlbmRlcigpIG9yIHNldHVwKCkuYFxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZShyZWdpc3RyeSwgbmFtZSkge1xyXG4gIHJldHVybiByZWdpc3RyeSAmJiAocmVnaXN0cnlbbmFtZV0gfHwgcmVnaXN0cnlbY2FtZWxpemUobmFtZSldIHx8IHJlZ2lzdHJ5W2NhcGl0YWxpemUoY2FtZWxpemUobmFtZSkpXSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbmRlckxpc3Qoc291cmNlLCByZW5kZXJJdGVtLCBjYWNoZSwgaW5kZXgpIHtcclxuICBsZXQgcmV0O1xyXG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlICYmIGNhY2hlW2luZGV4XTtcclxuICBjb25zdCBzb3VyY2VJc0FycmF5ID0gaXNBcnJheShzb3VyY2UpO1xyXG4gIGlmIChzb3VyY2VJc0FycmF5IHx8IGlzU3RyaW5nKHNvdXJjZSkpIHtcclxuICAgIGNvbnN0IHNvdXJjZUlzUmVhY3RpdmVBcnJheSA9IHNvdXJjZUlzQXJyYXkgJiYgaXNSZWFjdGl2ZShzb3VyY2UpO1xyXG4gICAgbGV0IG5lZWRzV3JhcCA9IGZhbHNlO1xyXG4gICAgaWYgKHNvdXJjZUlzUmVhY3RpdmVBcnJheSkge1xyXG4gICAgICBuZWVkc1dyYXAgPSAhaXNTaGFsbG93KHNvdXJjZSk7XHJcbiAgICAgIHNvdXJjZSA9IHNoYWxsb3dSZWFkQXJyYXkoc291cmNlKTtcclxuICAgIH1cclxuICAgIHJldCA9IG5ldyBBcnJheShzb3VyY2UubGVuZ3RoKTtcclxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gc291cmNlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICByZXRbaV0gPSByZW5kZXJJdGVtKFxyXG4gICAgICAgIG5lZWRzV3JhcCA/IHRvUmVhY3RpdmUoc291cmNlW2ldKSA6IHNvdXJjZVtpXSxcclxuICAgICAgICBpLFxyXG4gICAgICAgIHZvaWQgMCxcclxuICAgICAgICBjYWNoZWQgJiYgY2FjaGVkW2ldXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc291cmNlID09PSBcIm51bWJlclwiKSB7XHJcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhTnVtYmVyLmlzSW50ZWdlcihzb3VyY2UpKSB7XHJcbiAgICAgIHdhcm4kMShgVGhlIHYtZm9yIHJhbmdlIGV4cGVjdCBhbiBpbnRlZ2VyIHZhbHVlIGJ1dCBnb3QgJHtzb3VyY2V9LmApO1xyXG4gICAgfVxyXG4gICAgcmV0ID0gbmV3IEFycmF5KHNvdXJjZSk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZTsgaSsrKSB7XHJcbiAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oaSArIDEsIGksIHZvaWQgMCwgY2FjaGVkICYmIGNhY2hlZFtpXSk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChpc09iamVjdChzb3VyY2UpKSB7XHJcbiAgICBpZiAoc291cmNlW1N5bWJvbC5pdGVyYXRvcl0pIHtcclxuICAgICAgcmV0ID0gQXJyYXkuZnJvbShcclxuICAgICAgICBzb3VyY2UsXHJcbiAgICAgICAgKGl0ZW0sIGkpID0+IHJlbmRlckl0ZW0oaXRlbSwgaSwgdm9pZCAwLCBjYWNoZWQgJiYgY2FjaGVkW2ldKVxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XHJcbiAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oc291cmNlW2tleV0sIGtleSwgaSwgY2FjaGVkICYmIGNhY2hlZFtpXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgcmV0ID0gW107XHJcbiAgfVxyXG4gIGlmIChjYWNoZSkge1xyXG4gICAgY2FjaGVbaW5kZXhdID0gcmV0O1xyXG4gIH1cclxuICByZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVTbG90cyhzbG90cywgZHluYW1pY1Nsb3RzKSB7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljU2xvdHMubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IHNsb3QgPSBkeW5hbWljU2xvdHNbaV07XHJcbiAgICBpZiAoaXNBcnJheShzbG90KSkge1xyXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNsb3QubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICBzbG90c1tzbG90W2pdLm5hbWVdID0gc2xvdFtqXS5mbjtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChzbG90KSB7XHJcbiAgICAgIHNsb3RzW3Nsb3QubmFtZV0gPSBzbG90LmtleSA/ICguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVzID0gc2xvdC5mbiguLi5hcmdzKTtcclxuICAgICAgICBpZiAocmVzKSByZXMua2V5ID0gc2xvdC5rZXk7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgfSA6IHNsb3QuZm47XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBzbG90cztcclxufVxyXG5cclxuZnVuY3Rpb24gcmVuZGVyU2xvdChzbG90cywgbmFtZSwgcHJvcHMgPSB7fSwgZmFsbGJhY2ssIG5vU2xvdHRlZCkge1xyXG4gIGlmIChjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnBhcmVudCAmJiBpc0FzeW5jV3JhcHBlcihjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UucGFyZW50KSAmJiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UucGFyZW50LmNlKSB7XHJcbiAgICBpZiAobmFtZSAhPT0gXCJkZWZhdWx0XCIpIHByb3BzLm5hbWUgPSBuYW1lO1xyXG4gICAgcmV0dXJuIG9wZW5CbG9jaygpLCBjcmVhdGVCbG9jayhcclxuICAgICAgRnJhZ21lbnQsXHJcbiAgICAgIG51bGwsXHJcbiAgICAgIFtjcmVhdGVWTm9kZShcInNsb3RcIiwgcHJvcHMsIGZhbGxiYWNrICYmIGZhbGxiYWNrKCkpXSxcclxuICAgICAgNjRcclxuICAgICk7XHJcbiAgfVxyXG4gIGxldCBzbG90ID0gc2xvdHNbbmFtZV07XHJcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2xvdCAmJiBzbG90Lmxlbmd0aCA+IDEpIHtcclxuICAgIHdhcm4kMShcclxuICAgICAgYFNTUi1vcHRpbWl6ZWQgc2xvdCBmdW5jdGlvbiBkZXRlY3RlZCBpbiBhIG5vbi1TU1Itb3B0aW1pemVkIHJlbmRlciBmdW5jdGlvbi4gWW91IG5lZWQgdG8gbWFyayB0aGlzIGNvbXBvbmVudCB3aXRoICRkeW5hbWljLXNsb3RzIGluIHRoZSBwYXJlbnQgdGVtcGxhdGUuYFxyXG4gICAgKTtcclxuICAgIHNsb3QgPSAoKSA9PiBbXTtcclxuICB9XHJcbiAgaWYgKHNsb3QgJiYgc2xvdC5fYykge1xyXG4gICAgc2xvdC5fZCA9IGZhbHNlO1xyXG4gIH1cclxuICBvcGVuQmxvY2soKTtcclxuICBjb25zdCB2YWxpZFNsb3RDb250ZW50ID0gc2xvdCAmJiBlbnN1cmVWYWxpZFZOb2RlKHNsb3QocHJvcHMpKTtcclxuICBjb25zdCBzbG90S2V5ID0gcHJvcHMua2V5IHx8IC8vIHNsb3QgY29udGVudCBhcnJheSBvZiBhIGR5bmFtaWMgY29uZGl0aW9uYWwgc2xvdCBtYXkgaGF2ZSBhIGJyYW5jaFxyXG4gIC8vIGtleSBhdHRhY2hlZCBpbiB0aGUgYGNyZWF0ZVNsb3RzYCBoZWxwZXIsIHJlc3BlY3QgdGhhdFxyXG4gIHZhbGlkU2xvdENvbnRlbnQgJiYgdmFsaWRTbG90Q29udGVudC5rZXk7XHJcbiAgY29uc3QgcmVuZGVyZWQgPSBjcmVhdGVCbG9jayhcclxuICAgIEZyYWdtZW50LFxyXG4gICAge1xyXG4gICAgICBrZXk6IChzbG90S2V5ICYmICFpc1N5bWJvbChzbG90S2V5KSA/IHNsb3RLZXkgOiBgXyR7bmFtZX1gKSArIC8vICM3MjU2IGZvcmNlIGRpZmZlcmVudGlhdGUgZmFsbGJhY2sgY29udGVudCBmcm9tIGFjdHVhbCBjb250ZW50XHJcbiAgICAgICghdmFsaWRTbG90Q29udGVudCAmJiBmYWxsYmFjayA/IFwiX2ZiXCIgOiBcIlwiKVxyXG4gICAgfSxcclxuICAgIHZhbGlkU2xvdENvbnRlbnQgfHwgKGZhbGxiYWNrID8gZmFsbGJhY2soKSA6IFtdKSxcclxuICAgIHZhbGlkU2xvdENvbnRlbnQgJiYgc2xvdHMuXyA9PT0gMSA/IDY0IDogLTJcclxuICApO1xyXG4gIGlmICghbm9TbG90dGVkICYmIHJlbmRlcmVkLnNjb3BlSWQpIHtcclxuICAgIHJlbmRlcmVkLnNsb3RTY29wZUlkcyA9IFtyZW5kZXJlZC5zY29wZUlkICsgXCItc1wiXTtcclxuICB9XHJcbiAgaWYgKHNsb3QgJiYgc2xvdC5fYykge1xyXG4gICAgc2xvdC5fZCA9IHRydWU7XHJcbiAgfVxyXG4gIHJldHVybiByZW5kZXJlZDtcclxufVxyXG5mdW5jdGlvbiBlbnN1cmVWYWxpZFZOb2RlKHZub2Rlcykge1xyXG4gIHJldHVybiB2bm9kZXMuc29tZSgoY2hpbGQpID0+IHtcclxuICAgIGlmICghaXNWTm9kZShjaGlsZCkpIHJldHVybiB0cnVlO1xyXG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IENvbW1lbnQpIHJldHVybiBmYWxzZTtcclxuICAgIGlmIChjaGlsZC50eXBlID09PSBGcmFnbWVudCAmJiAhZW5zdXJlVmFsaWRWTm9kZShjaGlsZC5jaGlsZHJlbikpXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0pID8gdm5vZGVzIDogbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gdG9IYW5kbGVycyhvYmosIHByZXNlcnZlQ2FzZUlmTmVjZXNzYXJ5KSB7XHJcbiAgY29uc3QgcmV0ID0ge307XHJcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzT2JqZWN0KG9iaikpIHtcclxuICAgIHdhcm4kMShgdi1vbiB3aXRoIG5vIGFyZ3VtZW50IGV4cGVjdHMgYW4gb2JqZWN0IHZhbHVlLmApO1xyXG4gICAgcmV0dXJuIHJldDtcclxuICB9XHJcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICByZXRbcHJlc2VydmVDYXNlSWZOZWNlc3NhcnkgJiYgL1tBLVpdLy50ZXN0KGtleSkgPyBgb246JHtrZXl9YCA6IHRvSGFuZGxlcktleShrZXkpXSA9IG9ialtrZXldO1xyXG4gIH1cclxuICByZXR1cm4gcmV0O1xyXG59XHJcblxyXG5jb25zdCBnZXRQdWJsaWNJbnN0YW5jZSA9IChpKSA9PiB7XHJcbiAgaWYgKCFpKSByZXR1cm4gbnVsbDtcclxuICBpZiAoaXNTdGF0ZWZ1bENvbXBvbmVudChpKSkgcmV0dXJuIGdldENvbXBvbmVudFB1YmxpY0luc3RhbmNlKGkpO1xyXG4gIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShpLnBhcmVudCk7XHJcbn07XHJcbmNvbnN0IHB1YmxpY1Byb3BlcnRpZXNNYXAgPSAoXHJcbiAgLy8gTW92ZSBQVVJFIG1hcmtlciB0byBuZXcgbGluZSB0byB3b3JrYXJvdW5kIGNvbXBpbGVyIGRpc2NhcmRpbmcgaXRcclxuICAvLyBkdWUgdG8gdHlwZSBhbm5vdGF0aW9uXHJcbiAgLyogQF9fUFVSRV9fICovIGV4dGVuZCgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwge1xyXG4gICAgJDogKGkpID0+IGksXHJcbiAgICAkZWw6IChpKSA9PiBpLnZub2RlLmVsLFxyXG4gICAgJGRhdGE6IChpKSA9PiBpLmRhdGEsXHJcbiAgICAkcHJvcHM6IChpKSA9PiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGkucHJvcHMpIDogaS5wcm9wcyxcclxuICAgICRhdHRyczogKGkpID0+ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaS5hdHRycykgOiBpLmF0dHJzLFxyXG4gICAgJHNsb3RzOiAoaSkgPT4gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShpLnNsb3RzKSA6IGkuc2xvdHMsXHJcbiAgICAkcmVmczogKGkpID0+ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaS5yZWZzKSA6IGkucmVmcyxcclxuICAgICRwYXJlbnQ6IChpKSA9PiBnZXRQdWJsaWNJbnN0YW5jZShpLnBhcmVudCksXHJcbiAgICAkcm9vdDogKGkpID0+IGdldFB1YmxpY0luc3RhbmNlKGkucm9vdCksXHJcbiAgICAkaG9zdDogKGkpID0+IGkuY2UsXHJcbiAgICAkZW1pdDogKGkpID0+IGkuZW1pdCxcclxuICAgICRvcHRpb25zOiAoaSkgPT4gX19WVUVfT1BUSU9OU19BUElfXyA/IHJlc29sdmVNZXJnZWRPcHRpb25zKGkpIDogaS50eXBlLFxyXG4gICAgJGZvcmNlVXBkYXRlOiAoaSkgPT4gaS5mIHx8IChpLmYgPSAoKSA9PiB7XHJcbiAgICAgIHF1ZXVlSm9iKGkudXBkYXRlKTtcclxuICAgIH0pLFxyXG4gICAgJG5leHRUaWNrOiAoaSkgPT4gaS5uIHx8IChpLm4gPSBuZXh0VGljay5iaW5kKGkucHJveHkpKSxcclxuICAgICR3YXRjaDogKGkpID0+IF9fVlVFX09QVElPTlNfQVBJX18gPyBpbnN0YW5jZVdhdGNoLmJpbmQoaSkgOiBOT09QXHJcbiAgfSlcclxuKTtcclxuY29uc3QgaXNSZXNlcnZlZFByZWZpeCA9IChrZXkpID0+IGtleSA9PT0gXCJfXCIgfHwga2V5ID09PSBcIiRcIjtcclxuY29uc3QgaGFzU2V0dXBCaW5kaW5nID0gKHN0YXRlLCBrZXkpID0+IHN0YXRlICE9PSBFTVBUWV9PQkogJiYgIXN0YXRlLl9faXNTY3JpcHRTZXR1cCAmJiBoYXNPd24oc3RhdGUsIGtleSk7XHJcbmNvbnN0IFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyA9IHtcclxuICBnZXQoeyBfOiBpbnN0YW5jZSB9LCBrZXkpIHtcclxuICAgIGlmIChrZXkgPT09IFwiX192X3NraXBcIikge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgY3R4LCBzZXR1cFN0YXRlLCBkYXRhLCBwcm9wcywgYWNjZXNzQ2FjaGUsIHR5cGUsIGFwcENvbnRleHQgfSA9IGluc3RhbmNlO1xyXG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5ID09PSBcIl9faXNWdWVcIikge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGxldCBub3JtYWxpemVkUHJvcHM7XHJcbiAgICBpZiAoa2V5WzBdICE9PSBcIiRcIikge1xyXG4gICAgICBjb25zdCBuID0gYWNjZXNzQ2FjaGVba2V5XTtcclxuICAgICAgaWYgKG4gIT09IHZvaWQgMCkge1xyXG4gICAgICAgIHN3aXRjaCAobikge1xyXG4gICAgICAgICAgY2FzZSAxIC8qIFNFVFVQICovOlxyXG4gICAgICAgICAgICByZXR1cm4gc2V0dXBTdGF0ZVtrZXldO1xyXG4gICAgICAgICAgY2FzZSAyIC8qIERBVEEgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XHJcbiAgICAgICAgICBjYXNlIDQgLyogQ09OVEVYVCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xyXG4gICAgICAgICAgY2FzZSAzIC8qIFBST1BTICovOlxyXG4gICAgICAgICAgICByZXR1cm4gcHJvcHNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoaGFzU2V0dXBCaW5kaW5nKHNldHVwU3RhdGUsIGtleSkpIHtcclxuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMSAvKiBTRVRVUCAqLztcclxuICAgICAgICByZXR1cm4gc2V0dXBTdGF0ZVtrZXldO1xyXG4gICAgICB9IGVsc2UgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSkge1xyXG4gICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAyIC8qIERBVEEgKi87XHJcbiAgICAgICAgcmV0dXJuIGRhdGFba2V5XTtcclxuICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICAvLyBvbmx5IGNhY2hlIG90aGVyIHByb3BlcnRpZXMgd2hlbiBpbnN0YW5jZSBoYXMgZGVjbGFyZWQgKHRodXMgc3RhYmxlKVxyXG4gICAgICAgIC8vIHByb3BzXHJcbiAgICAgICAgKG5vcm1hbGl6ZWRQcm9wcyA9IGluc3RhbmNlLnByb3BzT3B0aW9uc1swXSkgJiYgaGFzT3duKG5vcm1hbGl6ZWRQcm9wcywga2V5KVxyXG4gICAgICApIHtcclxuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMyAvKiBQUk9QUyAqLztcclxuICAgICAgICByZXR1cm4gcHJvcHNba2V5XTtcclxuICAgICAgfSBlbHNlIGlmIChjdHggIT09IEVNUFRZX09CSiAmJiBoYXNPd24oY3R4LCBrZXkpKSB7XHJcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDQgLyogQ09OVEVYVCAqLztcclxuICAgICAgICByZXR1cm4gY3R4W2tleV07XHJcbiAgICAgIH0gZWxzZSBpZiAoIV9fVlVFX09QVElPTlNfQVBJX18gfHwgc2hvdWxkQ2FjaGVBY2Nlc3MpIHtcclxuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMCAvKiBPVEhFUiAqLztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgcHVibGljR2V0dGVyID0gcHVibGljUHJvcGVydGllc01hcFtrZXldO1xyXG4gICAgbGV0IGNzc01vZHVsZSwgZ2xvYmFsUHJvcGVydGllcztcclxuICAgIGlmIChwdWJsaWNHZXR0ZXIpIHtcclxuICAgICAgaWYgKGtleSA9PT0gXCIkYXR0cnNcIikge1xyXG4gICAgICAgIHRyYWNrKGluc3RhbmNlLmF0dHJzLCBcImdldFwiLCBcIlwiKTtcclxuICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXkgPT09IFwiJHNsb3RzXCIpIHtcclxuICAgICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiwga2V5KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcHVibGljR2V0dGVyKGluc3RhbmNlKTtcclxuICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgIC8vIGNzcyBtb2R1bGUgKGluamVjdGVkIGJ5IHZ1ZS1sb2FkZXIpXHJcbiAgICAgIChjc3NNb2R1bGUgPSB0eXBlLl9fY3NzTW9kdWxlcykgJiYgKGNzc01vZHVsZSA9IGNzc01vZHVsZVtrZXldKVxyXG4gICAgKSB7XHJcbiAgICAgIHJldHVybiBjc3NNb2R1bGU7XHJcbiAgICB9IGVsc2UgaWYgKGN0eCAhPT0gRU1QVFlfT0JKICYmIGhhc093bihjdHgsIGtleSkpIHtcclxuICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDQgLyogQ09OVEVYVCAqLztcclxuICAgICAgcmV0dXJuIGN0eFtrZXldO1xyXG4gICAgfSBlbHNlIGlmIChcclxuICAgICAgLy8gZ2xvYmFsIHByb3BlcnRpZXNcclxuICAgICAgZ2xvYmFsUHJvcGVydGllcyA9IGFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMsIGhhc093bihnbG9iYWxQcm9wZXJ0aWVzLCBrZXkpXHJcbiAgICApIHtcclxuICAgICAge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWxQcm9wZXJ0aWVzW2tleV07XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgJiYgKCFpc1N0cmluZyhrZXkpIHx8IC8vICMxMDkxIGF2b2lkIGludGVybmFsIGlzUmVmL2lzVk5vZGUgY2hlY2tzIG9uIGNvbXBvbmVudCBpbnN0YW5jZSBsZWFkaW5nXHJcbiAgICAvLyB0byBpbmZpbml0ZSB3YXJuaW5nIGxvb3BcclxuICAgIGtleS5pbmRleE9mKFwiX192XCIpICE9PSAwKSkge1xyXG4gICAgICBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGlzUmVzZXJ2ZWRQcmVmaXgoa2V5WzBdKSAmJiBoYXNPd24oZGF0YSwga2V5KSkge1xyXG4gICAgICAgIHdhcm4kMShcclxuICAgICAgICAgIGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KFxyXG4gICAgICAgICAgICBrZXlcclxuICAgICAgICAgICl9IG11c3QgYmUgYWNjZXNzZWQgdmlhICRkYXRhIGJlY2F1c2UgaXQgc3RhcnRzIHdpdGggYSByZXNlcnZlZCBjaGFyYWN0ZXIgKFwiJFwiIG9yIFwiX1wiKSBhbmQgaXMgbm90IHByb3hpZWQgb24gdGhlIHJlbmRlciBjb250ZXh0LmBcclxuICAgICAgICApO1xyXG4gICAgICB9IGVsc2UgaWYgKGluc3RhbmNlID09PSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpIHtcclxuICAgICAgICB3YXJuJDEoXHJcbiAgICAgICAgICBgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSB3YXMgYWNjZXNzZWQgZHVyaW5nIHJlbmRlciBidXQgaXMgbm90IGRlZmluZWQgb24gaW5zdGFuY2UuYFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG4gIHNldCh7IF86IGluc3RhbmNlIH0sIGtleSwgdmFsdWUpIHtcclxuICAgIGNvbnN0IHsgZGF0YSwgc2V0dXBTdGF0ZSwgY3R4IH0gPSBpbnN0YW5jZTtcclxuICAgIGlmIChoYXNTZXR1cEJpbmRpbmcoc2V0dXBTdGF0ZSwga2V5KSkge1xyXG4gICAgICBzZXR1cFN0YXRlW2tleV0gPSB2YWx1ZTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2V0dXBTdGF0ZS5fX2lzU2NyaXB0U2V0dXAgJiYgaGFzT3duKHNldHVwU3RhdGUsIGtleSkpIHtcclxuICAgICAgd2FybiQxKGBDYW5ub3QgbXV0YXRlIDxzY3JpcHQgc2V0dXA+IGJpbmRpbmcgXCIke2tleX1cIiBmcm9tIE9wdGlvbnMgQVBJLmApO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9IGVsc2UgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSkge1xyXG4gICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGVsc2UgaWYgKGhhc093bihpbnN0YW5jZS5wcm9wcywga2V5KSkge1xyXG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHJvcCBcIiR7a2V5fVwiLiBQcm9wcyBhcmUgcmVhZG9ubHkuYCk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChrZXlbMF0gPT09IFwiJFwiICYmIGtleS5zbGljZSgxKSBpbiBpbnN0YW5jZSkge1xyXG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShcclxuICAgICAgICBgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHVibGljIHByb3BlcnR5IFwiJHtrZXl9XCIuIFByb3BlcnRpZXMgc3RhcnRpbmcgd2l0aCAkIGFyZSByZXNlcnZlZCBhbmQgcmVhZG9ubHkuYFxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXkgaW4gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcykge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgIHZhbHVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY3R4W2tleV0gPSB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSxcclxuICBoYXMoe1xyXG4gICAgXzogeyBkYXRhLCBzZXR1cFN0YXRlLCBhY2Nlc3NDYWNoZSwgY3R4LCBhcHBDb250ZXh0LCBwcm9wc09wdGlvbnMgfVxyXG4gIH0sIGtleSkge1xyXG4gICAgbGV0IG5vcm1hbGl6ZWRQcm9wcztcclxuICAgIHJldHVybiAhIWFjY2Vzc0NhY2hlW2tleV0gfHwgZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpIHx8IGhhc1NldHVwQmluZGluZyhzZXR1cFN0YXRlLCBrZXkpIHx8IChub3JtYWxpemVkUHJvcHMgPSBwcm9wc09wdGlvbnNbMF0pICYmIGhhc093bihub3JtYWxpemVkUHJvcHMsIGtleSkgfHwgaGFzT3duKGN0eCwga2V5KSB8fCBoYXNPd24ocHVibGljUHJvcGVydGllc01hcCwga2V5KSB8fCBoYXNPd24oYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcywga2V5KTtcclxuICB9LFxyXG4gIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XHJcbiAgICBpZiAoZGVzY3JpcHRvci5nZXQgIT0gbnVsbCkge1xyXG4gICAgICB0YXJnZXQuXy5hY2Nlc3NDYWNoZVtrZXldID0gMDtcclxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGRlc2NyaXB0b3IsIFwidmFsdWVcIikpIHtcclxuICAgICAgdGhpcy5zZXQodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IudmFsdWUsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpO1xyXG4gIH1cclxufTtcclxuaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdHJ1ZSkge1xyXG4gIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5vd25LZXlzID0gKHRhcmdldCkgPT4ge1xyXG4gICAgd2FybiQxKFxyXG4gICAgICBgQXZvaWQgYXBwIGxvZ2ljIHRoYXQgcmVsaWVzIG9uIGVudW1lcmF0aW5nIGtleXMgb24gYSBjb21wb25lbnQgaW5zdGFuY2UuIFRoZSBrZXlzIHdpbGwgYmUgZW1wdHkgaW4gcHJvZHVjdGlvbiBtb2RlIHRvIGF2b2lkIHBlcmZvcm1hbmNlIG92ZXJoZWFkLmBcclxuICAgICk7XHJcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XHJcbiAgfTtcclxufVxyXG5jb25zdCBSdW50aW1lQ29tcGlsZWRQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKHt9LCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMsIHtcclxuICBnZXQodGFyZ2V0LCBrZXkpIHtcclxuICAgIGlmIChrZXkgPT09IFN5bWJvbC51bnNjb3BhYmxlcykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLmdldCh0YXJnZXQsIGtleSwgdGFyZ2V0KTtcclxuICB9LFxyXG4gIGhhcyhfLCBrZXkpIHtcclxuICAgIGNvbnN0IGhhcyA9IGtleVswXSAhPT0gXCJfXCIgJiYgIWlzR2xvYmFsbHlBbGxvd2VkKGtleSk7XHJcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaGFzICYmIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5oYXMoXywga2V5KSkge1xyXG4gICAgICB3YXJuJDEoXHJcbiAgICAgICAgYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoXHJcbiAgICAgICAgICBrZXlcclxuICAgICAgICApfSBzaG91bGQgbm90IHN0YXJ0IHdpdGggXyB3aGljaCBpcyBhIHJlc2VydmVkIHByZWZpeCBmb3IgVnVlIGludGVybmFscy5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFzO1xyXG4gIH1cclxufSk7XHJcbmZ1bmN0aW9uIGNyZWF0ZURldlJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcclxuICBjb25zdCB0YXJnZXQgPSB7fTtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBgX2AsIHtcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgZ2V0OiAoKSA9PiBpbnN0YW5jZVxyXG4gIH0pO1xyXG4gIE9iamVjdC5rZXlzKHB1YmxpY1Byb3BlcnRpZXNNYXApLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgIGdldDogKCkgPT4gcHVibGljUHJvcGVydGllc01hcFtrZXldKGluc3RhbmNlKSxcclxuICAgICAgLy8gaW50ZXJjZXB0ZWQgYnkgdGhlIHByb3h5IHNvIG5vIG5lZWQgZm9yIGltcGxlbWVudGF0aW9uLFxyXG4gICAgICAvLyBidXQgbmVlZGVkIHRvIHByZXZlbnQgc2V0IGVycm9yc1xyXG4gICAgICBzZXQ6IE5PT1BcclxuICAgIH0pO1xyXG4gIH0pO1xyXG4gIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuZnVuY3Rpb24gZXhwb3NlUHJvcHNPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcclxuICBjb25zdCB7XHJcbiAgICBjdHgsXHJcbiAgICBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdXHJcbiAgfSA9IGluc3RhbmNlO1xyXG4gIGlmIChwcm9wc09wdGlvbnMpIHtcclxuICAgIE9iamVjdC5rZXlzKHByb3BzT3B0aW9ucykuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGdldDogKCkgPT4gaW5zdGFuY2UucHJvcHNba2V5XSxcclxuICAgICAgICBzZXQ6IE5PT1BcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xyXG4gIGNvbnN0IHsgY3R4LCBzZXR1cFN0YXRlIH0gPSBpbnN0YW5jZTtcclxuICBPYmplY3Qua2V5cyh0b1JhdyhzZXR1cFN0YXRlKSkuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICBpZiAoIXNldHVwU3RhdGUuX19pc1NjcmlwdFNldHVwKSB7XHJcbiAgICAgIGlmIChpc1Jlc2VydmVkUHJlZml4KGtleVswXSkpIHtcclxuICAgICAgICB3YXJuJDEoXHJcbiAgICAgICAgICBgc2V0dXAoKSByZXR1cm4gcHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShcclxuICAgICAgICAgICAga2V5XHJcbiAgICAgICAgICApfSBzaG91bGQgbm90IHN0YXJ0IHdpdGggXCIkXCIgb3IgXCJfXCIgd2hpY2ggYXJlIHJlc2VydmVkIHByZWZpeGVzIGZvciBWdWUgaW50ZXJuYWxzLmBcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQ6ICgpID0+IHNldHVwU3RhdGVba2V5XSxcclxuICAgICAgICBzZXQ6IE5PT1BcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbmNvbnN0IHdhcm5SdW50aW1lVXNhZ2UgPSAobWV0aG9kKSA9PiB3YXJuJDEoXHJcbiAgYCR7bWV0aG9kfSgpIGlzIGEgY29tcGlsZXItaGludCBoZWxwZXIgdGhhdCBpcyBvbmx5IHVzYWJsZSBpbnNpZGUgPHNjcmlwdCBzZXR1cD4gb2YgYSBzaW5nbGUgZmlsZSBjb21wb25lbnQuIEl0cyBhcmd1bWVudHMgc2hvdWxkIGJlIGNvbXBpbGVkIGF3YXkgYW5kIHBhc3NpbmcgaXQgYXQgcnVudGltZSBoYXMgbm8gZWZmZWN0LmBcclxuKTtcclxuZnVuY3Rpb24gZGVmaW5lUHJvcHMoKSB7XHJcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZVByb3BzYCk7XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIGRlZmluZUVtaXRzKCkge1xyXG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVFbWl0c2ApO1xyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBkZWZpbmVFeHBvc2UoZXhwb3NlZCkge1xyXG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVFeHBvc2VgKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZGVmaW5lT3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZU9wdGlvbnNgKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZGVmaW5lU2xvdHMoKSB7XHJcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZVNsb3RzYCk7XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIGRlZmluZU1vZGVsKCkge1xyXG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICB3YXJuUnVudGltZVVzYWdlKFwiZGVmaW5lTW9kZWxcIik7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHdpdGhEZWZhdWx0cyhwcm9wcywgZGVmYXVsdHMpIHtcclxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgd2FyblJ1bnRpbWVVc2FnZShgd2l0aERlZmF1bHRzYCk7XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIHVzZVNsb3RzKCkge1xyXG4gIHJldHVybiBnZXRDb250ZXh0KCkuc2xvdHM7XHJcbn1cclxuZnVuY3Rpb24gdXNlQXR0cnMoKSB7XHJcbiAgcmV0dXJuIGdldENvbnRleHQoKS5hdHRycztcclxufVxyXG5mdW5jdGlvbiBnZXRDb250ZXh0KCkge1xyXG4gIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaSkge1xyXG4gICAgd2FybiQxKGB1c2VDb250ZXh0KCkgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGluc3RhbmNlLmApO1xyXG4gIH1cclxuICByZXR1cm4gaS5zZXR1cENvbnRleHQgfHwgKGkuc2V0dXBDb250ZXh0ID0gY3JlYXRlU2V0dXBDb250ZXh0KGkpKTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wc09yRW1pdHMocHJvcHMpIHtcclxuICByZXR1cm4gaXNBcnJheShwcm9wcykgPyBwcm9wcy5yZWR1Y2UoXHJcbiAgICAobm9ybWFsaXplZCwgcCkgPT4gKG5vcm1hbGl6ZWRbcF0gPSBudWxsLCBub3JtYWxpemVkKSxcclxuICAgIHt9XHJcbiAgKSA6IHByb3BzO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlRGVmYXVsdHMocmF3LCBkZWZhdWx0cykge1xyXG4gIGNvbnN0IHByb3BzID0gbm9ybWFsaXplUHJvcHNPckVtaXRzKHJhdyk7XHJcbiAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdHMpIHtcclxuICAgIGlmIChrZXkuc3RhcnRzV2l0aChcIl9fc2tpcFwiKSkgY29udGludWU7XHJcbiAgICBsZXQgb3B0ID0gcHJvcHNba2V5XTtcclxuICAgIGlmIChvcHQpIHtcclxuICAgICAgaWYgKGlzQXJyYXkob3B0KSB8fCBpc0Z1bmN0aW9uKG9wdCkpIHtcclxuICAgICAgICBvcHQgPSBwcm9wc1trZXldID0geyB0eXBlOiBvcHQsIGRlZmF1bHQ6IGRlZmF1bHRzW2tleV0gfTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBvcHQuZGVmYXVsdCA9IGRlZmF1bHRzW2tleV07XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAob3B0ID09PSBudWxsKSB7XHJcbiAgICAgIG9wdCA9IHByb3BzW2tleV0gPSB7IGRlZmF1bHQ6IGRlZmF1bHRzW2tleV0gfTtcclxuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICB3YXJuJDEoYHByb3BzIGRlZmF1bHQga2V5IFwiJHtrZXl9XCIgaGFzIG5vIGNvcnJlc3BvbmRpbmcgZGVjbGFyYXRpb24uYCk7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0ICYmIGRlZmF1bHRzW2BfX3NraXBfJHtrZXl9YF0pIHtcclxuICAgICAgb3B0LnNraXBGYWN0b3J5ID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHByb3BzO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlTW9kZWxzKGEsIGIpIHtcclxuICBpZiAoIWEgfHwgIWIpIHJldHVybiBhIHx8IGI7XHJcbiAgaWYgKGlzQXJyYXkoYSkgJiYgaXNBcnJheShiKSkgcmV0dXJuIGEuY29uY2F0KGIpO1xyXG4gIHJldHVybiBleHRlbmQoe30sIG5vcm1hbGl6ZVByb3BzT3JFbWl0cyhhKSwgbm9ybWFsaXplUHJvcHNPckVtaXRzKGIpKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVQcm9wc1Jlc3RQcm94eShwcm9wcywgZXhjbHVkZWRLZXlzKSB7XHJcbiAgY29uc3QgcmV0ID0ge307XHJcbiAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcclxuICAgIGlmICghZXhjbHVkZWRLZXlzLmluY2x1ZGVzKGtleSkpIHtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJldCwga2V5LCB7XHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQ6ICgpID0+IHByb3BzW2tleV1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXQ7XHJcbn1cclxuZnVuY3Rpb24gd2l0aEFzeW5jQ29udGV4dChnZXRBd2FpdGFibGUpIHtcclxuICBjb25zdCBjdHggPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhY3R4KSB7XHJcbiAgICB3YXJuJDEoXHJcbiAgICAgIGB3aXRoQXN5bmNDb250ZXh0IGNhbGxlZCB3aXRob3V0IGFjdGl2ZSBjdXJyZW50IGluc3RhbmNlLiBUaGlzIGlzIGxpa2VseSBhIGJ1Zy5gXHJcbiAgICApO1xyXG4gIH1cclxuICBsZXQgYXdhaXRhYmxlID0gZ2V0QXdhaXRhYmxlKCk7XHJcbiAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICBpZiAoaXNQcm9taXNlKGF3YWl0YWJsZSkpIHtcclxuICAgIGF3YWl0YWJsZSA9IGF3YWl0YWJsZS5jYXRjaCgoZSkgPT4ge1xyXG4gICAgICBzZXRDdXJyZW50SW5zdGFuY2UoY3R4KTtcclxuICAgICAgdGhyb3cgZTtcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gW2F3YWl0YWJsZSwgKCkgPT4gc2V0Q3VycmVudEluc3RhbmNlKGN0eCldO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVEdXBsaWNhdGVDaGVja2VyKCkge1xyXG4gIGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgcmV0dXJuICh0eXBlLCBrZXkpID0+IHtcclxuICAgIGlmIChjYWNoZVtrZXldKSB7XHJcbiAgICAgIHdhcm4kMShgJHt0eXBlfSBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiAke2NhY2hlW2tleV19LmApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY2FjaGVba2V5XSA9IHR5cGU7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5sZXQgc2hvdWxkQ2FjaGVBY2Nlc3MgPSB0cnVlO1xyXG5mdW5jdGlvbiBhcHBseU9wdGlvbnMoaW5zdGFuY2UpIHtcclxuICBjb25zdCBvcHRpb25zID0gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaW5zdGFuY2UpO1xyXG4gIGNvbnN0IHB1YmxpY1RoaXMgPSBpbnN0YW5jZS5wcm94eTtcclxuICBjb25zdCBjdHggPSBpbnN0YW5jZS5jdHg7XHJcbiAgc2hvdWxkQ2FjaGVBY2Nlc3MgPSBmYWxzZTtcclxuICBpZiAob3B0aW9ucy5iZWZvcmVDcmVhdGUpIHtcclxuICAgIGNhbGxIb29rKG9wdGlvbnMuYmVmb3JlQ3JlYXRlLCBpbnN0YW5jZSwgXCJiY1wiKTtcclxuICB9XHJcbiAgY29uc3Qge1xyXG4gICAgLy8gc3RhdGVcclxuICAgIGRhdGE6IGRhdGFPcHRpb25zLFxyXG4gICAgY29tcHV0ZWQ6IGNvbXB1dGVkT3B0aW9ucyxcclxuICAgIG1ldGhvZHMsXHJcbiAgICB3YXRjaDogd2F0Y2hPcHRpb25zLFxyXG4gICAgcHJvdmlkZTogcHJvdmlkZU9wdGlvbnMsXHJcbiAgICBpbmplY3Q6IGluamVjdE9wdGlvbnMsXHJcbiAgICAvLyBsaWZlY3ljbGVcclxuICAgIGNyZWF0ZWQsXHJcbiAgICBiZWZvcmVNb3VudCxcclxuICAgIG1vdW50ZWQsXHJcbiAgICBiZWZvcmVVcGRhdGUsXHJcbiAgICB1cGRhdGVkLFxyXG4gICAgYWN0aXZhdGVkLFxyXG4gICAgZGVhY3RpdmF0ZWQsXHJcbiAgICBiZWZvcmVEZXN0cm95LFxyXG4gICAgYmVmb3JlVW5tb3VudCxcclxuICAgIGRlc3Ryb3llZCxcclxuICAgIHVubW91bnRlZCxcclxuICAgIHJlbmRlcixcclxuICAgIHJlbmRlclRyYWNrZWQsXHJcbiAgICByZW5kZXJUcmlnZ2VyZWQsXHJcbiAgICBlcnJvckNhcHR1cmVkLFxyXG4gICAgc2VydmVyUHJlZmV0Y2gsXHJcbiAgICAvLyBwdWJsaWMgQVBJXHJcbiAgICBleHBvc2UsXHJcbiAgICBpbmhlcml0QXR0cnMsXHJcbiAgICAvLyBhc3NldHNcclxuICAgIGNvbXBvbmVudHMsXHJcbiAgICBkaXJlY3RpdmVzLFxyXG4gICAgZmlsdGVyc1xyXG4gIH0gPSBvcHRpb25zO1xyXG4gIGNvbnN0IGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBjcmVhdGVEdXBsaWNhdGVDaGVja2VyKCkgOiBudWxsO1xyXG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICBjb25zdCBbcHJvcHNPcHRpb25zXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcclxuICAgIGlmIChwcm9wc09wdGlvbnMpIHtcclxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHNPcHRpb25zKSB7XHJcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiUHJvcHNcIiAvKiBQUk9QUyAqLywga2V5KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoaW5qZWN0T3B0aW9ucykge1xyXG4gICAgcmVzb2x2ZUluamVjdGlvbnMoaW5qZWN0T3B0aW9ucywgY3R4LCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMpO1xyXG4gIH1cclxuICBpZiAobWV0aG9kcykge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gbWV0aG9kcykge1xyXG4gICAgICBjb25zdCBtZXRob2RIYW5kbGVyID0gbWV0aG9kc1trZXldO1xyXG4gICAgICBpZiAoaXNGdW5jdGlvbihtZXRob2RIYW5kbGVyKSkge1xyXG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgdmFsdWU6IG1ldGhvZEhhbmRsZXIuYmluZChwdWJsaWNUaGlzKSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGN0eFtrZXldID0gbWV0aG9kSGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiTWV0aG9kc1wiIC8qIE1FVEhPRFMgKi8sIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgICB3YXJuJDEoXHJcbiAgICAgICAgICBgTWV0aG9kIFwiJHtrZXl9XCIgaGFzIHR5cGUgXCIke3R5cGVvZiBtZXRob2RIYW5kbGVyfVwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9gXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoZGF0YU9wdGlvbnMpIHtcclxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0Z1bmN0aW9uKGRhdGFPcHRpb25zKSkge1xyXG4gICAgICB3YXJuJDEoXHJcbiAgICAgICAgYFRoZSBkYXRhIG9wdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24uIFBsYWluIG9iamVjdCB1c2FnZSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRhdGEgPSBkYXRhT3B0aW9ucy5jYWxsKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpO1xyXG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNQcm9taXNlKGRhdGEpKSB7XHJcbiAgICAgIHdhcm4kMShcclxuICAgICAgICBgZGF0YSgpIHJldHVybmVkIGEgUHJvbWlzZSAtIG5vdGUgZGF0YSgpIGNhbm5vdCBiZSBhc3luYzsgSWYgeW91IGludGVuZCB0byBwZXJmb3JtIGRhdGEgZmV0Y2hpbmcgYmVmb3JlIGNvbXBvbmVudCByZW5kZXJzLCB1c2UgYXN5bmMgc2V0dXAoKSArIDxTdXNwZW5zZT4uYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc09iamVjdChkYXRhKSkge1xyXG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShgZGF0YSgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LmApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaW5zdGFuY2UuZGF0YSA9IHJlYWN0aXZlKGRhdGEpO1xyXG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcclxuICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkRhdGFcIiAvKiBEQVRBICovLCBrZXkpO1xyXG4gICAgICAgICAgaWYgKCFpc1Jlc2VydmVkUHJlZml4KGtleVswXSkpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBkYXRhW2tleV0sXHJcbiAgICAgICAgICAgICAgc2V0OiBOT09QXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBzaG91bGRDYWNoZUFjY2VzcyA9IHRydWU7XHJcbiAgaWYgKGNvbXB1dGVkT3B0aW9ucykge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gY29tcHV0ZWRPcHRpb25zKSB7XHJcbiAgICAgIGNvbnN0IG9wdCA9IGNvbXB1dGVkT3B0aW9uc1trZXldO1xyXG4gICAgICBjb25zdCBnZXQgPSBpc0Z1bmN0aW9uKG9wdCkgPyBvcHQuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKSA6IGlzRnVuY3Rpb24ob3B0LmdldCkgPyBvcHQuZ2V0LmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcykgOiBOT09QO1xyXG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBnZXQgPT09IE5PT1ApIHtcclxuICAgICAgICB3YXJuJDEoYENvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaGFzIG5vIGdldHRlci5gKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBzZXQgPSAhaXNGdW5jdGlvbihvcHQpICYmIGlzRnVuY3Rpb24ob3B0LnNldCkgPyBvcHQuc2V0LmJpbmQocHVibGljVGhpcykgOiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gKCkgPT4ge1xyXG4gICAgICAgIHdhcm4kMShcclxuICAgICAgICAgIGBXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIHJlYWRvbmx5LmBcclxuICAgICAgICApO1xyXG4gICAgICB9IDogTk9PUDtcclxuICAgICAgY29uc3QgYyA9IGNvbXB1dGVkKHtcclxuICAgICAgICBnZXQsXHJcbiAgICAgICAgc2V0XHJcbiAgICAgIH0pO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQ6ICgpID0+IGMudmFsdWUsXHJcbiAgICAgICAgc2V0OiAodikgPT4gYy52YWx1ZSA9IHZcclxuICAgICAgfSk7XHJcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiQ29tcHV0ZWRcIiAvKiBDT01QVVRFRCAqLywga2V5KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBpZiAod2F0Y2hPcHRpb25zKSB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB3YXRjaE9wdGlvbnMpIHtcclxuICAgICAgY3JlYXRlV2F0Y2hlcih3YXRjaE9wdGlvbnNba2V5XSwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAocHJvdmlkZU9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHByb3ZpZGVzID0gaXNGdW5jdGlvbihwcm92aWRlT3B0aW9ucykgPyBwcm92aWRlT3B0aW9ucy5jYWxsKHB1YmxpY1RoaXMpIDogcHJvdmlkZU9wdGlvbnM7XHJcbiAgICBSZWZsZWN0Lm93bktleXMocHJvdmlkZXMpLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICBwcm92aWRlKGtleSwgcHJvdmlkZXNba2V5XSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgaWYgKGNyZWF0ZWQpIHtcclxuICAgIGNhbGxIb29rKGNyZWF0ZWQsIGluc3RhbmNlLCBcImNcIik7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhyZWdpc3RlciwgaG9vaykge1xyXG4gICAgaWYgKGlzQXJyYXkoaG9vaykpIHtcclxuICAgICAgaG9vay5mb3JFYWNoKChfaG9vaykgPT4gcmVnaXN0ZXIoX2hvb2suYmluZChwdWJsaWNUaGlzKSkpO1xyXG4gICAgfSBlbHNlIGlmIChob29rKSB7XHJcbiAgICAgIHJlZ2lzdGVyKGhvb2suYmluZChwdWJsaWNUaGlzKSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZU1vdW50LCBiZWZvcmVNb3VudCk7XHJcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uTW91bnRlZCwgbW91bnRlZCk7XHJcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlVXBkYXRlLCBiZWZvcmVVcGRhdGUpO1xyXG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblVwZGF0ZWQsIHVwZGF0ZWQpO1xyXG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkFjdGl2YXRlZCwgYWN0aXZhdGVkKTtcclxuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25EZWFjdGl2YXRlZCwgZGVhY3RpdmF0ZWQpO1xyXG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkVycm9yQ2FwdHVyZWQsIGVycm9yQ2FwdHVyZWQpO1xyXG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblJlbmRlclRyYWNrZWQsIHJlbmRlclRyYWNrZWQpO1xyXG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblJlbmRlclRyaWdnZXJlZCwgcmVuZGVyVHJpZ2dlcmVkKTtcclxuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVVbm1vdW50LCBiZWZvcmVVbm1vdW50KTtcclxuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25Vbm1vdW50ZWQsIHVubW91bnRlZCk7XHJcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uU2VydmVyUHJlZmV0Y2gsIHNlcnZlclByZWZldGNoKTtcclxuICBpZiAoaXNBcnJheShleHBvc2UpKSB7XHJcbiAgICBpZiAoZXhwb3NlLmxlbmd0aCkge1xyXG4gICAgICBjb25zdCBleHBvc2VkID0gaW5zdGFuY2UuZXhwb3NlZCB8fCAoaW5zdGFuY2UuZXhwb3NlZCA9IHt9KTtcclxuICAgICAgZXhwb3NlLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvc2VkLCBrZXksIHtcclxuICAgICAgICAgIGdldDogKCkgPT4gcHVibGljVGhpc1trZXldLFxyXG4gICAgICAgICAgc2V0OiAodmFsKSA9PiBwdWJsaWNUaGlzW2tleV0gPSB2YWxcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2UgaWYgKCFpbnN0YW5jZS5leHBvc2VkKSB7XHJcbiAgICAgIGluc3RhbmNlLmV4cG9zZWQgPSB7fTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKHJlbmRlciAmJiBpbnN0YW5jZS5yZW5kZXIgPT09IE5PT1ApIHtcclxuICAgIGluc3RhbmNlLnJlbmRlciA9IHJlbmRlcjtcclxuICB9XHJcbiAgaWYgKGluaGVyaXRBdHRycyAhPSBudWxsKSB7XHJcbiAgICBpbnN0YW5jZS5pbmhlcml0QXR0cnMgPSBpbmhlcml0QXR0cnM7XHJcbiAgfVxyXG4gIGlmIChjb21wb25lbnRzKSBpbnN0YW5jZS5jb21wb25lbnRzID0gY29tcG9uZW50cztcclxuICBpZiAoZGlyZWN0aXZlcykgaW5zdGFuY2UuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XHJcbiAgaWYgKHNlcnZlclByZWZldGNoKSB7XHJcbiAgICBtYXJrQXN5bmNCb3VuZGFyeShpbnN0YW5jZSk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlc29sdmVJbmplY3Rpb25zKGluamVjdE9wdGlvbnMsIGN0eCwgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzID0gTk9PUCkge1xyXG4gIGlmIChpc0FycmF5KGluamVjdE9wdGlvbnMpKSB7XHJcbiAgICBpbmplY3RPcHRpb25zID0gbm9ybWFsaXplSW5qZWN0KGluamVjdE9wdGlvbnMpO1xyXG4gIH1cclxuICBmb3IgKGNvbnN0IGtleSBpbiBpbmplY3RPcHRpb25zKSB7XHJcbiAgICBjb25zdCBvcHQgPSBpbmplY3RPcHRpb25zW2tleV07XHJcbiAgICBsZXQgaW5qZWN0ZWQ7XHJcbiAgICBpZiAoaXNPYmplY3Qob3B0KSkge1xyXG4gICAgICBpZiAoXCJkZWZhdWx0XCIgaW4gb3B0KSB7XHJcbiAgICAgICAgaW5qZWN0ZWQgPSBpbmplY3QoXHJcbiAgICAgICAgICBvcHQuZnJvbSB8fCBrZXksXHJcbiAgICAgICAgICBvcHQuZGVmYXVsdCxcclxuICAgICAgICAgIHRydWVcclxuICAgICAgICApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGluamVjdGVkID0gaW5qZWN0KG9wdC5mcm9tIHx8IGtleSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGluamVjdGVkID0gaW5qZWN0KG9wdCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNSZWYoaW5qZWN0ZWQpKSB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGdldDogKCkgPT4gaW5qZWN0ZWQudmFsdWUsXHJcbiAgICAgICAgc2V0OiAodikgPT4gaW5qZWN0ZWQudmFsdWUgPSB2XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY3R4W2tleV0gPSBpbmplY3RlZDtcclxuICAgIH1cclxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkluamVjdFwiIC8qIElOSkVDVCAqLywga2V5KTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZnVuY3Rpb24gY2FsbEhvb2soaG9vaywgaW5zdGFuY2UsIHR5cGUpIHtcclxuICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcclxuICAgIGlzQXJyYXkoaG9vaykgPyBob29rLm1hcCgoaCkgPT4gaC5iaW5kKGluc3RhbmNlLnByb3h5KSkgOiBob29rLmJpbmQoaW5zdGFuY2UucHJveHkpLFxyXG4gICAgaW5zdGFuY2UsXHJcbiAgICB0eXBlXHJcbiAgKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyKHJhdywgY3R4LCBwdWJsaWNUaGlzLCBrZXkpIHtcclxuICBsZXQgZ2V0dGVyID0ga2V5LmluY2x1ZGVzKFwiLlwiKSA/IGNyZWF0ZVBhdGhHZXR0ZXIocHVibGljVGhpcywga2V5KSA6ICgpID0+IHB1YmxpY1RoaXNba2V5XTtcclxuICBpZiAoaXNTdHJpbmcocmF3KSkge1xyXG4gICAgY29uc3QgaGFuZGxlciA9IGN0eFtyYXddO1xyXG4gICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcclxuICAgICAge1xyXG4gICAgICAgIHdhdGNoKGdldHRlciwgaGFuZGxlcik7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICB3YXJuJDEoYEludmFsaWQgd2F0Y2ggaGFuZGxlciBzcGVjaWZpZWQgYnkga2V5IFwiJHtyYXd9XCJgLCBoYW5kbGVyKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocmF3KSkge1xyXG4gICAge1xyXG4gICAgICB3YXRjaChnZXR0ZXIsIHJhdy5iaW5kKHB1YmxpY1RoaXMpKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHJhdykpIHtcclxuICAgIGlmIChpc0FycmF5KHJhdykpIHtcclxuICAgICAgcmF3LmZvckVhY2goKHIpID0+IGNyZWF0ZVdhdGNoZXIociwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBpc0Z1bmN0aW9uKHJhdy5oYW5kbGVyKSA/IHJhdy5oYW5kbGVyLmJpbmQocHVibGljVGhpcykgOiBjdHhbcmF3LmhhbmRsZXJdO1xyXG4gICAgICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xyXG4gICAgICAgIHdhdGNoKGdldHRlciwgaGFuZGxlciwgcmF3KTtcclxuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgICAgd2FybiQxKGBJbnZhbGlkIHdhdGNoIGhhbmRsZXIgc3BlY2lmaWVkIGJ5IGtleSBcIiR7cmF3LmhhbmRsZXJ9XCJgLCBoYW5kbGVyKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgd2FybiQxKGBJbnZhbGlkIHdhdGNoIG9wdGlvbjogXCIke2tleX1cImAsIHJhdyk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKSB7XHJcbiAgY29uc3QgYmFzZSA9IGluc3RhbmNlLnR5cGU7XHJcbiAgY29uc3QgeyBtaXhpbnMsIGV4dGVuZHM6IGV4dGVuZHNPcHRpb25zIH0gPSBiYXNlO1xyXG4gIGNvbnN0IHtcclxuICAgIG1peGluczogZ2xvYmFsTWl4aW5zLFxyXG4gICAgb3B0aW9uc0NhY2hlOiBjYWNoZSxcclxuICAgIGNvbmZpZzogeyBvcHRpb25NZXJnZVN0cmF0ZWdpZXMgfVxyXG4gIH0gPSBpbnN0YW5jZS5hcHBDb250ZXh0O1xyXG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChiYXNlKTtcclxuICBsZXQgcmVzb2x2ZWQ7XHJcbiAgaWYgKGNhY2hlZCkge1xyXG4gICAgcmVzb2x2ZWQgPSBjYWNoZWQ7XHJcbiAgfSBlbHNlIGlmICghZ2xvYmFsTWl4aW5zLmxlbmd0aCAmJiAhbWl4aW5zICYmICFleHRlbmRzT3B0aW9ucykge1xyXG4gICAge1xyXG4gICAgICByZXNvbHZlZCA9IGJhc2U7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHJlc29sdmVkID0ge307XHJcbiAgICBpZiAoZ2xvYmFsTWl4aW5zLmxlbmd0aCkge1xyXG4gICAgICBnbG9iYWxNaXhpbnMuZm9yRWFjaChcclxuICAgICAgICAobSkgPT4gbWVyZ2VPcHRpb25zKHJlc29sdmVkLCBtLCBvcHRpb25NZXJnZVN0cmF0ZWdpZXMsIHRydWUpXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICBtZXJnZU9wdGlvbnMocmVzb2x2ZWQsIGJhc2UsIG9wdGlvbk1lcmdlU3RyYXRlZ2llcyk7XHJcbiAgfVxyXG4gIGlmIChpc09iamVjdChiYXNlKSkge1xyXG4gICAgY2FjaGUuc2V0KGJhc2UsIHJlc29sdmVkKTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc29sdmVkO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyh0bywgZnJvbSwgc3RyYXRzLCBhc01peGluID0gZmFsc2UpIHtcclxuICBjb25zdCB7IG1peGlucywgZXh0ZW5kczogZXh0ZW5kc09wdGlvbnMgfSA9IGZyb207XHJcbiAgaWYgKGV4dGVuZHNPcHRpb25zKSB7XHJcbiAgICBtZXJnZU9wdGlvbnModG8sIGV4dGVuZHNPcHRpb25zLCBzdHJhdHMsIHRydWUpO1xyXG4gIH1cclxuICBpZiAobWl4aW5zKSB7XHJcbiAgICBtaXhpbnMuZm9yRWFjaChcclxuICAgICAgKG0pID0+IG1lcmdlT3B0aW9ucyh0bywgbSwgc3RyYXRzLCB0cnVlKVxyXG4gICAgKTtcclxuICB9XHJcbiAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xyXG4gICAgaWYgKGFzTWl4aW4gJiYga2V5ID09PSBcImV4cG9zZVwiKSB7XHJcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKFxyXG4gICAgICAgIGBcImV4cG9zZVwiIG9wdGlvbiBpcyBpZ25vcmVkIHdoZW4gZGVjbGFyZWQgaW4gbWl4aW5zIG9yIGV4dGVuZHMuIEl0IHNob3VsZCBvbmx5IGJlIGRlY2xhcmVkIGluIHRoZSBiYXNlIGNvbXBvbmVudCBpdHNlbGYuYFxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3Qgc3RyYXQgPSBpbnRlcm5hbE9wdGlvbk1lcmdlU3RyYXRzW2tleV0gfHwgc3RyYXRzICYmIHN0cmF0c1trZXldO1xyXG4gICAgICB0b1trZXldID0gc3RyYXQgPyBzdHJhdCh0b1trZXldLCBmcm9tW2tleV0pIDogZnJvbVtrZXldO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdG87XHJcbn1cclxuY29uc3QgaW50ZXJuYWxPcHRpb25NZXJnZVN0cmF0cyA9IHtcclxuICBkYXRhOiBtZXJnZURhdGFGbixcclxuICBwcm9wczogbWVyZ2VFbWl0c09yUHJvcHNPcHRpb25zLFxyXG4gIGVtaXRzOiBtZXJnZUVtaXRzT3JQcm9wc09wdGlvbnMsXHJcbiAgLy8gb2JqZWN0c1xyXG4gIG1ldGhvZHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcclxuICBjb21wdXRlZDogbWVyZ2VPYmplY3RPcHRpb25zLFxyXG4gIC8vIGxpZmVjeWNsZVxyXG4gIGJlZm9yZUNyZWF0ZTogbWVyZ2VBc0FycmF5LFxyXG4gIGNyZWF0ZWQ6IG1lcmdlQXNBcnJheSxcclxuICBiZWZvcmVNb3VudDogbWVyZ2VBc0FycmF5LFxyXG4gIG1vdW50ZWQ6IG1lcmdlQXNBcnJheSxcclxuICBiZWZvcmVVcGRhdGU6IG1lcmdlQXNBcnJheSxcclxuICB1cGRhdGVkOiBtZXJnZUFzQXJyYXksXHJcbiAgYmVmb3JlRGVzdHJveTogbWVyZ2VBc0FycmF5LFxyXG4gIGJlZm9yZVVubW91bnQ6IG1lcmdlQXNBcnJheSxcclxuICBkZXN0cm95ZWQ6IG1lcmdlQXNBcnJheSxcclxuICB1bm1vdW50ZWQ6IG1lcmdlQXNBcnJheSxcclxuICBhY3RpdmF0ZWQ6IG1lcmdlQXNBcnJheSxcclxuICBkZWFjdGl2YXRlZDogbWVyZ2VBc0FycmF5LFxyXG4gIGVycm9yQ2FwdHVyZWQ6IG1lcmdlQXNBcnJheSxcclxuICBzZXJ2ZXJQcmVmZXRjaDogbWVyZ2VBc0FycmF5LFxyXG4gIC8vIGFzc2V0c1xyXG4gIGNvbXBvbmVudHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcclxuICBkaXJlY3RpdmVzOiBtZXJnZU9iamVjdE9wdGlvbnMsXHJcbiAgLy8gd2F0Y2hcclxuICB3YXRjaDogbWVyZ2VXYXRjaE9wdGlvbnMsXHJcbiAgLy8gcHJvdmlkZSAvIGluamVjdFxyXG4gIHByb3ZpZGU6IG1lcmdlRGF0YUZuLFxyXG4gIGluamVjdDogbWVyZ2VJbmplY3RcclxufTtcclxuZnVuY3Rpb24gbWVyZ2VEYXRhRm4odG8sIGZyb20pIHtcclxuICBpZiAoIWZyb20pIHtcclxuICAgIHJldHVybiB0bztcclxuICB9XHJcbiAgaWYgKCF0bykge1xyXG4gICAgcmV0dXJuIGZyb207XHJcbiAgfVxyXG4gIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4oKSB7XHJcbiAgICByZXR1cm4gKGV4dGVuZCkoXHJcbiAgICAgIGlzRnVuY3Rpb24odG8pID8gdG8uY2FsbCh0aGlzLCB0aGlzKSA6IHRvLFxyXG4gICAgICBpc0Z1bmN0aW9uKGZyb20pID8gZnJvbS5jYWxsKHRoaXMsIHRoaXMpIDogZnJvbVxyXG4gICAgKTtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlSW5qZWN0KHRvLCBmcm9tKSB7XHJcbiAgcmV0dXJuIG1lcmdlT2JqZWN0T3B0aW9ucyhub3JtYWxpemVJbmplY3QodG8pLCBub3JtYWxpemVJbmplY3QoZnJvbSkpO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdChyYXcpIHtcclxuICBpZiAoaXNBcnJheShyYXcpKSB7XHJcbiAgICBjb25zdCByZXMgPSB7fTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHJlc1tyYXdbaV1dID0gcmF3W2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxuICB9XHJcbiAgcmV0dXJuIHJhdztcclxufVxyXG5mdW5jdGlvbiBtZXJnZUFzQXJyYXkodG8sIGZyb20pIHtcclxuICByZXR1cm4gdG8gPyBbLi4ubmV3IFNldChbXS5jb25jYXQodG8sIGZyb20pKV0gOiBmcm9tO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlT2JqZWN0T3B0aW9ucyh0bywgZnJvbSkge1xyXG4gIHJldHVybiB0byA/IGV4dGVuZCgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdG8sIGZyb20pIDogZnJvbTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZUVtaXRzT3JQcm9wc09wdGlvbnModG8sIGZyb20pIHtcclxuICBpZiAodG8pIHtcclxuICAgIGlmIChpc0FycmF5KHRvKSAmJiBpc0FycmF5KGZyb20pKSB7XHJcbiAgICAgIHJldHVybiBbLi4uLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLnRvLCAuLi5mcm9tXSldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV4dGVuZChcclxuICAgICAgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksXHJcbiAgICAgIG5vcm1hbGl6ZVByb3BzT3JFbWl0cyh0byksXHJcbiAgICAgIG5vcm1hbGl6ZVByb3BzT3JFbWl0cyhmcm9tICE9IG51bGwgPyBmcm9tIDoge30pXHJcbiAgICApO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gZnJvbTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VXYXRjaE9wdGlvbnModG8sIGZyb20pIHtcclxuICBpZiAoIXRvKSByZXR1cm4gZnJvbTtcclxuICBpZiAoIWZyb20pIHJldHVybiB0bztcclxuICBjb25zdCBtZXJnZWQgPSBleHRlbmQoLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHRvKTtcclxuICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XHJcbiAgICBtZXJnZWRba2V5XSA9IG1lcmdlQXNBcnJheSh0b1trZXldLCBmcm9tW2tleV0pO1xyXG4gIH1cclxuICByZXR1cm4gbWVyZ2VkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVBcHBDb250ZXh0KCkge1xyXG4gIHJldHVybiB7XHJcbiAgICBhcHA6IG51bGwsXHJcbiAgICBjb25maWc6IHtcclxuICAgICAgaXNOYXRpdmVUYWc6IE5PLFxyXG4gICAgICBwZXJmb3JtYW5jZTogZmFsc2UsXHJcbiAgICAgIGdsb2JhbFByb3BlcnRpZXM6IHt9LFxyXG4gICAgICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IHt9LFxyXG4gICAgICBlcnJvckhhbmRsZXI6IHZvaWQgMCxcclxuICAgICAgd2FybkhhbmRsZXI6IHZvaWQgMCxcclxuICAgICAgY29tcGlsZXJPcHRpb25zOiB7fVxyXG4gICAgfSxcclxuICAgIG1peGluczogW10sXHJcbiAgICBjb21wb25lbnRzOiB7fSxcclxuICAgIGRpcmVjdGl2ZXM6IHt9LFxyXG4gICAgcHJvdmlkZXM6IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG4gICAgb3B0aW9uc0NhY2hlOiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSxcclxuICAgIHByb3BzQ2FjaGU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLFxyXG4gICAgZW1pdHNDYWNoZTogLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKClcclxuICB9O1xyXG59XHJcbmxldCB1aWQkMSA9IDA7XHJcbmZ1bmN0aW9uIGNyZWF0ZUFwcEFQSShyZW5kZXIsIGh5ZHJhdGUpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXBwKHJvb3RDb21wb25lbnQsIHJvb3RQcm9wcyA9IG51bGwpIHtcclxuICAgIGlmICghaXNGdW5jdGlvbihyb290Q29tcG9uZW50KSkge1xyXG4gICAgICByb290Q29tcG9uZW50ID0gZXh0ZW5kKHt9LCByb290Q29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIGlmIChyb290UHJvcHMgIT0gbnVsbCAmJiAhaXNPYmplY3Qocm9vdFByb3BzKSkge1xyXG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShgcm9vdCBwcm9wcyBwYXNzZWQgdG8gYXBwLm1vdW50KCkgbXVzdCBiZSBhbiBvYmplY3QuYCk7XHJcbiAgICAgIHJvb3RQcm9wcyA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQXBwQ29udGV4dCgpO1xyXG4gICAgY29uc3QgaW5zdGFsbGVkUGx1Z2lucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xyXG4gICAgY29uc3QgcGx1Z2luQ2xlYW51cEZucyA9IFtdO1xyXG4gICAgbGV0IGlzTW91bnRlZCA9IGZhbHNlO1xyXG4gICAgY29uc3QgYXBwID0gY29udGV4dC5hcHAgPSB7XHJcbiAgICAgIF91aWQ6IHVpZCQxKyssXHJcbiAgICAgIF9jb21wb25lbnQ6IHJvb3RDb21wb25lbnQsXHJcbiAgICAgIF9wcm9wczogcm9vdFByb3BzLFxyXG4gICAgICBfY29udGFpbmVyOiBudWxsLFxyXG4gICAgICBfY29udGV4dDogY29udGV4dCxcclxuICAgICAgX2luc3RhbmNlOiBudWxsLFxyXG4gICAgICB2ZXJzaW9uLFxyXG4gICAgICBnZXQgY29uZmlnKCkge1xyXG4gICAgICAgIHJldHVybiBjb250ZXh0LmNvbmZpZztcclxuICAgICAgfSxcclxuICAgICAgc2V0IGNvbmZpZyh2KSB7XHJcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgICAgIHdhcm4kMShcclxuICAgICAgICAgICAgYGFwcC5jb25maWcgY2Fubm90IGJlIHJlcGxhY2VkLiBNb2RpZnkgaW5kaXZpZHVhbCBvcHRpb25zIGluc3RlYWQuYFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHVzZShwbHVnaW4sIC4uLm9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5oYXMocGx1Z2luKSkge1xyXG4gICAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoYFBsdWdpbiBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgdG8gdGFyZ2V0IGFwcC5gKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHBsdWdpbiAmJiBpc0Z1bmN0aW9uKHBsdWdpbi5pbnN0YWxsKSkge1xyXG4gICAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5hZGQocGx1Z2luKTtcclxuICAgICAgICAgIHBsdWdpbi5pbnN0YWxsKGFwcCwgLi4ub3B0aW9ucyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHBsdWdpbikpIHtcclxuICAgICAgICAgIGluc3RhbGxlZFBsdWdpbnMuYWRkKHBsdWdpbik7XHJcbiAgICAgICAgICBwbHVnaW4oYXBwLCAuLi5vcHRpb25zKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgICAgIHdhcm4kMShcclxuICAgICAgICAgICAgYEEgcGx1Z2luIG11c3QgZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0IHdpdGggYW4gXCJpbnN0YWxsXCIgZnVuY3Rpb24uYFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFwcDtcclxuICAgICAgfSxcclxuICAgICAgbWl4aW4obWl4aW4pIHtcclxuICAgICAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXykge1xyXG4gICAgICAgICAgaWYgKCFjb250ZXh0Lm1peGlucy5pbmNsdWRlcyhtaXhpbikpIHtcclxuICAgICAgICAgICAgY29udGV4dC5taXhpbnMucHVzaChtaXhpbik7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgICAgICAgd2FybiQxKFxyXG4gICAgICAgICAgICAgIFwiTWl4aW4gaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIHRvIHRhcmdldCBhcHBcIiArIChtaXhpbi5uYW1lID8gYDogJHttaXhpbi5uYW1lfWAgOiBcIlwiKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICAgICAgd2FybiQxKFwiTWl4aW5zIGFyZSBvbmx5IGF2YWlsYWJsZSBpbiBidWlsZHMgc3VwcG9ydGluZyBPcHRpb25zIEFQSVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFwcDtcclxuICAgICAgfSxcclxuICAgICAgY29tcG9uZW50KG5hbWUsIGNvbXBvbmVudCkge1xyXG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSwgY29udGV4dC5jb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xyXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY29udGV4dC5jb21wb25lbnRzW25hbWVdKSB7XHJcbiAgICAgICAgICB3YXJuJDEoYENvbXBvbmVudCBcIiR7bmFtZX1cIiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgaW4gdGFyZ2V0IGFwcC5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGV4dC5jb21wb25lbnRzW25hbWVdID0gY29tcG9uZW50O1xyXG4gICAgICAgIHJldHVybiBhcHA7XHJcbiAgICAgIH0sXHJcbiAgICAgIGRpcmVjdGl2ZShuYW1lLCBkaXJlY3RpdmUpIHtcclxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICAgICAgdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWRpcmVjdGl2ZSkge1xyXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY29udGV4dC5kaXJlY3RpdmVzW25hbWVdKSB7XHJcbiAgICAgICAgICB3YXJuJDEoYERpcmVjdGl2ZSBcIiR7bmFtZX1cIiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgaW4gdGFyZ2V0IGFwcC5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGV4dC5kaXJlY3RpdmVzW25hbWVdID0gZGlyZWN0aXZlO1xyXG4gICAgICAgIHJldHVybiBhcHA7XHJcbiAgICAgIH0sXHJcbiAgICAgIG1vdW50KHJvb3RDb250YWluZXIsIGlzSHlkcmF0ZSwgbmFtZXNwYWNlKSB7XHJcbiAgICAgICAgaWYgKCFpc01vdW50ZWQpIHtcclxuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHJvb3RDb250YWluZXIuX192dWVfYXBwX18pIHtcclxuICAgICAgICAgICAgd2FybiQxKFxyXG4gICAgICAgICAgICAgIGBUaGVyZSBpcyBhbHJlYWR5IGFuIGFwcCBpbnN0YW5jZSBtb3VudGVkIG9uIHRoZSBob3N0IGNvbnRhaW5lci5cclxuIElmIHlvdSB3YW50IHRvIG1vdW50IGFub3RoZXIgYXBwIG9uIHRoZSBzYW1lIGhvc3QgY29udGFpbmVyLCB5b3UgbmVlZCB0byB1bm1vdW50IHRoZSBwcmV2aW91cyBhcHAgYnkgY2FsbGluZyBcXGBhcHAudW5tb3VudCgpXFxgIGZpcnN0LmBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNvbnN0IHZub2RlID0gYXBwLl9jZVZOb2RlIHx8IGNyZWF0ZVZOb2RlKHJvb3RDb21wb25lbnQsIHJvb3RQcm9wcyk7XHJcbiAgICAgICAgICB2bm9kZS5hcHBDb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICAgIGlmIChuYW1lc3BhY2UgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgbmFtZXNwYWNlID0gXCJzdmdcIjtcclxuICAgICAgICAgIH0gZWxzZSBpZiAobmFtZXNwYWNlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBuYW1lc3BhY2UgPSB2b2lkIDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICAgICAgICBjb250ZXh0LnJlbG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICByZW5kZXIoXHJcbiAgICAgICAgICAgICAgICBjbG9uZVZOb2RlKHZub2RlKSxcclxuICAgICAgICAgICAgICAgIHJvb3RDb250YWluZXIsXHJcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGlzSHlkcmF0ZSAmJiBoeWRyYXRlKSB7XHJcbiAgICAgICAgICAgIGh5ZHJhdGUodm5vZGUsIHJvb3RDb250YWluZXIpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVuZGVyKHZub2RlLCByb290Q29udGFpbmVyLCBuYW1lc3BhY2UpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaXNNb3VudGVkID0gdHJ1ZTtcclxuICAgICAgICAgIGFwcC5fY29udGFpbmVyID0gcm9vdENvbnRhaW5lcjtcclxuICAgICAgICAgIHJvb3RDb250YWluZXIuX192dWVfYXBwX18gPSBhcHA7XHJcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgYXBwLl9pbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgZGV2dG9vbHNJbml0QXBwKGFwcCwgdmVyc2lvbik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50UHVibGljSW5zdGFuY2Uodm5vZGUuY29tcG9uZW50KTtcclxuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgICAgIHdhcm4kMShcclxuICAgICAgICAgICAgYEFwcCBoYXMgYWxyZWFkeSBiZWVuIG1vdW50ZWQuXHJcbklmIHlvdSB3YW50IHRvIHJlbW91bnQgdGhlIHNhbWUgYXBwLCBtb3ZlIHlvdXIgYXBwIGNyZWF0aW9uIGxvZ2ljIGludG8gYSBmYWN0b3J5IGZ1bmN0aW9uIGFuZCBjcmVhdGUgZnJlc2ggYXBwIGluc3RhbmNlcyBmb3IgZWFjaCBtb3VudCAtIGUuZy4gXFxgY29uc3QgY3JlYXRlTXlBcHAgPSAoKSA9PiBjcmVhdGVBcHAoQXBwKVxcYGBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBvblVubW91bnQoY2xlYW51cEZuKSB7XHJcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdHlwZW9mIGNsZWFudXBGbiAhPT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICB3YXJuJDEoXHJcbiAgICAgICAgICAgIGBFeHBlY3RlZCBmdW5jdGlvbiBhcyBmaXJzdCBhcmd1bWVudCB0byBhcHAub25Vbm1vdW50KCksIGJ1dCBnb3QgJHt0eXBlb2YgY2xlYW51cEZufWBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBsdWdpbkNsZWFudXBGbnMucHVzaChjbGVhbnVwRm4pO1xyXG4gICAgICB9LFxyXG4gICAgICB1bm1vdW50KCkge1xyXG4gICAgICAgIGlmIChpc01vdW50ZWQpIHtcclxuICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxyXG4gICAgICAgICAgICBwbHVnaW5DbGVhbnVwRm5zLFxyXG4gICAgICAgICAgICBhcHAuX2luc3RhbmNlLFxyXG4gICAgICAgICAgICAxNlxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIHJlbmRlcihudWxsLCBhcHAuX2NvbnRhaW5lcik7XHJcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgYXBwLl9pbnN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGRldnRvb2xzVW5tb3VudEFwcChhcHApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZGVsZXRlIGFwcC5fY29udGFpbmVyLl9fdnVlX2FwcF9fO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICAgICAgd2FybiQxKGBDYW5ub3QgdW5tb3VudCBhbiBhcHAgdGhhdCBpcyBub3QgbW91bnRlZC5gKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHByb3ZpZGUoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGtleSBpbiBjb250ZXh0LnByb3ZpZGVzKSB7XHJcbiAgICAgICAgICB3YXJuJDEoXHJcbiAgICAgICAgICAgIGBBcHAgYWxyZWFkeSBwcm92aWRlcyBwcm9wZXJ0eSB3aXRoIGtleSBcIiR7U3RyaW5nKGtleSl9XCIuIEl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCB0aGUgbmV3IHZhbHVlLmBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRleHQucHJvdmlkZXNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiBhcHA7XHJcbiAgICAgIH0sXHJcbiAgICAgIHJ1bldpdGhDb250ZXh0KGZuKSB7XHJcbiAgICAgICAgY29uc3QgbGFzdEFwcCA9IGN1cnJlbnRBcHA7XHJcbiAgICAgICAgY3VycmVudEFwcCA9IGFwcDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgIGN1cnJlbnRBcHAgPSBsYXN0QXBwO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBhcHA7XHJcbiAgfTtcclxufVxyXG5sZXQgY3VycmVudEFwcCA9IG51bGw7XHJcblxyXG5mdW5jdGlvbiBwcm92aWRlKGtleSwgdmFsdWUpIHtcclxuICBpZiAoIWN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgd2FybiQxKGBwcm92aWRlKCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKS5gKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgbGV0IHByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnByb3ZpZGVzO1xyXG4gICAgY29uc3QgcGFyZW50UHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucGFyZW50ICYmIGN1cnJlbnRJbnN0YW5jZS5wYXJlbnQucHJvdmlkZXM7XHJcbiAgICBpZiAocGFyZW50UHJvdmlkZXMgPT09IHByb3ZpZGVzKSB7XHJcbiAgICAgIHByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnByb3ZpZGVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRQcm92aWRlcyk7XHJcbiAgICB9XHJcbiAgICBwcm92aWRlc1trZXldID0gdmFsdWU7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGluamVjdChrZXksIGRlZmF1bHRWYWx1ZSwgdHJlYXREZWZhdWx0QXNGYWN0b3J5ID0gZmFsc2UpIHtcclxuICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XHJcbiAgaWYgKGluc3RhbmNlIHx8IGN1cnJlbnRBcHApIHtcclxuICAgIGNvbnN0IHByb3ZpZGVzID0gY3VycmVudEFwcCA/IGN1cnJlbnRBcHAuX2NvbnRleHQucHJvdmlkZXMgOiBpbnN0YW5jZSA/IGluc3RhbmNlLnBhcmVudCA9PSBudWxsID8gaW5zdGFuY2Uudm5vZGUuYXBwQ29udGV4dCAmJiBpbnN0YW5jZS52bm9kZS5hcHBDb250ZXh0LnByb3ZpZGVzIDogaW5zdGFuY2UucGFyZW50LnByb3ZpZGVzIDogdm9pZCAwO1xyXG4gICAgaWYgKHByb3ZpZGVzICYmIGtleSBpbiBwcm92aWRlcykge1xyXG4gICAgICByZXR1cm4gcHJvdmlkZXNba2V5XTtcclxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgcmV0dXJuIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSkgPyBkZWZhdWx0VmFsdWUuY2FsbChpbnN0YW5jZSAmJiBpbnN0YW5jZS5wcm94eSkgOiBkZWZhdWx0VmFsdWU7XHJcbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgd2FybiQxKGBpbmplY3Rpb24gXCIke1N0cmluZyhrZXkpfVwiIG5vdCBmb3VuZC5gKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgIHdhcm4kMShgaW5qZWN0KCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKSBvciBmdW5jdGlvbmFsIGNvbXBvbmVudHMuYCk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGhhc0luamVjdGlvbkNvbnRleHQoKSB7XHJcbiAgcmV0dXJuICEhKGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfHwgY3VycmVudEFwcCk7XHJcbn1cclxuXHJcbmNvbnN0IGludGVybmFsT2JqZWN0UHJvdG8gPSB7fTtcclxuY29uc3QgY3JlYXRlSW50ZXJuYWxPYmplY3QgPSAoKSA9PiBPYmplY3QuY3JlYXRlKGludGVybmFsT2JqZWN0UHJvdG8pO1xyXG5jb25zdCBpc0ludGVybmFsT2JqZWN0ID0gKG9iaikgPT4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IGludGVybmFsT2JqZWN0UHJvdG87XHJcblxyXG5mdW5jdGlvbiBpbml0UHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBpc1N0YXRlZnVsLCBpc1NTUiA9IGZhbHNlKSB7XHJcbiAgY29uc3QgcHJvcHMgPSB7fTtcclxuICBjb25zdCBhdHRycyA9IGNyZWF0ZUludGVybmFsT2JqZWN0KCk7XHJcbiAgaW5zdGFuY2UucHJvcHNEZWZhdWx0cyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gIHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycyk7XHJcbiAgZm9yIChjb25zdCBrZXkgaW4gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdKSB7XHJcbiAgICBpZiAoIShrZXkgaW4gcHJvcHMpKSB7XHJcbiAgICAgIHByb3BzW2tleV0gPSB2b2lkIDA7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzIHx8IHt9LCBwcm9wcywgaW5zdGFuY2UpO1xyXG4gIH1cclxuICBpZiAoaXNTdGF0ZWZ1bCkge1xyXG4gICAgaW5zdGFuY2UucHJvcHMgPSBpc1NTUiA/IHByb3BzIDogc2hhbGxvd1JlYWN0aXZlKHByb3BzKTtcclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKCFpbnN0YW5jZS50eXBlLnByb3BzKSB7XHJcbiAgICAgIGluc3RhbmNlLnByb3BzID0gYXR0cnM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpbnN0YW5jZS5wcm9wcyA9IHByb3BzO1xyXG4gICAgfVxyXG4gIH1cclxuICBpbnN0YW5jZS5hdHRycyA9IGF0dHJzO1xyXG59XHJcbmZ1bmN0aW9uIGlzSW5IbXJDb250ZXh0KGluc3RhbmNlKSB7XHJcbiAgd2hpbGUgKGluc3RhbmNlKSB7XHJcbiAgICBpZiAoaW5zdGFuY2UudHlwZS5fX2htcklkKSByZXR1cm4gdHJ1ZTtcclxuICAgIGluc3RhbmNlID0gaW5zdGFuY2UucGFyZW50O1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiB1cGRhdGVQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHJhd1ByZXZQcm9wcywgb3B0aW1pemVkKSB7XHJcbiAgY29uc3Qge1xyXG4gICAgcHJvcHMsXHJcbiAgICBhdHRycyxcclxuICAgIHZub2RlOiB7IHBhdGNoRmxhZyB9XHJcbiAgfSA9IGluc3RhbmNlO1xyXG4gIGNvbnN0IHJhd0N1cnJlbnRQcm9wcyA9IHRvUmF3KHByb3BzKTtcclxuICBjb25zdCBbb3B0aW9uc10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XHJcbiAgbGV0IGhhc0F0dHJzQ2hhbmdlZCA9IGZhbHNlO1xyXG4gIGlmIChcclxuICAgIC8vIGFsd2F5cyBmb3JjZSBmdWxsIGRpZmYgaW4gZGV2XHJcbiAgICAvLyAtICMxOTQyIGlmIGhtciBpcyBlbmFibGVkIHdpdGggc2ZjIGNvbXBvbmVudFxyXG4gICAgLy8gLSB2aXRlIzg3MiBub24tc2ZjIGNvbXBvbmVudCB1c2VkIGJ5IHNmYyBjb21wb25lbnRcclxuICAgICEoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0luSG1yQ29udGV4dChpbnN0YW5jZSkpICYmIChvcHRpbWl6ZWQgfHwgcGF0Y2hGbGFnID4gMCkgJiYgIShwYXRjaEZsYWcgJiAxNilcclxuICApIHtcclxuICAgIGlmIChwYXRjaEZsYWcgJiA4KSB7XHJcbiAgICAgIGNvbnN0IHByb3BzVG9VcGRhdGUgPSBpbnN0YW5jZS52bm9kZS5keW5hbWljUHJvcHM7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBrZXkgPSBwcm9wc1RvVXBkYXRlW2ldO1xyXG4gICAgICAgIGlmIChpc0VtaXRMaXN0ZW5lcihpbnN0YW5jZS5lbWl0c09wdGlvbnMsIGtleSkpIHtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHJhd1Byb3BzW2tleV07XHJcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgIGlmIChoYXNPd24oYXR0cnMsIGtleSkpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBhdHRyc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhbWVsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XHJcbiAgICAgICAgICAgIHByb3BzW2NhbWVsaXplZEtleV0gPSByZXNvbHZlUHJvcFZhbHVlKFxyXG4gICAgICAgICAgICAgIG9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgcmF3Q3VycmVudFByb3BzLFxyXG4gICAgICAgICAgICAgIGNhbWVsaXplZEtleSxcclxuICAgICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgICBpbnN0YW5jZSxcclxuICAgICAgICAgICAgICBmYWxzZVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAodmFsdWUgIT09IGF0dHJzW2tleV0pIHtcclxuICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKSkge1xyXG4gICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgbGV0IGtlYmFiS2V5O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmF3Q3VycmVudFByb3BzKSB7XHJcbiAgICAgIGlmICghcmF3UHJvcHMgfHwgLy8gZm9yIGNhbWVsQ2FzZVxyXG4gICAgICAhaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmIC8vIGl0J3MgcG9zc2libGUgdGhlIG9yaWdpbmFsIHByb3BzIHdhcyBwYXNzZWQgaW4gYXMga2ViYWItY2FzZVxyXG4gICAgICAvLyBhbmQgY29udmVydGVkIHRvIGNhbWVsQ2FzZSAoIzk1NSlcclxuICAgICAgKChrZWJhYktleSA9IGh5cGhlbmF0ZShrZXkpKSA9PT0ga2V5IHx8ICFoYXNPd24ocmF3UHJvcHMsIGtlYmFiS2V5KSkpIHtcclxuICAgICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgICAgaWYgKHJhd1ByZXZQcm9wcyAmJiAvLyBmb3IgY2FtZWxDYXNlXHJcbiAgICAgICAgICAocmF3UHJldlByb3BzW2tleV0gIT09IHZvaWQgMCB8fCAvLyBmb3Iga2ViYWItY2FzZVxyXG4gICAgICAgICAgcmF3UHJldlByb3BzW2tlYmFiS2V5XSAhPT0gdm9pZCAwKSkge1xyXG4gICAgICAgICAgICBwcm9wc1trZXldID0gcmVzb2x2ZVByb3BWYWx1ZShcclxuICAgICAgICAgICAgICBvcHRpb25zLFxyXG4gICAgICAgICAgICAgIHJhd0N1cnJlbnRQcm9wcyxcclxuICAgICAgICAgICAgICBrZXksXHJcbiAgICAgICAgICAgICAgdm9pZCAwLFxyXG4gICAgICAgICAgICAgIGluc3RhbmNlLFxyXG4gICAgICAgICAgICAgIHRydWVcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZGVsZXRlIHByb3BzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYXR0cnMgIT09IHJhd0N1cnJlbnRQcm9wcykge1xyXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xyXG4gICAgICAgIGlmICghcmF3UHJvcHMgfHwgIWhhc093bihyYXdQcm9wcywga2V5KSAmJiB0cnVlKSB7XHJcbiAgICAgICAgICBkZWxldGUgYXR0cnNba2V5XTtcclxuICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChoYXNBdHRyc0NoYW5nZWQpIHtcclxuICAgIHRyaWdnZXIoaW5zdGFuY2UuYXR0cnMsIFwic2V0XCIsIFwiXCIpO1xyXG4gIH1cclxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgdmFsaWRhdGVQcm9wcyhyYXdQcm9wcyB8fCB7fSwgcHJvcHMsIGluc3RhbmNlKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKSB7XHJcbiAgY29uc3QgW29wdGlvbnMsIG5lZWRDYXN0S2V5c10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XHJcbiAgbGV0IGhhc0F0dHJzQ2hhbmdlZCA9IGZhbHNlO1xyXG4gIGxldCByYXdDYXN0VmFsdWVzO1xyXG4gIGlmIChyYXdQcm9wcykge1xyXG4gICAgZm9yIChsZXQga2V5IGluIHJhd1Byb3BzKSB7XHJcbiAgICAgIGlmIChpc1Jlc2VydmVkUHJvcChrZXkpKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgdmFsdWUgPSByYXdQcm9wc1trZXldO1xyXG4gICAgICBsZXQgY2FtZWxLZXk7XHJcbiAgICAgIGlmIChvcHRpb25zICYmIGhhc093bihvcHRpb25zLCBjYW1lbEtleSA9IGNhbWVsaXplKGtleSkpKSB7XHJcbiAgICAgICAgaWYgKCFuZWVkQ2FzdEtleXMgfHwgIW5lZWRDYXN0S2V5cy5pbmNsdWRlcyhjYW1lbEtleSkpIHtcclxuICAgICAgICAgIHByb3BzW2NhbWVsS2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAocmF3Q2FzdFZhbHVlcyB8fCAocmF3Q2FzdFZhbHVlcyA9IHt9KSlbY2FtZWxLZXldID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKCFpc0VtaXRMaXN0ZW5lcihpbnN0YW5jZS5lbWl0c09wdGlvbnMsIGtleSkpIHtcclxuICAgICAgICBpZiAoIShrZXkgaW4gYXR0cnMpIHx8IHZhbHVlICE9PSBhdHRyc1trZXldKSB7XHJcbiAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBpZiAobmVlZENhc3RLZXlzKSB7XHJcbiAgICBjb25zdCByYXdDdXJyZW50UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XHJcbiAgICBjb25zdCBjYXN0VmFsdWVzID0gcmF3Q2FzdFZhbHVlcyB8fCBFTVBUWV9PQko7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5lZWRDYXN0S2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBrZXkgPSBuZWVkQ2FzdEtleXNbaV07XHJcbiAgICAgIHByb3BzW2tleV0gPSByZXNvbHZlUHJvcFZhbHVlKFxyXG4gICAgICAgIG9wdGlvbnMsXHJcbiAgICAgICAgcmF3Q3VycmVudFByb3BzLFxyXG4gICAgICAgIGtleSxcclxuICAgICAgICBjYXN0VmFsdWVzW2tleV0sXHJcbiAgICAgICAgaW5zdGFuY2UsXHJcbiAgICAgICAgIWhhc093bihjYXN0VmFsdWVzLCBrZXkpXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBoYXNBdHRyc0NoYW5nZWQ7XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZVByb3BWYWx1ZShvcHRpb25zLCBwcm9wcywga2V5LCB2YWx1ZSwgaW5zdGFuY2UsIGlzQWJzZW50KSB7XHJcbiAgY29uc3Qgb3B0ID0gb3B0aW9uc1trZXldO1xyXG4gIGlmIChvcHQgIT0gbnVsbCkge1xyXG4gICAgY29uc3QgaGFzRGVmYXVsdCA9IGhhc093bihvcHQsIFwiZGVmYXVsdFwiKTtcclxuICAgIGlmIChoYXNEZWZhdWx0ICYmIHZhbHVlID09PSB2b2lkIDApIHtcclxuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gb3B0LmRlZmF1bHQ7XHJcbiAgICAgIGlmIChvcHQudHlwZSAhPT0gRnVuY3Rpb24gJiYgIW9wdC5za2lwRmFjdG9yeSAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSkpIHtcclxuICAgICAgICBjb25zdCB7IHByb3BzRGVmYXVsdHMgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgIGlmIChrZXkgaW4gcHJvcHNEZWZhdWx0cykge1xyXG4gICAgICAgICAgdmFsdWUgPSBwcm9wc0RlZmF1bHRzW2tleV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnN0IHJlc2V0ID0gc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcclxuICAgICAgICAgIHZhbHVlID0gcHJvcHNEZWZhdWx0c1trZXldID0gZGVmYXVsdFZhbHVlLmNhbGwoXHJcbiAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgIHByb3BzXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgcmVzZXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGluc3RhbmNlLmNlKSB7XHJcbiAgICAgICAgaW5zdGFuY2UuY2UuX3NldFByb3Aoa2V5LCB2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChvcHRbMCAvKiBzaG91bGRDYXN0ICovXSkge1xyXG4gICAgICBpZiAoaXNBYnNlbnQgJiYgIWhhc0RlZmF1bHQpIHtcclxuICAgICAgICB2YWx1ZSA9IGZhbHNlO1xyXG4gICAgICB9IGVsc2UgaWYgKG9wdFsxIC8qIHNob3VsZENhc3RUcnVlICovXSAmJiAodmFsdWUgPT09IFwiXCIgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xyXG4gICAgICAgIHZhbHVlID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdmFsdWU7XHJcbn1cclxuY29uc3QgbWl4aW5Qcm9wc0NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzT3B0aW9ucyhjb21wLCBhcHBDb250ZXh0LCBhc01peGluID0gZmFsc2UpIHtcclxuICBjb25zdCBjYWNoZSA9IF9fVlVFX09QVElPTlNfQVBJX18gJiYgYXNNaXhpbiA/IG1peGluUHJvcHNDYWNoZSA6IGFwcENvbnRleHQucHJvcHNDYWNoZTtcclxuICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoY29tcCk7XHJcbiAgaWYgKGNhY2hlZCkge1xyXG4gICAgcmV0dXJuIGNhY2hlZDtcclxuICB9XHJcbiAgY29uc3QgcmF3ID0gY29tcC5wcm9wcztcclxuICBjb25zdCBub3JtYWxpemVkID0ge307XHJcbiAgY29uc3QgbmVlZENhc3RLZXlzID0gW107XHJcbiAgbGV0IGhhc0V4dGVuZHMgPSBmYWxzZTtcclxuICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xyXG4gICAgY29uc3QgZXh0ZW5kUHJvcHMgPSAocmF3MikgPT4ge1xyXG4gICAgICBoYXNFeHRlbmRzID0gdHJ1ZTtcclxuICAgICAgY29uc3QgW3Byb3BzLCBrZXlzXSA9IG5vcm1hbGl6ZVByb3BzT3B0aW9ucyhyYXcyLCBhcHBDb250ZXh0LCB0cnVlKTtcclxuICAgICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIHByb3BzKTtcclxuICAgICAgaWYgKGtleXMpIG5lZWRDYXN0S2V5cy5wdXNoKC4uLmtleXMpO1xyXG4gICAgfTtcclxuICAgIGlmICghYXNNaXhpbiAmJiBhcHBDb250ZXh0Lm1peGlucy5sZW5ndGgpIHtcclxuICAgICAgYXBwQ29udGV4dC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XHJcbiAgICB9XHJcbiAgICBpZiAoY29tcC5leHRlbmRzKSB7XHJcbiAgICAgIGV4dGVuZFByb3BzKGNvbXAuZXh0ZW5kcyk7XHJcbiAgICB9XHJcbiAgICBpZiAoY29tcC5taXhpbnMpIHtcclxuICAgICAgY29tcC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmICghcmF3ICYmICFoYXNFeHRlbmRzKSB7XHJcbiAgICBpZiAoaXNPYmplY3QoY29tcCkpIHtcclxuICAgICAgY2FjaGUuc2V0KGNvbXAsIEVNUFRZX0FSUik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRU1QVFlfQVJSO1xyXG4gIH1cclxuICBpZiAoaXNBcnJheShyYXcpKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNTdHJpbmcocmF3W2ldKSkge1xyXG4gICAgICAgIHdhcm4kMShgcHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LmAsIHJhd1tpXSk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGNhbWVsaXplKHJhd1tpXSk7XHJcbiAgICAgIGlmICh2YWxpZGF0ZVByb3BOYW1lKG5vcm1hbGl6ZWRLZXkpKSB7XHJcbiAgICAgICAgbm9ybWFsaXplZFtub3JtYWxpemVkS2V5XSA9IEVNUFRZX09CSjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAocmF3KSB7XHJcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNPYmplY3QocmF3KSkge1xyXG4gICAgICB3YXJuJDEoYGludmFsaWQgcHJvcHMgb3B0aW9uc2AsIHJhdyk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiByYXcpIHtcclxuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XHJcbiAgICAgIGlmICh2YWxpZGF0ZVByb3BOYW1lKG5vcm1hbGl6ZWRLZXkpKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0ID0gcmF3W2tleV07XHJcbiAgICAgICAgY29uc3QgcHJvcCA9IG5vcm1hbGl6ZWRbbm9ybWFsaXplZEtleV0gPSBpc0FycmF5KG9wdCkgfHwgaXNGdW5jdGlvbihvcHQpID8geyB0eXBlOiBvcHQgfSA6IGV4dGVuZCh7fSwgb3B0KTtcclxuICAgICAgICBjb25zdCBwcm9wVHlwZSA9IHByb3AudHlwZTtcclxuICAgICAgICBsZXQgc2hvdWxkQ2FzdCA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBzaG91bGRDYXN0VHJ1ZSA9IHRydWU7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkocHJvcFR5cGUpKSB7XHJcbiAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcHJvcFR5cGUubGVuZ3RoOyArK2luZGV4KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBwcm9wVHlwZVtpbmRleF07XHJcbiAgICAgICAgICAgIGNvbnN0IHR5cGVOYW1lID0gaXNGdW5jdGlvbih0eXBlKSAmJiB0eXBlLm5hbWU7XHJcbiAgICAgICAgICAgIGlmICh0eXBlTmFtZSA9PT0gXCJCb29sZWFuXCIpIHtcclxuICAgICAgICAgICAgICBzaG91bGRDYXN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlTmFtZSA9PT0gXCJTdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgIHNob3VsZENhc3RUcnVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc2hvdWxkQ2FzdCA9IGlzRnVuY3Rpb24ocHJvcFR5cGUpICYmIHByb3BUeXBlLm5hbWUgPT09IFwiQm9vbGVhblwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm9wWzAgLyogc2hvdWxkQ2FzdCAqL10gPSBzaG91bGRDYXN0O1xyXG4gICAgICAgIHByb3BbMSAvKiBzaG91bGRDYXN0VHJ1ZSAqL10gPSBzaG91bGRDYXN0VHJ1ZTtcclxuICAgICAgICBpZiAoc2hvdWxkQ2FzdCB8fCBoYXNPd24ocHJvcCwgXCJkZWZhdWx0XCIpKSB7XHJcbiAgICAgICAgICBuZWVkQ2FzdEtleXMucHVzaChub3JtYWxpemVkS2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgY29uc3QgcmVzID0gW25vcm1hbGl6ZWQsIG5lZWRDYXN0S2V5c107XHJcbiAgaWYgKGlzT2JqZWN0KGNvbXApKSB7XHJcbiAgICBjYWNoZS5zZXQoY29tcCwgcmVzKTtcclxuICB9XHJcbiAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BOYW1lKGtleSkge1xyXG4gIGlmIChrZXlbMF0gIT09IFwiJFwiICYmICFpc1Jlc2VydmVkUHJvcChrZXkpKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgIHdhcm4kMShgSW52YWxpZCBwcm9wIG5hbWU6IFwiJHtrZXl9XCIgaXMgYSByZXNlcnZlZCBwcm9wZXJ0eS5gKTtcclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGdldFR5cGUoY3Rvcikge1xyXG4gIGlmIChjdG9yID09PSBudWxsKSB7XHJcbiAgICByZXR1cm4gXCJudWxsXCI7XHJcbiAgfVxyXG4gIGlmICh0eXBlb2YgY3RvciA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICByZXR1cm4gY3Rvci5uYW1lIHx8IFwiXCI7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgY3RvciA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgY29uc3QgbmFtZSA9IGN0b3IuY29uc3RydWN0b3IgJiYgY3Rvci5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgcmV0dXJuIG5hbWUgfHwgXCJcIjtcclxuICB9XHJcbiAgcmV0dXJuIFwiXCI7XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhyYXdQcm9wcywgcHJvcHMsIGluc3RhbmNlKSB7XHJcbiAgY29uc3QgcmVzb2x2ZWRWYWx1ZXMgPSB0b1Jhdyhwcm9wcyk7XHJcbiAgY29uc3Qgb3B0aW9ucyA9IGluc3RhbmNlLnByb3BzT3B0aW9uc1swXTtcclxuICBjb25zdCBjYW1lbGl6ZVByb3BzS2V5ID0gT2JqZWN0LmtleXMocmF3UHJvcHMpLm1hcCgoa2V5KSA9PiBjYW1lbGl6ZShrZXkpKTtcclxuICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XHJcbiAgICBsZXQgb3B0ID0gb3B0aW9uc1trZXldO1xyXG4gICAgaWYgKG9wdCA9PSBudWxsKSBjb250aW51ZTtcclxuICAgIHZhbGlkYXRlUHJvcChcclxuICAgICAga2V5LFxyXG4gICAgICByZXNvbHZlZFZhbHVlc1trZXldLFxyXG4gICAgICBvcHQsXHJcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkocmVzb2x2ZWRWYWx1ZXMpIDogcmVzb2x2ZWRWYWx1ZXMsXHJcbiAgICAgICFjYW1lbGl6ZVByb3BzS2V5LmluY2x1ZGVzKGtleSlcclxuICAgICk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcChuYW1lLCB2YWx1ZSwgcHJvcCwgcHJvcHMsIGlzQWJzZW50KSB7XHJcbiAgY29uc3QgeyB0eXBlLCByZXF1aXJlZCwgdmFsaWRhdG9yLCBza2lwQ2hlY2sgfSA9IHByb3A7XHJcbiAgaWYgKHJlcXVpcmVkICYmIGlzQWJzZW50KSB7XHJcbiAgICB3YXJuJDEoJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcmVxdWlyZWQpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKHR5cGUgIT0gbnVsbCAmJiB0eXBlICE9PSB0cnVlICYmICFza2lwQ2hlY2spIHtcclxuICAgIGxldCBpc1ZhbGlkID0gZmFsc2U7XHJcbiAgICBjb25zdCB0eXBlcyA9IGlzQXJyYXkodHlwZSkgPyB0eXBlIDogW3R5cGVdO1xyXG4gICAgY29uc3QgZXhwZWN0ZWRUeXBlcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGggJiYgIWlzVmFsaWQ7IGkrKykge1xyXG4gICAgICBjb25zdCB7IHZhbGlkLCBleHBlY3RlZFR5cGUgfSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVzW2ldKTtcclxuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGV4cGVjdGVkVHlwZSB8fCBcIlwiKTtcclxuICAgICAgaXNWYWxpZCA9IHZhbGlkO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc1ZhbGlkKSB7XHJcbiAgICAgIHdhcm4kMShnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAodmFsaWRhdG9yICYmICF2YWxpZGF0b3IodmFsdWUsIHByb3BzKSkge1xyXG4gICAgd2FybiQxKCdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyk7XHJcbiAgfVxyXG59XHJcbmNvbnN0IGlzU2ltcGxlVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxyXG4gIFwiU3RyaW5nLE51bWJlcixCb29sZWFuLEZ1bmN0aW9uLFN5bWJvbCxCaWdJbnRcIlxyXG4pO1xyXG5mdW5jdGlvbiBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlKSB7XHJcbiAgbGV0IHZhbGlkO1xyXG4gIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XHJcbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gXCJudWxsXCIpIHtcclxuICAgIHZhbGlkID0gdmFsdWUgPT09IG51bGw7XHJcbiAgfSBlbHNlIGlmIChpc1NpbXBsZVR5cGUoZXhwZWN0ZWRUeXBlKSkge1xyXG4gICAgY29uc3QgdCA9IHR5cGVvZiB2YWx1ZTtcclxuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBpZiAoIXZhbGlkICYmIHQgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IFwiT2JqZWN0XCIpIHtcclxuICAgIHZhbGlkID0gaXNPYmplY3QodmFsdWUpO1xyXG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBcIkFycmF5XCIpIHtcclxuICAgIHZhbGlkID0gaXNBcnJheSh2YWx1ZSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xyXG4gIH1cclxuICByZXR1cm4ge1xyXG4gICAgdmFsaWQsXHJcbiAgICBleHBlY3RlZFR5cGVcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldEludmFsaWRUeXBlTWVzc2FnZShuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcykge1xyXG4gIGlmIChleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIGBQcm9wIHR5cGUgW10gZm9yIHByb3AgXCIke25hbWV9XCIgd29uJ3QgbWF0Y2ggYW55dGhpbmcuIERpZCB5b3UgbWVhbiB0byB1c2UgdHlwZSBBcnJheSBpbnN0ZWFkP2A7XHJcbiAgfVxyXG4gIGxldCBtZXNzYWdlID0gYEludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCIke25hbWV9XCIuIEV4cGVjdGVkICR7ZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbihcIiB8IFwiKX1gO1xyXG4gIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZXNbMF07XHJcbiAgY29uc3QgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcclxuICBjb25zdCBleHBlY3RlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgZXhwZWN0ZWRUeXBlKTtcclxuICBjb25zdCByZWNlaXZlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgcmVjZWl2ZWRUeXBlKTtcclxuICBpZiAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPT09IDEgJiYgaXNFeHBsaWNhYmxlKGV4cGVjdGVkVHlwZSkgJiYgIWlzQm9vbGVhbihleHBlY3RlZFR5cGUsIHJlY2VpdmVkVHlwZSkpIHtcclxuICAgIG1lc3NhZ2UgKz0gYCB3aXRoIHZhbHVlICR7ZXhwZWN0ZWRWYWx1ZX1gO1xyXG4gIH1cclxuICBtZXNzYWdlICs9IGAsIGdvdCAke3JlY2VpdmVkVHlwZX0gYDtcclxuICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcclxuICAgIG1lc3NhZ2UgKz0gYHdpdGggdmFsdWUgJHtyZWNlaXZlZFZhbHVlfS5gO1xyXG4gIH1cclxuICByZXR1cm4gbWVzc2FnZTtcclxufVxyXG5mdW5jdGlvbiBzdHlsZVZhbHVlKHZhbHVlLCB0eXBlKSB7XHJcbiAgaWYgKHR5cGUgPT09IFwiU3RyaW5nXCIpIHtcclxuICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYDtcclxuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiTnVtYmVyXCIpIHtcclxuICAgIHJldHVybiBgJHtOdW1iZXIodmFsdWUpfWA7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBgJHt2YWx1ZX1gO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBpc0V4cGxpY2FibGUodHlwZSkge1xyXG4gIGNvbnN0IGV4cGxpY2l0VHlwZXMgPSBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJib29sZWFuXCJdO1xyXG4gIHJldHVybiBleHBsaWNpdFR5cGVzLnNvbWUoKGVsZW0pID0+IHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbSk7XHJcbn1cclxuZnVuY3Rpb24gaXNCb29sZWFuKC4uLmFyZ3MpIHtcclxuICByZXR1cm4gYXJncy5zb21lKChlbGVtKSA9PiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09IFwiYm9vbGVhblwiKTtcclxufVxyXG5cclxuY29uc3QgaXNJbnRlcm5hbEtleSA9IChrZXkpID0+IGtleVswXSA9PT0gXCJfXCIgfHwga2V5ID09PSBcIiRzdGFibGVcIjtcclxuY29uc3Qgbm9ybWFsaXplU2xvdFZhbHVlID0gKHZhbHVlKSA9PiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcChub3JtYWxpemVWTm9kZSkgOiBbbm9ybWFsaXplVk5vZGUodmFsdWUpXTtcclxuY29uc3Qgbm9ybWFsaXplU2xvdCA9IChrZXksIHJhd1Nsb3QsIGN0eCkgPT4ge1xyXG4gIGlmIChyYXdTbG90Ll9uKSB7XHJcbiAgICByZXR1cm4gcmF3U2xvdDtcclxuICB9XHJcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHdpdGhDdHgoKC4uLmFyZ3MpID0+IHtcclxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGN1cnJlbnRJbnN0YW5jZSAmJiAoIWN0eCB8fCBjdHgucm9vdCA9PT0gY3VycmVudEluc3RhbmNlLnJvb3QpKSB7XHJcbiAgICAgIHdhcm4kMShcclxuICAgICAgICBgU2xvdCBcIiR7a2V5fVwiIGludm9rZWQgb3V0c2lkZSBvZiB0aGUgcmVuZGVyIGZ1bmN0aW9uOiB0aGlzIHdpbGwgbm90IHRyYWNrIGRlcGVuZGVuY2llcyB1c2VkIGluIHRoZSBzbG90LiBJbnZva2UgdGhlIHNsb3QgZnVuY3Rpb24gaW5zaWRlIHRoZSByZW5kZXIgZnVuY3Rpb24gaW5zdGVhZC5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9ybWFsaXplU2xvdFZhbHVlKHJhd1Nsb3QoLi4uYXJncykpO1xyXG4gIH0sIGN0eCk7XHJcbiAgbm9ybWFsaXplZC5fYyA9IGZhbHNlO1xyXG4gIHJldHVybiBub3JtYWxpemVkO1xyXG59O1xyXG5jb25zdCBub3JtYWxpemVPYmplY3RTbG90cyA9IChyYXdTbG90cywgc2xvdHMsIGluc3RhbmNlKSA9PiB7XHJcbiAgY29uc3QgY3R4ID0gcmF3U2xvdHMuX2N0eDtcclxuICBmb3IgKGNvbnN0IGtleSBpbiByYXdTbG90cykge1xyXG4gICAgaWYgKGlzSW50ZXJuYWxLZXkoa2V5KSkgY29udGludWU7XHJcbiAgICBjb25zdCB2YWx1ZSA9IHJhd1Nsb3RzW2tleV07XHJcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgc2xvdHNba2V5XSA9IG5vcm1hbGl6ZVNsb3Qoa2V5LCB2YWx1ZSwgY3R4KTtcclxuICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB0cnVlKSB7XHJcbiAgICAgICAgd2FybiQxKFxyXG4gICAgICAgICAgYE5vbi1mdW5jdGlvbiB2YWx1ZSBlbmNvdW50ZXJlZCBmb3Igc2xvdCBcIiR7a2V5fVwiLiBQcmVmZXIgZnVuY3Rpb24gc2xvdHMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5gXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplU2xvdFZhbHVlKHZhbHVlKTtcclxuICAgICAgc2xvdHNba2V5XSA9ICgpID0+IG5vcm1hbGl6ZWQ7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5jb25zdCBub3JtYWxpemVWTm9kZVNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbikgPT4ge1xyXG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0tlZXBBbGl2ZShpbnN0YW5jZS52bm9kZSkgJiYgdHJ1ZSkge1xyXG4gICAgd2FybiQxKFxyXG4gICAgICBgTm9uLWZ1bmN0aW9uIHZhbHVlIGVuY291bnRlcmVkIGZvciBkZWZhdWx0IHNsb3QuIFByZWZlciBmdW5jdGlvbiBzbG90cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLmBcclxuICAgICk7XHJcbiAgfVxyXG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTbG90VmFsdWUoY2hpbGRyZW4pO1xyXG4gIGluc3RhbmNlLnNsb3RzLmRlZmF1bHQgPSAoKSA9PiBub3JtYWxpemVkO1xyXG59O1xyXG5jb25zdCBhc3NpZ25TbG90cyA9IChzbG90cywgY2hpbGRyZW4sIG9wdGltaXplZCkgPT4ge1xyXG4gIGZvciAoY29uc3Qga2V5IGluIGNoaWxkcmVuKSB7XHJcbiAgICBpZiAob3B0aW1pemVkIHx8IGtleSAhPT0gXCJfXCIpIHtcclxuICAgICAgc2xvdHNba2V5XSA9IGNoaWxkcmVuW2tleV07XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5jb25zdCBpbml0U2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpID0+IHtcclxuICBjb25zdCBzbG90cyA9IGluc3RhbmNlLnNsb3RzID0gY3JlYXRlSW50ZXJuYWxPYmplY3QoKTtcclxuICBpZiAoaW5zdGFuY2Uudm5vZGUuc2hhcGVGbGFnICYgMzIpIHtcclxuICAgIGNvbnN0IHR5cGUgPSBjaGlsZHJlbi5fO1xyXG4gICAgaWYgKHR5cGUpIHtcclxuICAgICAgYXNzaWduU2xvdHMoc2xvdHMsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xyXG4gICAgICBpZiAob3B0aW1pemVkKSB7XHJcbiAgICAgICAgZGVmKHNsb3RzLCBcIl9cIiwgdHlwZSwgdHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG5vcm1hbGl6ZU9iamVjdFNsb3RzKGNoaWxkcmVuLCBzbG90cyk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChjaGlsZHJlbikge1xyXG4gICAgbm9ybWFsaXplVk5vZGVTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4pO1xyXG4gIH1cclxufTtcclxuY29uc3QgdXBkYXRlU2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpID0+IHtcclxuICBjb25zdCB7IHZub2RlLCBzbG90cyB9ID0gaW5zdGFuY2U7XHJcbiAgbGV0IG5lZWREZWxldGlvbkNoZWNrID0gdHJ1ZTtcclxuICBsZXQgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0gRU1QVFlfT0JKO1xyXG4gIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAzMikge1xyXG4gICAgY29uc3QgdHlwZSA9IGNoaWxkcmVuLl87XHJcbiAgICBpZiAodHlwZSkge1xyXG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0htclVwZGF0aW5nKSB7XHJcbiAgICAgICAgYXNzaWduU2xvdHMoc2xvdHMsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIHRyaWdnZXIoaW5zdGFuY2UsIFwic2V0XCIsIFwiJHNsb3RzXCIpO1xyXG4gICAgICB9IGVsc2UgaWYgKG9wdGltaXplZCAmJiB0eXBlID09PSAxKSB7XHJcbiAgICAgICAgbmVlZERlbGV0aW9uQ2hlY2sgPSBmYWxzZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhc3NpZ25TbG90cyhzbG90cywgY2hpbGRyZW4sIG9wdGltaXplZCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG5lZWREZWxldGlvbkNoZWNrID0gIWNoaWxkcmVuLiRzdGFibGU7XHJcbiAgICAgIG5vcm1hbGl6ZU9iamVjdFNsb3RzKGNoaWxkcmVuLCBzbG90cyk7XHJcbiAgICB9XHJcbiAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSBjaGlsZHJlbjtcclxuICB9IGVsc2UgaWYgKGNoaWxkcmVuKSB7XHJcbiAgICBub3JtYWxpemVWTm9kZVNsb3RzKGluc3RhbmNlLCBjaGlsZHJlbik7XHJcbiAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSB7IGRlZmF1bHQ6IDEgfTtcclxuICB9XHJcbiAgaWYgKG5lZWREZWxldGlvbkNoZWNrKSB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xyXG4gICAgICBpZiAoIWlzSW50ZXJuYWxLZXkoa2V5KSAmJiBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXRba2V5XSA9PSBudWxsKSB7XHJcbiAgICAgICAgZGVsZXRlIHNsb3RzW2tleV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5sZXQgc3VwcG9ydGVkO1xyXG5sZXQgcGVyZjtcclxuZnVuY3Rpb24gc3RhcnRNZWFzdXJlKGluc3RhbmNlLCB0eXBlKSB7XHJcbiAgaWYgKGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLnBlcmZvcm1hbmNlICYmIGlzU3VwcG9ydGVkKCkpIHtcclxuICAgIHBlcmYubWFyayhgdnVlLSR7dHlwZX0tJHtpbnN0YW5jZS51aWR9YCk7XHJcbiAgfVxyXG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgZGV2dG9vbHNQZXJmU3RhcnQoaW5zdGFuY2UsIHR5cGUsIGlzU3VwcG9ydGVkKCkgPyBwZXJmLm5vdygpIDogRGF0ZS5ub3coKSk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGVuZE1lYXN1cmUoaW5zdGFuY2UsIHR5cGUpIHtcclxuICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcucGVyZm9ybWFuY2UgJiYgaXNTdXBwb3J0ZWQoKSkge1xyXG4gICAgY29uc3Qgc3RhcnRUYWcgPSBgdnVlLSR7dHlwZX0tJHtpbnN0YW5jZS51aWR9YDtcclxuICAgIGNvbnN0IGVuZFRhZyA9IHN0YXJ0VGFnICsgYDplbmRgO1xyXG4gICAgcGVyZi5tYXJrKGVuZFRhZyk7XHJcbiAgICBwZXJmLm1lYXN1cmUoXHJcbiAgICAgIGA8JHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBpbnN0YW5jZS50eXBlKX0+ICR7dHlwZX1gLFxyXG4gICAgICBzdGFydFRhZyxcclxuICAgICAgZW5kVGFnXHJcbiAgICApO1xyXG4gICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcclxuICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xyXG4gIH1cclxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgIGRldnRvb2xzUGVyZkVuZChpbnN0YW5jZSwgdHlwZSwgaXNTdXBwb3J0ZWQoKSA/IHBlcmYubm93KCkgOiBEYXRlLm5vdygpKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XHJcbiAgaWYgKHN1cHBvcnRlZCAhPT0gdm9pZCAwKSB7XHJcbiAgICByZXR1cm4gc3VwcG9ydGVkO1xyXG4gIH1cclxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucGVyZm9ybWFuY2UpIHtcclxuICAgIHN1cHBvcnRlZCA9IHRydWU7XHJcbiAgICBwZXJmID0gd2luZG93LnBlcmZvcm1hbmNlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcclxuICB9XHJcbiAgcmV0dXJuIHN1cHBvcnRlZDtcclxufVxyXG5cclxuZnVuY3Rpb24gaW5pdEZlYXR1cmVGbGFncygpIHtcclxuICBjb25zdCBuZWVkV2FybiA9IFtdO1xyXG4gIGlmICh0eXBlb2YgX19WVUVfT1BUSU9OU19BUElfXyAhPT0gXCJib29sZWFuXCIpIHtcclxuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbmVlZFdhcm4ucHVzaChgX19WVUVfT1BUSU9OU19BUElfX2ApO1xyXG4gICAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX09QVElPTlNfQVBJX18gPSB0cnVlO1xyXG4gIH1cclxuICBpZiAodHlwZW9mIF9fVlVFX1BST0RfREVWVE9PTFNfXyAhPT0gXCJib29sZWFuXCIpIHtcclxuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbmVlZFdhcm4ucHVzaChgX19WVUVfUFJPRF9ERVZUT09MU19fYCk7XHJcbiAgICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfUFJPRF9ERVZUT09MU19fID0gZmFsc2U7XHJcbiAgfVxyXG4gIGlmICh0eXBlb2YgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fICE9PSBcImJvb2xlYW5cIikge1xyXG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBuZWVkV2Fybi5wdXNoKGBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX19gKTtcclxuICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18gPSBmYWxzZTtcclxuICB9XHJcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbmVlZFdhcm4ubGVuZ3RoKSB7XHJcbiAgICBjb25zdCBtdWx0aSA9IG5lZWRXYXJuLmxlbmd0aCA+IDE7XHJcbiAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgIGBGZWF0dXJlIGZsYWcke211bHRpID8gYHNgIDogYGB9ICR7bmVlZFdhcm4uam9pbihcIiwgXCIpfSAke211bHRpID8gYGFyZWAgOiBgaXNgfSBub3QgZXhwbGljaXRseSBkZWZpbmVkLiBZb3UgYXJlIHJ1bm5pbmcgdGhlIGVzbS1idW5kbGVyIGJ1aWxkIG9mIFZ1ZSwgd2hpY2ggZXhwZWN0cyB0aGVzZSBjb21waWxlLXRpbWUgZmVhdHVyZSBmbGFncyB0byBiZSBnbG9iYWxseSBpbmplY3RlZCB2aWEgdGhlIGJ1bmRsZXIgY29uZmlnIGluIG9yZGVyIHRvIGdldCBiZXR0ZXIgdHJlZS1zaGFraW5nIGluIHRoZSBwcm9kdWN0aW9uIGJ1bmRsZS5cclxuXHJcbkZvciBtb3JlIGRldGFpbHMsIHNlZSBodHRwczovL2xpbmsudnVlanMub3JnL2ZlYXR1cmUtZmxhZ3MuYFxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IHF1ZXVlUG9zdFJlbmRlckVmZmVjdCA9IHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlIDtcclxuZnVuY3Rpb24gY3JlYXRlUmVuZGVyZXIob3B0aW9ucykge1xyXG4gIHJldHVybiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIob3B0aW9ucykge1xyXG4gIHJldHVybiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucywgY3JlYXRlSHlkcmF0aW9uRnVuY3Rpb25zKTtcclxufVxyXG5mdW5jdGlvbiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucywgY3JlYXRlSHlkcmF0aW9uRm5zKSB7XHJcbiAge1xyXG4gICAgaW5pdEZlYXR1cmVGbGFncygpO1xyXG4gIH1cclxuICBjb25zdCB0YXJnZXQgPSBnZXRHbG9iYWxUaGlzKCk7XHJcbiAgdGFyZ2V0Ll9fVlVFX18gPSB0cnVlO1xyXG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgc2V0RGV2dG9vbHNIb29rJDEodGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18sIHRhcmdldCk7XHJcbiAgfVxyXG4gIGNvbnN0IHtcclxuICAgIGluc2VydDogaG9zdEluc2VydCxcclxuICAgIHJlbW92ZTogaG9zdFJlbW92ZSxcclxuICAgIHBhdGNoUHJvcDogaG9zdFBhdGNoUHJvcCxcclxuICAgIGNyZWF0ZUVsZW1lbnQ6IGhvc3RDcmVhdGVFbGVtZW50LFxyXG4gICAgY3JlYXRlVGV4dDogaG9zdENyZWF0ZVRleHQsXHJcbiAgICBjcmVhdGVDb21tZW50OiBob3N0Q3JlYXRlQ29tbWVudCxcclxuICAgIHNldFRleHQ6IGhvc3RTZXRUZXh0LFxyXG4gICAgc2V0RWxlbWVudFRleHQ6IGhvc3RTZXRFbGVtZW50VGV4dCxcclxuICAgIHBhcmVudE5vZGU6IGhvc3RQYXJlbnROb2RlLFxyXG4gICAgbmV4dFNpYmxpbmc6IGhvc3ROZXh0U2libGluZyxcclxuICAgIHNldFNjb3BlSWQ6IGhvc3RTZXRTY29wZUlkID0gTk9PUCxcclxuICAgIGluc2VydFN0YXRpY0NvbnRlbnQ6IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50XHJcbiAgfSA9IG9wdGlvbnM7XHJcbiAgY29uc3QgcGF0Y2ggPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciA9IG51bGwsIHBhcmVudENvbXBvbmVudCA9IG51bGwsIHBhcmVudFN1c3BlbnNlID0gbnVsbCwgbmFtZXNwYWNlID0gdm9pZCAwLCBzbG90U2NvcGVJZHMgPSBudWxsLCBvcHRpbWl6ZWQgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSG1yVXBkYXRpbmcgPyBmYWxzZSA6ICEhbjIuZHluYW1pY0NoaWxkcmVuKSA9PiB7XHJcbiAgICBpZiAobjEgPT09IG4yKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChuMSAmJiAhaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcclxuICAgICAgYW5jaG9yID0gZ2V0TmV4dEhvc3ROb2RlKG4xKTtcclxuICAgICAgdW5tb3VudChuMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgIG4xID0gbnVsbDtcclxuICAgIH1cclxuICAgIGlmIChuMi5wYXRjaEZsYWcgPT09IC0yKSB7XHJcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xyXG4gICAgICBuMi5keW5hbWljQ2hpbGRyZW4gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyB0eXBlLCByZWYsIHNoYXBlRmxhZyB9ID0gbjI7XHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgY2FzZSBUZXh0OlxyXG4gICAgICAgIHByb2Nlc3NUZXh0KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIENvbW1lbnQ6XHJcbiAgICAgICAgcHJvY2Vzc0NvbW1lbnROb2RlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFN0YXRpYzpcclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgbW91bnRTdGF0aWNOb2RlKG4yLCBjb250YWluZXIsIGFuY2hvciwgbmFtZXNwYWNlKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgICAgIHBhdGNoU3RhdGljTm9kZShuMSwgbjIsIGNvbnRhaW5lciwgbmFtZXNwYWNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRnJhZ21lbnQ6XHJcbiAgICAgICAgcHJvY2Vzc0ZyYWdtZW50KFxyXG4gICAgICAgICAgbjEsXHJcbiAgICAgICAgICBuMixcclxuICAgICAgICAgIGNvbnRhaW5lcixcclxuICAgICAgICAgIGFuY2hvcixcclxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcclxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxyXG4gICAgICAgICAgbmFtZXNwYWNlLFxyXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxyXG4gICAgICAgICAgb3B0aW1pemVkXHJcbiAgICAgICAgKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMSkge1xyXG4gICAgICAgICAgcHJvY2Vzc0VsZW1lbnQoXHJcbiAgICAgICAgICAgIG4xLFxyXG4gICAgICAgICAgICBuMixcclxuICAgICAgICAgICAgY29udGFpbmVyLFxyXG4gICAgICAgICAgICBhbmNob3IsXHJcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcclxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcclxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxyXG4gICAgICAgICAgICBvcHRpbWl6ZWRcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiA2KSB7XHJcbiAgICAgICAgICBwcm9jZXNzQ29tcG9uZW50KFxyXG4gICAgICAgICAgICBuMSxcclxuICAgICAgICAgICAgbjIsXHJcbiAgICAgICAgICAgIGNvbnRhaW5lcixcclxuICAgICAgICAgICAgYW5jaG9yLFxyXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxyXG4gICAgICAgICAgICBuYW1lc3BhY2UsXHJcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcclxuICAgICAgICAgICAgb3B0aW1pemVkXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQpIHtcclxuICAgICAgICAgIHR5cGUucHJvY2VzcyhcclxuICAgICAgICAgICAgbjEsXHJcbiAgICAgICAgICAgIG4yLFxyXG4gICAgICAgICAgICBjb250YWluZXIsXHJcbiAgICAgICAgICAgIGFuY2hvcixcclxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcclxuICAgICAgICAgICAgbmFtZXNwYWNlLFxyXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXHJcbiAgICAgICAgICAgIG9wdGltaXplZCxcclxuICAgICAgICAgICAgaW50ZXJuYWxzXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XHJcbiAgICAgICAgICB0eXBlLnByb2Nlc3MoXHJcbiAgICAgICAgICAgIG4xLFxyXG4gICAgICAgICAgICBuMixcclxuICAgICAgICAgICAgY29udGFpbmVyLFxyXG4gICAgICAgICAgICBhbmNob3IsXHJcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcclxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcclxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxyXG4gICAgICAgICAgICBvcHRpbWl6ZWQsXHJcbiAgICAgICAgICAgIGludGVybmFsc1xyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgICAgIHdhcm4kMShcIkludmFsaWQgVk5vZGUgdHlwZTpcIiwgdHlwZSwgYCgke3R5cGVvZiB0eXBlfSlgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocmVmICE9IG51bGwgJiYgcGFyZW50Q29tcG9uZW50KSB7XHJcbiAgICAgIHNldFJlZihyZWYsIG4xICYmIG4xLnJlZiwgcGFyZW50U3VzcGVuc2UsIG4yIHx8IG4xLCAhbjIpO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgY29uc3QgcHJvY2Vzc1RleHQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcikgPT4ge1xyXG4gICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgaG9zdEluc2VydChcclxuICAgICAgICBuMi5lbCA9IGhvc3RDcmVhdGVUZXh0KG4yLmNoaWxkcmVuKSxcclxuICAgICAgICBjb250YWluZXIsXHJcbiAgICAgICAgYW5jaG9yXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBlbCA9IG4yLmVsID0gbjEuZWw7XHJcbiAgICAgIGlmIChuMi5jaGlsZHJlbiAhPT0gbjEuY2hpbGRyZW4pIHtcclxuICAgICAgICBob3N0U2V0VGV4dChlbCwgbjIuY2hpbGRyZW4pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuICBjb25zdCBwcm9jZXNzQ29tbWVudE5vZGUgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcikgPT4ge1xyXG4gICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgaG9zdEluc2VydChcclxuICAgICAgICBuMi5lbCA9IGhvc3RDcmVhdGVDb21tZW50KG4yLmNoaWxkcmVuIHx8IFwiXCIpLFxyXG4gICAgICAgIGNvbnRhaW5lcixcclxuICAgICAgICBhbmNob3JcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG4yLmVsID0gbjEuZWw7XHJcbiAgICB9XHJcbiAgfTtcclxuICBjb25zdCBtb3VudFN0YXRpY05vZGUgPSAobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBuYW1lc3BhY2UpID0+IHtcclxuICAgIFtuMi5lbCwgbjIuYW5jaG9yXSA9IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50KFxyXG4gICAgICBuMi5jaGlsZHJlbixcclxuICAgICAgY29udGFpbmVyLFxyXG4gICAgICBhbmNob3IsXHJcbiAgICAgIG5hbWVzcGFjZSxcclxuICAgICAgbjIuZWwsXHJcbiAgICAgIG4yLmFuY2hvclxyXG4gICAgKTtcclxuICB9O1xyXG4gIGNvbnN0IHBhdGNoU3RhdGljTm9kZSA9IChuMSwgbjIsIGNvbnRhaW5lciwgbmFtZXNwYWNlKSA9PiB7XHJcbiAgICBpZiAobjIuY2hpbGRyZW4gIT09IG4xLmNoaWxkcmVuKSB7XHJcbiAgICAgIGNvbnN0IGFuY2hvciA9IGhvc3ROZXh0U2libGluZyhuMS5hbmNob3IpO1xyXG4gICAgICByZW1vdmVTdGF0aWNOb2RlKG4xKTtcclxuICAgICAgW24yLmVsLCBuMi5hbmNob3JdID0gaG9zdEluc2VydFN0YXRpY0NvbnRlbnQoXHJcbiAgICAgICAgbjIuY2hpbGRyZW4sXHJcbiAgICAgICAgY29udGFpbmVyLFxyXG4gICAgICAgIGFuY2hvcixcclxuICAgICAgICBuYW1lc3BhY2VcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG4yLmVsID0gbjEuZWw7XHJcbiAgICAgIG4yLmFuY2hvciA9IG4xLmFuY2hvcjtcclxuICAgIH1cclxuICB9O1xyXG4gIGNvbnN0IG1vdmVTdGF0aWNOb2RlID0gKHsgZWwsIGFuY2hvciB9LCBjb250YWluZXIsIG5leHRTaWJsaW5nKSA9PiB7XHJcbiAgICBsZXQgbmV4dDtcclxuICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gYW5jaG9yKSB7XHJcbiAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoZWwpO1xyXG4gICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIG5leHRTaWJsaW5nKTtcclxuICAgICAgZWwgPSBuZXh0O1xyXG4gICAgfVxyXG4gICAgaG9zdEluc2VydChhbmNob3IsIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpO1xyXG4gIH07XHJcbiAgY29uc3QgcmVtb3ZlU3RhdGljTm9kZSA9ICh7IGVsLCBhbmNob3IgfSkgPT4ge1xyXG4gICAgbGV0IG5leHQ7XHJcbiAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGFuY2hvcikge1xyXG4gICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGVsKTtcclxuICAgICAgaG9zdFJlbW92ZShlbCk7XHJcbiAgICAgIGVsID0gbmV4dDtcclxuICAgIH1cclxuICAgIGhvc3RSZW1vdmUoYW5jaG9yKTtcclxuICB9O1xyXG4gIGNvbnN0IHByb2Nlc3NFbGVtZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgIGlmIChuMi50eXBlID09PSBcInN2Z1wiKSB7XHJcbiAgICAgIG5hbWVzcGFjZSA9IFwic3ZnXCI7XHJcbiAgICB9IGVsc2UgaWYgKG4yLnR5cGUgPT09IFwibWF0aFwiKSB7XHJcbiAgICAgIG5hbWVzcGFjZSA9IFwibWF0aG1sXCI7XHJcbiAgICB9XHJcbiAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICBtb3VudEVsZW1lbnQoXHJcbiAgICAgICAgbjIsXHJcbiAgICAgICAgY29udGFpbmVyLFxyXG4gICAgICAgIGFuY2hvcixcclxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgICAgbmFtZXNwYWNlLFxyXG4gICAgICAgIHNsb3RTY29wZUlkcyxcclxuICAgICAgICBvcHRpbWl6ZWRcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBhdGNoRWxlbWVudChcclxuICAgICAgICBuMSxcclxuICAgICAgICBuMixcclxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgICAgbmFtZXNwYWNlLFxyXG4gICAgICAgIHNsb3RTY29wZUlkcyxcclxuICAgICAgICBvcHRpbWl6ZWRcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9O1xyXG4gIGNvbnN0IG1vdW50RWxlbWVudCA9ICh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgIGxldCBlbDtcclxuICAgIGxldCB2bm9kZUhvb2s7XHJcbiAgICBjb25zdCB7IHByb3BzLCBzaGFwZUZsYWcsIHRyYW5zaXRpb24sIGRpcnMgfSA9IHZub2RlO1xyXG4gICAgZWwgPSB2bm9kZS5lbCA9IGhvc3RDcmVhdGVFbGVtZW50KFxyXG4gICAgICB2bm9kZS50eXBlLFxyXG4gICAgICBuYW1lc3BhY2UsXHJcbiAgICAgIHByb3BzICYmIHByb3BzLmlzLFxyXG4gICAgICBwcm9wc1xyXG4gICAgKTtcclxuICAgIGlmIChzaGFwZUZsYWcgJiA4KSB7XHJcbiAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgdm5vZGUuY2hpbGRyZW4pO1xyXG4gICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiAxNikge1xyXG4gICAgICBtb3VudENoaWxkcmVuKFxyXG4gICAgICAgIHZub2RlLmNoaWxkcmVuLFxyXG4gICAgICAgIGVsLFxyXG4gICAgICAgIG51bGwsXHJcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxyXG4gICAgICAgIHJlc29sdmVDaGlsZHJlbk5hbWVzcGFjZSh2bm9kZSwgbmFtZXNwYWNlKSxcclxuICAgICAgICBzbG90U2NvcGVJZHMsXHJcbiAgICAgICAgb3B0aW1pemVkXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICBpZiAoZGlycykge1xyXG4gICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiY3JlYXRlZFwiKTtcclxuICAgIH1cclxuICAgIHNldFNjb3BlSWQoZWwsIHZub2RlLCB2bm9kZS5zY29wZUlkLCBzbG90U2NvcGVJZHMsIHBhcmVudENvbXBvbmVudCk7XHJcbiAgICBpZiAocHJvcHMpIHtcclxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcclxuICAgICAgICBpZiAoa2V5ICE9PSBcInZhbHVlXCIgJiYgIWlzUmVzZXJ2ZWRQcm9wKGtleSkpIHtcclxuICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgbnVsbCwgcHJvcHNba2V5XSwgbmFtZXNwYWNlLCBwYXJlbnRDb21wb25lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIHByb3BzKSB7XHJcbiAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgXCJ2YWx1ZVwiLCBudWxsLCBwcm9wcy52YWx1ZSwgbmFtZXNwYWNlKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodm5vZGVIb29rID0gcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSB7XHJcbiAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICBkZWYoZWwsIFwiX192bm9kZVwiLCB2bm9kZSwgdHJ1ZSk7XHJcbiAgICAgIGRlZihlbCwgXCJfX3Z1ZVBhcmVudENvbXBvbmVudFwiLCBwYXJlbnRDb21wb25lbnQsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgaWYgKGRpcnMpIHtcclxuICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcImJlZm9yZU1vdW50XCIpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgPSBuZWVkVHJhbnNpdGlvbihwYXJlbnRTdXNwZW5zZSwgdHJhbnNpdGlvbik7XHJcbiAgICBpZiAobmVlZENhbGxUcmFuc2l0aW9uSG9va3MpIHtcclxuICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XHJcbiAgICB9XHJcbiAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSB8fCBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyB8fCBkaXJzKSB7XHJcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xyXG4gICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzICYmIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xyXG4gICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcIm1vdW50ZWRcIik7XHJcbiAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgIH1cclxuICB9O1xyXG4gIGNvbnN0IHNldFNjb3BlSWQgPSAoZWwsIHZub2RlLCBzY29wZUlkLCBzbG90U2NvcGVJZHMsIHBhcmVudENvbXBvbmVudCkgPT4ge1xyXG4gICAgaWYgKHNjb3BlSWQpIHtcclxuICAgICAgaG9zdFNldFNjb3BlSWQoZWwsIHNjb3BlSWQpO1xyXG4gICAgfVxyXG4gICAgaWYgKHNsb3RTY29wZUlkcykge1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsb3RTY29wZUlkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGhvc3RTZXRTY29wZUlkKGVsLCBzbG90U2NvcGVJZHNbaV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocGFyZW50Q29tcG9uZW50KSB7XHJcbiAgICAgIGxldCBzdWJUcmVlID0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWU7XHJcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHN1YlRyZWUucGF0Y2hGbGFnID4gMCAmJiBzdWJUcmVlLnBhdGNoRmxhZyAmIDIwNDgpIHtcclxuICAgICAgICBzdWJUcmVlID0gZmlsdGVyU2luZ2xlUm9vdChzdWJUcmVlLmNoaWxkcmVuKSB8fCBzdWJUcmVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh2bm9kZSA9PT0gc3ViVHJlZSB8fCBpc1N1c3BlbnNlKHN1YlRyZWUudHlwZSkgJiYgKHN1YlRyZWUuc3NDb250ZW50ID09PSB2bm9kZSB8fCBzdWJUcmVlLnNzRmFsbGJhY2sgPT09IHZub2RlKSkge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudFZOb2RlID0gcGFyZW50Q29tcG9uZW50LnZub2RlO1xyXG4gICAgICAgIHNldFNjb3BlSWQoXHJcbiAgICAgICAgICBlbCxcclxuICAgICAgICAgIHBhcmVudFZOb2RlLFxyXG4gICAgICAgICAgcGFyZW50Vk5vZGUuc2NvcGVJZCxcclxuICAgICAgICAgIHBhcmVudFZOb2RlLnNsb3RTY29wZUlkcyxcclxuICAgICAgICAgIHBhcmVudENvbXBvbmVudC5wYXJlbnRcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuICBjb25zdCBtb3VudENoaWxkcmVuID0gKGNoaWxkcmVuLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgc3RhcnQgPSAwKSA9PiB7XHJcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoY2hpbGRyZW5baV0pIDogbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baV0pO1xyXG4gICAgICBwYXRjaChcclxuICAgICAgICBudWxsLFxyXG4gICAgICAgIGNoaWxkLFxyXG4gICAgICAgIGNvbnRhaW5lcixcclxuICAgICAgICBhbmNob3IsXHJcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxyXG4gICAgICAgIG5hbWVzcGFjZSxcclxuICAgICAgICBzbG90U2NvcGVJZHMsXHJcbiAgICAgICAgb3B0aW1pemVkXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBjb25zdCBwYXRjaEVsZW1lbnQgPSAobjEsIG4yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICBjb25zdCBlbCA9IG4yLmVsID0gbjEuZWw7XHJcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgZWwuX192bm9kZSA9IG4yO1xyXG4gICAgfVxyXG4gICAgbGV0IHsgcGF0Y2hGbGFnLCBkeW5hbWljQ2hpbGRyZW4sIGRpcnMgfSA9IG4yO1xyXG4gICAgcGF0Y2hGbGFnIHw9IG4xLnBhdGNoRmxhZyAmIDE2O1xyXG4gICAgY29uc3Qgb2xkUHJvcHMgPSBuMS5wcm9wcyB8fCBFTVBUWV9PQko7XHJcbiAgICBjb25zdCBuZXdQcm9wcyA9IG4yLnByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgIGxldCB2bm9kZUhvb2s7XHJcbiAgICBwYXJlbnRDb21wb25lbnQgJiYgdG9nZ2xlUmVjdXJzZShwYXJlbnRDb21wb25lbnQsIGZhbHNlKTtcclxuICAgIGlmICh2bm9kZUhvb2sgPSBuZXdQcm9wcy5vblZub2RlQmVmb3JlVXBkYXRlKSB7XHJcbiAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgbjIsIG4xKTtcclxuICAgIH1cclxuICAgIGlmIChkaXJzKSB7XHJcbiAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sobjIsIG4xLCBwYXJlbnRDb21wb25lbnQsIFwiYmVmb3JlVXBkYXRlXCIpO1xyXG4gICAgfVxyXG4gICAgcGFyZW50Q29tcG9uZW50ICYmIHRvZ2dsZVJlY3Vyc2UocGFyZW50Q29tcG9uZW50LCB0cnVlKTtcclxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSG1yVXBkYXRpbmcpIHtcclxuICAgICAgcGF0Y2hGbGFnID0gMDtcclxuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XHJcbiAgICAgIGR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAob2xkUHJvcHMuaW5uZXJIVE1MICYmIG5ld1Byb3BzLmlubmVySFRNTCA9PSBudWxsIHx8IG9sZFByb3BzLnRleHRDb250ZW50ICYmIG5ld1Byb3BzLnRleHRDb250ZW50ID09IG51bGwpIHtcclxuICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGVsLCBcIlwiKTtcclxuICAgIH1cclxuICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcclxuICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKFxyXG4gICAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbixcclxuICAgICAgICBkeW5hbWljQ2hpbGRyZW4sXHJcbiAgICAgICAgZWwsXHJcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxyXG4gICAgICAgIHJlc29sdmVDaGlsZHJlbk5hbWVzcGFjZShuMiwgbmFtZXNwYWNlKSxcclxuICAgICAgICBzbG90U2NvcGVJZHNcclxuICAgICAgKTtcclxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMik7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoIW9wdGltaXplZCkge1xyXG4gICAgICBwYXRjaENoaWxkcmVuKFxyXG4gICAgICAgIG4xLFxyXG4gICAgICAgIG4yLFxyXG4gICAgICAgIGVsLFxyXG4gICAgICAgIG51bGwsXHJcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxyXG4gICAgICAgIHJlc29sdmVDaGlsZHJlbk5hbWVzcGFjZShuMiwgbmFtZXNwYWNlKSxcclxuICAgICAgICBzbG90U2NvcGVJZHMsXHJcbiAgICAgICAgZmFsc2VcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIGlmIChwYXRjaEZsYWcgPiAwKSB7XHJcbiAgICAgIGlmIChwYXRjaEZsYWcgJiAxNikge1xyXG4gICAgICAgIHBhdGNoUHJvcHMoZWwsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBuYW1lc3BhY2UpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiAyKSB7XHJcbiAgICAgICAgICBpZiAob2xkUHJvcHMuY2xhc3MgIT09IG5ld1Byb3BzLmNsYXNzKSB7XHJcbiAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIFwiY2xhc3NcIiwgbnVsbCwgbmV3UHJvcHMuY2xhc3MsIG5hbWVzcGFjZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiA0KSB7XHJcbiAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBcInN0eWxlXCIsIG9sZFByb3BzLnN0eWxlLCBuZXdQcm9wcy5zdHlsZSwgbmFtZXNwYWNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDgpIHtcclxuICAgICAgICAgIGNvbnN0IHByb3BzVG9VcGRhdGUgPSBuMi5keW5hbWljUHJvcHM7XHJcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcclxuICAgICAgICAgICAgY29uc3QgcHJldiA9IG9sZFByb3BzW2tleV07XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXdQcm9wc1trZXldO1xyXG4gICAgICAgICAgICBpZiAobmV4dCAhPT0gcHJldiB8fCBrZXkgPT09IFwidmFsdWVcIikge1xyXG4gICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgcHJldiwgbmV4dCwgbmFtZXNwYWNlLCBwYXJlbnRDb21wb25lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChwYXRjaEZsYWcgJiAxKSB7XHJcbiAgICAgICAgaWYgKG4xLmNoaWxkcmVuICE9PSBuMi5jaGlsZHJlbikge1xyXG4gICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGVsLCBuMi5jaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKCFvcHRpbWl6ZWQgJiYgZHluYW1pY0NoaWxkcmVuID09IG51bGwpIHtcclxuICAgICAgcGF0Y2hQcm9wcyhlbCwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIG5hbWVzcGFjZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoKHZub2RlSG9vayA9IG5ld1Byb3BzLm9uVm5vZGVVcGRhdGVkKSB8fCBkaXJzKSB7XHJcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgbjIsIG4xKTtcclxuICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sobjIsIG4xLCBwYXJlbnRDb21wb25lbnQsIFwidXBkYXRlZFwiKTtcclxuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgY29uc3QgcGF0Y2hCbG9ja0NoaWxkcmVuID0gKG9sZENoaWxkcmVuLCBuZXdDaGlsZHJlbiwgZmFsbGJhY2tDb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzKSA9PiB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5baV07XHJcbiAgICAgIGNvbnN0IG5ld1ZOb2RlID0gbmV3Q2hpbGRyZW5baV07XHJcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IChcclxuICAgICAgICAvLyBvbGRWTm9kZSBtYXkgYmUgYW4gZXJyb3JlZCBhc3luYyBzZXR1cCgpIGNvbXBvbmVudCBpbnNpZGUgU3VzcGVuc2VcclxuICAgICAgICAvLyB3aGljaCB3aWxsIG5vdCBoYXZlIGEgbW91bnRlZCBlbGVtZW50XHJcbiAgICAgICAgb2xkVk5vZGUuZWwgJiYgLy8gLSBJbiB0aGUgY2FzZSBvZiBhIEZyYWdtZW50LCB3ZSBuZWVkIHRvIHByb3ZpZGUgdGhlIGFjdHVhbCBwYXJlbnRcclxuICAgICAgICAvLyBvZiB0aGUgRnJhZ21lbnQgaXRzZWxmIHNvIGl0IGNhbiBtb3ZlIGl0cyBjaGlsZHJlbi5cclxuICAgICAgICAob2xkVk5vZGUudHlwZSA9PT0gRnJhZ21lbnQgfHwgLy8gLSBJbiB0aGUgY2FzZSBvZiBkaWZmZXJlbnQgbm9kZXMsIHRoZXJlIGlzIGdvaW5nIHRvIGJlIGEgcmVwbGFjZW1lbnRcclxuICAgICAgICAvLyB3aGljaCBhbHNvIHJlcXVpcmVzIHRoZSBjb3JyZWN0IHBhcmVudCBjb250YWluZXJcclxuICAgICAgICAhaXNTYW1lVk5vZGVUeXBlKG9sZFZOb2RlLCBuZXdWTm9kZSkgfHwgLy8gLSBJbiB0aGUgY2FzZSBvZiBhIGNvbXBvbmVudCwgaXQgY291bGQgY29udGFpbiBhbnl0aGluZy5cclxuICAgICAgICBvbGRWTm9kZS5zaGFwZUZsYWcgJiAoNiB8IDY0KSkgPyBob3N0UGFyZW50Tm9kZShvbGRWTm9kZS5lbCkgOiAoXHJcbiAgICAgICAgICAvLyBJbiBvdGhlciBjYXNlcywgdGhlIHBhcmVudCBjb250YWluZXIgaXMgbm90IGFjdHVhbGx5IHVzZWQgc28gd2VcclxuICAgICAgICAgIC8vIGp1c3QgcGFzcyB0aGUgYmxvY2sgZWxlbWVudCBoZXJlIHRvIGF2b2lkIGEgRE9NIHBhcmVudE5vZGUgY2FsbC5cclxuICAgICAgICAgIGZhbGxiYWNrQ29udGFpbmVyXHJcbiAgICAgICAgKVxyXG4gICAgICApO1xyXG4gICAgICBwYXRjaChcclxuICAgICAgICBvbGRWTm9kZSxcclxuICAgICAgICBuZXdWTm9kZSxcclxuICAgICAgICBjb250YWluZXIsXHJcbiAgICAgICAgbnVsbCxcclxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgICAgbmFtZXNwYWNlLFxyXG4gICAgICAgIHNsb3RTY29wZUlkcyxcclxuICAgICAgICB0cnVlXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBjb25zdCBwYXRjaFByb3BzID0gKGVsLCBvbGRQcm9wcywgbmV3UHJvcHMsIHBhcmVudENvbXBvbmVudCwgbmFtZXNwYWNlKSA9PiB7XHJcbiAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzKSB7XHJcbiAgICAgIGlmIChvbGRQcm9wcyAhPT0gRU1QVFlfT0JKKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2xkUHJvcHMpIHtcclxuICAgICAgICAgIGlmICghaXNSZXNlcnZlZFByb3Aoa2V5KSAmJiAhKGtleSBpbiBuZXdQcm9wcykpIHtcclxuICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChcclxuICAgICAgICAgICAgICBlbCxcclxuICAgICAgICAgICAgICBrZXksXHJcbiAgICAgICAgICAgICAgb2xkUHJvcHNba2V5XSxcclxuICAgICAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICAgIG5hbWVzcGFjZSxcclxuICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnRcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV3UHJvcHMpIHtcclxuICAgICAgICBpZiAoaXNSZXNlcnZlZFByb3Aoa2V5KSkgY29udGludWU7XHJcbiAgICAgICAgY29uc3QgbmV4dCA9IG5ld1Byb3BzW2tleV07XHJcbiAgICAgICAgY29uc3QgcHJldiA9IG9sZFByb3BzW2tleV07XHJcbiAgICAgICAgaWYgKG5leHQgIT09IHByZXYgJiYga2V5ICE9PSBcInZhbHVlXCIpIHtcclxuICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgcHJldiwgbmV4dCwgbmFtZXNwYWNlLCBwYXJlbnRDb21wb25lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIG5ld1Byb3BzKSB7XHJcbiAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgXCJ2YWx1ZVwiLCBvbGRQcm9wcy52YWx1ZSwgbmV3UHJvcHMudmFsdWUsIG5hbWVzcGFjZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG4gIGNvbnN0IHByb2Nlc3NGcmFnbWVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICBjb25zdCBmcmFnbWVudFN0YXJ0QW5jaG9yID0gbjIuZWwgPSBuMSA/IG4xLmVsIDogaG9zdENyZWF0ZVRleHQoXCJcIik7XHJcbiAgICBjb25zdCBmcmFnbWVudEVuZEFuY2hvciA9IG4yLmFuY2hvciA9IG4xID8gbjEuYW5jaG9yIDogaG9zdENyZWF0ZVRleHQoXCJcIik7XHJcbiAgICBsZXQgeyBwYXRjaEZsYWcsIGR5bmFtaWNDaGlsZHJlbiwgc2xvdFNjb3BlSWRzOiBmcmFnbWVudFNsb3RTY29wZUlkcyB9ID0gbjI7XHJcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAvLyAjNTUyMyBkZXYgcm9vdCBmcmFnbWVudCBtYXkgaW5oZXJpdCBkaXJlY3RpdmVzXHJcbiAgICAoaXNIbXJVcGRhdGluZyB8fCBwYXRjaEZsYWcgJiAyMDQ4KSkge1xyXG4gICAgICBwYXRjaEZsYWcgPSAwO1xyXG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcclxuICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcclxuICAgIH1cclxuICAgIGlmIChmcmFnbWVudFNsb3RTY29wZUlkcykge1xyXG4gICAgICBzbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHMgPyBzbG90U2NvcGVJZHMuY29uY2F0KGZyYWdtZW50U2xvdFNjb3BlSWRzKSA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xyXG4gICAgfVxyXG4gICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgaG9zdEluc2VydChmcmFnbWVudFN0YXJ0QW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgIGhvc3RJbnNlcnQoZnJhZ21lbnRFbmRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgbW91bnRDaGlsZHJlbihcclxuICAgICAgICAvLyAjMTAwMDdcclxuICAgICAgICAvLyBzdWNoIGZyYWdtZW50IGxpa2UgYDw+PC8+YCB3aWxsIGJlIGNvbXBpbGVkIGludG9cclxuICAgICAgICAvLyBhIGZyYWdtZW50IHdoaWNoIGRvZXNuJ3QgaGF2ZSBhIGNoaWxkcmVuLlxyXG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSBmYWxsYmFjayB0byBhbiBlbXB0eSBhcnJheVxyXG4gICAgICAgIG4yLmNoaWxkcmVuIHx8IFtdLFxyXG4gICAgICAgIGNvbnRhaW5lcixcclxuICAgICAgICBmcmFnbWVudEVuZEFuY2hvcixcclxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgICAgbmFtZXNwYWNlLFxyXG4gICAgICAgIHNsb3RTY29wZUlkcyxcclxuICAgICAgICBvcHRpbWl6ZWRcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChwYXRjaEZsYWcgPiAwICYmIHBhdGNoRmxhZyAmIDY0ICYmIGR5bmFtaWNDaGlsZHJlbiAmJiAvLyAjMjcxNSB0aGUgcHJldmlvdXMgZnJhZ21lbnQgY291bGQndmUgYmVlbiBhIEJBSUxlZCBvbmUgYXMgYSByZXN1bHRcclxuICAgICAgLy8gb2YgcmVuZGVyU2xvdCgpIHdpdGggbm8gdmFsaWQgY2hpbGRyZW5cclxuICAgICAgbjEuZHluYW1pY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKFxyXG4gICAgICAgICAgbjEuZHluYW1pY0NoaWxkcmVuLFxyXG4gICAgICAgICAgZHluYW1pY0NoaWxkcmVuLFxyXG4gICAgICAgICAgY29udGFpbmVyLFxyXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgICAgICBuYW1lc3BhY2UsXHJcbiAgICAgICAgICBzbG90U2NvcGVJZHNcclxuICAgICAgICApO1xyXG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMik7XHJcbiAgICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICAgIC8vICMyMDgwIGlmIHRoZSBzdGFibGUgZnJhZ21lbnQgaGFzIGEga2V5LCBpdCdzIGEgPHRlbXBsYXRlIHYtZm9yPiB0aGF0IG1heVxyXG4gICAgICAgICAgLy8gIGdldCBtb3ZlZCBhcm91bmQuIE1ha2Ugc3VyZSBhbGwgcm9vdCBsZXZlbCB2bm9kZXMgaW5oZXJpdCBlbC5cclxuICAgICAgICAgIC8vICMyMTM0IG9yIGlmIGl0J3MgYSBjb21wb25lbnQgcm9vdCwgaXQgbWF5IGFsc28gZ2V0IG1vdmVkIGFyb3VuZFxyXG4gICAgICAgICAgLy8gYXMgdGhlIGNvbXBvbmVudCBpcyBiZWluZyBtb3ZlZC5cclxuICAgICAgICAgIG4yLmtleSAhPSBudWxsIHx8IHBhcmVudENvbXBvbmVudCAmJiBuMiA9PT0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWVcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4oXHJcbiAgICAgICAgICAgIG4xLFxyXG4gICAgICAgICAgICBuMixcclxuICAgICAgICAgICAgdHJ1ZVxyXG4gICAgICAgICAgICAvKiBzaGFsbG93ICovXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwYXRjaENoaWxkcmVuKFxyXG4gICAgICAgICAgbjEsXHJcbiAgICAgICAgICBuMixcclxuICAgICAgICAgIGNvbnRhaW5lcixcclxuICAgICAgICAgIGZyYWdtZW50RW5kQW5jaG9yLFxyXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgICAgICBuYW1lc3BhY2UsXHJcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXHJcbiAgICAgICAgICBvcHRpbWl6ZWRcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuICBjb25zdCBwcm9jZXNzQ29tcG9uZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgIG4yLnNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcztcclxuICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgIGlmIChuMi5zaGFwZUZsYWcgJiA1MTIpIHtcclxuICAgICAgICBwYXJlbnRDb21wb25lbnQuY3R4LmFjdGl2YXRlKFxyXG4gICAgICAgICAgbjIsXHJcbiAgICAgICAgICBjb250YWluZXIsXHJcbiAgICAgICAgICBhbmNob3IsXHJcbiAgICAgICAgICBuYW1lc3BhY2UsXHJcbiAgICAgICAgICBvcHRpbWl6ZWRcclxuICAgICAgICApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG1vdW50Q29tcG9uZW50KFxyXG4gICAgICAgICAgbjIsXHJcbiAgICAgICAgICBjb250YWluZXIsXHJcbiAgICAgICAgICBhbmNob3IsXHJcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcclxuICAgICAgICAgIG5hbWVzcGFjZSxcclxuICAgICAgICAgIG9wdGltaXplZFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHVwZGF0ZUNvbXBvbmVudChuMSwgbjIsIG9wdGltaXplZCk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBjb25zdCBtb3VudENvbXBvbmVudCA9IChpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgY29uc3QgaW5zdGFuY2UgPSAoaW5pdGlhbFZOb2RlLmNvbXBvbmVudCA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlKFxyXG4gICAgICBpbml0aWFsVk5vZGUsXHJcbiAgICAgIHBhcmVudENvbXBvbmVudCxcclxuICAgICAgcGFyZW50U3VzcGVuc2VcclxuICAgICkpO1xyXG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaW5zdGFuY2UudHlwZS5fX2htcklkKSB7XHJcbiAgICAgIHJlZ2lzdGVySE1SKGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChpbml0aWFsVk5vZGUpO1xyXG4gICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBtb3VudGApO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzS2VlcEFsaXZlKGluaXRpYWxWTm9kZSkpIHtcclxuICAgICAgaW5zdGFuY2UuY3R4LnJlbmRlcmVyID0gaW50ZXJuYWxzO1xyXG4gICAgfVxyXG4gICAge1xyXG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYGluaXRgKTtcclxuICAgICAgfVxyXG4gICAgICBzZXR1cENvbXBvbmVudChpbnN0YW5jZSwgZmFsc2UsIG9wdGltaXplZCk7XHJcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGluaXRgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGluc3RhbmNlLmFzeW5jRGVwKSB7XHJcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSG1yVXBkYXRpbmcpIGluaXRpYWxWTm9kZS5lbCA9IG51bGw7XHJcbiAgICAgIHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnJlZ2lzdGVyRGVwKGluc3RhbmNlLCBzZXR1cFJlbmRlckVmZmVjdCwgb3B0aW1pemVkKTtcclxuICAgICAgaWYgKCFpbml0aWFsVk5vZGUuZWwpIHtcclxuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IGluc3RhbmNlLnN1YlRyZWUgPSBjcmVhdGVWTm9kZShDb21tZW50KTtcclxuICAgICAgICBwcm9jZXNzQ29tbWVudE5vZGUobnVsbCwgcGxhY2Vob2xkZXIsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2V0dXBSZW5kZXJFZmZlY3QoXHJcbiAgICAgICAgaW5zdGFuY2UsXHJcbiAgICAgICAgaW5pdGlhbFZOb2RlLFxyXG4gICAgICAgIGNvbnRhaW5lcixcclxuICAgICAgICBhbmNob3IsXHJcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgICAgbmFtZXNwYWNlLFxyXG4gICAgICAgIG9wdGltaXplZFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcclxuICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYG1vdW50YCk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBjb25zdCB1cGRhdGVDb21wb25lbnQgPSAobjEsIG4yLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgIGNvbnN0IGluc3RhbmNlID0gbjIuY29tcG9uZW50ID0gbjEuY29tcG9uZW50O1xyXG4gICAgaWYgKHNob3VsZFVwZGF0ZUNvbXBvbmVudChuMSwgbjIsIG9wdGltaXplZCkpIHtcclxuICAgICAgaWYgKGluc3RhbmNlLmFzeW5jRGVwICYmICFpbnN0YW5jZS5hc3luY1Jlc29sdmVkKSB7XHJcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChuMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbjIsIG9wdGltaXplZCk7XHJcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpbnN0YW5jZS5uZXh0ID0gbjI7XHJcbiAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG4yLmVsID0gbjEuZWw7XHJcbiAgICAgIGluc3RhbmNlLnZub2RlID0gbjI7XHJcbiAgICB9XHJcbiAgfTtcclxuICBjb25zdCBzZXR1cFJlbmRlckVmZmVjdCA9IChpbnN0YW5jZSwgaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgb3B0aW1pemVkKSA9PiB7XHJcbiAgICBjb25zdCBjb21wb25lbnRVcGRhdGVGbiA9ICgpID0+IHtcclxuICAgICAgaWYgKCFpbnN0YW5jZS5pc01vdW50ZWQpIHtcclxuICAgICAgICBsZXQgdm5vZGVIb29rO1xyXG4gICAgICAgIGNvbnN0IHsgZWwsIHByb3BzIH0gPSBpbml0aWFsVk5vZGU7XHJcbiAgICAgICAgY29uc3QgeyBibSwgbSwgcGFyZW50LCByb290LCB0eXBlIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICBjb25zdCBpc0FzeW5jV3JhcHBlclZOb2RlID0gaXNBc3luY1dyYXBwZXIoaW5pdGlhbFZOb2RlKTtcclxuICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKGJtKSB7XHJcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhibSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNBc3luY1dyYXBwZXJWTm9kZSAmJiAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSkge1xyXG4gICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBpbml0aWFsVk5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCB0cnVlKTtcclxuICAgICAgICBpZiAoZWwgJiYgaHlkcmF0ZU5vZGUpIHtcclxuICAgICAgICAgIGNvbnN0IGh5ZHJhdGVTdWJUcmVlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnN1YlRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKTtcclxuICAgICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBoeWRyYXRlYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaHlkcmF0ZU5vZGUoXHJcbiAgICAgICAgICAgICAgZWwsXHJcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSxcclxuICAgICAgICAgICAgICBpbnN0YW5jZSxcclxuICAgICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcclxuICAgICAgICAgICAgICBudWxsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGh5ZHJhdGVgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIGlmIChpc0FzeW5jV3JhcHBlclZOb2RlICYmIHR5cGUuX19hc3luY0h5ZHJhdGUpIHtcclxuICAgICAgICAgICAgdHlwZS5fX2FzeW5jSHlkcmF0ZShcclxuICAgICAgICAgICAgICBlbCxcclxuICAgICAgICAgICAgICBpbnN0YW5jZSxcclxuICAgICAgICAgICAgICBoeWRyYXRlU3ViVHJlZVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaHlkcmF0ZVN1YlRyZWUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKHJvb3QuY2UpIHtcclxuICAgICAgICAgICAgcm9vdC5jZS5faW5qZWN0Q2hpbGRTdHlsZSh0eXBlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY29uc3Qgc3ViVHJlZSA9IGluc3RhbmNlLnN1YlRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKTtcclxuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBwYXRjaChcclxuICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgc3ViVHJlZSxcclxuICAgICAgICAgICAgY29udGFpbmVyLFxyXG4gICAgICAgICAgICBhbmNob3IsXHJcbiAgICAgICAgICAgIGluc3RhbmNlLFxyXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcclxuICAgICAgICAgICAgbmFtZXNwYWNlXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpbml0aWFsVk5vZGUuZWwgPSBzdWJUcmVlLmVsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobSkge1xyXG4gICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KG0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc0FzeW5jV3JhcHBlclZOb2RlICYmICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlTW91bnRlZCkpIHtcclxuICAgICAgICAgIGNvbnN0IHNjb3BlZEluaXRpYWxWTm9kZSA9IGluaXRpYWxWTm9kZTtcclxuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChcclxuICAgICAgICAgICAgKCkgPT4gaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBzY29wZWRJbml0aWFsVk5vZGUpLFxyXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluaXRpYWxWTm9kZS5zaGFwZUZsYWcgJiAyNTYgfHwgcGFyZW50ICYmIGlzQXN5bmNXcmFwcGVyKHBhcmVudC52bm9kZSkgJiYgcGFyZW50LnZub2RlLnNoYXBlRmxhZyAmIDI1Nikge1xyXG4gICAgICAgICAgaW5zdGFuY2UuYSAmJiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoaW5zdGFuY2UuYSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnN0YW5jZS5pc01vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluaXRpYWxWTm9kZSA9IGNvbnRhaW5lciA9IGFuY2hvciA9IG51bGw7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IHsgbmV4dCwgYnUsIHUsIHBhcmVudCwgdm5vZGUgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIGNvbnN0IG5vbkh5ZHJhdGVkQXN5bmNSb290ID0gbG9jYXRlTm9uSHlkcmF0ZWRBc3luY1Jvb3QoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgaWYgKG5vbkh5ZHJhdGVkQXN5bmNSb290KSB7XHJcbiAgICAgICAgICAgIGlmIChuZXh0KSB7XHJcbiAgICAgICAgICAgICAgbmV4dC5lbCA9IHZub2RlLmVsO1xyXG4gICAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbmV4dCwgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBub25IeWRyYXRlZEFzeW5jUm9vdC5hc3luY0RlcC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICBpZiAoIWluc3RhbmNlLmlzVW5tb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnRVcGRhdGVGbigpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG9yaWdpbk5leHQgPSBuZXh0O1xyXG4gICAgICAgIGxldCB2bm9kZUhvb2s7XHJcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChuZXh0IHx8IGluc3RhbmNlLnZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgZmFsc2UpO1xyXG4gICAgICAgIGlmIChuZXh0KSB7XHJcbiAgICAgICAgICBuZXh0LmVsID0gdm5vZGUuZWw7XHJcbiAgICAgICAgICB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIoaW5zdGFuY2UsIG5leHQsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5leHQgPSB2bm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJ1KSB7XHJcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhidSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2bm9kZUhvb2sgPSBuZXh0LnByb3BzICYmIG5leHQucHJvcHMub25Wbm9kZUJlZm9yZVVwZGF0ZSkge1xyXG4gICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBuZXh0LCB2bm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xyXG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV4dFRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKTtcclxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwcmV2VHJlZSA9IGluc3RhbmNlLnN1YlRyZWU7XHJcbiAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSA9IG5leHRUcmVlO1xyXG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXRjaChcclxuICAgICAgICAgIHByZXZUcmVlLFxyXG4gICAgICAgICAgbmV4dFRyZWUsXHJcbiAgICAgICAgICAvLyBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBpZiBpdCdzIGluIGEgdGVsZXBvcnRcclxuICAgICAgICAgIGhvc3RQYXJlbnROb2RlKHByZXZUcmVlLmVsKSxcclxuICAgICAgICAgIC8vIGFuY2hvciBtYXkgaGF2ZSBjaGFuZ2VkIGlmIGl0J3MgaW4gYSBmcmFnbWVudFxyXG4gICAgICAgICAgZ2V0TmV4dEhvc3ROb2RlKHByZXZUcmVlKSxcclxuICAgICAgICAgIGluc3RhbmNlLFxyXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgICAgICBuYW1lc3BhY2VcclxuICAgICAgICApO1xyXG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbmV4dC5lbCA9IG5leHRUcmVlLmVsO1xyXG4gICAgICAgIGlmIChvcmlnaW5OZXh0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIG5leHRUcmVlLmVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHUpIHtcclxuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCh1LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2bm9kZUhvb2sgPSBuZXh0LnByb3BzICYmIG5leHQucHJvcHMub25Wbm9kZVVwZGF0ZWQpIHtcclxuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChcclxuICAgICAgICAgICAgKCkgPT4gaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBuZXh0LCB2bm9kZSksXHJcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZChpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIGluc3RhbmNlLnNjb3BlLm9uKCk7XHJcbiAgICBjb25zdCBlZmZlY3QgPSBpbnN0YW5jZS5lZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoY29tcG9uZW50VXBkYXRlRm4pO1xyXG4gICAgaW5zdGFuY2Uuc2NvcGUub2ZmKCk7XHJcbiAgICBjb25zdCB1cGRhdGUgPSBpbnN0YW5jZS51cGRhdGUgPSBlZmZlY3QucnVuLmJpbmQoZWZmZWN0KTtcclxuICAgIGNvbnN0IGpvYiA9IGluc3RhbmNlLmpvYiA9IGVmZmVjdC5ydW5JZkRpcnR5LmJpbmQoZWZmZWN0KTtcclxuICAgIGpvYi5pID0gaW5zdGFuY2U7XHJcbiAgICBqb2IuaWQgPSBpbnN0YW5jZS51aWQ7XHJcbiAgICBlZmZlY3Quc2NoZWR1bGVyID0gKCkgPT4gcXVldWVKb2Ioam9iKTtcclxuICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xyXG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgZWZmZWN0Lm9uVHJhY2sgPSBpbnN0YW5jZS5ydGMgPyAoZSkgPT4gaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UucnRjLCBlKSA6IHZvaWQgMDtcclxuICAgICAgZWZmZWN0Lm9uVHJpZ2dlciA9IGluc3RhbmNlLnJ0ZyA/IChlKSA9PiBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5ydGcsIGUpIDogdm9pZCAwO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKCk7XHJcbiAgfTtcclxuICBjb25zdCB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIgPSAoaW5zdGFuY2UsIG5leHRWTm9kZSwgb3B0aW1pemVkKSA9PiB7XHJcbiAgICBuZXh0Vk5vZGUuY29tcG9uZW50ID0gaW5zdGFuY2U7XHJcbiAgICBjb25zdCBwcmV2UHJvcHMgPSBpbnN0YW5jZS52bm9kZS5wcm9wcztcclxuICAgIGluc3RhbmNlLnZub2RlID0gbmV4dFZOb2RlO1xyXG4gICAgaW5zdGFuY2UubmV4dCA9IG51bGw7XHJcbiAgICB1cGRhdGVQcm9wcyhpbnN0YW5jZSwgbmV4dFZOb2RlLnByb3BzLCBwcmV2UHJvcHMsIG9wdGltaXplZCk7XHJcbiAgICB1cGRhdGVTbG90cyhpbnN0YW5jZSwgbmV4dFZOb2RlLmNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xyXG4gICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgZmx1c2hQcmVGbHVzaENicyhpbnN0YW5jZSk7XHJcbiAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgfTtcclxuICBjb25zdCBwYXRjaENoaWxkcmVuID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xyXG4gICAgY29uc3QgYzEgPSBuMSAmJiBuMS5jaGlsZHJlbjtcclxuICAgIGNvbnN0IHByZXZTaGFwZUZsYWcgPSBuMSA/IG4xLnNoYXBlRmxhZyA6IDA7XHJcbiAgICBjb25zdCBjMiA9IG4yLmNoaWxkcmVuO1xyXG4gICAgY29uc3QgeyBwYXRjaEZsYWcsIHNoYXBlRmxhZyB9ID0gbjI7XHJcbiAgICBpZiAocGF0Y2hGbGFnID4gMCkge1xyXG4gICAgICBpZiAocGF0Y2hGbGFnICYgMTI4KSB7XHJcbiAgICAgICAgcGF0Y2hLZXllZENoaWxkcmVuKFxyXG4gICAgICAgICAgYzEsXHJcbiAgICAgICAgICBjMixcclxuICAgICAgICAgIGNvbnRhaW5lcixcclxuICAgICAgICAgIGFuY2hvcixcclxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcclxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxyXG4gICAgICAgICAgbmFtZXNwYWNlLFxyXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxyXG4gICAgICAgICAgb3B0aW1pemVkXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH0gZWxzZSBpZiAocGF0Y2hGbGFnICYgMjU2KSB7XHJcbiAgICAgICAgcGF0Y2hVbmtleWVkQ2hpbGRyZW4oXHJcbiAgICAgICAgICBjMSxcclxuICAgICAgICAgIGMyLFxyXG4gICAgICAgICAgY29udGFpbmVyLFxyXG4gICAgICAgICAgYW5jaG9yLFxyXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgICAgICBuYW1lc3BhY2UsXHJcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXHJcbiAgICAgICAgICBvcHRpbWl6ZWRcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHNoYXBlRmxhZyAmIDgpIHtcclxuICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiAxNikge1xyXG4gICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGMyICE9PSBjMSkge1xyXG4gICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsIGMyKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiAxNikge1xyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xyXG4gICAgICAgICAgcGF0Y2hLZXllZENoaWxkcmVuKFxyXG4gICAgICAgICAgICBjMSxcclxuICAgICAgICAgICAgYzIsXHJcbiAgICAgICAgICAgIGNvbnRhaW5lcixcclxuICAgICAgICAgICAgYW5jaG9yLFxyXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxyXG4gICAgICAgICAgICBuYW1lc3BhY2UsXHJcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcclxuICAgICAgICAgICAgb3B0aW1pemVkXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oYzEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDgpIHtcclxuICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsIFwiXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcclxuICAgICAgICAgIG1vdW50Q2hpbGRyZW4oXHJcbiAgICAgICAgICAgIGMyLFxyXG4gICAgICAgICAgICBjb250YWluZXIsXHJcbiAgICAgICAgICAgIGFuY2hvcixcclxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcclxuICAgICAgICAgICAgbmFtZXNwYWNlLFxyXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXHJcbiAgICAgICAgICAgIG9wdGltaXplZFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG4gIGNvbnN0IHBhdGNoVW5rZXllZENoaWxkcmVuID0gKGMxLCBjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgIGMxID0gYzEgfHwgRU1QVFlfQVJSO1xyXG4gICAgYzIgPSBjMiB8fCBFTVBUWV9BUlI7XHJcbiAgICBjb25zdCBvbGRMZW5ndGggPSBjMS5sZW5ndGg7XHJcbiAgICBjb25zdCBuZXdMZW5ndGggPSBjMi5sZW5ndGg7XHJcbiAgICBjb25zdCBjb21tb25MZW5ndGggPSBNYXRoLm1pbihvbGRMZW5ndGgsIG5ld0xlbmd0aCk7XHJcbiAgICBsZXQgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBjb21tb25MZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBuZXh0Q2hpbGQgPSBjMltpXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGMyW2ldKSA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKTtcclxuICAgICAgcGF0Y2goXHJcbiAgICAgICAgYzFbaV0sXHJcbiAgICAgICAgbmV4dENoaWxkLFxyXG4gICAgICAgIGNvbnRhaW5lcixcclxuICAgICAgICBudWxsLFxyXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcclxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcclxuICAgICAgICBuYW1lc3BhY2UsXHJcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxyXG4gICAgICAgIG9wdGltaXplZFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgaWYgKG9sZExlbmd0aCA+IG5ld0xlbmd0aCkge1xyXG4gICAgICB1bm1vdW50Q2hpbGRyZW4oXHJcbiAgICAgICAgYzEsXHJcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxyXG4gICAgICAgIHRydWUsXHJcbiAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgY29tbW9uTGVuZ3RoXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBtb3VudENoaWxkcmVuKFxyXG4gICAgICAgIGMyLFxyXG4gICAgICAgIGNvbnRhaW5lcixcclxuICAgICAgICBhbmNob3IsXHJcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxyXG4gICAgICAgIG5hbWVzcGFjZSxcclxuICAgICAgICBzbG90U2NvcGVJZHMsXHJcbiAgICAgICAgb3B0aW1pemVkLFxyXG4gICAgICAgIGNvbW1vbkxlbmd0aFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgY29uc3QgcGF0Y2hLZXllZENoaWxkcmVuID0gKGMxLCBjMiwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgIGxldCBpID0gMDtcclxuICAgIGNvbnN0IGwyID0gYzIubGVuZ3RoO1xyXG4gICAgbGV0IGUxID0gYzEubGVuZ3RoIC0gMTtcclxuICAgIGxldCBlMiA9IGwyIC0gMTtcclxuICAgIHdoaWxlIChpIDw9IGUxICYmIGkgPD0gZTIpIHtcclxuICAgICAgY29uc3QgbjEgPSBjMVtpXTtcclxuICAgICAgY29uc3QgbjIgPSBjMltpXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGMyW2ldKSA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKTtcclxuICAgICAgaWYgKGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XHJcbiAgICAgICAgcGF0Y2goXHJcbiAgICAgICAgICBuMSxcclxuICAgICAgICAgIG4yLFxyXG4gICAgICAgICAgY29udGFpbmVyLFxyXG4gICAgICAgICAgbnVsbCxcclxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcclxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxyXG4gICAgICAgICAgbmFtZXNwYWNlLFxyXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxyXG4gICAgICAgICAgb3B0aW1pemVkXHJcbiAgICAgICAgKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBpKys7XHJcbiAgICB9XHJcbiAgICB3aGlsZSAoaSA8PSBlMSAmJiBpIDw9IGUyKSB7XHJcbiAgICAgIGNvbnN0IG4xID0gYzFbZTFdO1xyXG4gICAgICBjb25zdCBuMiA9IGMyW2UyXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGMyW2UyXSkgOiBub3JtYWxpemVWTm9kZShjMltlMl0pO1xyXG4gICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcclxuICAgICAgICBwYXRjaChcclxuICAgICAgICAgIG4xLFxyXG4gICAgICAgICAgbjIsXHJcbiAgICAgICAgICBjb250YWluZXIsXHJcbiAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgICAgICBuYW1lc3BhY2UsXHJcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXHJcbiAgICAgICAgICBvcHRpbWl6ZWRcclxuICAgICAgICApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGUxLS07XHJcbiAgICAgIGUyLS07XHJcbiAgICB9XHJcbiAgICBpZiAoaSA+IGUxKSB7XHJcbiAgICAgIGlmIChpIDw9IGUyKSB7XHJcbiAgICAgICAgY29uc3QgbmV4dFBvcyA9IGUyICsgMTtcclxuICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0UG9zIDwgbDIgPyBjMltuZXh0UG9zXS5lbCA6IHBhcmVudEFuY2hvcjtcclxuICAgICAgICB3aGlsZSAoaSA8PSBlMikge1xyXG4gICAgICAgICAgcGF0Y2goXHJcbiAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgIGMyW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pLFxyXG4gICAgICAgICAgICBjb250YWluZXIsXHJcbiAgICAgICAgICAgIGFuY2hvcixcclxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcclxuICAgICAgICAgICAgbmFtZXNwYWNlLFxyXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXHJcbiAgICAgICAgICAgIG9wdGltaXplZFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoaSA+IGUyKSB7XHJcbiAgICAgIHdoaWxlIChpIDw9IGUxKSB7XHJcbiAgICAgICAgdW5tb3VudChjMVtpXSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgaSsrO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBzMSA9IGk7XHJcbiAgICAgIGNvbnN0IHMyID0gaTtcclxuICAgICAgY29uc3Qga2V5VG9OZXdJbmRleE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XHJcbiAgICAgIGZvciAoaSA9IHMyOyBpIDw9IGUyOyBpKyspIHtcclxuICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSBjMltpXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGMyW2ldKSA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKTtcclxuICAgICAgICBpZiAobmV4dENoaWxkLmtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXlUb05ld0luZGV4TWFwLmhhcyhuZXh0Q2hpbGQua2V5KSkge1xyXG4gICAgICAgICAgICB3YXJuJDEoXHJcbiAgICAgICAgICAgICAgYER1cGxpY2F0ZSBrZXlzIGZvdW5kIGR1cmluZyB1cGRhdGU6YCxcclxuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShuZXh0Q2hpbGQua2V5KSxcclxuICAgICAgICAgICAgICBgTWFrZSBzdXJlIGtleXMgYXJlIHVuaXF1ZS5gXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBrZXlUb05ld0luZGV4TWFwLnNldChuZXh0Q2hpbGQua2V5LCBpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgbGV0IGo7XHJcbiAgICAgIGxldCBwYXRjaGVkID0gMDtcclxuICAgICAgY29uc3QgdG9CZVBhdGNoZWQgPSBlMiAtIHMyICsgMTtcclxuICAgICAgbGV0IG1vdmVkID0gZmFsc2U7XHJcbiAgICAgIGxldCBtYXhOZXdJbmRleFNvRmFyID0gMDtcclxuICAgICAgY29uc3QgbmV3SW5kZXhUb09sZEluZGV4TWFwID0gbmV3IEFycmF5KHRvQmVQYXRjaGVkKTtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IHRvQmVQYXRjaGVkOyBpKyspIG5ld0luZGV4VG9PbGRJbmRleE1hcFtpXSA9IDA7XHJcbiAgICAgIGZvciAoaSA9IHMxOyBpIDw9IGUxOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwcmV2Q2hpbGQgPSBjMVtpXTtcclxuICAgICAgICBpZiAocGF0Y2hlZCA+PSB0b0JlUGF0Y2hlZCkge1xyXG4gICAgICAgICAgdW5tb3VudChwcmV2Q2hpbGQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBuZXdJbmRleDtcclxuICAgICAgICBpZiAocHJldkNoaWxkLmtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgICBuZXdJbmRleCA9IGtleVRvTmV3SW5kZXhNYXAuZ2V0KHByZXZDaGlsZC5rZXkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBmb3IgKGogPSBzMjsgaiA8PSBlMjsgaisrKSB7XHJcbiAgICAgICAgICAgIGlmIChuZXdJbmRleFRvT2xkSW5kZXhNYXBbaiAtIHMyXSA9PT0gMCAmJiBpc1NhbWVWTm9kZVR5cGUocHJldkNoaWxkLCBjMltqXSkpIHtcclxuICAgICAgICAgICAgICBuZXdJbmRleCA9IGo7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5ld0luZGV4ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgIHVubW91bnQocHJldkNoaWxkLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbmV3SW5kZXhUb09sZEluZGV4TWFwW25ld0luZGV4IC0gczJdID0gaSArIDE7XHJcbiAgICAgICAgICBpZiAobmV3SW5kZXggPj0gbWF4TmV3SW5kZXhTb0Zhcikge1xyXG4gICAgICAgICAgICBtYXhOZXdJbmRleFNvRmFyID0gbmV3SW5kZXg7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBwYXRjaChcclxuICAgICAgICAgICAgcHJldkNoaWxkLFxyXG4gICAgICAgICAgICBjMltuZXdJbmRleF0sXHJcbiAgICAgICAgICAgIGNvbnRhaW5lcixcclxuICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcclxuICAgICAgICAgICAgbmFtZXNwYWNlLFxyXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXHJcbiAgICAgICAgICAgIG9wdGltaXplZFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIHBhdGNoZWQrKztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UgPSBtb3ZlZCA/IGdldFNlcXVlbmNlKG5ld0luZGV4VG9PbGRJbmRleE1hcCkgOiBFTVBUWV9BUlI7XHJcbiAgICAgIGogPSBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZS5sZW5ndGggLSAxO1xyXG4gICAgICBmb3IgKGkgPSB0b0JlUGF0Y2hlZCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gczIgKyBpO1xyXG4gICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IGMyW25leHRJbmRleF07XHJcbiAgICAgICAgY29uc3QgYW5jaG9yID0gbmV4dEluZGV4ICsgMSA8IGwyID8gYzJbbmV4dEluZGV4ICsgMV0uZWwgOiBwYXJlbnRBbmNob3I7XHJcbiAgICAgICAgaWYgKG5ld0luZGV4VG9PbGRJbmRleE1hcFtpXSA9PT0gMCkge1xyXG4gICAgICAgICAgcGF0Y2goXHJcbiAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgIG5leHRDaGlsZCxcclxuICAgICAgICAgICAgY29udGFpbmVyLFxyXG4gICAgICAgICAgICBhbmNob3IsXHJcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcclxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcclxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxyXG4gICAgICAgICAgICBvcHRpbWl6ZWRcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtb3ZlZCkge1xyXG4gICAgICAgICAgaWYgKGogPCAwIHx8IGkgIT09IGluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlW2pdKSB7XHJcbiAgICAgICAgICAgIG1vdmUobmV4dENoaWxkLCBjb250YWluZXIsIGFuY2hvciwgMik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBqLS07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuICBjb25zdCBtb3ZlID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUsIHBhcmVudFN1c3BlbnNlID0gbnVsbCkgPT4ge1xyXG4gICAgY29uc3QgeyBlbCwgdHlwZSwgdHJhbnNpdGlvbiwgY2hpbGRyZW4sIHNoYXBlRmxhZyB9ID0gdm5vZGU7XHJcbiAgICBpZiAoc2hhcGVGbGFnICYgNikge1xyXG4gICAgICBtb3ZlKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XHJcbiAgICAgIHZub2RlLnN1c3BlbnNlLm1vdmUoY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XHJcbiAgICAgIHR5cGUubW92ZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIGludGVybmFscyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlID09PSBGcmFnbWVudCkge1xyXG4gICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBtb3ZlKGNoaWxkcmVuW2ldLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xyXG4gICAgICB9XHJcbiAgICAgIGhvc3RJbnNlcnQodm5vZGUuYW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlID09PSBTdGF0aWMpIHtcclxuICAgICAgbW92ZVN0YXRpY05vZGUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmVlZFRyYW5zaXRpb24yID0gbW92ZVR5cGUgIT09IDIgJiYgc2hhcGVGbGFnICYgMSAmJiB0cmFuc2l0aW9uO1xyXG4gICAgaWYgKG5lZWRUcmFuc2l0aW9uMikge1xyXG4gICAgICBpZiAobW92ZVR5cGUgPT09IDApIHtcclxuICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcclxuICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHRyYW5zaXRpb24uZW50ZXIoZWwpLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgeyBsZWF2ZSwgZGVsYXlMZWF2ZSwgYWZ0ZXJMZWF2ZSB9ID0gdHJhbnNpdGlvbjtcclxuICAgICAgICBjb25zdCByZW1vdmUyID0gKCkgPT4gaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgIGNvbnN0IHBlcmZvcm1MZWF2ZSA9ICgpID0+IHtcclxuICAgICAgICAgIGxlYXZlKGVsLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHJlbW92ZTIoKTtcclxuICAgICAgICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChkZWxheUxlYXZlKSB7XHJcbiAgICAgICAgICBkZWxheUxlYXZlKGVsLCByZW1vdmUyLCBwZXJmb3JtTGVhdmUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBwZXJmb3JtTGVhdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgIH1cclxuICB9O1xyXG4gIGNvbnN0IHVubW91bnQgPSAodm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIHR5cGUsXHJcbiAgICAgIHByb3BzLFxyXG4gICAgICByZWYsXHJcbiAgICAgIGNoaWxkcmVuLFxyXG4gICAgICBkeW5hbWljQ2hpbGRyZW4sXHJcbiAgICAgIHNoYXBlRmxhZyxcclxuICAgICAgcGF0Y2hGbGFnLFxyXG4gICAgICBkaXJzLFxyXG4gICAgICBjYWNoZUluZGV4XHJcbiAgICB9ID0gdm5vZGU7XHJcbiAgICBpZiAocGF0Y2hGbGFnID09PSAtMikge1xyXG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChyZWYgIT0gbnVsbCkge1xyXG4gICAgICBzZXRSZWYocmVmLCBudWxsLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgaWYgKGNhY2hlSW5kZXggIT0gbnVsbCkge1xyXG4gICAgICBwYXJlbnRDb21wb25lbnQucmVuZGVyQ2FjaGVbY2FjaGVJbmRleF0gPSB2b2lkIDA7XHJcbiAgICB9XHJcbiAgICBpZiAoc2hhcGVGbGFnICYgMjU2KSB7XHJcbiAgICAgIHBhcmVudENvbXBvbmVudC5jdHguZGVhY3RpdmF0ZSh2bm9kZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHNob3VsZEludm9rZURpcnMgPSBzaGFwZUZsYWcgJiAxICYmIGRpcnM7XHJcbiAgICBjb25zdCBzaG91bGRJbnZva2VWbm9kZUhvb2sgPSAhaXNBc3luY1dyYXBwZXIodm5vZGUpO1xyXG4gICAgbGV0IHZub2RlSG9vaztcclxuICAgIGlmIChzaG91bGRJbnZva2VWbm9kZUhvb2sgJiYgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVVbm1vdW50KSkge1xyXG4gICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgIH1cclxuICAgIGlmIChzaGFwZUZsYWcgJiA2KSB7XHJcbiAgICAgIHVubW91bnRDb21wb25lbnQodm5vZGUuY29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHNoYXBlRmxhZyAmIDEyOCkge1xyXG4gICAgICAgIHZub2RlLnN1c3BlbnNlLnVubW91bnQocGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNob3VsZEludm9rZURpcnMpIHtcclxuICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiYmVmb3JlVW5tb3VudFwiKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2hhcGVGbGFnICYgNjQpIHtcclxuICAgICAgICB2bm9kZS50eXBlLnJlbW92ZShcclxuICAgICAgICAgIHZub2RlLFxyXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgICAgICBpbnRlcm5hbHMsXHJcbiAgICAgICAgICBkb1JlbW92ZVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gZWxzZSBpZiAoZHluYW1pY0NoaWxkcmVuICYmIC8vICM1MTU0XHJcbiAgICAgIC8vIHdoZW4gdi1vbmNlIGlzIHVzZWQgaW5zaWRlIGEgYmxvY2ssIHNldEJsb2NrVHJhY2tpbmcoLTEpIG1hcmtzIHRoZVxyXG4gICAgICAvLyBwYXJlbnQgYmxvY2sgd2l0aCBoYXNPbmNlOiB0cnVlXHJcbiAgICAgIC8vIHNvIHRoYXQgaXQgZG9lc24ndCB0YWtlIHRoZSBmYXN0IHBhdGggZHVyaW5nIHVubW91bnQgLSBvdGhlcndpc2VcclxuICAgICAgLy8gY29tcG9uZW50cyBuZXN0ZWQgaW4gdi1vbmNlIGFyZSBuZXZlciB1bm1vdW50ZWQuXHJcbiAgICAgICFkeW5hbWljQ2hpbGRyZW4uaGFzT25jZSAmJiAvLyAjMTE1MzogZmFzdCBwYXRoIHNob3VsZCBub3QgYmUgdGFrZW4gZm9yIG5vbi1zdGFibGUgKHYtZm9yKSBmcmFnbWVudHNcclxuICAgICAgKHR5cGUgIT09IEZyYWdtZW50IHx8IHBhdGNoRmxhZyA+IDAgJiYgcGF0Y2hGbGFnICYgNjQpKSB7XHJcbiAgICAgICAgdW5tb3VudENoaWxkcmVuKFxyXG4gICAgICAgICAgZHluYW1pY0NoaWxkcmVuLFxyXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXHJcbiAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgIHRydWVcclxuICAgICAgICApO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEZyYWdtZW50ICYmIHBhdGNoRmxhZyAmICgxMjggfCAyNTYpIHx8ICFvcHRpbWl6ZWQgJiYgc2hhcGVGbGFnICYgMTYpIHtcclxuICAgICAgICB1bm1vdW50Q2hpbGRyZW4oY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChkb1JlbW92ZSkge1xyXG4gICAgICAgIHJlbW92ZSh2bm9kZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChzaG91bGRJbnZva2VWbm9kZUhvb2sgJiYgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVVbm1vdW50ZWQpIHx8IHNob3VsZEludm9rZURpcnMpIHtcclxuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XHJcbiAgICAgICAgc2hvdWxkSW52b2tlRGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwidW5tb3VudGVkXCIpO1xyXG4gICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBjb25zdCByZW1vdmUgPSAodm5vZGUpID0+IHtcclxuICAgIGNvbnN0IHsgdHlwZSwgZWwsIGFuY2hvciwgdHJhbnNpdGlvbiB9ID0gdm5vZGU7XHJcbiAgICBpZiAodHlwZSA9PT0gRnJhZ21lbnQpIHtcclxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdm5vZGUucGF0Y2hGbGFnID4gMCAmJiB2bm9kZS5wYXRjaEZsYWcgJiAyMDQ4ICYmIHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkKSB7XHJcbiAgICAgICAgdm5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcclxuICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBDb21tZW50KSB7XHJcbiAgICAgICAgICAgIGhvc3RSZW1vdmUoY2hpbGQuZWwpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVtb3ZlKGNoaWxkKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZW1vdmVGcmFnbWVudChlbCwgYW5jaG9yKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZSA9PT0gU3RhdGljKSB7XHJcbiAgICAgIHJlbW92ZVN0YXRpY05vZGUodm5vZGUpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBwZXJmb3JtUmVtb3ZlID0gKCkgPT4ge1xyXG4gICAgICBob3N0UmVtb3ZlKGVsKTtcclxuICAgICAgaWYgKHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkICYmIHRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSkge1xyXG4gICAgICAgIHRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEgJiYgdHJhbnNpdGlvbiAmJiAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQpIHtcclxuICAgICAgY29uc3QgeyBsZWF2ZSwgZGVsYXlMZWF2ZSB9ID0gdHJhbnNpdGlvbjtcclxuICAgICAgY29uc3QgcGVyZm9ybUxlYXZlID0gKCkgPT4gbGVhdmUoZWwsIHBlcmZvcm1SZW1vdmUpO1xyXG4gICAgICBpZiAoZGVsYXlMZWF2ZSkge1xyXG4gICAgICAgIGRlbGF5TGVhdmUodm5vZGUuZWwsIHBlcmZvcm1SZW1vdmUsIHBlcmZvcm1MZWF2ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcGVyZm9ybUxlYXZlKCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBlcmZvcm1SZW1vdmUoKTtcclxuICAgIH1cclxuICB9O1xyXG4gIGNvbnN0IHJlbW92ZUZyYWdtZW50ID0gKGN1ciwgZW5kKSA9PiB7XHJcbiAgICBsZXQgbmV4dDtcclxuICAgIHdoaWxlIChjdXIgIT09IGVuZCkge1xyXG4gICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGN1cik7XHJcbiAgICAgIGhvc3RSZW1vdmUoY3VyKTtcclxuICAgICAgY3VyID0gbmV4dDtcclxuICAgIH1cclxuICAgIGhvc3RSZW1vdmUoZW5kKTtcclxuICB9O1xyXG4gIGNvbnN0IHVubW91bnRDb21wb25lbnQgPSAoaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSkgPT4ge1xyXG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaW5zdGFuY2UudHlwZS5fX2htcklkKSB7XHJcbiAgICAgIHVucmVnaXN0ZXJITVIoaW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBidW0sIHNjb3BlLCBqb2IsIHN1YlRyZWUsIHVtLCBtLCBhIH0gPSBpbnN0YW5jZTtcclxuICAgIGludmFsaWRhdGVNb3VudChtKTtcclxuICAgIGludmFsaWRhdGVNb3VudChhKTtcclxuICAgIGlmIChidW0pIHtcclxuICAgICAgaW52b2tlQXJyYXlGbnMoYnVtKTtcclxuICAgIH1cclxuICAgIHNjb3BlLnN0b3AoKTtcclxuICAgIGlmIChqb2IpIHtcclxuICAgICAgam9iLmZsYWdzIHw9IDg7XHJcbiAgICAgIHVubW91bnQoc3ViVHJlZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XHJcbiAgICB9XHJcbiAgICBpZiAodW0pIHtcclxuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KHVtLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICB9XHJcbiAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xyXG4gICAgICBpbnN0YW5jZS5pc1VubW91bnRlZCA9IHRydWU7XHJcbiAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICBpZiAocGFyZW50U3VzcGVuc2UgJiYgcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCAmJiAhcGFyZW50U3VzcGVuc2UuaXNVbm1vdW50ZWQgJiYgaW5zdGFuY2UuYXN5bmNEZXAgJiYgIWluc3RhbmNlLmFzeW5jUmVzb2x2ZWQgJiYgaW5zdGFuY2Uuc3VzcGVuc2VJZCA9PT0gcGFyZW50U3VzcGVuc2UucGVuZGluZ0lkKSB7XHJcbiAgICAgIHBhcmVudFN1c3BlbnNlLmRlcHMtLTtcclxuICAgICAgaWYgKHBhcmVudFN1c3BlbnNlLmRlcHMgPT09IDApIHtcclxuICAgICAgICBwYXJlbnRTdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICBkZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQoaW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgY29uc3QgdW5tb3VudENoaWxkcmVuID0gKGNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSA9IGZhbHNlLCBvcHRpbWl6ZWQgPSBmYWxzZSwgc3RhcnQgPSAwKSA9PiB7XHJcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICB1bm1vdW50KGNoaWxkcmVuW2ldLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSwgb3B0aW1pemVkKTtcclxuICAgIH1cclxuICB9O1xyXG4gIGNvbnN0IGdldE5leHRIb3N0Tm9kZSA9ICh2bm9kZSkgPT4ge1xyXG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYpIHtcclxuICAgICAgcmV0dXJuIGdldE5leHRIb3N0Tm9kZSh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSk7XHJcbiAgICB9XHJcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4KSB7XHJcbiAgICAgIHJldHVybiB2bm9kZS5zdXNwZW5zZS5uZXh0KCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBlbCA9IGhvc3ROZXh0U2libGluZyh2bm9kZS5hbmNob3IgfHwgdm5vZGUuZWwpO1xyXG4gICAgY29uc3QgdGVsZXBvcnRFbmQgPSBlbCAmJiBlbFtUZWxlcG9ydEVuZEtleV07XHJcbiAgICByZXR1cm4gdGVsZXBvcnRFbmQgPyBob3N0TmV4dFNpYmxpbmcodGVsZXBvcnRFbmQpIDogZWw7XHJcbiAgfTtcclxuICBsZXQgaXNGbHVzaGluZyA9IGZhbHNlO1xyXG4gIGNvbnN0IHJlbmRlciA9ICh2bm9kZSwgY29udGFpbmVyLCBuYW1lc3BhY2UpID0+IHtcclxuICAgIGlmICh2bm9kZSA9PSBudWxsKSB7XHJcbiAgICAgIGlmIChjb250YWluZXIuX3Zub2RlKSB7XHJcbiAgICAgICAgdW5tb3VudChjb250YWluZXIuX3Zub2RlLCBudWxsLCBudWxsLCB0cnVlKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcGF0Y2goXHJcbiAgICAgICAgY29udGFpbmVyLl92bm9kZSB8fCBudWxsLFxyXG4gICAgICAgIHZub2RlLFxyXG4gICAgICAgIGNvbnRhaW5lcixcclxuICAgICAgICBudWxsLFxyXG4gICAgICAgIG51bGwsXHJcbiAgICAgICAgbnVsbCxcclxuICAgICAgICBuYW1lc3BhY2VcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIGNvbnRhaW5lci5fdm5vZGUgPSB2bm9kZTtcclxuICAgIGlmICghaXNGbHVzaGluZykge1xyXG4gICAgICBpc0ZsdXNoaW5nID0gdHJ1ZTtcclxuICAgICAgZmx1c2hQcmVGbHVzaENicygpO1xyXG4gICAgICBmbHVzaFBvc3RGbHVzaENicygpO1xyXG4gICAgICBpc0ZsdXNoaW5nID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfTtcclxuICBjb25zdCBpbnRlcm5hbHMgPSB7XHJcbiAgICBwOiBwYXRjaCxcclxuICAgIHVtOiB1bm1vdW50LFxyXG4gICAgbTogbW92ZSxcclxuICAgIHI6IHJlbW92ZSxcclxuICAgIG10OiBtb3VudENvbXBvbmVudCxcclxuICAgIG1jOiBtb3VudENoaWxkcmVuLFxyXG4gICAgcGM6IHBhdGNoQ2hpbGRyZW4sXHJcbiAgICBwYmM6IHBhdGNoQmxvY2tDaGlsZHJlbixcclxuICAgIG46IGdldE5leHRIb3N0Tm9kZSxcclxuICAgIG86IG9wdGlvbnNcclxuICB9O1xyXG4gIGxldCBoeWRyYXRlO1xyXG4gIGxldCBoeWRyYXRlTm9kZTtcclxuICBpZiAoY3JlYXRlSHlkcmF0aW9uRm5zKSB7XHJcbiAgICBbaHlkcmF0ZSwgaHlkcmF0ZU5vZGVdID0gY3JlYXRlSHlkcmF0aW9uRm5zKFxyXG4gICAgICBpbnRlcm5hbHNcclxuICAgICk7XHJcbiAgfVxyXG4gIHJldHVybiB7XHJcbiAgICByZW5kZXIsXHJcbiAgICBoeWRyYXRlLFxyXG4gICAgY3JlYXRlQXBwOiBjcmVhdGVBcHBBUEkocmVuZGVyLCBoeWRyYXRlKVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZUNoaWxkcmVuTmFtZXNwYWNlKHsgdHlwZSwgcHJvcHMgfSwgY3VycmVudE5hbWVzcGFjZSkge1xyXG4gIHJldHVybiBjdXJyZW50TmFtZXNwYWNlID09PSBcInN2Z1wiICYmIHR5cGUgPT09IFwiZm9yZWlnbk9iamVjdFwiIHx8IGN1cnJlbnROYW1lc3BhY2UgPT09IFwibWF0aG1sXCIgJiYgdHlwZSA9PT0gXCJhbm5vdGF0aW9uLXhtbFwiICYmIHByb3BzICYmIHByb3BzLmVuY29kaW5nICYmIHByb3BzLmVuY29kaW5nLmluY2x1ZGVzKFwiaHRtbFwiKSA/IHZvaWQgMCA6IGN1cnJlbnROYW1lc3BhY2U7XHJcbn1cclxuZnVuY3Rpb24gdG9nZ2xlUmVjdXJzZSh7IGVmZmVjdCwgam9iIH0sIGFsbG93ZWQpIHtcclxuICBpZiAoYWxsb3dlZCkge1xyXG4gICAgZWZmZWN0LmZsYWdzIHw9IDMyO1xyXG4gICAgam9iLmZsYWdzIHw9IDQ7XHJcbiAgfSBlbHNlIHtcclxuICAgIGVmZmVjdC5mbGFncyAmPSB+MzI7XHJcbiAgICBqb2IuZmxhZ3MgJj0gfjQ7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIG5lZWRUcmFuc2l0aW9uKHBhcmVudFN1c3BlbnNlLCB0cmFuc2l0aW9uKSB7XHJcbiAgcmV0dXJuICghcGFyZW50U3VzcGVuc2UgfHwgcGFyZW50U3VzcGVuc2UgJiYgIXBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpICYmIHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkO1xyXG59XHJcbmZ1bmN0aW9uIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yLCBzaGFsbG93ID0gZmFsc2UpIHtcclxuICBjb25zdCBjaDEgPSBuMS5jaGlsZHJlbjtcclxuICBjb25zdCBjaDIgPSBuMi5jaGlsZHJlbjtcclxuICBpZiAoaXNBcnJheShjaDEpICYmIGlzQXJyYXkoY2gyKSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaDEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgYzEgPSBjaDFbaV07XHJcbiAgICAgIGxldCBjMiA9IGNoMltpXTtcclxuICAgICAgaWYgKGMyLnNoYXBlRmxhZyAmIDEgJiYgIWMyLmR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgIGlmIChjMi5wYXRjaEZsYWcgPD0gMCB8fCBjMi5wYXRjaEZsYWcgPT09IDMyKSB7XHJcbiAgICAgICAgICBjMiA9IGNoMltpXSA9IGNsb25lSWZNb3VudGVkKGNoMltpXSk7XHJcbiAgICAgICAgICBjMi5lbCA9IGMxLmVsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXNoYWxsb3cgJiYgYzIucGF0Y2hGbGFnICE9PSAtMilcclxuICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4oYzEsIGMyKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoYzIudHlwZSA9PT0gVGV4dCkge1xyXG4gICAgICAgIGMyLmVsID0gYzEuZWw7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgYzIudHlwZSA9PT0gQ29tbWVudCAmJiAhYzIuZWwpIHtcclxuICAgICAgICBjMi5lbCA9IGMxLmVsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFNlcXVlbmNlKGFycikge1xyXG4gIGNvbnN0IHAgPSBhcnIuc2xpY2UoKTtcclxuICBjb25zdCByZXN1bHQgPSBbMF07XHJcbiAgbGV0IGksIGosIHUsIHYsIGM7XHJcbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgIGNvbnN0IGFyckkgPSBhcnJbaV07XHJcbiAgICBpZiAoYXJySSAhPT0gMCkge1xyXG4gICAgICBqID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcclxuICAgICAgaWYgKGFycltqXSA8IGFyckkpIHtcclxuICAgICAgICBwW2ldID0gajtcclxuICAgICAgICByZXN1bHQucHVzaChpKTtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICB1ID0gMDtcclxuICAgICAgdiA9IHJlc3VsdC5sZW5ndGggLSAxO1xyXG4gICAgICB3aGlsZSAodSA8IHYpIHtcclxuICAgICAgICBjID0gdSArIHYgPj4gMTtcclxuICAgICAgICBpZiAoYXJyW3Jlc3VsdFtjXV0gPCBhcnJJKSB7XHJcbiAgICAgICAgICB1ID0gYyArIDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHYgPSBjO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoYXJySSA8IGFycltyZXN1bHRbdV1dKSB7XHJcbiAgICAgICAgaWYgKHUgPiAwKSB7XHJcbiAgICAgICAgICBwW2ldID0gcmVzdWx0W3UgLSAxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0W3VdID0gaTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICB1ID0gcmVzdWx0Lmxlbmd0aDtcclxuICB2ID0gcmVzdWx0W3UgLSAxXTtcclxuICB3aGlsZSAodS0tID4gMCkge1xyXG4gICAgcmVzdWx0W3VdID0gdjtcclxuICAgIHYgPSBwW3ZdO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGxvY2F0ZU5vbkh5ZHJhdGVkQXN5bmNSb290KGluc3RhbmNlKSB7XHJcbiAgY29uc3Qgc3ViQ29tcG9uZW50ID0gaW5zdGFuY2Uuc3ViVHJlZS5jb21wb25lbnQ7XHJcbiAgaWYgKHN1YkNvbXBvbmVudCkge1xyXG4gICAgaWYgKHN1YkNvbXBvbmVudC5hc3luY0RlcCAmJiAhc3ViQ29tcG9uZW50LmFzeW5jUmVzb2x2ZWQpIHtcclxuICAgICAgcmV0dXJuIHN1YkNvbXBvbmVudDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBsb2NhdGVOb25IeWRyYXRlZEFzeW5jUm9vdChzdWJDb21wb25lbnQpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBpbnZhbGlkYXRlTW91bnQoaG9va3MpIHtcclxuICBpZiAoaG9va3MpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspXHJcbiAgICAgIGhvb2tzW2ldLmZsYWdzIHw9IDg7XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBzc3JDb250ZXh0S2V5ID0gU3ltYm9sLmZvcihcInYtc2N4XCIpO1xyXG5jb25zdCB1c2VTU1JDb250ZXh0ID0gKCkgPT4ge1xyXG4gIHtcclxuICAgIGNvbnN0IGN0eCA9IGluamVjdChzc3JDb250ZXh0S2V5KTtcclxuICAgIGlmICghY3R4KSB7XHJcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKFxyXG4gICAgICAgIGBTZXJ2ZXIgcmVuZGVyaW5nIGNvbnRleHQgbm90IHByb3ZpZGVkLiBNYWtlIHN1cmUgdG8gb25seSBjYWxsIHVzZVNTUkNvbnRleHQoKSBjb25kaXRpb25hbGx5IGluIHRoZSBzZXJ2ZXIgYnVpbGQuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGN0eDtcclxuICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiB3YXRjaEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcclxuICByZXR1cm4gZG9XYXRjaChlZmZlY3QsIG51bGwsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIHdhdGNoUG9zdEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcclxuICByZXR1cm4gZG9XYXRjaChcclxuICAgIGVmZmVjdCxcclxuICAgIG51bGwsXHJcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gZXh0ZW5kKHt9LCBvcHRpb25zLCB7IGZsdXNoOiBcInBvc3RcIiB9KSA6IHsgZmx1c2g6IFwicG9zdFwiIH1cclxuICApO1xyXG59XHJcbmZ1bmN0aW9uIHdhdGNoU3luY0VmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcclxuICByZXR1cm4gZG9XYXRjaChcclxuICAgIGVmZmVjdCxcclxuICAgIG51bGwsXHJcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gZXh0ZW5kKHt9LCBvcHRpb25zLCB7IGZsdXNoOiBcInN5bmNcIiB9KSA6IHsgZmx1c2g6IFwic3luY1wiIH1cclxuICApO1xyXG59XHJcbmZ1bmN0aW9uIHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpIHtcclxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNGdW5jdGlvbihjYikpIHtcclxuICAgIHdhcm4kMShcclxuICAgICAgYFxcYHdhdGNoKGZuLCBvcHRpb25zPylcXGAgc2lnbmF0dXJlIGhhcyBiZWVuIG1vdmVkIHRvIGEgc2VwYXJhdGUgQVBJLiBVc2UgXFxgd2F0Y2hFZmZlY3QoZm4sIG9wdGlvbnM/KVxcYCBpbnN0ZWFkLiBcXGB3YXRjaFxcYCBub3cgb25seSBzdXBwb3J0cyBcXGB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zPykgc2lnbmF0dXJlLmBcclxuICAgICk7XHJcbiAgfVxyXG4gIHJldHVybiBkb1dhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIGRvV2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucyA9IEVNUFRZX09CSikge1xyXG4gIGNvbnN0IHsgaW1tZWRpYXRlLCBkZWVwLCBmbHVzaCwgb25jZSB9ID0gb3B0aW9ucztcclxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhY2IpIHtcclxuICAgIGlmIChpbW1lZGlhdGUgIT09IHZvaWQgMCkge1xyXG4gICAgICB3YXJuJDEoXHJcbiAgICAgICAgYHdhdGNoKCkgXCJpbW1lZGlhdGVcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICBpZiAoZGVlcCAhPT0gdm9pZCAwKSB7XHJcbiAgICAgIHdhcm4kMShcclxuICAgICAgICBgd2F0Y2goKSBcImRlZXBcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICBpZiAob25jZSAhPT0gdm9pZCAwKSB7XHJcbiAgICAgIHdhcm4kMShcclxuICAgICAgICBgd2F0Y2goKSBcIm9uY2VcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNvbnN0IGJhc2VXYXRjaE9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xyXG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSBiYXNlV2F0Y2hPcHRpb25zLm9uV2FybiA9IHdhcm4kMTtcclxuICBjb25zdCBydW5zSW1tZWRpYXRlbHkgPSBjYiAmJiBpbW1lZGlhdGUgfHwgIWNiICYmIGZsdXNoICE9PSBcInBvc3RcIjtcclxuICBsZXQgc3NyQ2xlYW51cDtcclxuICBpZiAoaXNJblNTUkNvbXBvbmVudFNldHVwKSB7XHJcbiAgICBpZiAoZmx1c2ggPT09IFwic3luY1wiKSB7XHJcbiAgICAgIGNvbnN0IGN0eCA9IHVzZVNTUkNvbnRleHQoKTtcclxuICAgICAgc3NyQ2xlYW51cCA9IGN0eC5fX3dhdGNoZXJIYW5kbGVzIHx8IChjdHguX193YXRjaGVySGFuZGxlcyA9IFtdKTtcclxuICAgIH0gZWxzZSBpZiAoIXJ1bnNJbW1lZGlhdGVseSkge1xyXG4gICAgICBjb25zdCB3YXRjaFN0b3BIYW5kbGUgPSAoKSA9PiB7XHJcbiAgICAgIH07XHJcbiAgICAgIHdhdGNoU3RvcEhhbmRsZS5zdG9wID0gTk9PUDtcclxuICAgICAgd2F0Y2hTdG9wSGFuZGxlLnJlc3VtZSA9IE5PT1A7XHJcbiAgICAgIHdhdGNoU3RvcEhhbmRsZS5wYXVzZSA9IE5PT1A7XHJcbiAgICAgIHJldHVybiB3YXRjaFN0b3BIYW5kbGU7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNvbnN0IGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlO1xyXG4gIGJhc2VXYXRjaE9wdGlvbnMuY2FsbCA9IChmbiwgdHlwZSwgYXJncykgPT4gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKTtcclxuICBsZXQgaXNQcmUgPSBmYWxzZTtcclxuICBpZiAoZmx1c2ggPT09IFwicG9zdFwiKSB7XHJcbiAgICBiYXNlV2F0Y2hPcHRpb25zLnNjaGVkdWxlciA9IChqb2IpID0+IHtcclxuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGpvYiwgaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc3VzcGVuc2UpO1xyXG4gICAgfTtcclxuICB9IGVsc2UgaWYgKGZsdXNoICE9PSBcInN5bmNcIikge1xyXG4gICAgaXNQcmUgPSB0cnVlO1xyXG4gICAgYmFzZVdhdGNoT3B0aW9ucy5zY2hlZHVsZXIgPSAoam9iLCBpc0ZpcnN0UnVuKSA9PiB7XHJcbiAgICAgIGlmIChpc0ZpcnN0UnVuKSB7XHJcbiAgICAgICAgam9iKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcXVldWVKb2Ioam9iKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcbiAgYmFzZVdhdGNoT3B0aW9ucy5hdWdtZW50Sm9iID0gKGpvYikgPT4ge1xyXG4gICAgaWYgKGNiKSB7XHJcbiAgICAgIGpvYi5mbGFncyB8PSA0O1xyXG4gICAgfVxyXG4gICAgaWYgKGlzUHJlKSB7XHJcbiAgICAgIGpvYi5mbGFncyB8PSAyO1xyXG4gICAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICBqb2IuaWQgPSBpbnN0YW5jZS51aWQ7XHJcbiAgICAgICAgam9iLmkgPSBpbnN0YW5jZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcbiAgY29uc3Qgd2F0Y2hIYW5kbGUgPSB3YXRjaCQxKHNvdXJjZSwgY2IsIGJhc2VXYXRjaE9wdGlvbnMpO1xyXG4gIGlmIChpc0luU1NSQ29tcG9uZW50U2V0dXApIHtcclxuICAgIGlmIChzc3JDbGVhbnVwKSB7XHJcbiAgICAgIHNzckNsZWFudXAucHVzaCh3YXRjaEhhbmRsZSk7XHJcbiAgICB9IGVsc2UgaWYgKHJ1bnNJbW1lZGlhdGVseSkge1xyXG4gICAgICB3YXRjaEhhbmRsZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gd2F0Y2hIYW5kbGU7XHJcbn1cclxuZnVuY3Rpb24gaW5zdGFuY2VXYXRjaChzb3VyY2UsIHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgY29uc3QgcHVibGljVGhpcyA9IHRoaXMucHJveHk7XHJcbiAgY29uc3QgZ2V0dGVyID0gaXNTdHJpbmcoc291cmNlKSA/IHNvdXJjZS5pbmNsdWRlcyhcIi5cIikgPyBjcmVhdGVQYXRoR2V0dGVyKHB1YmxpY1RoaXMsIHNvdXJjZSkgOiAoKSA9PiBwdWJsaWNUaGlzW3NvdXJjZV0gOiBzb3VyY2UuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKTtcclxuICBsZXQgY2I7XHJcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICBjYiA9IHZhbHVlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjYiA9IHZhbHVlLmhhbmRsZXI7XHJcbiAgICBvcHRpb25zID0gdmFsdWU7XHJcbiAgfVxyXG4gIGNvbnN0IHJlc2V0ID0gc2V0Q3VycmVudEluc3RhbmNlKHRoaXMpO1xyXG4gIGNvbnN0IHJlcyA9IGRvV2F0Y2goZ2V0dGVyLCBjYi5iaW5kKHB1YmxpY1RoaXMpLCBvcHRpb25zKTtcclxuICByZXNldCgpO1xyXG4gIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUGF0aEdldHRlcihjdHgsIHBhdGgpIHtcclxuICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIuXCIpO1xyXG4gIHJldHVybiAoKSA9PiB7XHJcbiAgICBsZXQgY3VyID0gY3R4O1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGggJiYgY3VyOyBpKyspIHtcclxuICAgICAgY3VyID0gY3VyW3NlZ21lbnRzW2ldXTtcclxuICAgIH1cclxuICAgIHJldHVybiBjdXI7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gdXNlTW9kZWwocHJvcHMsIG5hbWUsIG9wdGlvbnMgPSBFTVBUWV9PQkopIHtcclxuICBjb25zdCBpID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWkpIHtcclxuICAgIHdhcm4kMShgdXNlTW9kZWwoKSBjYWxsZWQgd2l0aG91dCBhY3RpdmUgaW5zdGFuY2UuYCk7XHJcbiAgICByZXR1cm4gcmVmKCk7XHJcbiAgfVxyXG4gIGNvbnN0IGNhbWVsaXplZE5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcclxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaS5wcm9wc09wdGlvbnNbMF1bY2FtZWxpemVkTmFtZV0pIHtcclxuICAgIHdhcm4kMShgdXNlTW9kZWwoKSBjYWxsZWQgd2l0aCBwcm9wIFwiJHtuYW1lfVwiIHdoaWNoIGlzIG5vdCBkZWNsYXJlZC5gKTtcclxuICAgIHJldHVybiByZWYoKTtcclxuICB9XHJcbiAgY29uc3QgaHlwaGVuYXRlZE5hbWUgPSBoeXBoZW5hdGUobmFtZSk7XHJcbiAgY29uc3QgbW9kaWZpZXJzID0gZ2V0TW9kZWxNb2RpZmllcnMocHJvcHMsIGNhbWVsaXplZE5hbWUpO1xyXG4gIGNvbnN0IHJlcyA9IGN1c3RvbVJlZigodHJhY2ssIHRyaWdnZXIpID0+IHtcclxuICAgIGxldCBsb2NhbFZhbHVlO1xyXG4gICAgbGV0IHByZXZTZXRWYWx1ZSA9IEVNUFRZX09CSjtcclxuICAgIGxldCBwcmV2RW1pdHRlZFZhbHVlO1xyXG4gICAgd2F0Y2hTeW5jRWZmZWN0KCgpID0+IHtcclxuICAgICAgY29uc3QgcHJvcFZhbHVlID0gcHJvcHNbY2FtZWxpemVkTmFtZV07XHJcbiAgICAgIGlmIChoYXNDaGFuZ2VkKGxvY2FsVmFsdWUsIHByb3BWYWx1ZSkpIHtcclxuICAgICAgICBsb2NhbFZhbHVlID0gcHJvcFZhbHVlO1xyXG4gICAgICAgIHRyaWdnZXIoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBnZXQoKSB7XHJcbiAgICAgICAgdHJhY2soKTtcclxuICAgICAgICByZXR1cm4gb3B0aW9ucy5nZXQgPyBvcHRpb25zLmdldChsb2NhbFZhbHVlKSA6IGxvY2FsVmFsdWU7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldCh2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IGVtaXR0ZWRWYWx1ZSA9IG9wdGlvbnMuc2V0ID8gb3B0aW9ucy5zZXQodmFsdWUpIDogdmFsdWU7XHJcbiAgICAgICAgaWYgKCFoYXNDaGFuZ2VkKGVtaXR0ZWRWYWx1ZSwgbG9jYWxWYWx1ZSkgJiYgIShwcmV2U2V0VmFsdWUgIT09IEVNUFRZX09CSiAmJiBoYXNDaGFuZ2VkKHZhbHVlLCBwcmV2U2V0VmFsdWUpKSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByYXdQcm9wcyA9IGkudm5vZGUucHJvcHM7XHJcbiAgICAgICAgaWYgKCEocmF3UHJvcHMgJiYgLy8gY2hlY2sgaWYgcGFyZW50IGhhcyBwYXNzZWQgdi1tb2RlbFxyXG4gICAgICAgIChuYW1lIGluIHJhd1Byb3BzIHx8IGNhbWVsaXplZE5hbWUgaW4gcmF3UHJvcHMgfHwgaHlwaGVuYXRlZE5hbWUgaW4gcmF3UHJvcHMpICYmIChgb25VcGRhdGU6JHtuYW1lfWAgaW4gcmF3UHJvcHMgfHwgYG9uVXBkYXRlOiR7Y2FtZWxpemVkTmFtZX1gIGluIHJhd1Byb3BzIHx8IGBvblVwZGF0ZToke2h5cGhlbmF0ZWROYW1lfWAgaW4gcmF3UHJvcHMpKSkge1xyXG4gICAgICAgICAgbG9jYWxWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgdHJpZ2dlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpLmVtaXQoYHVwZGF0ZToke25hbWV9YCwgZW1pdHRlZFZhbHVlKTtcclxuICAgICAgICBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgZW1pdHRlZFZhbHVlKSAmJiBoYXNDaGFuZ2VkKHZhbHVlLCBwcmV2U2V0VmFsdWUpICYmICFoYXNDaGFuZ2VkKGVtaXR0ZWRWYWx1ZSwgcHJldkVtaXR0ZWRWYWx1ZSkpIHtcclxuICAgICAgICAgIHRyaWdnZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJldlNldFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgcHJldkVtaXR0ZWRWYWx1ZSA9IGVtaXR0ZWRWYWx1ZTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9KTtcclxuICByZXNbU3ltYm9sLml0ZXJhdG9yXSA9ICgpID0+IHtcclxuICAgIGxldCBpMiA9IDA7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBuZXh0KCkge1xyXG4gICAgICAgIGlmIChpMiA8IDIpIHtcclxuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBpMisrID8gbW9kaWZpZXJzIHx8IEVNUFRZX09CSiA6IHJlcywgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9O1xyXG4gIHJldHVybiByZXM7XHJcbn1cclxuY29uc3QgZ2V0TW9kZWxNb2RpZmllcnMgPSAocHJvcHMsIG1vZGVsTmFtZSkgPT4ge1xyXG4gIHJldHVybiBtb2RlbE5hbWUgPT09IFwibW9kZWxWYWx1ZVwiIHx8IG1vZGVsTmFtZSA9PT0gXCJtb2RlbC12YWx1ZVwiID8gcHJvcHMubW9kZWxNb2RpZmllcnMgOiBwcm9wc1tgJHttb2RlbE5hbWV9TW9kaWZpZXJzYF0gfHwgcHJvcHNbYCR7Y2FtZWxpemUobW9kZWxOYW1lKX1Nb2RpZmllcnNgXSB8fCBwcm9wc1tgJHtoeXBoZW5hdGUobW9kZWxOYW1lKX1Nb2RpZmllcnNgXTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGVtaXQoaW5zdGFuY2UsIGV2ZW50LCAuLi5yYXdBcmdzKSB7XHJcbiAgaWYgKGluc3RhbmNlLmlzVW5tb3VudGVkKSByZXR1cm47XHJcbiAgY29uc3QgcHJvcHMgPSBpbnN0YW5jZS52bm9kZS5wcm9wcyB8fCBFTVBUWV9PQko7XHJcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgZW1pdHNPcHRpb25zLFxyXG4gICAgICBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdXHJcbiAgICB9ID0gaW5zdGFuY2U7XHJcbiAgICBpZiAoZW1pdHNPcHRpb25zKSB7XHJcbiAgICAgIGlmICghKGV2ZW50IGluIGVtaXRzT3B0aW9ucykgJiYgdHJ1ZSkge1xyXG4gICAgICAgIGlmICghcHJvcHNPcHRpb25zIHx8ICEodG9IYW5kbGVyS2V5KGNhbWVsaXplKGV2ZW50KSkgaW4gcHJvcHNPcHRpb25zKSkge1xyXG4gICAgICAgICAgd2FybiQxKFxyXG4gICAgICAgICAgICBgQ29tcG9uZW50IGVtaXR0ZWQgZXZlbnQgXCIke2V2ZW50fVwiIGJ1dCBpdCBpcyBuZWl0aGVyIGRlY2xhcmVkIGluIHRoZSBlbWl0cyBvcHRpb24gbm9yIGFzIGFuIFwiJHt0b0hhbmRsZXJLZXkoY2FtZWxpemUoZXZlbnQpKX1cIiBwcm9wLmBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IGVtaXRzT3B0aW9uc1tldmVudF07XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsaWRhdG9yKSkge1xyXG4gICAgICAgICAgY29uc3QgaXNWYWxpZCA9IHZhbGlkYXRvciguLi5yYXdBcmdzKTtcclxuICAgICAgICAgIGlmICghaXNWYWxpZCkge1xyXG4gICAgICAgICAgICB3YXJuJDEoXHJcbiAgICAgICAgICAgICAgYEludmFsaWQgZXZlbnQgYXJndW1lbnRzOiBldmVudCB2YWxpZGF0aW9uIGZhaWxlZCBmb3IgZXZlbnQgXCIke2V2ZW50fVwiLmBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgbGV0IGFyZ3MgPSByYXdBcmdzO1xyXG4gIGNvbnN0IGlzTW9kZWxMaXN0ZW5lciA9IGV2ZW50LnN0YXJ0c1dpdGgoXCJ1cGRhdGU6XCIpO1xyXG4gIGNvbnN0IG1vZGlmaWVycyA9IGlzTW9kZWxMaXN0ZW5lciAmJiBnZXRNb2RlbE1vZGlmaWVycyhwcm9wcywgZXZlbnQuc2xpY2UoNykpO1xyXG4gIGlmIChtb2RpZmllcnMpIHtcclxuICAgIGlmIChtb2RpZmllcnMudHJpbSkge1xyXG4gICAgICBhcmdzID0gcmF3QXJncy5tYXAoKGEpID0+IGlzU3RyaW5nKGEpID8gYS50cmltKCkgOiBhKTtcclxuICAgIH1cclxuICAgIGlmIChtb2RpZmllcnMubnVtYmVyKSB7XHJcbiAgICAgIGFyZ3MgPSByYXdBcmdzLm1hcChsb29zZVRvTnVtYmVyKTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICBkZXZ0b29sc0NvbXBvbmVudEVtaXQoaW5zdGFuY2UsIGV2ZW50LCBhcmdzKTtcclxuICB9XHJcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgIGNvbnN0IGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcclxuICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgcHJvcHNbdG9IYW5kbGVyS2V5KGxvd2VyQ2FzZUV2ZW50KV0pIHtcclxuICAgICAgd2FybiQxKFxyXG4gICAgICAgIGBFdmVudCBcIiR7bG93ZXJDYXNlRXZlbnR9XCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgJHtmb3JtYXRDb21wb25lbnROYW1lKFxyXG4gICAgICAgICAgaW5zdGFuY2UsXHJcbiAgICAgICAgICBpbnN0YW5jZS50eXBlXHJcbiAgICAgICAgKX0gYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFwiJHtldmVudH1cIi4gTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2Ugdi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFwiJHtoeXBoZW5hdGUoXHJcbiAgICAgICAgICBldmVudFxyXG4gICAgICAgICl9XCIgaW5zdGVhZCBvZiBcIiR7ZXZlbnR9XCIuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuICBsZXQgaGFuZGxlck5hbWU7XHJcbiAgbGV0IGhhbmRsZXIgPSBwcm9wc1toYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShldmVudCldIHx8IC8vIGFsc28gdHJ5IGNhbWVsQ2FzZSBldmVudCBoYW5kbGVyICgjMjI0OSlcclxuICBwcm9wc1toYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShjYW1lbGl6ZShldmVudCkpXTtcclxuICBpZiAoIWhhbmRsZXIgJiYgaXNNb2RlbExpc3RlbmVyKSB7XHJcbiAgICBoYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoaHlwaGVuYXRlKGV2ZW50KSldO1xyXG4gIH1cclxuICBpZiAoaGFuZGxlcikge1xyXG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXHJcbiAgICAgIGhhbmRsZXIsXHJcbiAgICAgIGluc3RhbmNlLFxyXG4gICAgICA2LFxyXG4gICAgICBhcmdzXHJcbiAgICApO1xyXG4gIH1cclxuICBjb25zdCBvbmNlSGFuZGxlciA9IHByb3BzW2hhbmRsZXJOYW1lICsgYE9uY2VgXTtcclxuICBpZiAob25jZUhhbmRsZXIpIHtcclxuICAgIGlmICghaW5zdGFuY2UuZW1pdHRlZCkge1xyXG4gICAgICBpbnN0YW5jZS5lbWl0dGVkID0ge307XHJcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLmVtaXR0ZWRbaGFuZGxlck5hbWVdKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGluc3RhbmNlLmVtaXR0ZWRbaGFuZGxlck5hbWVdID0gdHJ1ZTtcclxuICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxyXG4gICAgICBvbmNlSGFuZGxlcixcclxuICAgICAgaW5zdGFuY2UsXHJcbiAgICAgIDYsXHJcbiAgICAgIGFyZ3NcclxuICAgICk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyhjb21wLCBhcHBDb250ZXh0LCBhc01peGluID0gZmFsc2UpIHtcclxuICBjb25zdCBjYWNoZSA9IGFwcENvbnRleHQuZW1pdHNDYWNoZTtcclxuICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoY29tcCk7XHJcbiAgaWYgKGNhY2hlZCAhPT0gdm9pZCAwKSB7XHJcbiAgICByZXR1cm4gY2FjaGVkO1xyXG4gIH1cclxuICBjb25zdCByYXcgPSBjb21wLmVtaXRzO1xyXG4gIGxldCBub3JtYWxpemVkID0ge307XHJcbiAgbGV0IGhhc0V4dGVuZHMgPSBmYWxzZTtcclxuICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xyXG4gICAgY29uc3QgZXh0ZW5kRW1pdHMgPSAocmF3MikgPT4ge1xyXG4gICAgICBjb25zdCBub3JtYWxpemVkRnJvbUV4dGVuZCA9IG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyhyYXcyLCBhcHBDb250ZXh0LCB0cnVlKTtcclxuICAgICAgaWYgKG5vcm1hbGl6ZWRGcm9tRXh0ZW5kKSB7XHJcbiAgICAgICAgaGFzRXh0ZW5kcyA9IHRydWU7XHJcbiAgICAgICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIG5vcm1hbGl6ZWRGcm9tRXh0ZW5kKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIGlmICghYXNNaXhpbiAmJiBhcHBDb250ZXh0Lm1peGlucy5sZW5ndGgpIHtcclxuICAgICAgYXBwQ29udGV4dC5taXhpbnMuZm9yRWFjaChleHRlbmRFbWl0cyk7XHJcbiAgICB9XHJcbiAgICBpZiAoY29tcC5leHRlbmRzKSB7XHJcbiAgICAgIGV4dGVuZEVtaXRzKGNvbXAuZXh0ZW5kcyk7XHJcbiAgICB9XHJcbiAgICBpZiAoY29tcC5taXhpbnMpIHtcclxuICAgICAgY29tcC5taXhpbnMuZm9yRWFjaChleHRlbmRFbWl0cyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmICghcmF3ICYmICFoYXNFeHRlbmRzKSB7XHJcbiAgICBpZiAoaXNPYmplY3QoY29tcCkpIHtcclxuICAgICAgY2FjaGUuc2V0KGNvbXAsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIGlmIChpc0FycmF5KHJhdykpIHtcclxuICAgIHJhdy5mb3JFYWNoKChrZXkpID0+IG5vcm1hbGl6ZWRba2V5XSA9IG51bGwpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBleHRlbmQobm9ybWFsaXplZCwgcmF3KTtcclxuICB9XHJcbiAgaWYgKGlzT2JqZWN0KGNvbXApKSB7XHJcbiAgICBjYWNoZS5zZXQoY29tcCwgbm9ybWFsaXplZCk7XHJcbiAgfVxyXG4gIHJldHVybiBub3JtYWxpemVkO1xyXG59XHJcbmZ1bmN0aW9uIGlzRW1pdExpc3RlbmVyKG9wdGlvbnMsIGtleSkge1xyXG4gIGlmICghb3B0aW9ucyB8fCAhaXNPbihrZXkpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIGtleSA9IGtleS5zbGljZSgyKS5yZXBsYWNlKC9PbmNlJC8sIFwiXCIpO1xyXG4gIHJldHVybiBoYXNPd24ob3B0aW9ucywga2V5WzBdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSkpIHx8IGhhc093bihvcHRpb25zLCBoeXBoZW5hdGUoa2V5KSkgfHwgaGFzT3duKG9wdGlvbnMsIGtleSk7XHJcbn1cclxuXHJcbmxldCBhY2Nlc3NlZEF0dHJzID0gZmFsc2U7XHJcbmZ1bmN0aW9uIG1hcmtBdHRyc0FjY2Vzc2VkKCkge1xyXG4gIGFjY2Vzc2VkQXR0cnMgPSB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpIHtcclxuICBjb25zdCB7XHJcbiAgICB0eXBlOiBDb21wb25lbnQsXHJcbiAgICB2bm9kZSxcclxuICAgIHByb3h5LFxyXG4gICAgd2l0aFByb3h5LFxyXG4gICAgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXSxcclxuICAgIHNsb3RzLFxyXG4gICAgYXR0cnMsXHJcbiAgICBlbWl0LFxyXG4gICAgcmVuZGVyLFxyXG4gICAgcmVuZGVyQ2FjaGUsXHJcbiAgICBwcm9wcyxcclxuICAgIGRhdGEsXHJcbiAgICBzZXR1cFN0YXRlLFxyXG4gICAgY3R4LFxyXG4gICAgaW5oZXJpdEF0dHJzXHJcbiAgfSA9IGluc3RhbmNlO1xyXG4gIGNvbnN0IHByZXYgPSBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaW5zdGFuY2UpO1xyXG4gIGxldCByZXN1bHQ7XHJcbiAgbGV0IGZhbGx0aHJvdWdoQXR0cnM7XHJcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgIGFjY2Vzc2VkQXR0cnMgPSBmYWxzZTtcclxuICB9XHJcbiAgdHJ5IHtcclxuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA0KSB7XHJcbiAgICAgIGNvbnN0IHByb3h5VG9Vc2UgPSB3aXRoUHJveHkgfHwgcHJveHk7XHJcbiAgICAgIGNvbnN0IHRoaXNQcm94eSA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2V0dXBTdGF0ZS5fX2lzU2NyaXB0U2V0dXAgPyBuZXcgUHJveHkocHJveHlUb1VzZSwge1xyXG4gICAgICAgIGdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpIHtcclxuICAgICAgICAgIHdhcm4kMShcclxuICAgICAgICAgICAgYFByb3BlcnR5ICcke1N0cmluZyhcclxuICAgICAgICAgICAgICBrZXlcclxuICAgICAgICAgICAgKX0nIHdhcyBhY2Nlc3NlZCB2aWEgJ3RoaXMnLiBBdm9pZCB1c2luZyAndGhpcycgaW4gdGVtcGxhdGVzLmBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pIDogcHJveHlUb1VzZTtcclxuICAgICAgcmVzdWx0ID0gbm9ybWFsaXplVk5vZGUoXHJcbiAgICAgICAgcmVuZGVyLmNhbGwoXHJcbiAgICAgICAgICB0aGlzUHJveHksXHJcbiAgICAgICAgICBwcm94eVRvVXNlLFxyXG4gICAgICAgICAgcmVuZGVyQ2FjaGUsXHJcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KHByb3BzKSA6IHByb3BzLFxyXG4gICAgICAgICAgc2V0dXBTdGF0ZSxcclxuICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICBjdHhcclxuICAgICAgICApXHJcbiAgICAgICk7XHJcbiAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBhdHRycztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IHJlbmRlcjIgPSBDb21wb25lbnQ7XHJcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGF0dHJzID09PSBwcm9wcykge1xyXG4gICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmVzdWx0ID0gbm9ybWFsaXplVk5vZGUoXHJcbiAgICAgICAgcmVuZGVyMi5sZW5ndGggPiAxID8gcmVuZGVyMihcclxuICAgICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkocHJvcHMpIDogcHJvcHMsXHJcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8ge1xyXG4gICAgICAgICAgICBnZXQgYXR0cnMoKSB7XHJcbiAgICAgICAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcclxuICAgICAgICAgICAgICByZXR1cm4gc2hhbGxvd1JlYWRvbmx5KGF0dHJzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2xvdHMsXHJcbiAgICAgICAgICAgIGVtaXRcclxuICAgICAgICAgIH0gOiB7IGF0dHJzLCBzbG90cywgZW1pdCB9XHJcbiAgICAgICAgKSA6IHJlbmRlcjIoXHJcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KHByb3BzKSA6IHByb3BzLFxyXG4gICAgICAgICAgbnVsbFxyXG4gICAgICAgIClcclxuICAgICAgKTtcclxuICAgICAgZmFsbHRocm91Z2hBdHRycyA9IENvbXBvbmVudC5wcm9wcyA/IGF0dHJzIDogZ2V0RnVuY3Rpb25hbEZhbGx0aHJvdWdoKGF0dHJzKTtcclxuICAgIH1cclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGJsb2NrU3RhY2subGVuZ3RoID0gMDtcclxuICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDEpO1xyXG4gICAgcmVzdWx0ID0gY3JlYXRlVk5vZGUoQ29tbWVudCk7XHJcbiAgfVxyXG4gIGxldCByb290ID0gcmVzdWx0O1xyXG4gIGxldCBzZXRSb290ID0gdm9pZCAwO1xyXG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHJlc3VsdC5wYXRjaEZsYWcgPiAwICYmIHJlc3VsdC5wYXRjaEZsYWcgJiAyMDQ4KSB7XHJcbiAgICBbcm9vdCwgc2V0Um9vdF0gPSBnZXRDaGlsZFJvb3QocmVzdWx0KTtcclxuICB9XHJcbiAgaWYgKGZhbGx0aHJvdWdoQXR0cnMgJiYgaW5oZXJpdEF0dHJzICE9PSBmYWxzZSkge1xyXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZhbGx0aHJvdWdoQXR0cnMpO1xyXG4gICAgY29uc3QgeyBzaGFwZUZsYWcgfSA9IHJvb3Q7XHJcbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcclxuICAgICAgaWYgKHNoYXBlRmxhZyAmICgxIHwgNikpIHtcclxuICAgICAgICBpZiAocHJvcHNPcHRpb25zICYmIGtleXMuc29tZShpc01vZGVsTGlzdGVuZXIpKSB7XHJcbiAgICAgICAgICBmYWxsdGhyb3VnaEF0dHJzID0gZmlsdGVyTW9kZWxMaXN0ZW5lcnMoXHJcbiAgICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMsXHJcbiAgICAgICAgICAgIHByb3BzT3B0aW9uc1xyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcm9vdCA9IGNsb25lVk5vZGUocm9vdCwgZmFsbHRocm91Z2hBdHRycywgZmFsc2UsIHRydWUpO1xyXG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWFjY2Vzc2VkQXR0cnMgJiYgcm9vdC50eXBlICE9PSBDb21tZW50KSB7XHJcbiAgICAgICAgY29uc3QgYWxsQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycyk7XHJcbiAgICAgICAgY29uc3QgZXZlbnRBdHRycyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGV4dHJhQXR0cnMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFsbEF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgY29uc3Qga2V5ID0gYWxsQXR0cnNbaV07XHJcbiAgICAgICAgICBpZiAoaXNPbihrZXkpKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNNb2RlbExpc3RlbmVyKGtleSkpIHtcclxuICAgICAgICAgICAgICBldmVudEF0dHJzLnB1c2goa2V5WzJdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBleHRyYUF0dHJzLnB1c2goa2V5KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV4dHJhQXR0cnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICB3YXJuJDEoXHJcbiAgICAgICAgICAgIGBFeHRyYW5lb3VzIG5vbi1wcm9wcyBhdHRyaWJ1dGVzICgke2V4dHJhQXR0cnMuam9pbihcIiwgXCIpfSkgd2VyZSBwYXNzZWQgdG8gY29tcG9uZW50IGJ1dCBjb3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBpbmhlcml0ZWQgYmVjYXVzZSBjb21wb25lbnQgcmVuZGVycyBmcmFnbWVudCBvciB0ZXh0IG9yIHRlbGVwb3J0IHJvb3Qgbm9kZXMuYFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV2ZW50QXR0cnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICB3YXJuJDEoXHJcbiAgICAgICAgICAgIGBFeHRyYW5lb3VzIG5vbi1lbWl0cyBldmVudCBsaXN0ZW5lcnMgKCR7ZXZlbnRBdHRycy5qb2luKFwiLCBcIil9KSB3ZXJlIHBhc3NlZCB0byBjb21wb25lbnQgYnV0IGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGluaGVyaXRlZCBiZWNhdXNlIGNvbXBvbmVudCByZW5kZXJzIGZyYWdtZW50IG9yIHRleHQgcm9vdCBub2Rlcy4gSWYgdGhlIGxpc3RlbmVyIGlzIGludGVuZGVkIHRvIGJlIGEgY29tcG9uZW50IGN1c3RvbSBldmVudCBsaXN0ZW5lciBvbmx5LCBkZWNsYXJlIGl0IHVzaW5nIHRoZSBcImVtaXRzXCIgb3B0aW9uLmBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmICh2bm9kZS5kaXJzKSB7XHJcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNFbGVtZW50Um9vdChyb290KSkge1xyXG4gICAgICB3YXJuJDEoXHJcbiAgICAgICAgYFJ1bnRpbWUgZGlyZWN0aXZlIHVzZWQgb24gY29tcG9uZW50IHdpdGggbm9uLWVsZW1lbnQgcm9vdCBub2RlLiBUaGUgZGlyZWN0aXZlcyB3aWxsIG5vdCBmdW5jdGlvbiBhcyBpbnRlbmRlZC5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICByb290ID0gY2xvbmVWTm9kZShyb290LCBudWxsLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICByb290LmRpcnMgPSByb290LmRpcnMgPyByb290LmRpcnMuY29uY2F0KHZub2RlLmRpcnMpIDogdm5vZGUuZGlycztcclxuICB9XHJcbiAgaWYgKHZub2RlLnRyYW5zaXRpb24pIHtcclxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0VsZW1lbnRSb290KHJvb3QpKSB7XHJcbiAgICAgIHdhcm4kMShcclxuICAgICAgICBgQ29tcG9uZW50IGluc2lkZSA8VHJhbnNpdGlvbj4gcmVuZGVycyBub24tZWxlbWVudCByb290IG5vZGUgdGhhdCBjYW5ub3QgYmUgYW5pbWF0ZWQuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgc2V0VHJhbnNpdGlvbkhvb2tzKHJvb3QsIHZub2RlLnRyYW5zaXRpb24pO1xyXG4gIH1cclxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzZXRSb290KSB7XHJcbiAgICBzZXRSb290KHJvb3QpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXN1bHQgPSByb290O1xyXG4gIH1cclxuICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UocHJldik7XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5jb25zdCBnZXRDaGlsZFJvb3QgPSAodm5vZGUpID0+IHtcclxuICBjb25zdCByYXdDaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xyXG4gIGNvbnN0IGR5bmFtaWNDaGlsZHJlbiA9IHZub2RlLmR5bmFtaWNDaGlsZHJlbjtcclxuICBjb25zdCBjaGlsZFJvb3QgPSBmaWx0ZXJTaW5nbGVSb290KHJhd0NoaWxkcmVuLCBmYWxzZSk7XHJcbiAgaWYgKCFjaGlsZFJvb3QpIHtcclxuICAgIHJldHVybiBbdm5vZGUsIHZvaWQgMF07XHJcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNoaWxkUm9vdC5wYXRjaEZsYWcgPiAwICYmIGNoaWxkUm9vdC5wYXRjaEZsYWcgJiAyMDQ4KSB7XHJcbiAgICByZXR1cm4gZ2V0Q2hpbGRSb290KGNoaWxkUm9vdCk7XHJcbiAgfVxyXG4gIGNvbnN0IGluZGV4ID0gcmF3Q2hpbGRyZW4uaW5kZXhPZihjaGlsZFJvb3QpO1xyXG4gIGNvbnN0IGR5bmFtaWNJbmRleCA9IGR5bmFtaWNDaGlsZHJlbiA/IGR5bmFtaWNDaGlsZHJlbi5pbmRleE9mKGNoaWxkUm9vdCkgOiAtMTtcclxuICBjb25zdCBzZXRSb290ID0gKHVwZGF0ZWRSb290KSA9PiB7XHJcbiAgICByYXdDaGlsZHJlbltpbmRleF0gPSB1cGRhdGVkUm9vdDtcclxuICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcclxuICAgICAgaWYgKGR5bmFtaWNJbmRleCA+IC0xKSB7XHJcbiAgICAgICAgZHluYW1pY0NoaWxkcmVuW2R5bmFtaWNJbmRleF0gPSB1cGRhdGVkUm9vdDtcclxuICAgICAgfSBlbHNlIGlmICh1cGRhdGVkUm9vdC5wYXRjaEZsYWcgPiAwKSB7XHJcbiAgICAgICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gWy4uLmR5bmFtaWNDaGlsZHJlbiwgdXBkYXRlZFJvb3RdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuICByZXR1cm4gW25vcm1hbGl6ZVZOb2RlKGNoaWxkUm9vdCksIHNldFJvb3RdO1xyXG59O1xyXG5mdW5jdGlvbiBmaWx0ZXJTaW5nbGVSb290KGNoaWxkcmVuLCByZWN1cnNlID0gdHJ1ZSkge1xyXG4gIGxldCBzaW5nbGVSb290O1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICBpZiAoaXNWTm9kZShjaGlsZCkpIHtcclxuICAgICAgaWYgKGNoaWxkLnR5cGUgIT09IENvbW1lbnQgfHwgY2hpbGQuY2hpbGRyZW4gPT09IFwidi1pZlwiKSB7XHJcbiAgICAgICAgaWYgKHNpbmdsZVJvb3QpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc2luZ2xlUm9vdCA9IGNoaWxkO1xyXG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgcmVjdXJzZSAmJiBzaW5nbGVSb290LnBhdGNoRmxhZyA+IDAgJiYgc2luZ2xlUm9vdC5wYXRjaEZsYWcgJiAyMDQ4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJTaW5nbGVSb290KHNpbmdsZVJvb3QuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gc2luZ2xlUm9vdDtcclxufVxyXG5jb25zdCBnZXRGdW5jdGlvbmFsRmFsbHRocm91Z2ggPSAoYXR0cnMpID0+IHtcclxuICBsZXQgcmVzO1xyXG4gIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XHJcbiAgICBpZiAoa2V5ID09PSBcImNsYXNzXCIgfHwga2V5ID09PSBcInN0eWxlXCIgfHwgaXNPbihrZXkpKSB7XHJcbiAgICAgIChyZXMgfHwgKHJlcyA9IHt9KSlba2V5XSA9IGF0dHJzW2tleV07XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXM7XHJcbn07XHJcbmNvbnN0IGZpbHRlck1vZGVsTGlzdGVuZXJzID0gKGF0dHJzLCBwcm9wcykgPT4ge1xyXG4gIGNvbnN0IHJlcyA9IHt9O1xyXG4gIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XHJcbiAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpIHx8ICEoa2V5LnNsaWNlKDkpIGluIHByb3BzKSkge1xyXG4gICAgICByZXNba2V5XSA9IGF0dHJzW2tleV07XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXM7XHJcbn07XHJcbmNvbnN0IGlzRWxlbWVudFJvb3QgPSAodm5vZGUpID0+IHtcclxuICByZXR1cm4gdm5vZGUuc2hhcGVGbGFnICYgKDYgfCAxKSB8fCB2bm9kZS50eXBlID09PSBDb21tZW50O1xyXG59O1xyXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVDb21wb25lbnQocHJldlZOb2RlLCBuZXh0Vk5vZGUsIG9wdGltaXplZCkge1xyXG4gIGNvbnN0IHsgcHJvcHM6IHByZXZQcm9wcywgY2hpbGRyZW46IHByZXZDaGlsZHJlbiwgY29tcG9uZW50IH0gPSBwcmV2Vk5vZGU7XHJcbiAgY29uc3QgeyBwcm9wczogbmV4dFByb3BzLCBjaGlsZHJlbjogbmV4dENoaWxkcmVuLCBwYXRjaEZsYWcgfSA9IG5leHRWTm9kZTtcclxuICBjb25zdCBlbWl0cyA9IGNvbXBvbmVudC5lbWl0c09wdGlvbnM7XHJcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgKHByZXZDaGlsZHJlbiB8fCBuZXh0Q2hpbGRyZW4pICYmIGlzSG1yVXBkYXRpbmcpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICBpZiAobmV4dFZOb2RlLmRpcnMgfHwgbmV4dFZOb2RlLnRyYW5zaXRpb24pIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICBpZiAob3B0aW1pemVkICYmIHBhdGNoRmxhZyA+PSAwKSB7XHJcbiAgICBpZiAocGF0Y2hGbGFnICYgMTAyNCkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChwYXRjaEZsYWcgJiAxNikge1xyXG4gICAgICBpZiAoIXByZXZQcm9wcykge1xyXG4gICAgICAgIHJldHVybiAhIW5leHRQcm9wcztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0cyk7XHJcbiAgICB9IGVsc2UgaWYgKHBhdGNoRmxhZyAmIDgpIHtcclxuICAgICAgY29uc3QgZHluYW1pY1Byb3BzID0gbmV4dFZOb2RlLmR5bmFtaWNQcm9wcztcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljUHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBkeW5hbWljUHJvcHNbaV07XHJcbiAgICAgICAgaWYgKG5leHRQcm9wc1trZXldICE9PSBwcmV2UHJvcHNba2V5XSAmJiAhaXNFbWl0TGlzdGVuZXIoZW1pdHMsIGtleSkpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAocHJldkNoaWxkcmVuIHx8IG5leHRDaGlsZHJlbikge1xyXG4gICAgICBpZiAoIW5leHRDaGlsZHJlbiB8fCAhbmV4dENoaWxkcmVuLiRzdGFibGUpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHByZXZQcm9wcyA9PT0gbmV4dFByb3BzKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICghcHJldlByb3BzKSB7XHJcbiAgICAgIHJldHVybiAhIW5leHRQcm9wcztcclxuICAgIH1cclxuICAgIGlmICghbmV4dFByb3BzKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHMpO1xyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0c09wdGlvbnMpIHtcclxuICBjb25zdCBuZXh0S2V5cyA9IE9iamVjdC5rZXlzKG5leHRQcm9wcyk7XHJcbiAgaWYgKG5leHRLZXlzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMocHJldlByb3BzKS5sZW5ndGgpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRLZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBrZXkgPSBuZXh0S2V5c1tpXTtcclxuICAgIGlmIChuZXh0UHJvcHNba2V5XSAhPT0gcHJldlByb3BzW2tleV0gJiYgIWlzRW1pdExpc3RlbmVyKGVtaXRzT3B0aW9ucywga2V5KSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZUhPQ0hvc3RFbCh7IHZub2RlLCBwYXJlbnQgfSwgZWwpIHtcclxuICB3aGlsZSAocGFyZW50KSB7XHJcbiAgICBjb25zdCByb290ID0gcGFyZW50LnN1YlRyZWU7XHJcbiAgICBpZiAocm9vdC5zdXNwZW5zZSAmJiByb290LnN1c3BlbnNlLmFjdGl2ZUJyYW5jaCA9PT0gdm5vZGUpIHtcclxuICAgICAgcm9vdC5lbCA9IHZub2RlLmVsO1xyXG4gICAgfVxyXG4gICAgaWYgKHJvb3QgPT09IHZub2RlKSB7XHJcbiAgICAgICh2bm9kZSA9IHBhcmVudC52bm9kZSkuZWwgPSBlbDtcclxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuY29uc3QgaXNTdXNwZW5zZSA9ICh0eXBlKSA9PiB0eXBlLl9faXNTdXNwZW5zZTtcclxubGV0IHN1c3BlbnNlSWQgPSAwO1xyXG5jb25zdCBTdXNwZW5zZUltcGwgPSB7XHJcbiAgbmFtZTogXCJTdXNwZW5zZVwiLFxyXG4gIC8vIEluIG9yZGVyIHRvIG1ha2UgU3VzcGVuc2UgdHJlZS1zaGFrYWJsZSwgd2UgbmVlZCB0byBhdm9pZCBpbXBvcnRpbmcgaXRcclxuICAvLyBkaXJlY3RseSBpbiB0aGUgcmVuZGVyZXIuIFRoZSByZW5kZXJlciBjaGVja3MgZm9yIHRoZSBfX2lzU3VzcGVuc2UgZmxhZ1xyXG4gIC8vIG9uIGEgdm5vZGUncyB0eXBlIGFuZCBjYWxscyB0aGUgYHByb2Nlc3NgIG1ldGhvZCwgcGFzc2luZyBpbiByZW5kZXJlclxyXG4gIC8vIGludGVybmFscy5cclxuICBfX2lzU3VzcGVuc2U6IHRydWUsXHJcbiAgcHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscykge1xyXG4gICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgbW91bnRTdXNwZW5zZShcclxuICAgICAgICBuMixcclxuICAgICAgICBjb250YWluZXIsXHJcbiAgICAgICAgYW5jaG9yLFxyXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcclxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcclxuICAgICAgICBuYW1lc3BhY2UsXHJcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxyXG4gICAgICAgIG9wdGltaXplZCxcclxuICAgICAgICByZW5kZXJlckludGVybmFsc1xyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLmRlcHMgPiAwICYmICFuMS5zdXNwZW5zZS5pc0luRmFsbGJhY2spIHtcclxuICAgICAgICBuMi5zdXNwZW5zZSA9IG4xLnN1c3BlbnNlO1xyXG4gICAgICAgIG4yLnN1c3BlbnNlLnZub2RlID0gbjI7XHJcbiAgICAgICAgbjIuZWwgPSBuMS5lbDtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgcGF0Y2hTdXNwZW5zZShcclxuICAgICAgICBuMSxcclxuICAgICAgICBuMixcclxuICAgICAgICBjb250YWluZXIsXHJcbiAgICAgICAgYW5jaG9yLFxyXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcclxuICAgICAgICBuYW1lc3BhY2UsXHJcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxyXG4gICAgICAgIG9wdGltaXplZCxcclxuICAgICAgICByZW5kZXJlckludGVybmFsc1xyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgaHlkcmF0ZTogaHlkcmF0ZVN1c3BlbnNlLFxyXG4gIG5vcm1hbGl6ZTogbm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlblxyXG59O1xyXG5jb25zdCBTdXNwZW5zZSA9IFN1c3BlbnNlSW1wbCA7XHJcbmZ1bmN0aW9uIHRyaWdnZXJFdmVudCh2bm9kZSwgbmFtZSkge1xyXG4gIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wc1tuYW1lXTtcclxuICBpZiAoaXNGdW5jdGlvbihldmVudExpc3RlbmVyKSkge1xyXG4gICAgZXZlbnRMaXN0ZW5lcigpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBtb3VudFN1c3BlbnNlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpIHtcclxuICBjb25zdCB7XHJcbiAgICBwOiBwYXRjaCxcclxuICAgIG86IHsgY3JlYXRlRWxlbWVudCB9XHJcbiAgfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xyXG4gIGNvbnN0IGhpZGRlbkNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgY29uc3Qgc3VzcGVuc2UgPSB2bm9kZS5zdXNwZW5zZSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkoXHJcbiAgICB2bm9kZSxcclxuICAgIHBhcmVudFN1c3BlbnNlLFxyXG4gICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgY29udGFpbmVyLFxyXG4gICAgaGlkZGVuQ29udGFpbmVyLFxyXG4gICAgYW5jaG9yLFxyXG4gICAgbmFtZXNwYWNlLFxyXG4gICAgc2xvdFNjb3BlSWRzLFxyXG4gICAgb3B0aW1pemVkLFxyXG4gICAgcmVuZGVyZXJJbnRlcm5hbHNcclxuICApO1xyXG4gIHBhdGNoKFxyXG4gICAgbnVsbCxcclxuICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSB2bm9kZS5zc0NvbnRlbnQsXHJcbiAgICBoaWRkZW5Db250YWluZXIsXHJcbiAgICBudWxsLFxyXG4gICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgc3VzcGVuc2UsXHJcbiAgICBuYW1lc3BhY2UsXHJcbiAgICBzbG90U2NvcGVJZHNcclxuICApO1xyXG4gIGlmIChzdXNwZW5zZS5kZXBzID4gMCkge1xyXG4gICAgdHJpZ2dlckV2ZW50KHZub2RlLCBcIm9uUGVuZGluZ1wiKTtcclxuICAgIHRyaWdnZXJFdmVudCh2bm9kZSwgXCJvbkZhbGxiYWNrXCIpO1xyXG4gICAgcGF0Y2goXHJcbiAgICAgIG51bGwsXHJcbiAgICAgIHZub2RlLnNzRmFsbGJhY2ssXHJcbiAgICAgIGNvbnRhaW5lcixcclxuICAgICAgYW5jaG9yLFxyXG4gICAgICBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgIG51bGwsXHJcbiAgICAgIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XHJcbiAgICAgIG5hbWVzcGFjZSxcclxuICAgICAgc2xvdFNjb3BlSWRzXHJcbiAgICApO1xyXG4gICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCB2bm9kZS5zc0ZhbGxiYWNrKTtcclxuICB9IGVsc2Uge1xyXG4gICAgc3VzcGVuc2UucmVzb2x2ZShmYWxzZSwgdHJ1ZSk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHBhdGNoU3VzcGVuc2UobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCB7IHA6IHBhdGNoLCB1bTogdW5tb3VudCwgbzogeyBjcmVhdGVFbGVtZW50IH0gfSkge1xyXG4gIGNvbnN0IHN1c3BlbnNlID0gbjIuc3VzcGVuc2UgPSBuMS5zdXNwZW5zZTtcclxuICBzdXNwZW5zZS52bm9kZSA9IG4yO1xyXG4gIG4yLmVsID0gbjEuZWw7XHJcbiAgY29uc3QgbmV3QnJhbmNoID0gbjIuc3NDb250ZW50O1xyXG4gIGNvbnN0IG5ld0ZhbGxiYWNrID0gbjIuc3NGYWxsYmFjaztcclxuICBjb25zdCB7IGFjdGl2ZUJyYW5jaCwgcGVuZGluZ0JyYW5jaCwgaXNJbkZhbGxiYWNrLCBpc0h5ZHJhdGluZyB9ID0gc3VzcGVuc2U7XHJcbiAgaWYgKHBlbmRpbmdCcmFuY2gpIHtcclxuICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBuZXdCcmFuY2g7XHJcbiAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgcGVuZGluZ0JyYW5jaCkpIHtcclxuICAgICAgcGF0Y2goXHJcbiAgICAgICAgcGVuZGluZ0JyYW5jaCxcclxuICAgICAgICBuZXdCcmFuY2gsXHJcbiAgICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLFxyXG4gICAgICAgIG51bGwsXHJcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgIHN1c3BlbnNlLFxyXG4gICAgICAgIG5hbWVzcGFjZSxcclxuICAgICAgICBzbG90U2NvcGVJZHMsXHJcbiAgICAgICAgb3B0aW1pemVkXHJcbiAgICAgICk7XHJcbiAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcclxuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNJbkZhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKCFpc0h5ZHJhdGluZykge1xyXG4gICAgICAgICAgcGF0Y2goXHJcbiAgICAgICAgICAgIGFjdGl2ZUJyYW5jaCxcclxuICAgICAgICAgICAgbmV3RmFsbGJhY2ssXHJcbiAgICAgICAgICAgIGNvbnRhaW5lcixcclxuICAgICAgICAgICAgYW5jaG9yLFxyXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XHJcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcclxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxyXG4gICAgICAgICAgICBvcHRpbWl6ZWRcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0ZhbGxiYWNrKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCA9IHN1c3BlbnNlSWQrKztcclxuICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XHJcbiAgICAgICAgc3VzcGVuc2UuaXNIeWRyYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggPSBwZW5kaW5nQnJhbmNoO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHVubW91bnQocGVuZGluZ0JyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSk7XHJcbiAgICAgIH1cclxuICAgICAgc3VzcGVuc2UuZGVwcyA9IDA7XHJcbiAgICAgIHN1c3BlbnNlLmVmZmVjdHMubGVuZ3RoID0gMDtcclxuICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgaWYgKGlzSW5GYWxsYmFjaykge1xyXG4gICAgICAgIHBhdGNoKFxyXG4gICAgICAgICAgbnVsbCxcclxuICAgICAgICAgIG5ld0JyYW5jaCxcclxuICAgICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lcixcclxuICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgICBzdXNwZW5zZSxcclxuICAgICAgICAgIG5hbWVzcGFjZSxcclxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcclxuICAgICAgICAgIG9wdGltaXplZFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xyXG4gICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBwYXRjaChcclxuICAgICAgICAgICAgYWN0aXZlQnJhbmNoLFxyXG4gICAgICAgICAgICBuZXdGYWxsYmFjayxcclxuICAgICAgICAgICAgY29udGFpbmVyLFxyXG4gICAgICAgICAgICBhbmNob3IsXHJcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcclxuICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcclxuICAgICAgICAgICAgbmFtZXNwYWNlLFxyXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXHJcbiAgICAgICAgICAgIG9wdGltaXplZFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3RmFsbGJhY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChhY3RpdmVCcmFuY2ggJiYgaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgYWN0aXZlQnJhbmNoKSkge1xyXG4gICAgICAgIHBhdGNoKFxyXG4gICAgICAgICAgYWN0aXZlQnJhbmNoLFxyXG4gICAgICAgICAgbmV3QnJhbmNoLFxyXG4gICAgICAgICAgY29udGFpbmVyLFxyXG4gICAgICAgICAgYW5jaG9yLFxyXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgICAgc3VzcGVuc2UsXHJcbiAgICAgICAgICBuYW1lc3BhY2UsXHJcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXHJcbiAgICAgICAgICBvcHRpbWl6ZWRcclxuICAgICAgICApO1xyXG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUodHJ1ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcGF0Y2goXHJcbiAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgbmV3QnJhbmNoLFxyXG4gICAgICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLFxyXG4gICAgICAgICAgbnVsbCxcclxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcclxuICAgICAgICAgIHN1c3BlbnNlLFxyXG4gICAgICAgICAgbmFtZXNwYWNlLFxyXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxyXG4gICAgICAgICAgb3B0aW1pemVkXHJcbiAgICAgICAgKTtcclxuICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XHJcbiAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmIChhY3RpdmVCcmFuY2ggJiYgaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgYWN0aXZlQnJhbmNoKSkge1xyXG4gICAgICBwYXRjaChcclxuICAgICAgICBhY3RpdmVCcmFuY2gsXHJcbiAgICAgICAgbmV3QnJhbmNoLFxyXG4gICAgICAgIGNvbnRhaW5lcixcclxuICAgICAgICBhbmNob3IsXHJcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgIHN1c3BlbnNlLFxyXG4gICAgICAgIG5hbWVzcGFjZSxcclxuICAgICAgICBzbG90U2NvcGVJZHMsXHJcbiAgICAgICAgb3B0aW1pemVkXHJcbiAgICAgICk7XHJcbiAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3QnJhbmNoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRyaWdnZXJFdmVudChuMiwgXCJvblBlbmRpbmdcIik7XHJcbiAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBuZXdCcmFuY2g7XHJcbiAgICAgIGlmIChuZXdCcmFuY2guc2hhcGVGbGFnICYgNTEyKSB7XHJcbiAgICAgICAgc3VzcGVuc2UucGVuZGluZ0lkID0gbmV3QnJhbmNoLmNvbXBvbmVudC5zdXNwZW5zZUlkO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCA9IHN1c3BlbnNlSWQrKztcclxuICAgICAgfVxyXG4gICAgICBwYXRjaChcclxuICAgICAgICBudWxsLFxyXG4gICAgICAgIG5ld0JyYW5jaCxcclxuICAgICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsXHJcbiAgICAgICAgbnVsbCxcclxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgc3VzcGVuc2UsXHJcbiAgICAgICAgbmFtZXNwYWNlLFxyXG4gICAgICAgIHNsb3RTY29wZUlkcyxcclxuICAgICAgICBvcHRpbWl6ZWRcclxuICAgICAgKTtcclxuICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xyXG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCB7IHRpbWVvdXQsIHBlbmRpbmdJZCB9ID0gc3VzcGVuc2U7XHJcbiAgICAgICAgaWYgKHRpbWVvdXQgPiAwKSB7XHJcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdJZCA9PT0gcGVuZGluZ0lkKSB7XHJcbiAgICAgICAgICAgICAgc3VzcGVuc2UuZmFsbGJhY2sobmV3RmFsbGJhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9LCB0aW1lb3V0KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRpbWVvdXQgPT09IDApIHtcclxuICAgICAgICAgIHN1c3BlbnNlLmZhbGxiYWNrKG5ld0ZhbGxiYWNrKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxubGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xyXG5mdW5jdGlvbiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHZub2RlLCBwYXJlbnRTdXNwZW5zZSwgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIsIGhpZGRlbkNvbnRhaW5lciwgYW5jaG9yLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaXNIeWRyYXRpbmcgPSBmYWxzZSkge1xyXG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHRydWUgJiYgIWhhc1dhcm5lZCkge1xyXG4gICAgaGFzV2FybmVkID0gdHJ1ZTtcclxuICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gXCJpbmZvXCIgOiBcImxvZ1wiXShcclxuICAgICAgYDxTdXNwZW5zZT4gaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUgYW5kIGl0cyBBUEkgd2lsbCBsaWtlbHkgY2hhbmdlLmBcclxuICAgICk7XHJcbiAgfVxyXG4gIGNvbnN0IHtcclxuICAgIHA6IHBhdGNoLFxyXG4gICAgbTogbW92ZSxcclxuICAgIHVtOiB1bm1vdW50LFxyXG4gICAgbjogbmV4dCxcclxuICAgIG86IHsgcGFyZW50Tm9kZSwgcmVtb3ZlIH1cclxuICB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XHJcbiAgbGV0IHBhcmVudFN1c3BlbnNlSWQ7XHJcbiAgY29uc3QgaXNTdXNwZW5zaWJsZSA9IGlzVk5vZGVTdXNwZW5zaWJsZSh2bm9kZSk7XHJcbiAgaWYgKGlzU3VzcGVuc2libGUpIHtcclxuICAgIGlmIChwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgIHBhcmVudFN1c3BlbnNlSWQgPSBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nSWQ7XHJcbiAgICAgIHBhcmVudFN1c3BlbnNlLmRlcHMrKztcclxuICAgIH1cclxuICB9XHJcbiAgY29uc3QgdGltZW91dCA9IHZub2RlLnByb3BzID8gdG9OdW1iZXIodm5vZGUucHJvcHMudGltZW91dCkgOiB2b2lkIDA7XHJcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgIGFzc2VydE51bWJlcih0aW1lb3V0LCBgU3VzcGVuc2UgdGltZW91dGApO1xyXG4gIH1cclxuICBjb25zdCBpbml0aWFsQW5jaG9yID0gYW5jaG9yO1xyXG4gIGNvbnN0IHN1c3BlbnNlID0ge1xyXG4gICAgdm5vZGUsXHJcbiAgICBwYXJlbnQ6IHBhcmVudFN1c3BlbnNlLFxyXG4gICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgbmFtZXNwYWNlLFxyXG4gICAgY29udGFpbmVyLFxyXG4gICAgaGlkZGVuQ29udGFpbmVyLFxyXG4gICAgZGVwczogMCxcclxuICAgIHBlbmRpbmdJZDogc3VzcGVuc2VJZCsrLFxyXG4gICAgdGltZW91dDogdHlwZW9mIHRpbWVvdXQgPT09IFwibnVtYmVyXCIgPyB0aW1lb3V0IDogLTEsXHJcbiAgICBhY3RpdmVCcmFuY2g6IG51bGwsXHJcbiAgICBwZW5kaW5nQnJhbmNoOiBudWxsLFxyXG4gICAgaXNJbkZhbGxiYWNrOiAhaXNIeWRyYXRpbmcsXHJcbiAgICBpc0h5ZHJhdGluZyxcclxuICAgIGlzVW5tb3VudGVkOiBmYWxzZSxcclxuICAgIGVmZmVjdHM6IFtdLFxyXG4gICAgcmVzb2x2ZShyZXN1bWUgPSBmYWxzZSwgc3luYyA9IGZhbHNlKSB7XHJcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgICAgaWYgKCFyZXN1bWUgJiYgIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgYHN1c3BlbnNlLnJlc29sdmUoKSBpcyBjYWxsZWQgd2l0aG91dCBhIHBlbmRpbmcgYnJhbmNoLmBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdXNwZW5zZS5pc1VubW91bnRlZCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICBgc3VzcGVuc2UucmVzb2x2ZSgpIGlzIGNhbGxlZCBvbiBhbiBhbHJlYWR5IHVubW91bnRlZCBzdXNwZW5zZSBib3VuZGFyeS5gXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgdm5vZGU6IHZub2RlMixcclxuICAgICAgICBhY3RpdmVCcmFuY2gsXHJcbiAgICAgICAgcGVuZGluZ0JyYW5jaCxcclxuICAgICAgICBwZW5kaW5nSWQsXHJcbiAgICAgICAgZWZmZWN0cyxcclxuICAgICAgICBwYXJlbnRDb21wb25lbnQ6IHBhcmVudENvbXBvbmVudDIsXHJcbiAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIyXHJcbiAgICAgIH0gPSBzdXNwZW5zZTtcclxuICAgICAgbGV0IGRlbGF5RW50ZXIgPSBmYWxzZTtcclxuICAgICAgaWYgKHN1c3BlbnNlLmlzSHlkcmF0aW5nKSB7XHJcbiAgICAgICAgc3VzcGVuc2UuaXNIeWRyYXRpbmcgPSBmYWxzZTtcclxuICAgICAgfSBlbHNlIGlmICghcmVzdW1lKSB7XHJcbiAgICAgICAgZGVsYXlFbnRlciA9IGFjdGl2ZUJyYW5jaCAmJiBwZW5kaW5nQnJhbmNoLnRyYW5zaXRpb24gJiYgcGVuZGluZ0JyYW5jaC50cmFuc2l0aW9uLm1vZGUgPT09IFwib3V0LWluXCI7XHJcbiAgICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcclxuICAgICAgICAgIGFjdGl2ZUJyYW5jaC50cmFuc2l0aW9uLmFmdGVyTGVhdmUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwZW5kaW5nSWQgPT09IHN1c3BlbnNlLnBlbmRpbmdJZCkge1xyXG4gICAgICAgICAgICAgIG1vdmUoXHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nQnJhbmNoLFxyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyMixcclxuICAgICAgICAgICAgICAgIGFuY2hvciA9PT0gaW5pdGlhbEFuY2hvciA/IG5leHQoYWN0aXZlQnJhbmNoKSA6IGFuY2hvcixcclxuICAgICAgICAgICAgICAgIDBcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgIHF1ZXVlUG9zdEZsdXNoQ2IoZWZmZWN0cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhY3RpdmVCcmFuY2gpIHtcclxuICAgICAgICAgIGlmIChwYXJlbnROb2RlKGFjdGl2ZUJyYW5jaC5lbCkgPT09IGNvbnRhaW5lcjIpIHtcclxuICAgICAgICAgICAgYW5jaG9yID0gbmV4dChhY3RpdmVCcmFuY2gpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdW5tb3VudChhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudDIsIHN1c3BlbnNlLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFkZWxheUVudGVyKSB7XHJcbiAgICAgICAgICBtb3ZlKHBlbmRpbmdCcmFuY2gsIGNvbnRhaW5lcjIsIGFuY2hvciwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgcGVuZGluZ0JyYW5jaCk7XHJcbiAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBudWxsO1xyXG4gICAgICBzdXNwZW5zZS5pc0luRmFsbGJhY2sgPSBmYWxzZTtcclxuICAgICAgbGV0IHBhcmVudCA9IHN1c3BlbnNlLnBhcmVudDtcclxuICAgICAgbGV0IGhhc1VucmVzb2x2ZWRBbmNlc3RvciA9IGZhbHNlO1xyXG4gICAgICB3aGlsZSAocGFyZW50KSB7XHJcbiAgICAgICAgaWYgKHBhcmVudC5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgICBwYXJlbnQuZWZmZWN0cy5wdXNoKC4uLmVmZmVjdHMpO1xyXG4gICAgICAgICAgaGFzVW5yZXNvbHZlZEFuY2VzdG9yID0gdHJ1ZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghaGFzVW5yZXNvbHZlZEFuY2VzdG9yICYmICFkZWxheUVudGVyKSB7XHJcbiAgICAgICAgcXVldWVQb3N0Rmx1c2hDYihlZmZlY3RzKTtcclxuICAgICAgfVxyXG4gICAgICBzdXNwZW5zZS5lZmZlY3RzID0gW107XHJcbiAgICAgIGlmIChpc1N1c3BlbnNpYmxlKSB7XHJcbiAgICAgICAgaWYgKHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggJiYgcGFyZW50U3VzcGVuc2VJZCA9PT0gcGFyZW50U3VzcGVuc2UucGVuZGluZ0lkKSB7XHJcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5kZXBzLS07XHJcbiAgICAgICAgICBpZiAocGFyZW50U3VzcGVuc2UuZGVwcyA9PT0gMCAmJiAhc3luYykge1xyXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRyaWdnZXJFdmVudCh2bm9kZTIsIFwib25SZXNvbHZlXCIpO1xyXG4gICAgfSxcclxuICAgIGZhbGxiYWNrKGZhbGxiYWNrVk5vZGUpIHtcclxuICAgICAgaWYgKCFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHsgdm5vZGU6IHZub2RlMiwgYWN0aXZlQnJhbmNoLCBwYXJlbnRDb21wb25lbnQ6IHBhcmVudENvbXBvbmVudDIsIGNvbnRhaW5lcjogY29udGFpbmVyMiwgbmFtZXNwYWNlOiBuYW1lc3BhY2UyIH0gPSBzdXNwZW5zZTtcclxuICAgICAgdHJpZ2dlckV2ZW50KHZub2RlMiwgXCJvbkZhbGxiYWNrXCIpO1xyXG4gICAgICBjb25zdCBhbmNob3IyID0gbmV4dChhY3RpdmVCcmFuY2gpO1xyXG4gICAgICBjb25zdCBtb3VudEZhbGxiYWNrID0gKCkgPT4ge1xyXG4gICAgICAgIGlmICghc3VzcGVuc2UuaXNJbkZhbGxiYWNrKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhdGNoKFxyXG4gICAgICAgICAgbnVsbCxcclxuICAgICAgICAgIGZhbGxiYWNrVk5vZGUsXHJcbiAgICAgICAgICBjb250YWluZXIyLFxyXG4gICAgICAgICAgYW5jaG9yMixcclxuICAgICAgICAgIHBhcmVudENvbXBvbmVudDIsXHJcbiAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcclxuICAgICAgICAgIG5hbWVzcGFjZTIsXHJcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXHJcbiAgICAgICAgICBvcHRpbWl6ZWRcclxuICAgICAgICApO1xyXG4gICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgZmFsbGJhY2tWTm9kZSk7XHJcbiAgICAgIH07XHJcbiAgICAgIGNvbnN0IGRlbGF5RW50ZXIgPSBmYWxsYmFja1ZOb2RlLnRyYW5zaXRpb24gJiYgZmFsbGJhY2tWTm9kZS50cmFuc2l0aW9uLm1vZGUgPT09IFwib3V0LWluXCI7XHJcbiAgICAgIGlmIChkZWxheUVudGVyKSB7XHJcbiAgICAgICAgYWN0aXZlQnJhbmNoLnRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSA9IG1vdW50RmFsbGJhY2s7XHJcbiAgICAgIH1cclxuICAgICAgc3VzcGVuc2UuaXNJbkZhbGxiYWNrID0gdHJ1ZTtcclxuICAgICAgdW5tb3VudChcclxuICAgICAgICBhY3RpdmVCcmFuY2gsXHJcbiAgICAgICAgcGFyZW50Q29tcG9uZW50MixcclxuICAgICAgICBudWxsLFxyXG4gICAgICAgIC8vIG5vIHN1c3BlbnNlIHNvIHVubW91bnQgaG9va3MgZmlyZSBub3dcclxuICAgICAgICB0cnVlXHJcbiAgICAgICAgLy8gc2hvdWxkUmVtb3ZlXHJcbiAgICAgICk7XHJcbiAgICAgIGlmICghZGVsYXlFbnRlcikge1xyXG4gICAgICAgIG1vdW50RmFsbGJhY2soKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1vdmUoY29udGFpbmVyMiwgYW5jaG9yMiwgdHlwZSkge1xyXG4gICAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggJiYgbW92ZShzdXNwZW5zZS5hY3RpdmVCcmFuY2gsIGNvbnRhaW5lcjIsIGFuY2hvcjIsIHR5cGUpO1xyXG4gICAgICBzdXNwZW5zZS5jb250YWluZXIgPSBjb250YWluZXIyO1xyXG4gICAgfSxcclxuICAgIG5leHQoKSB7XHJcbiAgICAgIHJldHVybiBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggJiYgbmV4dChzdXNwZW5zZS5hY3RpdmVCcmFuY2gpO1xyXG4gICAgfSxcclxuICAgIHJlZ2lzdGVyRGVwKGluc3RhbmNlLCBzZXR1cFJlbmRlckVmZmVjdCwgb3B0aW1pemVkMikge1xyXG4gICAgICBjb25zdCBpc0luUGVuZGluZ1N1c3BlbnNlID0gISFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoO1xyXG4gICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSkge1xyXG4gICAgICAgIHN1c3BlbnNlLmRlcHMrKztcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBoeWRyYXRlZEVsID0gaW5zdGFuY2Uudm5vZGUuZWw7XHJcbiAgICAgIGluc3RhbmNlLmFzeW5jRGVwLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCAwKTtcclxuICAgICAgfSkudGhlbigoYXN5bmNTZXR1cFJlc3VsdCkgPT4ge1xyXG4gICAgICAgIGlmIChpbnN0YW5jZS5pc1VubW91bnRlZCB8fCBzdXNwZW5zZS5pc1VubW91bnRlZCB8fCBzdXNwZW5zZS5wZW5kaW5nSWQgIT09IGluc3RhbmNlLnN1c3BlbnNlSWQpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCA9IHRydWU7XHJcbiAgICAgICAgY29uc3QgeyB2bm9kZTogdm5vZGUyIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KHZub2RlMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBhc3luY1NldHVwUmVzdWx0LCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKGh5ZHJhdGVkRWwpIHtcclxuICAgICAgICAgIHZub2RlMi5lbCA9IGh5ZHJhdGVkRWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gIWh5ZHJhdGVkRWwgJiYgaW5zdGFuY2Uuc3ViVHJlZS5lbDtcclxuICAgICAgICBzZXR1cFJlbmRlckVmZmVjdChcclxuICAgICAgICAgIGluc3RhbmNlLFxyXG4gICAgICAgICAgdm5vZGUyLFxyXG4gICAgICAgICAgLy8gY29tcG9uZW50IG1heSBoYXZlIGJlZW4gbW92ZWQgYmVmb3JlIHJlc29sdmUuXHJcbiAgICAgICAgICAvLyBpZiB0aGlzIGlzIG5vdCBhIGh5ZHJhdGlvbiwgaW5zdGFuY2Uuc3ViVHJlZSB3aWxsIGJlIHRoZSBjb21tZW50XHJcbiAgICAgICAgICAvLyBwbGFjZWhvbGRlci5cclxuICAgICAgICAgIHBhcmVudE5vZGUoaHlkcmF0ZWRFbCB8fCBpbnN0YW5jZS5zdWJUcmVlLmVsKSxcclxuICAgICAgICAgIC8vIGFuY2hvciB3aWxsIG5vdCBiZSB1c2VkIGlmIHRoaXMgaXMgaHlkcmF0aW9uLCBzbyBvbmx5IG5lZWQgdG9cclxuICAgICAgICAgIC8vIGNvbnNpZGVyIHRoZSBjb21tZW50IHBsYWNlaG9sZGVyIGNhc2UuXHJcbiAgICAgICAgICBoeWRyYXRlZEVsID8gbnVsbCA6IG5leHQoaW5zdGFuY2Uuc3ViVHJlZSksXHJcbiAgICAgICAgICBzdXNwZW5zZSxcclxuICAgICAgICAgIG5hbWVzcGFjZSxcclxuICAgICAgICAgIG9wdGltaXplZDJcclxuICAgICAgICApO1xyXG4gICAgICAgIGlmIChwbGFjZWhvbGRlcikge1xyXG4gICAgICAgICAgcmVtb3ZlKHBsYWNlaG9sZGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXBkYXRlSE9DSG9zdEVsKGluc3RhbmNlLCB2bm9kZTIuZWwpO1xyXG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSAmJiAtLXN1c3BlbnNlLmRlcHMgPT09IDApIHtcclxuICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIHVubW91bnQocGFyZW50U3VzcGVuc2UyLCBkb1JlbW92ZSkge1xyXG4gICAgICBzdXNwZW5zZS5pc1VubW91bnRlZCA9IHRydWU7XHJcbiAgICAgIGlmIChzdXNwZW5zZS5hY3RpdmVCcmFuY2gpIHtcclxuICAgICAgICB1bm1vdW50KFxyXG4gICAgICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoLFxyXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UyLFxyXG4gICAgICAgICAgZG9SZW1vdmVcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgdW5tb3VudChcclxuICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gsXHJcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZTIsXHJcbiAgICAgICAgICBkb1JlbW92ZVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG4gIHJldHVybiBzdXNwZW5zZTtcclxufVxyXG5mdW5jdGlvbiBoeWRyYXRlU3VzcGVuc2Uobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBoeWRyYXRlTm9kZSkge1xyXG4gIGNvbnN0IHN1c3BlbnNlID0gdm5vZGUuc3VzcGVuc2UgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxyXG4gICAgdm5vZGUsXHJcbiAgICBwYXJlbnRTdXNwZW5zZSxcclxuICAgIHBhcmVudENvbXBvbmVudCxcclxuICAgIG5vZGUucGFyZW50Tm9kZSxcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcclxuICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXHJcbiAgICBudWxsLFxyXG4gICAgbmFtZXNwYWNlLFxyXG4gICAgc2xvdFNjb3BlSWRzLFxyXG4gICAgb3B0aW1pemVkLFxyXG4gICAgcmVuZGVyZXJJbnRlcm5hbHMsXHJcbiAgICB0cnVlXHJcbiAgKTtcclxuICBjb25zdCByZXN1bHQgPSBoeWRyYXRlTm9kZShcclxuICAgIG5vZGUsXHJcbiAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gdm5vZGUuc3NDb250ZW50LFxyXG4gICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgc3VzcGVuc2UsXHJcbiAgICBzbG90U2NvcGVJZHMsXHJcbiAgICBvcHRpbWl6ZWRcclxuICApO1xyXG4gIGlmIChzdXNwZW5zZS5kZXBzID09PSAwKSB7XHJcbiAgICBzdXNwZW5zZS5yZXNvbHZlKGZhbHNlLCB0cnVlKTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVTdXNwZW5zZUNoaWxkcmVuKHZub2RlKSB7XHJcbiAgY29uc3QgeyBzaGFwZUZsYWcsIGNoaWxkcmVuIH0gPSB2bm9kZTtcclxuICBjb25zdCBpc1Nsb3RDaGlsZHJlbiA9IHNoYXBlRmxhZyAmIDMyO1xyXG4gIHZub2RlLnNzQ29udGVudCA9IG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChcclxuICAgIGlzU2xvdENoaWxkcmVuID8gY2hpbGRyZW4uZGVmYXVsdCA6IGNoaWxkcmVuXHJcbiAgKTtcclxuICB2bm9kZS5zc0ZhbGxiYWNrID0gaXNTbG90Q2hpbGRyZW4gPyBub3JtYWxpemVTdXNwZW5zZVNsb3QoY2hpbGRyZW4uZmFsbGJhY2spIDogY3JlYXRlVk5vZGUoQ29tbWVudCk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VTbG90KHMpIHtcclxuICBsZXQgYmxvY2s7XHJcbiAgaWYgKGlzRnVuY3Rpb24ocykpIHtcclxuICAgIGNvbnN0IHRyYWNrQmxvY2sgPSBpc0Jsb2NrVHJlZUVuYWJsZWQgJiYgcy5fYztcclxuICAgIGlmICh0cmFja0Jsb2NrKSB7XHJcbiAgICAgIHMuX2QgPSBmYWxzZTtcclxuICAgICAgb3BlbkJsb2NrKCk7XHJcbiAgICB9XHJcbiAgICBzID0gcygpO1xyXG4gICAgaWYgKHRyYWNrQmxvY2spIHtcclxuICAgICAgcy5fZCA9IHRydWU7XHJcbiAgICAgIGJsb2NrID0gY3VycmVudEJsb2NrO1xyXG4gICAgICBjbG9zZUJsb2NrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChpc0FycmF5KHMpKSB7XHJcbiAgICBjb25zdCBzaW5nbGVDaGlsZCA9IGZpbHRlclNpbmdsZVJvb3Qocyk7XHJcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhc2luZ2xlQ2hpbGQgJiYgcy5maWx0ZXIoKGNoaWxkKSA9PiBjaGlsZCAhPT0gTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCkubGVuZ3RoID4gMCkge1xyXG4gICAgICB3YXJuJDEoYDxTdXNwZW5zZT4gc2xvdHMgZXhwZWN0IGEgc2luZ2xlIHJvb3Qgbm9kZS5gKTtcclxuICAgIH1cclxuICAgIHMgPSBzaW5nbGVDaGlsZDtcclxuICB9XHJcbiAgcyA9IG5vcm1hbGl6ZVZOb2RlKHMpO1xyXG4gIGlmIChibG9jayAmJiAhcy5keW5hbWljQ2hpbGRyZW4pIHtcclxuICAgIHMuZHluYW1pY0NoaWxkcmVuID0gYmxvY2suZmlsdGVyKChjKSA9PiBjICE9PSBzKTtcclxuICB9XHJcbiAgcmV0dXJuIHM7XHJcbn1cclxuZnVuY3Rpb24gcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UoZm4sIHN1c3BlbnNlKSB7XHJcbiAgaWYgKHN1c3BlbnNlICYmIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcclxuICAgIGlmIChpc0FycmF5KGZuKSkge1xyXG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goLi4uZm4pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKGZuKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgcXVldWVQb3N0Rmx1c2hDYihmbik7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgYnJhbmNoKSB7XHJcbiAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoID0gYnJhbmNoO1xyXG4gIGNvbnN0IHsgdm5vZGUsIHBhcmVudENvbXBvbmVudCB9ID0gc3VzcGVuc2U7XHJcbiAgbGV0IGVsID0gYnJhbmNoLmVsO1xyXG4gIHdoaWxlICghZWwgJiYgYnJhbmNoLmNvbXBvbmVudCkge1xyXG4gICAgYnJhbmNoID0gYnJhbmNoLmNvbXBvbmVudC5zdWJUcmVlO1xyXG4gICAgZWwgPSBicmFuY2guZWw7XHJcbiAgfVxyXG4gIHZub2RlLmVsID0gZWw7XHJcbiAgaWYgKHBhcmVudENvbXBvbmVudCAmJiBwYXJlbnRDb21wb25lbnQuc3ViVHJlZSA9PT0gdm5vZGUpIHtcclxuICAgIHBhcmVudENvbXBvbmVudC52bm9kZS5lbCA9IGVsO1xyXG4gICAgdXBkYXRlSE9DSG9zdEVsKHBhcmVudENvbXBvbmVudCwgZWwpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBpc1ZOb2RlU3VzcGVuc2libGUodm5vZGUpIHtcclxuICBjb25zdCBzdXNwZW5zaWJsZSA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnN1c3BlbnNpYmxlO1xyXG4gIHJldHVybiBzdXNwZW5zaWJsZSAhPSBudWxsICYmIHN1c3BlbnNpYmxlICE9PSBmYWxzZTtcclxufVxyXG5cclxuY29uc3QgRnJhZ21lbnQgPSBTeW1ib2wuZm9yKFwidi1mZ3RcIik7XHJcbmNvbnN0IFRleHQgPSBTeW1ib2wuZm9yKFwidi10eHRcIik7XHJcbmNvbnN0IENvbW1lbnQgPSBTeW1ib2wuZm9yKFwidi1jbXRcIik7XHJcbmNvbnN0IFN0YXRpYyA9IFN5bWJvbC5mb3IoXCJ2LXN0Y1wiKTtcclxuY29uc3QgYmxvY2tTdGFjayA9IFtdO1xyXG5sZXQgY3VycmVudEJsb2NrID0gbnVsbDtcclxuZnVuY3Rpb24gb3BlbkJsb2NrKGRpc2FibGVUcmFja2luZyA9IGZhbHNlKSB7XHJcbiAgYmxvY2tTdGFjay5wdXNoKGN1cnJlbnRCbG9jayA9IGRpc2FibGVUcmFja2luZyA/IG51bGwgOiBbXSk7XHJcbn1cclxuZnVuY3Rpb24gY2xvc2VCbG9jaygpIHtcclxuICBibG9ja1N0YWNrLnBvcCgpO1xyXG4gIGN1cnJlbnRCbG9jayA9IGJsb2NrU3RhY2tbYmxvY2tTdGFjay5sZW5ndGggLSAxXSB8fCBudWxsO1xyXG59XHJcbmxldCBpc0Jsb2NrVHJlZUVuYWJsZWQgPSAxO1xyXG5mdW5jdGlvbiBzZXRCbG9ja1RyYWNraW5nKHZhbHVlLCBpblZPbmNlID0gZmFsc2UpIHtcclxuICBpc0Jsb2NrVHJlZUVuYWJsZWQgKz0gdmFsdWU7XHJcbiAgaWYgKHZhbHVlIDwgMCAmJiBjdXJyZW50QmxvY2sgJiYgaW5WT25jZSkge1xyXG4gICAgY3VycmVudEJsb2NrLmhhc09uY2UgPSB0cnVlO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBzZXR1cEJsb2NrKHZub2RlKSB7XHJcbiAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gaXNCbG9ja1RyZWVFbmFibGVkID4gMCA/IGN1cnJlbnRCbG9jayB8fCBFTVBUWV9BUlIgOiBudWxsO1xyXG4gIGNsb3NlQmxvY2soKTtcclxuICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiBjdXJyZW50QmxvY2spIHtcclxuICAgIGN1cnJlbnRCbG9jay5wdXNoKHZub2RlKTtcclxuICB9XHJcbiAgcmV0dXJuIHZub2RlO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRCbG9jayh0eXBlLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzLCBzaGFwZUZsYWcpIHtcclxuICByZXR1cm4gc2V0dXBCbG9jayhcclxuICAgIGNyZWF0ZUJhc2VWTm9kZShcclxuICAgICAgdHlwZSxcclxuICAgICAgcHJvcHMsXHJcbiAgICAgIGNoaWxkcmVuLFxyXG4gICAgICBwYXRjaEZsYWcsXHJcbiAgICAgIGR5bmFtaWNQcm9wcyxcclxuICAgICAgc2hhcGVGbGFnLFxyXG4gICAgICB0cnVlXHJcbiAgICApXHJcbiAgKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVCbG9jayh0eXBlLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzKSB7XHJcbiAgcmV0dXJuIHNldHVwQmxvY2soXHJcbiAgICBjcmVhdGVWTm9kZShcclxuICAgICAgdHlwZSxcclxuICAgICAgcHJvcHMsXHJcbiAgICAgIGNoaWxkcmVuLFxyXG4gICAgICBwYXRjaEZsYWcsXHJcbiAgICAgIGR5bmFtaWNQcm9wcyxcclxuICAgICAgdHJ1ZVxyXG4gICAgKVxyXG4gICk7XHJcbn1cclxuZnVuY3Rpb24gaXNWTm9kZSh2YWx1ZSkge1xyXG4gIHJldHVybiB2YWx1ZSA/IHZhbHVlLl9fdl9pc1ZOb2RlID09PSB0cnVlIDogZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikge1xyXG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG4yLnNoYXBlRmxhZyAmIDYgJiYgbjEuY29tcG9uZW50KSB7XHJcbiAgICBjb25zdCBkaXJ0eUluc3RhbmNlcyA9IGhtckRpcnR5Q29tcG9uZW50cy5nZXQobjIudHlwZSk7XHJcbiAgICBpZiAoZGlydHlJbnN0YW5jZXMgJiYgZGlydHlJbnN0YW5jZXMuaGFzKG4xLmNvbXBvbmVudCkpIHtcclxuICAgICAgbjEuc2hhcGVGbGFnICY9IH4yNTY7XHJcbiAgICAgIG4yLnNoYXBlRmxhZyAmPSB+NTEyO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBuMS50eXBlID09PSBuMi50eXBlICYmIG4xLmtleSA9PT0gbjIua2V5O1xyXG59XHJcbmxldCB2bm9kZUFyZ3NUcmFuc2Zvcm1lcjtcclxuZnVuY3Rpb24gdHJhbnNmb3JtVk5vZGVBcmdzKHRyYW5zZm9ybWVyKSB7XHJcbiAgdm5vZGVBcmdzVHJhbnNmb3JtZXIgPSB0cmFuc2Zvcm1lcjtcclxufVxyXG5jb25zdCBjcmVhdGVWTm9kZVdpdGhBcmdzVHJhbnNmb3JtID0gKC4uLmFyZ3MpID0+IHtcclxuICByZXR1cm4gX2NyZWF0ZVZOb2RlKFxyXG4gICAgLi4udm5vZGVBcmdzVHJhbnNmb3JtZXIgPyB2bm9kZUFyZ3NUcmFuc2Zvcm1lcihhcmdzLCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpIDogYXJnc1xyXG4gICk7XHJcbn07XHJcbmNvbnN0IG5vcm1hbGl6ZUtleSA9ICh7IGtleSB9KSA9PiBrZXkgIT0gbnVsbCA/IGtleSA6IG51bGw7XHJcbmNvbnN0IG5vcm1hbGl6ZVJlZiA9ICh7XHJcbiAgcmVmLFxyXG4gIHJlZl9rZXksXHJcbiAgcmVmX2ZvclxyXG59KSA9PiB7XHJcbiAgaWYgKHR5cGVvZiByZWYgPT09IFwibnVtYmVyXCIpIHtcclxuICAgIHJlZiA9IFwiXCIgKyByZWY7XHJcbiAgfVxyXG4gIHJldHVybiByZWYgIT0gbnVsbCA/IGlzU3RyaW5nKHJlZikgfHwgaXNSZWYocmVmKSB8fCBpc0Z1bmN0aW9uKHJlZikgPyB7IGk6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSwgcjogcmVmLCBrOiByZWZfa2V5LCBmOiAhIXJlZl9mb3IgfSA6IHJlZiA6IG51bGw7XHJcbn07XHJcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VWTm9kZSh0eXBlLCBwcm9wcyA9IG51bGwsIGNoaWxkcmVuID0gbnVsbCwgcGF0Y2hGbGFnID0gMCwgZHluYW1pY1Byb3BzID0gbnVsbCwgc2hhcGVGbGFnID0gdHlwZSA9PT0gRnJhZ21lbnQgPyAwIDogMSwgaXNCbG9ja05vZGUgPSBmYWxzZSwgbmVlZEZ1bGxDaGlsZHJlbk5vcm1hbGl6YXRpb24gPSBmYWxzZSkge1xyXG4gIGNvbnN0IHZub2RlID0ge1xyXG4gICAgX192X2lzVk5vZGU6IHRydWUsXHJcbiAgICBfX3Zfc2tpcDogdHJ1ZSxcclxuICAgIHR5cGUsXHJcbiAgICBwcm9wcyxcclxuICAgIGtleTogcHJvcHMgJiYgbm9ybWFsaXplS2V5KHByb3BzKSxcclxuICAgIHJlZjogcHJvcHMgJiYgbm9ybWFsaXplUmVmKHByb3BzKSxcclxuICAgIHNjb3BlSWQ6IGN1cnJlbnRTY29wZUlkLFxyXG4gICAgc2xvdFNjb3BlSWRzOiBudWxsLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICBjb21wb25lbnQ6IG51bGwsXHJcbiAgICBzdXNwZW5zZTogbnVsbCxcclxuICAgIHNzQ29udGVudDogbnVsbCxcclxuICAgIHNzRmFsbGJhY2s6IG51bGwsXHJcbiAgICBkaXJzOiBudWxsLFxyXG4gICAgdHJhbnNpdGlvbjogbnVsbCxcclxuICAgIGVsOiBudWxsLFxyXG4gICAgYW5jaG9yOiBudWxsLFxyXG4gICAgdGFyZ2V0OiBudWxsLFxyXG4gICAgdGFyZ2V0U3RhcnQ6IG51bGwsXHJcbiAgICB0YXJnZXRBbmNob3I6IG51bGwsXHJcbiAgICBzdGF0aWNDb3VudDogMCxcclxuICAgIHNoYXBlRmxhZyxcclxuICAgIHBhdGNoRmxhZyxcclxuICAgIGR5bmFtaWNQcm9wcyxcclxuICAgIGR5bmFtaWNDaGlsZHJlbjogbnVsbCxcclxuICAgIGFwcENvbnRleHQ6IG51bGwsXHJcbiAgICBjdHg6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZVxyXG4gIH07XHJcbiAgaWYgKG5lZWRGdWxsQ2hpbGRyZW5Ob3JtYWxpemF0aW9uKSB7XHJcbiAgICBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pO1xyXG4gICAgaWYgKHNoYXBlRmxhZyAmIDEyOCkge1xyXG4gICAgICB0eXBlLm5vcm1hbGl6ZSh2bm9kZSk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChjaGlsZHJlbikge1xyXG4gICAgdm5vZGUuc2hhcGVGbGFnIHw9IGlzU3RyaW5nKGNoaWxkcmVuKSA/IDggOiAxNjtcclxuICB9XHJcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdm5vZGUua2V5ICE9PSB2bm9kZS5rZXkpIHtcclxuICAgIHdhcm4kMShgVk5vZGUgY3JlYXRlZCB3aXRoIGludmFsaWQga2V5IChOYU4pLiBWTm9kZSB0eXBlOmAsIHZub2RlLnR5cGUpO1xyXG4gIH1cclxuICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiAvLyBhdm9pZCBhIGJsb2NrIG5vZGUgZnJvbSB0cmFja2luZyBpdHNlbGZcclxuICAhaXNCbG9ja05vZGUgJiYgLy8gaGFzIGN1cnJlbnQgcGFyZW50IGJsb2NrXHJcbiAgY3VycmVudEJsb2NrICYmIC8vIHByZXNlbmNlIG9mIGEgcGF0Y2ggZmxhZyBpbmRpY2F0ZXMgdGhpcyBub2RlIG5lZWRzIHBhdGNoaW5nIG9uIHVwZGF0ZXMuXHJcbiAgLy8gY29tcG9uZW50IG5vZGVzIGFsc28gc2hvdWxkIGFsd2F5cyBiZSBwYXRjaGVkLCBiZWNhdXNlIGV2ZW4gaWYgdGhlXHJcbiAgLy8gY29tcG9uZW50IGRvZXNuJ3QgbmVlZCB0byB1cGRhdGUsIGl0IG5lZWRzIHRvIHBlcnNpc3QgdGhlIGluc3RhbmNlIG9uIHRvXHJcbiAgLy8gdGhlIG5leHQgdm5vZGUgc28gdGhhdCBpdCBjYW4gYmUgcHJvcGVybHkgdW5tb3VudGVkIGxhdGVyLlxyXG4gICh2bm9kZS5wYXRjaEZsYWcgPiAwIHx8IHNoYXBlRmxhZyAmIDYpICYmIC8vIHRoZSBFVkVOVFMgZmxhZyBpcyBvbmx5IGZvciBoeWRyYXRpb24gYW5kIGlmIGl0IGlzIHRoZSBvbmx5IGZsYWcsIHRoZVxyXG4gIC8vIHZub2RlIHNob3VsZCBub3QgYmUgY29uc2lkZXJlZCBkeW5hbWljIGR1ZSB0byBoYW5kbGVyIGNhY2hpbmcuXHJcbiAgdm5vZGUucGF0Y2hGbGFnICE9PSAzMikge1xyXG4gICAgY3VycmVudEJsb2NrLnB1c2godm5vZGUpO1xyXG4gIH1cclxuICByZXR1cm4gdm5vZGU7XHJcbn1cclxuY29uc3QgY3JlYXRlVk5vZGUgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gY3JlYXRlVk5vZGVXaXRoQXJnc1RyYW5zZm9ybSA6IF9jcmVhdGVWTm9kZTtcclxuZnVuY3Rpb24gX2NyZWF0ZVZOb2RlKHR5cGUsIHByb3BzID0gbnVsbCwgY2hpbGRyZW4gPSBudWxsLCBwYXRjaEZsYWcgPSAwLCBkeW5hbWljUHJvcHMgPSBudWxsLCBpc0Jsb2NrTm9kZSA9IGZhbHNlKSB7XHJcbiAgaWYgKCF0eXBlIHx8IHR5cGUgPT09IE5VTExfRFlOQU1JQ19DT01QT05FTlQpIHtcclxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICF0eXBlKSB7XHJcbiAgICAgIHdhcm4kMShgSW52YWxpZCB2bm9kZSB0eXBlIHdoZW4gY3JlYXRpbmcgdm5vZGU6ICR7dHlwZX0uYCk7XHJcbiAgICB9XHJcbiAgICB0eXBlID0gQ29tbWVudDtcclxuICB9XHJcbiAgaWYgKGlzVk5vZGUodHlwZSkpIHtcclxuICAgIGNvbnN0IGNsb25lZCA9IGNsb25lVk5vZGUoXHJcbiAgICAgIHR5cGUsXHJcbiAgICAgIHByb3BzLFxyXG4gICAgICB0cnVlXHJcbiAgICAgIC8qIG1lcmdlUmVmOiB0cnVlICovXHJcbiAgICApO1xyXG4gICAgaWYgKGNoaWxkcmVuKSB7XHJcbiAgICAgIG5vcm1hbGl6ZUNoaWxkcmVuKGNsb25lZCwgY2hpbGRyZW4pO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgIWlzQmxvY2tOb2RlICYmIGN1cnJlbnRCbG9jaykge1xyXG4gICAgICBpZiAoY2xvbmVkLnNoYXBlRmxhZyAmIDYpIHtcclxuICAgICAgICBjdXJyZW50QmxvY2tbY3VycmVudEJsb2NrLmluZGV4T2YodHlwZSldID0gY2xvbmVkO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGN1cnJlbnRCbG9jay5wdXNoKGNsb25lZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGNsb25lZC5wYXRjaEZsYWcgPSAtMjtcclxuICAgIHJldHVybiBjbG9uZWQ7XHJcbiAgfVxyXG4gIGlmIChpc0NsYXNzQ29tcG9uZW50KHR5cGUpKSB7XHJcbiAgICB0eXBlID0gdHlwZS5fX3ZjY09wdHM7XHJcbiAgfVxyXG4gIGlmIChwcm9wcykge1xyXG4gICAgcHJvcHMgPSBndWFyZFJlYWN0aXZlUHJvcHMocHJvcHMpO1xyXG4gICAgbGV0IHsgY2xhc3M6IGtsYXNzLCBzdHlsZSB9ID0gcHJvcHM7XHJcbiAgICBpZiAoa2xhc3MgJiYgIWlzU3RyaW5nKGtsYXNzKSkge1xyXG4gICAgICBwcm9wcy5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKGtsYXNzKTtcclxuICAgIH1cclxuICAgIGlmIChpc09iamVjdChzdHlsZSkpIHtcclxuICAgICAgaWYgKGlzUHJveHkoc3R5bGUpICYmICFpc0FycmF5KHN0eWxlKSkge1xyXG4gICAgICAgIHN0eWxlID0gZXh0ZW5kKHt9LCBzdHlsZSk7XHJcbiAgICAgIH1cclxuICAgICAgcHJvcHMuc3R5bGUgPSBub3JtYWxpemVTdHlsZShzdHlsZSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNvbnN0IHNoYXBlRmxhZyA9IGlzU3RyaW5nKHR5cGUpID8gMSA6IGlzU3VzcGVuc2UodHlwZSkgPyAxMjggOiBpc1RlbGVwb3J0KHR5cGUpID8gNjQgOiBpc09iamVjdCh0eXBlKSA/IDQgOiBpc0Z1bmN0aW9uKHR5cGUpID8gMiA6IDA7XHJcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2hhcGVGbGFnICYgNCAmJiBpc1Byb3h5KHR5cGUpKSB7XHJcbiAgICB0eXBlID0gdG9SYXcodHlwZSk7XHJcbiAgICB3YXJuJDEoXHJcbiAgICAgIGBWdWUgcmVjZWl2ZWQgYSBDb21wb25lbnQgdGhhdCB3YXMgbWFkZSBhIHJlYWN0aXZlIG9iamVjdC4gVGhpcyBjYW4gbGVhZCB0byB1bm5lY2Vzc2FyeSBwZXJmb3JtYW5jZSBvdmVyaGVhZCBhbmQgc2hvdWxkIGJlIGF2b2lkZWQgYnkgbWFya2luZyB0aGUgY29tcG9uZW50IHdpdGggXFxgbWFya1Jhd1xcYCBvciB1c2luZyBcXGBzaGFsbG93UmVmXFxgIGluc3RlYWQgb2YgXFxgcmVmXFxgLmAsXHJcbiAgICAgIGBcclxuQ29tcG9uZW50IHRoYXQgd2FzIG1hZGUgcmVhY3RpdmU6IGAsXHJcbiAgICAgIHR5cGVcclxuICAgICk7XHJcbiAgfVxyXG4gIHJldHVybiBjcmVhdGVCYXNlVk5vZGUoXHJcbiAgICB0eXBlLFxyXG4gICAgcHJvcHMsXHJcbiAgICBjaGlsZHJlbixcclxuICAgIHBhdGNoRmxhZyxcclxuICAgIGR5bmFtaWNQcm9wcyxcclxuICAgIHNoYXBlRmxhZyxcclxuICAgIGlzQmxvY2tOb2RlLFxyXG4gICAgdHJ1ZVxyXG4gICk7XHJcbn1cclxuZnVuY3Rpb24gZ3VhcmRSZWFjdGl2ZVByb3BzKHByb3BzKSB7XHJcbiAgaWYgKCFwcm9wcykgcmV0dXJuIG51bGw7XHJcbiAgcmV0dXJuIGlzUHJveHkocHJvcHMpIHx8IGlzSW50ZXJuYWxPYmplY3QocHJvcHMpID8gZXh0ZW5kKHt9LCBwcm9wcykgOiBwcm9wcztcclxufVxyXG5mdW5jdGlvbiBjbG9uZVZOb2RlKHZub2RlLCBleHRyYVByb3BzLCBtZXJnZVJlZiA9IGZhbHNlLCBjbG9uZVRyYW5zaXRpb24gPSBmYWxzZSkge1xyXG4gIGNvbnN0IHsgcHJvcHMsIHJlZiwgcGF0Y2hGbGFnLCBjaGlsZHJlbiwgdHJhbnNpdGlvbiB9ID0gdm5vZGU7XHJcbiAgY29uc3QgbWVyZ2VkUHJvcHMgPSBleHRyYVByb3BzID8gbWVyZ2VQcm9wcyhwcm9wcyB8fCB7fSwgZXh0cmFQcm9wcykgOiBwcm9wcztcclxuICBjb25zdCBjbG9uZWQgPSB7XHJcbiAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcclxuICAgIF9fdl9za2lwOiB0cnVlLFxyXG4gICAgdHlwZTogdm5vZGUudHlwZSxcclxuICAgIHByb3BzOiBtZXJnZWRQcm9wcyxcclxuICAgIGtleTogbWVyZ2VkUHJvcHMgJiYgbm9ybWFsaXplS2V5KG1lcmdlZFByb3BzKSxcclxuICAgIHJlZjogZXh0cmFQcm9wcyAmJiBleHRyYVByb3BzLnJlZiA/IChcclxuICAgICAgLy8gIzIwNzggaW4gdGhlIGNhc2Ugb2YgPGNvbXBvbmVudCA6aXM9XCJ2bm9kZVwiIHJlZj1cImV4dHJhXCIvPlxyXG4gICAgICAvLyBpZiB0aGUgdm5vZGUgaXRzZWxmIGFscmVhZHkgaGFzIGEgcmVmLCBjbG9uZVZOb2RlIHdpbGwgbmVlZCB0byBtZXJnZVxyXG4gICAgICAvLyB0aGUgcmVmcyBzbyB0aGUgc2luZ2xlIHZub2RlIGNhbiBiZSBzZXQgb24gbXVsdGlwbGUgcmVmc1xyXG4gICAgICBtZXJnZVJlZiAmJiByZWYgPyBpc0FycmF5KHJlZikgPyByZWYuY29uY2F0KG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKSkgOiBbcmVmLCBub3JtYWxpemVSZWYoZXh0cmFQcm9wcyldIDogbm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpXHJcbiAgICApIDogcmVmLFxyXG4gICAgc2NvcGVJZDogdm5vZGUuc2NvcGVJZCxcclxuICAgIHNsb3RTY29wZUlkczogdm5vZGUuc2xvdFNjb3BlSWRzLFxyXG4gICAgY2hpbGRyZW46ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgcGF0Y2hGbGFnID09PSAtMSAmJiBpc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuLm1hcChkZWVwQ2xvbmVWTm9kZSkgOiBjaGlsZHJlbixcclxuICAgIHRhcmdldDogdm5vZGUudGFyZ2V0LFxyXG4gICAgdGFyZ2V0U3RhcnQ6IHZub2RlLnRhcmdldFN0YXJ0LFxyXG4gICAgdGFyZ2V0QW5jaG9yOiB2bm9kZS50YXJnZXRBbmNob3IsXHJcbiAgICBzdGF0aWNDb3VudDogdm5vZGUuc3RhdGljQ291bnQsXHJcbiAgICBzaGFwZUZsYWc6IHZub2RlLnNoYXBlRmxhZyxcclxuICAgIC8vIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgd2l0aCBleHRyYSBwcm9wcywgd2UgY2FuIG5vIGxvbmdlciBhc3N1bWUgaXRzXHJcbiAgICAvLyBleGlzdGluZyBwYXRjaCBmbGFnIHRvIGJlIHJlbGlhYmxlIGFuZCBuZWVkIHRvIGFkZCB0aGUgRlVMTF9QUk9QUyBmbGFnLlxyXG4gICAgLy8gbm90ZTogcHJlc2VydmUgZmxhZyBmb3IgZnJhZ21lbnRzIHNpbmNlIHRoZXkgdXNlIHRoZSBmbGFnIGZvciBjaGlsZHJlblxyXG4gICAgLy8gZmFzdCBwYXRocyBvbmx5LlxyXG4gICAgcGF0Y2hGbGFnOiBleHRyYVByb3BzICYmIHZub2RlLnR5cGUgIT09IEZyYWdtZW50ID8gcGF0Y2hGbGFnID09PSAtMSA/IDE2IDogcGF0Y2hGbGFnIHwgMTYgOiBwYXRjaEZsYWcsXHJcbiAgICBkeW5hbWljUHJvcHM6IHZub2RlLmR5bmFtaWNQcm9wcyxcclxuICAgIGR5bmFtaWNDaGlsZHJlbjogdm5vZGUuZHluYW1pY0NoaWxkcmVuLFxyXG4gICAgYXBwQ29udGV4dDogdm5vZGUuYXBwQ29udGV4dCxcclxuICAgIGRpcnM6IHZub2RlLmRpcnMsXHJcbiAgICB0cmFuc2l0aW9uLFxyXG4gICAgLy8gVGhlc2Ugc2hvdWxkIHRlY2huaWNhbGx5IG9ubHkgYmUgbm9uLW51bGwgb24gbW91bnRlZCBWTm9kZXMuIEhvd2V2ZXIsXHJcbiAgICAvLyB0aGV5ICpzaG91bGQqIGJlIGNvcGllZCBmb3Iga2VwdC1hbGl2ZSB2bm9kZXMuIFNvIHdlIGp1c3QgYWx3YXlzIGNvcHlcclxuICAgIC8vIHRoZW0gc2luY2UgdGhlbSBiZWluZyBub24tbnVsbCBkdXJpbmcgYSBtb3VudCBkb2Vzbid0IGFmZmVjdCB0aGUgbG9naWMgYXNcclxuICAgIC8vIHRoZXkgd2lsbCBzaW1wbHkgYmUgb3ZlcndyaXR0ZW4uXHJcbiAgICBjb21wb25lbnQ6IHZub2RlLmNvbXBvbmVudCxcclxuICAgIHN1c3BlbnNlOiB2bm9kZS5zdXNwZW5zZSxcclxuICAgIHNzQ29udGVudDogdm5vZGUuc3NDb250ZW50ICYmIGNsb25lVk5vZGUodm5vZGUuc3NDb250ZW50KSxcclxuICAgIHNzRmFsbGJhY2s6IHZub2RlLnNzRmFsbGJhY2sgJiYgY2xvbmVWTm9kZSh2bm9kZS5zc0ZhbGxiYWNrKSxcclxuICAgIGVsOiB2bm9kZS5lbCxcclxuICAgIGFuY2hvcjogdm5vZGUuYW5jaG9yLFxyXG4gICAgY3R4OiB2bm9kZS5jdHgsXHJcbiAgICBjZTogdm5vZGUuY2VcclxuICB9O1xyXG4gIGlmICh0cmFuc2l0aW9uICYmIGNsb25lVHJhbnNpdGlvbikge1xyXG4gICAgc2V0VHJhbnNpdGlvbkhvb2tzKFxyXG4gICAgICBjbG9uZWQsXHJcbiAgICAgIHRyYW5zaXRpb24uY2xvbmUoY2xvbmVkKVxyXG4gICAgKTtcclxuICB9XHJcbiAgcmV0dXJuIGNsb25lZDtcclxufVxyXG5mdW5jdGlvbiBkZWVwQ2xvbmVWTm9kZSh2bm9kZSkge1xyXG4gIGNvbnN0IGNsb25lZCA9IGNsb25lVk5vZGUodm5vZGUpO1xyXG4gIGlmIChpc0FycmF5KHZub2RlLmNoaWxkcmVuKSkge1xyXG4gICAgY2xvbmVkLmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW4ubWFwKGRlZXBDbG9uZVZOb2RlKTtcclxuICB9XHJcbiAgcmV0dXJuIGNsb25lZDtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUodGV4dCA9IFwiIFwiLCBmbGFnID0gMCkge1xyXG4gIHJldHVybiBjcmVhdGVWTm9kZShUZXh0LCBudWxsLCB0ZXh0LCBmbGFnKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNWTm9kZShjb250ZW50LCBudW1iZXJPZk5vZGVzKSB7XHJcbiAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZShTdGF0aWMsIG51bGwsIGNvbnRlbnQpO1xyXG4gIHZub2RlLnN0YXRpY0NvdW50ID0gbnVtYmVyT2ZOb2RlcztcclxuICByZXR1cm4gdm5vZGU7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudFZOb2RlKHRleHQgPSBcIlwiLCBhc0Jsb2NrID0gZmFsc2UpIHtcclxuICByZXR1cm4gYXNCbG9jayA/IChvcGVuQmxvY2soKSwgY3JlYXRlQmxvY2soQ29tbWVudCwgbnVsbCwgdGV4dCkpIDogY3JlYXRlVk5vZGUoQ29tbWVudCwgbnVsbCwgdGV4dCk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplVk5vZGUoY2hpbGQpIHtcclxuICBpZiAoY2hpbGQgPT0gbnVsbCB8fCB0eXBlb2YgY2hpbGQgPT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlVk5vZGUoQ29tbWVudCk7XHJcbiAgfSBlbHNlIGlmIChpc0FycmF5KGNoaWxkKSkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKFxyXG4gICAgICBGcmFnbWVudCxcclxuICAgICAgbnVsbCxcclxuICAgICAgLy8gIzM2NjYsIGF2b2lkIHJlZmVyZW5jZSBwb2xsdXRpb24gd2hlbiByZXVzaW5nIHZub2RlXHJcbiAgICAgIGNoaWxkLnNsaWNlKClcclxuICAgICk7XHJcbiAgfSBlbHNlIGlmIChpc1ZOb2RlKGNoaWxkKSkge1xyXG4gICAgcmV0dXJuIGNsb25lSWZNb3VudGVkKGNoaWxkKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKFRleHQsIG51bGwsIFN0cmluZyhjaGlsZCkpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBjbG9uZUlmTW91bnRlZChjaGlsZCkge1xyXG4gIHJldHVybiBjaGlsZC5lbCA9PT0gbnVsbCAmJiBjaGlsZC5wYXRjaEZsYWcgIT09IC0xIHx8IGNoaWxkLm1lbW8gPyBjaGlsZCA6IGNsb25lVk5vZGUoY2hpbGQpO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbikge1xyXG4gIGxldCB0eXBlID0gMDtcclxuICBjb25zdCB7IHNoYXBlRmxhZyB9ID0gdm5vZGU7XHJcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcclxuICAgIGNoaWxkcmVuID0gbnVsbDtcclxuICB9IGVsc2UgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XHJcbiAgICB0eXBlID0gMTY7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09IFwib2JqZWN0XCIpIHtcclxuICAgIGlmIChzaGFwZUZsYWcgJiAoMSB8IDY0KSkge1xyXG4gICAgICBjb25zdCBzbG90ID0gY2hpbGRyZW4uZGVmYXVsdDtcclxuICAgICAgaWYgKHNsb3QpIHtcclxuICAgICAgICBzbG90Ll9jICYmIChzbG90Ll9kID0gZmFsc2UpO1xyXG4gICAgICAgIG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLCBzbG90KCkpO1xyXG4gICAgICAgIHNsb3QuX2MgJiYgKHNsb3QuX2QgPSB0cnVlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm47XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0eXBlID0gMzI7XHJcbiAgICAgIGNvbnN0IHNsb3RGbGFnID0gY2hpbGRyZW4uXztcclxuICAgICAgaWYgKCFzbG90RmxhZyAmJiAhaXNJbnRlcm5hbE9iamVjdChjaGlsZHJlbikpIHtcclxuICAgICAgICBjaGlsZHJlbi5fY3R4ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xyXG4gICAgICB9IGVsc2UgaWYgKHNsb3RGbGFnID09PSAzICYmIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkge1xyXG4gICAgICAgIGlmIChjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2Uuc2xvdHMuXyA9PT0gMSkge1xyXG4gICAgICAgICAgY2hpbGRyZW4uXyA9IDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNoaWxkcmVuLl8gPSAyO1xyXG4gICAgICAgICAgdm5vZGUucGF0Y2hGbGFnIHw9IDEwMjQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKGNoaWxkcmVuKSkge1xyXG4gICAgY2hpbGRyZW4gPSB7IGRlZmF1bHQ6IGNoaWxkcmVuLCBfY3R4OiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfTtcclxuICAgIHR5cGUgPSAzMjtcclxuICB9IGVsc2Uge1xyXG4gICAgY2hpbGRyZW4gPSBTdHJpbmcoY2hpbGRyZW4pO1xyXG4gICAgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XHJcbiAgICAgIHR5cGUgPSAxNjtcclxuICAgICAgY2hpbGRyZW4gPSBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0eXBlID0gODtcclxuICAgIH1cclxuICB9XHJcbiAgdm5vZGUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICB2bm9kZS5zaGFwZUZsYWcgfD0gdHlwZTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZVByb3BzKC4uLmFyZ3MpIHtcclxuICBjb25zdCByZXQgPSB7fTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IHRvTWVyZ2UgPSBhcmdzW2ldO1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gdG9NZXJnZSkge1xyXG4gICAgICBpZiAoa2V5ID09PSBcImNsYXNzXCIpIHtcclxuICAgICAgICBpZiAocmV0LmNsYXNzICE9PSB0b01lcmdlLmNsYXNzKSB7XHJcbiAgICAgICAgICByZXQuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhbcmV0LmNsYXNzLCB0b01lcmdlLmNsYXNzXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzdHlsZVwiKSB7XHJcbiAgICAgICAgcmV0LnN0eWxlID0gbm9ybWFsaXplU3R5bGUoW3JldC5zdHlsZSwgdG9NZXJnZS5zdHlsZV0pO1xyXG4gICAgICB9IGVsc2UgaWYgKGlzT24oa2V5KSkge1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gcmV0W2tleV07XHJcbiAgICAgICAgY29uc3QgaW5jb21pbmcgPSB0b01lcmdlW2tleV07XHJcbiAgICAgICAgaWYgKGluY29taW5nICYmIGV4aXN0aW5nICE9PSBpbmNvbWluZyAmJiAhKGlzQXJyYXkoZXhpc3RpbmcpICYmIGV4aXN0aW5nLmluY2x1ZGVzKGluY29taW5nKSkpIHtcclxuICAgICAgICAgIHJldFtrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGluY29taW5nKSA6IGluY29taW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChrZXkgIT09IFwiXCIpIHtcclxuICAgICAgICByZXRba2V5XSA9IHRvTWVyZ2Vba2V5XTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmV0O1xyXG59XHJcbmZ1bmN0aW9uIGludm9rZVZOb2RlSG9vayhob29rLCBpbnN0YW5jZSwgdm5vZGUsIHByZXZWTm9kZSA9IG51bGwpIHtcclxuICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgNywgW1xyXG4gICAgdm5vZGUsXHJcbiAgICBwcmV2Vk5vZGVcclxuICBdKTtcclxufVxyXG5cclxuY29uc3QgZW1wdHlBcHBDb250ZXh0ID0gY3JlYXRlQXBwQ29udGV4dCgpO1xyXG5sZXQgdWlkID0gMDtcclxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2Uodm5vZGUsIHBhcmVudCwgc3VzcGVuc2UpIHtcclxuICBjb25zdCB0eXBlID0gdm5vZGUudHlwZTtcclxuICBjb25zdCBhcHBDb250ZXh0ID0gKHBhcmVudCA/IHBhcmVudC5hcHBDb250ZXh0IDogdm5vZGUuYXBwQ29udGV4dCkgfHwgZW1wdHlBcHBDb250ZXh0O1xyXG4gIGNvbnN0IGluc3RhbmNlID0ge1xyXG4gICAgdWlkOiB1aWQrKyxcclxuICAgIHZub2RlLFxyXG4gICAgdHlwZSxcclxuICAgIHBhcmVudCxcclxuICAgIGFwcENvbnRleHQsXHJcbiAgICByb290OiBudWxsLFxyXG4gICAgLy8gdG8gYmUgaW1tZWRpYXRlbHkgc2V0XHJcbiAgICBuZXh0OiBudWxsLFxyXG4gICAgc3ViVHJlZTogbnVsbCxcclxuICAgIC8vIHdpbGwgYmUgc2V0IHN5bmNocm9ub3VzbHkgcmlnaHQgYWZ0ZXIgY3JlYXRpb25cclxuICAgIGVmZmVjdDogbnVsbCxcclxuICAgIHVwZGF0ZTogbnVsbCxcclxuICAgIC8vIHdpbGwgYmUgc2V0IHN5bmNocm9ub3VzbHkgcmlnaHQgYWZ0ZXIgY3JlYXRpb25cclxuICAgIGpvYjogbnVsbCxcclxuICAgIHNjb3BlOiBuZXcgRWZmZWN0U2NvcGUoXHJcbiAgICAgIHRydWVcclxuICAgICAgLyogZGV0YWNoZWQgKi9cclxuICAgICksXHJcbiAgICByZW5kZXI6IG51bGwsXHJcbiAgICBwcm94eTogbnVsbCxcclxuICAgIGV4cG9zZWQ6IG51bGwsXHJcbiAgICBleHBvc2VQcm94eTogbnVsbCxcclxuICAgIHdpdGhQcm94eTogbnVsbCxcclxuICAgIHByb3ZpZGVzOiBwYXJlbnQgPyBwYXJlbnQucHJvdmlkZXMgOiBPYmplY3QuY3JlYXRlKGFwcENvbnRleHQucHJvdmlkZXMpLFxyXG4gICAgaWRzOiBwYXJlbnQgPyBwYXJlbnQuaWRzIDogW1wiXCIsIDAsIDBdLFxyXG4gICAgYWNjZXNzQ2FjaGU6IG51bGwsXHJcbiAgICByZW5kZXJDYWNoZTogW10sXHJcbiAgICAvLyBsb2NhbCByZXNvbHZlZCBhc3NldHNcclxuICAgIGNvbXBvbmVudHM6IG51bGwsXHJcbiAgICBkaXJlY3RpdmVzOiBudWxsLFxyXG4gICAgLy8gcmVzb2x2ZWQgcHJvcHMgYW5kIGVtaXRzIG9wdGlvbnNcclxuICAgIHByb3BzT3B0aW9uczogbm9ybWFsaXplUHJvcHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxyXG4gICAgZW1pdHNPcHRpb25zOiBub3JtYWxpemVFbWl0c09wdGlvbnModHlwZSwgYXBwQ29udGV4dCksXHJcbiAgICAvLyBlbWl0XHJcbiAgICBlbWl0OiBudWxsLFxyXG4gICAgLy8gdG8gYmUgc2V0IGltbWVkaWF0ZWx5XHJcbiAgICBlbWl0dGVkOiBudWxsLFxyXG4gICAgLy8gcHJvcHMgZGVmYXVsdCB2YWx1ZVxyXG4gICAgcHJvcHNEZWZhdWx0czogRU1QVFlfT0JKLFxyXG4gICAgLy8gaW5oZXJpdEF0dHJzXHJcbiAgICBpbmhlcml0QXR0cnM6IHR5cGUuaW5oZXJpdEF0dHJzLFxyXG4gICAgLy8gc3RhdGVcclxuICAgIGN0eDogRU1QVFlfT0JKLFxyXG4gICAgZGF0YTogRU1QVFlfT0JKLFxyXG4gICAgcHJvcHM6IEVNUFRZX09CSixcclxuICAgIGF0dHJzOiBFTVBUWV9PQkosXHJcbiAgICBzbG90czogRU1QVFlfT0JKLFxyXG4gICAgcmVmczogRU1QVFlfT0JKLFxyXG4gICAgc2V0dXBTdGF0ZTogRU1QVFlfT0JKLFxyXG4gICAgc2V0dXBDb250ZXh0OiBudWxsLFxyXG4gICAgLy8gc3VzcGVuc2UgcmVsYXRlZFxyXG4gICAgc3VzcGVuc2UsXHJcbiAgICBzdXNwZW5zZUlkOiBzdXNwZW5zZSA/IHN1c3BlbnNlLnBlbmRpbmdJZCA6IDAsXHJcbiAgICBhc3luY0RlcDogbnVsbCxcclxuICAgIGFzeW5jUmVzb2x2ZWQ6IGZhbHNlLFxyXG4gICAgLy8gbGlmZWN5Y2xlIGhvb2tzXHJcbiAgICAvLyBub3QgdXNpbmcgZW51bXMgaGVyZSBiZWNhdXNlIGl0IHJlc3VsdHMgaW4gY29tcHV0ZWQgcHJvcGVydGllc1xyXG4gICAgaXNNb3VudGVkOiBmYWxzZSxcclxuICAgIGlzVW5tb3VudGVkOiBmYWxzZSxcclxuICAgIGlzRGVhY3RpdmF0ZWQ6IGZhbHNlLFxyXG4gICAgYmM6IG51bGwsXHJcbiAgICBjOiBudWxsLFxyXG4gICAgYm06IG51bGwsXHJcbiAgICBtOiBudWxsLFxyXG4gICAgYnU6IG51bGwsXHJcbiAgICB1OiBudWxsLFxyXG4gICAgdW06IG51bGwsXHJcbiAgICBidW06IG51bGwsXHJcbiAgICBkYTogbnVsbCxcclxuICAgIGE6IG51bGwsXHJcbiAgICBydGc6IG51bGwsXHJcbiAgICBydGM6IG51bGwsXHJcbiAgICBlYzogbnVsbCxcclxuICAgIHNwOiBudWxsXHJcbiAgfTtcclxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgaW5zdGFuY2UuY3R4ID0gY3JlYXRlRGV2UmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGluc3RhbmNlLmN0eCA9IHsgXzogaW5zdGFuY2UgfTtcclxuICB9XHJcbiAgaW5zdGFuY2Uucm9vdCA9IHBhcmVudCA/IHBhcmVudC5yb290IDogaW5zdGFuY2U7XHJcbiAgaW5zdGFuY2UuZW1pdCA9IGVtaXQuYmluZChudWxsLCBpbnN0YW5jZSk7XHJcbiAgaWYgKHZub2RlLmNlKSB7XHJcbiAgICB2bm9kZS5jZShpbnN0YW5jZSk7XHJcbiAgfVxyXG4gIHJldHVybiBpbnN0YW5jZTtcclxufVxyXG5sZXQgY3VycmVudEluc3RhbmNlID0gbnVsbDtcclxuY29uc3QgZ2V0Q3VycmVudEluc3RhbmNlID0gKCkgPT4gY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcclxubGV0IGludGVybmFsU2V0Q3VycmVudEluc3RhbmNlO1xyXG5sZXQgc2V0SW5TU1JTZXR1cFN0YXRlO1xyXG57XHJcbiAgY29uc3QgZyA9IGdldEdsb2JhbFRoaXMoKTtcclxuICBjb25zdCByZWdpc3Rlckdsb2JhbFNldHRlciA9IChrZXksIHNldHRlcikgPT4ge1xyXG4gICAgbGV0IHNldHRlcnM7XHJcbiAgICBpZiAoIShzZXR0ZXJzID0gZ1trZXldKSkgc2V0dGVycyA9IGdba2V5XSA9IFtdO1xyXG4gICAgc2V0dGVycy5wdXNoKHNldHRlcik7XHJcbiAgICByZXR1cm4gKHYpID0+IHtcclxuICAgICAgaWYgKHNldHRlcnMubGVuZ3RoID4gMSkgc2V0dGVycy5mb3JFYWNoKChzZXQpID0+IHNldCh2KSk7XHJcbiAgICAgIGVsc2Ugc2V0dGVyc1swXSh2KTtcclxuICAgIH07XHJcbiAgfTtcclxuICBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZSA9IHJlZ2lzdGVyR2xvYmFsU2V0dGVyKFxyXG4gICAgYF9fVlVFX0lOU1RBTkNFX1NFVFRFUlNfX2AsXHJcbiAgICAodikgPT4gY3VycmVudEluc3RhbmNlID0gdlxyXG4gICk7XHJcbiAgc2V0SW5TU1JTZXR1cFN0YXRlID0gcmVnaXN0ZXJHbG9iYWxTZXR0ZXIoXHJcbiAgICBgX19WVUVfU1NSX1NFVFRFUlNfX2AsXHJcbiAgICAodikgPT4gaXNJblNTUkNvbXBvbmVudFNldHVwID0gdlxyXG4gICk7XHJcbn1cclxuY29uc3Qgc2V0Q3VycmVudEluc3RhbmNlID0gKGluc3RhbmNlKSA9PiB7XHJcbiAgY29uc3QgcHJldiA9IGN1cnJlbnRJbnN0YW5jZTtcclxuICBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XHJcbiAgaW5zdGFuY2Uuc2NvcGUub24oKTtcclxuICByZXR1cm4gKCkgPT4ge1xyXG4gICAgaW5zdGFuY2Uuc2NvcGUub2ZmKCk7XHJcbiAgICBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZShwcmV2KTtcclxuICB9O1xyXG59O1xyXG5jb25zdCB1bnNldEN1cnJlbnRJbnN0YW5jZSA9ICgpID0+IHtcclxuICBjdXJyZW50SW5zdGFuY2UgJiYgY3VycmVudEluc3RhbmNlLnNjb3BlLm9mZigpO1xyXG4gIGludGVybmFsU2V0Q3VycmVudEluc3RhbmNlKG51bGwpO1xyXG59O1xyXG5jb25zdCBpc0J1aWx0SW5UYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcInNsb3QsY29tcG9uZW50XCIpO1xyXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSwgeyBpc05hdGl2ZVRhZyB9KSB7XHJcbiAgaWYgKGlzQnVpbHRJblRhZyhuYW1lKSB8fCBpc05hdGl2ZVRhZyhuYW1lKSkge1xyXG4gICAgd2FybiQxKFxyXG4gICAgICBcIkRvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgaWQ6IFwiICsgbmFtZVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gaXNTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSkge1xyXG4gIHJldHVybiBpbnN0YW5jZS52bm9kZS5zaGFwZUZsYWcgJiA0O1xyXG59XHJcbmxldCBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSBmYWxzZTtcclxuZnVuY3Rpb24gc2V0dXBDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlKSB7XHJcbiAgaXNTU1IgJiYgc2V0SW5TU1JTZXR1cFN0YXRlKGlzU1NSKTtcclxuICBjb25zdCB7IHByb3BzLCBjaGlsZHJlbiB9ID0gaW5zdGFuY2Uudm5vZGU7XHJcbiAgY29uc3QgaXNTdGF0ZWZ1bCA9IGlzU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UpO1xyXG4gIGluaXRQcm9wcyhpbnN0YW5jZSwgcHJvcHMsIGlzU3RhdGVmdWwsIGlzU1NSKTtcclxuICBpbml0U2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xyXG4gIGNvbnN0IHNldHVwUmVzdWx0ID0gaXNTdGF0ZWZ1bCA/IHNldHVwU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSKSA6IHZvaWQgMDtcclxuICBpc1NTUiAmJiBzZXRJblNTUlNldHVwU3RhdGUoZmFsc2UpO1xyXG4gIHJldHVybiBzZXR1cFJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBzZXR1cFN0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUikge1xyXG4gIHZhciBfYTtcclxuICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xyXG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICBpZiAoQ29tcG9uZW50Lm5hbWUpIHtcclxuICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKENvbXBvbmVudC5uYW1lLCBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZyk7XHJcbiAgICB9XHJcbiAgICBpZiAoQ29tcG9uZW50LmNvbXBvbmVudHMpIHtcclxuICAgICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhDb21wb25lbnQuY29tcG9uZW50cyk7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZXNbaV0sIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKENvbXBvbmVudC5kaXJlY3RpdmVzKSB7XHJcbiAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoQ29tcG9uZW50LmRpcmVjdGl2ZXMpO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWVzW2ldKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKENvbXBvbmVudC5jb21waWxlck9wdGlvbnMgJiYgaXNSdW50aW1lT25seSgpKSB7XHJcbiAgICAgIHdhcm4kMShcclxuICAgICAgICBgXCJjb21waWxlck9wdGlvbnNcIiBpcyBvbmx5IHN1cHBvcnRlZCB3aGVuIHVzaW5nIGEgYnVpbGQgb2YgVnVlIHRoYXQgaW5jbHVkZXMgdGhlIHJ1bnRpbWUgY29tcGlsZXIuIFNpbmNlIHlvdSBhcmUgdXNpbmcgYSBydW50aW1lLW9ubHkgYnVpbGQsIHRoZSBvcHRpb25zIHNob3VsZCBiZSBwYXNzZWQgdmlhIHlvdXIgYnVpbGQgdG9vbCBjb25maWcgaW5zdGVhZC5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGluc3RhbmNlLmFjY2Vzc0NhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgaW5zdGFuY2UucHJveHkgPSBuZXcgUHJveHkoaW5zdGFuY2UuY3R4LCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMpO1xyXG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICBleHBvc2VQcm9wc09uUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XHJcbiAgfVxyXG4gIGNvbnN0IHsgc2V0dXAgfSA9IENvbXBvbmVudDtcclxuICBpZiAoc2V0dXApIHtcclxuICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgIGNvbnN0IHNldHVwQ29udGV4dCA9IGluc3RhbmNlLnNldHVwQ29udGV4dCA9IHNldHVwLmxlbmd0aCA+IDEgPyBjcmVhdGVTZXR1cENvbnRleHQoaW5zdGFuY2UpIDogbnVsbDtcclxuICAgIGNvbnN0IHJlc2V0ID0gc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcclxuICAgIGNvbnN0IHNldHVwUmVzdWx0ID0gY2FsbFdpdGhFcnJvckhhbmRsaW5nKFxyXG4gICAgICBzZXR1cCxcclxuICAgICAgaW5zdGFuY2UsXHJcbiAgICAgIDAsXHJcbiAgICAgIFtcclxuICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGluc3RhbmNlLnByb3BzKSA6IGluc3RhbmNlLnByb3BzLFxyXG4gICAgICAgIHNldHVwQ29udGV4dFxyXG4gICAgICBdXHJcbiAgICApO1xyXG4gICAgY29uc3QgaXNBc3luY1NldHVwID0gaXNQcm9taXNlKHNldHVwUmVzdWx0KTtcclxuICAgIHJlc2V0VHJhY2tpbmcoKTtcclxuICAgIHJlc2V0KCk7XHJcbiAgICBpZiAoKGlzQXN5bmNTZXR1cCB8fCBpbnN0YW5jZS5zcCkgJiYgIWlzQXN5bmNXcmFwcGVyKGluc3RhbmNlKSkge1xyXG4gICAgICBtYXJrQXN5bmNCb3VuZGFyeShpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNBc3luY1NldHVwKSB7XHJcbiAgICAgIHNldHVwUmVzdWx0LnRoZW4odW5zZXRDdXJyZW50SW5zdGFuY2UsIHVuc2V0Q3VycmVudEluc3RhbmNlKTtcclxuICAgICAgaWYgKGlzU1NSKSB7XHJcbiAgICAgICAgcmV0dXJuIHNldHVwUmVzdWx0LnRoZW4oKHJlc29sdmVkUmVzdWx0KSA9PiB7XHJcbiAgICAgICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgcmVzb2x2ZWRSZXN1bHQsIGlzU1NSKTtcclxuICAgICAgICB9KS5jYXRjaCgoZSkgPT4ge1xyXG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgaW5zdGFuY2UsIDApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGluc3RhbmNlLmFzeW5jRGVwID0gc2V0dXBSZXN1bHQ7XHJcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWluc3RhbmNlLnN1c3BlbnNlKSB7XHJcbiAgICAgICAgICBjb25zdCBuYW1lID0gKF9hID0gQ29tcG9uZW50Lm5hbWUpICE9IG51bGwgPyBfYSA6IFwiQW5vbnltb3VzXCI7XHJcbiAgICAgICAgICB3YXJuJDEoXHJcbiAgICAgICAgICAgIGBDb21wb25lbnQgPCR7bmFtZX0+OiBzZXR1cCBmdW5jdGlvbiByZXR1cm5lZCBhIHByb21pc2UsIGJ1dCBubyA8U3VzcGVuc2U+IGJvdW5kYXJ5IHdhcyBmb3VuZCBpbiB0aGUgcGFyZW50IGNvbXBvbmVudCB0cmVlLiBBIGNvbXBvbmVudCB3aXRoIGFzeW5jIHNldHVwKCkgbXVzdCBiZSBuZXN0ZWQgaW4gYSA8U3VzcGVuc2U+IGluIG9yZGVyIHRvIGJlIHJlbmRlcmVkLmBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgc2V0dXBSZXN1bHQsIGlzU1NSKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHNldHVwUmVzdWx0LCBpc1NTUikge1xyXG4gIGlmIChpc0Z1bmN0aW9uKHNldHVwUmVzdWx0KSkge1xyXG4gICAgaWYgKGluc3RhbmNlLnR5cGUuX19zc3JJbmxpbmVSZW5kZXIpIHtcclxuICAgICAgaW5zdGFuY2Uuc3NyUmVuZGVyID0gc2V0dXBSZXN1bHQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpbnN0YW5jZS5yZW5kZXIgPSBzZXR1cFJlc3VsdDtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHNldHVwUmVzdWx0KSkge1xyXG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNWTm9kZShzZXR1cFJlc3VsdCkpIHtcclxuICAgICAgd2FybiQxKFxyXG4gICAgICAgIGBzZXR1cCgpIHNob3VsZCBub3QgcmV0dXJuIFZOb2RlcyBkaXJlY3RseSAtIHJldHVybiBhIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICBpbnN0YW5jZS5kZXZ0b29sc1Jhd1NldHVwU3RhdGUgPSBzZXR1cFJlc3VsdDtcclxuICAgIH1cclxuICAgIGluc3RhbmNlLnNldHVwU3RhdGUgPSBwcm94eVJlZnMoc2V0dXBSZXN1bHQpO1xyXG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNldHVwUmVzdWx0ICE9PSB2b2lkIDApIHtcclxuICAgIHdhcm4kMShcclxuICAgICAgYHNldHVwKCkgc2hvdWxkIHJldHVybiBhbiBvYmplY3QuIFJlY2VpdmVkOiAke3NldHVwUmVzdWx0ID09PSBudWxsID8gXCJudWxsXCIgOiB0eXBlb2Ygc2V0dXBSZXN1bHR9YFxyXG4gICAgKTtcclxuICB9XHJcbiAgZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSKTtcclxufVxyXG5sZXQgY29tcGlsZTtcclxubGV0IGluc3RhbGxXaXRoUHJveHk7XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyKF9jb21waWxlKSB7XHJcbiAgY29tcGlsZSA9IF9jb21waWxlO1xyXG4gIGluc3RhbGxXaXRoUHJveHkgPSAoaSkgPT4ge1xyXG4gICAgaWYgKGkucmVuZGVyLl9yYykge1xyXG4gICAgICBpLndpdGhQcm94eSA9IG5ldyBQcm94eShpLmN0eCwgUnVudGltZUNvbXBpbGVkUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzKTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcbmNvbnN0IGlzUnVudGltZU9ubHkgPSAoKSA9PiAhY29tcGlsZTtcclxuZnVuY3Rpb24gZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSLCBza2lwT3B0aW9ucykge1xyXG4gIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XHJcbiAgaWYgKCFpbnN0YW5jZS5yZW5kZXIpIHtcclxuICAgIGlmICghaXNTU1IgJiYgY29tcGlsZSAmJiAhQ29tcG9uZW50LnJlbmRlcikge1xyXG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IENvbXBvbmVudC50ZW1wbGF0ZSB8fCBfX1ZVRV9PUFRJT05TX0FQSV9fICYmIHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKS50ZW1wbGF0ZTtcclxuICAgICAgaWYgKHRlbXBsYXRlKSB7XHJcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYGNvbXBpbGVgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBpc0N1c3RvbUVsZW1lbnQsIGNvbXBpbGVyT3B0aW9ucyB9ID0gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWc7XHJcbiAgICAgICAgY29uc3QgeyBkZWxpbWl0ZXJzLCBjb21waWxlck9wdGlvbnM6IGNvbXBvbmVudENvbXBpbGVyT3B0aW9ucyB9ID0gQ29tcG9uZW50O1xyXG4gICAgICAgIGNvbnN0IGZpbmFsQ29tcGlsZXJPcHRpb25zID0gZXh0ZW5kKFxyXG4gICAgICAgICAgZXh0ZW5kKFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgaXNDdXN0b21FbGVtZW50LFxyXG4gICAgICAgICAgICAgIGRlbGltaXRlcnNcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY29tcGlsZXJPcHRpb25zXHJcbiAgICAgICAgICApLFxyXG4gICAgICAgICAgY29tcG9uZW50Q29tcGlsZXJPcHRpb25zXHJcbiAgICAgICAgKTtcclxuICAgICAgICBDb21wb25lbnQucmVuZGVyID0gY29tcGlsZSh0ZW1wbGF0ZSwgZmluYWxDb21waWxlck9wdGlvbnMpO1xyXG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgY29tcGlsZWApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaW5zdGFuY2UucmVuZGVyID0gQ29tcG9uZW50LnJlbmRlciB8fCBOT09QO1xyXG4gICAgaWYgKGluc3RhbGxXaXRoUHJveHkpIHtcclxuICAgICAgaW5zdGFsbFdpdGhQcm94eShpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmIHRydWUpIHtcclxuICAgIGNvbnN0IHJlc2V0ID0gc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcclxuICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGFwcGx5T3B0aW9ucyhpbnN0YW5jZSk7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICAgIHJlc2V0KCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFDb21wb25lbnQucmVuZGVyICYmIGluc3RhbmNlLnJlbmRlciA9PT0gTk9PUCAmJiAhaXNTU1IpIHtcclxuICAgIGlmICghY29tcGlsZSAmJiBDb21wb25lbnQudGVtcGxhdGUpIHtcclxuICAgICAgd2FybiQxKFxyXG4gICAgICAgIGBDb21wb25lbnQgcHJvdmlkZWQgdGVtcGxhdGUgb3B0aW9uIGJ1dCBydW50aW1lIGNvbXBpbGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBWdWUuYCArIChgIENvbmZpZ3VyZSB5b3VyIGJ1bmRsZXIgdG8gYWxpYXMgXCJ2dWVcIiB0byBcInZ1ZS9kaXN0L3Z1ZS5lc20tYnVuZGxlci5qc1wiLmAgKVxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgd2FybiQxKGBDb21wb25lbnQgaXMgbWlzc2luZyB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb246IGAsIENvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmNvbnN0IGF0dHJzUHJveHlIYW5kbGVycyA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyB7XHJcbiAgZ2V0KHRhcmdldCwga2V5KSB7XHJcbiAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xyXG4gICAgdHJhY2sodGFyZ2V0LCBcImdldFwiLCBcIlwiKTtcclxuICAgIHJldHVybiB0YXJnZXRba2V5XTtcclxuICB9LFxyXG4gIHNldCgpIHtcclxuICAgIHdhcm4kMShgc2V0dXBDb250ZXh0LmF0dHJzIGlzIHJlYWRvbmx5LmApO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sXHJcbiAgZGVsZXRlUHJvcGVydHkoKSB7XHJcbiAgICB3YXJuJDEoYHNldHVwQ29udGV4dC5hdHRycyBpcyByZWFkb25seS5gKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn0gOiB7XHJcbiAgZ2V0KHRhcmdldCwga2V5KSB7XHJcbiAgICB0cmFjayh0YXJnZXQsIFwiZ2V0XCIsIFwiXCIpO1xyXG4gICAgcmV0dXJuIHRhcmdldFtrZXldO1xyXG4gIH1cclxufTtcclxuZnVuY3Rpb24gZ2V0U2xvdHNQcm94eShpbnN0YW5jZSkge1xyXG4gIHJldHVybiBuZXcgUHJveHkoaW5zdGFuY2Uuc2xvdHMsIHtcclxuICAgIGdldCh0YXJnZXQsIGtleSkge1xyXG4gICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiwgXCIkc2xvdHNcIik7XHJcbiAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVTZXR1cENvbnRleHQoaW5zdGFuY2UpIHtcclxuICBjb25zdCBleHBvc2UgPSAoZXhwb3NlZCkgPT4ge1xyXG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgaWYgKGluc3RhbmNlLmV4cG9zZWQpIHtcclxuICAgICAgICB3YXJuJDEoYGV4cG9zZSgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlIHBlciBzZXR1cCgpLmApO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChleHBvc2VkICE9IG51bGwpIHtcclxuICAgICAgICBsZXQgZXhwb3NlZFR5cGUgPSB0eXBlb2YgZXhwb3NlZDtcclxuICAgICAgICBpZiAoZXhwb3NlZFR5cGUgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgIGlmIChpc0FycmF5KGV4cG9zZWQpKSB7XHJcbiAgICAgICAgICAgIGV4cG9zZWRUeXBlID0gXCJhcnJheVwiO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChpc1JlZihleHBvc2VkKSkge1xyXG4gICAgICAgICAgICBleHBvc2VkVHlwZSA9IFwicmVmXCI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChleHBvc2VkVHlwZSAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgd2FybiQxKFxyXG4gICAgICAgICAgICBgZXhwb3NlKCkgc2hvdWxkIGJlIHBhc3NlZCBhIHBsYWluIG9iamVjdCwgcmVjZWl2ZWQgJHtleHBvc2VkVHlwZX0uYFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGluc3RhbmNlLmV4cG9zZWQgPSBleHBvc2VkIHx8IHt9O1xyXG4gIH07XHJcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgIGxldCBhdHRyc1Byb3h5O1xyXG4gICAgbGV0IHNsb3RzUHJveHk7XHJcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICAgIGdldCBhdHRycygpIHtcclxuICAgICAgICByZXR1cm4gYXR0cnNQcm94eSB8fCAoYXR0cnNQcm94eSA9IG5ldyBQcm94eShpbnN0YW5jZS5hdHRycywgYXR0cnNQcm94eUhhbmRsZXJzKSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGdldCBzbG90cygpIHtcclxuICAgICAgICByZXR1cm4gc2xvdHNQcm94eSB8fCAoc2xvdHNQcm94eSA9IGdldFNsb3RzUHJveHkoaW5zdGFuY2UpKTtcclxuICAgICAgfSxcclxuICAgICAgZ2V0IGVtaXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIChldmVudCwgLi4uYXJncykgPT4gaW5zdGFuY2UuZW1pdChldmVudCwgLi4uYXJncyk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGV4cG9zZVxyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGF0dHJzOiBuZXcgUHJveHkoaW5zdGFuY2UuYXR0cnMsIGF0dHJzUHJveHlIYW5kbGVycyksXHJcbiAgICAgIHNsb3RzOiBpbnN0YW5jZS5zbG90cyxcclxuICAgICAgZW1pdDogaW5zdGFuY2UuZW1pdCxcclxuICAgICAgZXhwb3NlXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBnZXRDb21wb25lbnRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSkge1xyXG4gIGlmIChpbnN0YW5jZS5leHBvc2VkKSB7XHJcbiAgICByZXR1cm4gaW5zdGFuY2UuZXhwb3NlUHJveHkgfHwgKGluc3RhbmNlLmV4cG9zZVByb3h5ID0gbmV3IFByb3h5KHByb3h5UmVmcyhtYXJrUmF3KGluc3RhbmNlLmV4cG9zZWQpKSwge1xyXG4gICAgICBnZXQodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICBpZiAoa2V5IGluIHRhcmdldCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoa2V5IGluIHB1YmxpY1Byb3BlcnRpZXNNYXApIHtcclxuICAgICAgICAgIHJldHVybiBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV0oaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgaGFzKHRhcmdldCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIGtleSBpbiB0YXJnZXQgfHwga2V5IGluIHB1YmxpY1Byb3BlcnRpZXNNYXA7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGluc3RhbmNlLnByb3h5O1xyXG4gIH1cclxufVxyXG5jb25zdCBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xyXG5jb25zdCBjbGFzc2lmeSA9IChzdHIpID0+IHN0ci5yZXBsYWNlKGNsYXNzaWZ5UkUsIChjKSA9PiBjLnRvVXBwZXJDYXNlKCkpLnJlcGxhY2UoL1stX10vZywgXCJcIik7XHJcbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50LCBpbmNsdWRlSW5mZXJyZWQgPSB0cnVlKSB7XHJcbiAgcmV0dXJuIGlzRnVuY3Rpb24oQ29tcG9uZW50KSA/IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSA6IENvbXBvbmVudC5uYW1lIHx8IGluY2x1ZGVJbmZlcnJlZCAmJiBDb21wb25lbnQuX19uYW1lO1xyXG59XHJcbmZ1bmN0aW9uIGZvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIENvbXBvbmVudCwgaXNSb290ID0gZmFsc2UpIHtcclxuICBsZXQgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KTtcclxuICBpZiAoIW5hbWUgJiYgQ29tcG9uZW50Ll9fZmlsZSkge1xyXG4gICAgY29uc3QgbWF0Y2ggPSBDb21wb25lbnQuX19maWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLlxcdyskLyk7XHJcbiAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgbmFtZSA9IG1hdGNoWzFdO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoIW5hbWUgJiYgaW5zdGFuY2UgJiYgaW5zdGFuY2UucGFyZW50KSB7XHJcbiAgICBjb25zdCBpbmZlckZyb21SZWdpc3RyeSA9IChyZWdpc3RyeSkgPT4ge1xyXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiByZWdpc3RyeSkge1xyXG4gICAgICAgIGlmIChyZWdpc3RyeVtrZXldID09PSBDb21wb25lbnQpIHtcclxuICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgbmFtZSA9IGluZmVyRnJvbVJlZ2lzdHJ5KFxyXG4gICAgICBpbnN0YW5jZS5jb21wb25lbnRzIHx8IGluc3RhbmNlLnBhcmVudC50eXBlLmNvbXBvbmVudHNcclxuICAgICkgfHwgaW5mZXJGcm9tUmVnaXN0cnkoaW5zdGFuY2UuYXBwQ29udGV4dC5jb21wb25lbnRzKTtcclxuICB9XHJcbiAgcmV0dXJuIG5hbWUgPyBjbGFzc2lmeShuYW1lKSA6IGlzUm9vdCA/IGBBcHBgIDogYEFub255bW91c2A7XHJcbn1cclxuZnVuY3Rpb24gaXNDbGFzc0NvbXBvbmVudCh2YWx1ZSkge1xyXG4gIHJldHVybiBpc0Z1bmN0aW9uKHZhbHVlKSAmJiBcIl9fdmNjT3B0c1wiIGluIHZhbHVlO1xyXG59XHJcblxyXG5jb25zdCBjb21wdXRlZCA9IChnZXR0ZXJPck9wdGlvbnMsIGRlYnVnT3B0aW9ucykgPT4ge1xyXG4gIGNvbnN0IGMgPSBjb21wdXRlZCQxKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zLCBpc0luU1NSQ29tcG9uZW50U2V0dXApO1xyXG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICBjb25zdCBpID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICBpZiAoaSAmJiBpLmFwcENvbnRleHQuY29uZmlnLndhcm5SZWN1cnNpdmVDb21wdXRlZCkge1xyXG4gICAgICBjLl93YXJuUmVjdXJzaXZlID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGM7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBoKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pIHtcclxuICBjb25zdCBsID0gYXJndW1lbnRzLmxlbmd0aDtcclxuICBpZiAobCA9PT0gMikge1xyXG4gICAgaWYgKGlzT2JqZWN0KHByb3BzT3JDaGlsZHJlbikgJiYgIWlzQXJyYXkocHJvcHNPckNoaWxkcmVuKSkge1xyXG4gICAgICBpZiAoaXNWTm9kZShwcm9wc09yQ2hpbGRyZW4pKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG51bGwsIFtwcm9wc09yQ2hpbGRyZW5dKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHNPckNoaWxkcmVuKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBudWxsLCBwcm9wc09yQ2hpbGRyZW4pO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAobCA+IDMpIHtcclxuICAgICAgY2hpbGRyZW4gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG4gICAgfSBlbHNlIGlmIChsID09PSAzICYmIGlzVk5vZGUoY2hpbGRyZW4pKSB7XHJcbiAgICAgIGNoaWxkcmVuID0gW2NoaWxkcmVuXTtcclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wc09yQ2hpbGRyZW4sIGNoaWxkcmVuKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXRDdXN0b21Gb3JtYXR0ZXIoKSB7XHJcbiAgaWYgKCEhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgY29uc3QgdnVlU3R5bGUgPSB7IHN0eWxlOiBcImNvbG9yOiMzYmE3NzZcIiB9O1xyXG4gIGNvbnN0IG51bWJlclN0eWxlID0geyBzdHlsZTogXCJjb2xvcjojMTY3N2ZmXCIgfTtcclxuICBjb25zdCBzdHJpbmdTdHlsZSA9IHsgc3R5bGU6IFwiY29sb3I6I2Y1MjIyZFwiIH07XHJcbiAgY29uc3Qga2V5d29yZFN0eWxlID0geyBzdHlsZTogXCJjb2xvcjojZWIyZjk2XCIgfTtcclxuICBjb25zdCBmb3JtYXR0ZXIgPSB7XHJcbiAgICBfX3Z1ZV9jdXN0b21fZm9ybWF0dGVyOiB0cnVlLFxyXG4gICAgaGVhZGVyKG9iaikge1xyXG4gICAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBpZiAob2JqLl9faXNWdWUpIHtcclxuICAgICAgICByZXR1cm4gW1wiZGl2XCIsIHZ1ZVN0eWxlLCBgVnVlSW5zdGFuY2VgXTtcclxuICAgICAgfSBlbHNlIGlmIChpc1JlZihvYmopKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgIFwiZGl2XCIsXHJcbiAgICAgICAgICB7fSxcclxuICAgICAgICAgIFtcInNwYW5cIiwgdnVlU3R5bGUsIGdlblJlZkZsYWcob2JqKV0sXHJcbiAgICAgICAgICBcIjxcIixcclxuICAgICAgICAgIC8vIGF2b2lkIGRlYnVnZ2VyIGFjY2Vzc2luZyB2YWx1ZSBhZmZlY3RpbmcgYmVoYXZpb3JcclxuICAgICAgICAgIGZvcm1hdFZhbHVlKFwiX3ZhbHVlXCIgaW4gb2JqID8gb2JqLl92YWx1ZSA6IG9iaiksXHJcbiAgICAgICAgICBgPmBcclxuICAgICAgICBdO1xyXG4gICAgICB9IGVsc2UgaWYgKGlzUmVhY3RpdmUob2JqKSkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICBcImRpdlwiLFxyXG4gICAgICAgICAge30sXHJcbiAgICAgICAgICBbXCJzcGFuXCIsIHZ1ZVN0eWxlLCBpc1NoYWxsb3cob2JqKSA/IFwiU2hhbGxvd1JlYWN0aXZlXCIgOiBcIlJlYWN0aXZlXCJdLFxyXG4gICAgICAgICAgXCI8XCIsXHJcbiAgICAgICAgICBmb3JtYXRWYWx1ZShvYmopLFxyXG4gICAgICAgICAgYD4ke2lzUmVhZG9ubHkob2JqKSA/IGAgKHJlYWRvbmx5KWAgOiBgYH1gXHJcbiAgICAgICAgXTtcclxuICAgICAgfSBlbHNlIGlmIChpc1JlYWRvbmx5KG9iaikpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgXCJkaXZcIixcclxuICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgW1wic3BhblwiLCB2dWVTdHlsZSwgaXNTaGFsbG93KG9iaikgPyBcIlNoYWxsb3dSZWFkb25seVwiIDogXCJSZWFkb25seVwiXSxcclxuICAgICAgICAgIFwiPFwiLFxyXG4gICAgICAgICAgZm9ybWF0VmFsdWUob2JqKSxcclxuICAgICAgICAgIFwiPlwiXHJcbiAgICAgICAgXTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0sXHJcbiAgICBoYXNCb2R5KG9iaikge1xyXG4gICAgICByZXR1cm4gb2JqICYmIG9iai5fX2lzVnVlO1xyXG4gICAgfSxcclxuICAgIGJvZHkob2JqKSB7XHJcbiAgICAgIGlmIChvYmogJiYgb2JqLl9faXNWdWUpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgXCJkaXZcIixcclxuICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgLi4uZm9ybWF0SW5zdGFuY2Uob2JqLiQpXHJcbiAgICAgICAgXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcbiAgZnVuY3Rpb24gZm9ybWF0SW5zdGFuY2UoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IGJsb2NrcyA9IFtdO1xyXG4gICAgaWYgKGluc3RhbmNlLnR5cGUucHJvcHMgJiYgaW5zdGFuY2UucHJvcHMpIHtcclxuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcInByb3BzXCIsIHRvUmF3KGluc3RhbmNlLnByb3BzKSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKGluc3RhbmNlLnNldHVwU3RhdGUgIT09IEVNUFRZX09CSikge1xyXG4gICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKFwic2V0dXBcIiwgaW5zdGFuY2Uuc2V0dXBTdGF0ZSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKGluc3RhbmNlLmRhdGEgIT09IEVNUFRZX09CSikge1xyXG4gICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKFwiZGF0YVwiLCB0b1JhdyhpbnN0YW5jZS5kYXRhKSkpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY29tcHV0ZWQgPSBleHRyYWN0S2V5cyhpbnN0YW5jZSwgXCJjb21wdXRlZFwiKTtcclxuICAgIGlmIChjb21wdXRlZCkge1xyXG4gICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKFwiY29tcHV0ZWRcIiwgY29tcHV0ZWQpKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGluamVjdGVkID0gZXh0cmFjdEtleXMoaW5zdGFuY2UsIFwiaW5qZWN0XCIpO1xyXG4gICAgaWYgKGluamVjdGVkKSB7XHJcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJpbmplY3RlZFwiLCBpbmplY3RlZCkpO1xyXG4gICAgfVxyXG4gICAgYmxvY2tzLnB1c2goW1xyXG4gICAgICBcImRpdlwiLFxyXG4gICAgICB7fSxcclxuICAgICAgW1xyXG4gICAgICAgIFwic3BhblwiLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHN0eWxlOiBrZXl3b3JkU3R5bGUuc3R5bGUgKyBcIjtvcGFjaXR5OjAuNjZcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCIkIChpbnRlcm5hbCk6IFwiXHJcbiAgICAgIF0sXHJcbiAgICAgIFtcIm9iamVjdFwiLCB7IG9iamVjdDogaW5zdGFuY2UgfV1cclxuICAgIF0pO1xyXG4gICAgcmV0dXJuIGJsb2NrcztcclxuICB9XHJcbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VCbG9jayh0eXBlLCB0YXJnZXQpIHtcclxuICAgIHRhcmdldCA9IGV4dGVuZCh7fSwgdGFyZ2V0KTtcclxuICAgIGlmICghT2JqZWN0LmtleXModGFyZ2V0KS5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIFtcInNwYW5cIiwge31dO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtcclxuICAgICAgXCJkaXZcIixcclxuICAgICAgeyBzdHlsZTogXCJsaW5lLWhlaWdodDoxLjI1ZW07bWFyZ2luLWJvdHRvbTowLjZlbVwiIH0sXHJcbiAgICAgIFtcclxuICAgICAgICBcImRpdlwiLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHN0eWxlOiBcImNvbG9yOiM0NzY1ODJcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHlwZVxyXG4gICAgICBdLFxyXG4gICAgICBbXHJcbiAgICAgICAgXCJkaXZcIixcclxuICAgICAgICB7XHJcbiAgICAgICAgICBzdHlsZTogXCJwYWRkaW5nLWxlZnQ6MS4yNWVtXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIC4uLk9iamVjdC5rZXlzKHRhcmdldCkubWFwKChrZXkpID0+IHtcclxuICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIFwiZGl2XCIsXHJcbiAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICBbXCJzcGFuXCIsIGtleXdvcmRTdHlsZSwga2V5ICsgXCI6IFwiXSxcclxuICAgICAgICAgICAgZm9ybWF0VmFsdWUodGFyZ2V0W2tleV0sIGZhbHNlKVxyXG4gICAgICAgICAgXTtcclxuICAgICAgICB9KVxyXG4gICAgICBdXHJcbiAgICBdO1xyXG4gIH1cclxuICBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh2LCBhc1JhdyA9IHRydWUpIHtcclxuICAgIGlmICh0eXBlb2YgdiA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICByZXR1cm4gW1wic3BhblwiLCBudW1iZXJTdHlsZSwgdl07XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIHN0cmluZ1N0eWxlLCBKU09OLnN0cmluZ2lmeSh2KV07XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcImJvb2xlYW5cIikge1xyXG4gICAgICByZXR1cm4gW1wic3BhblwiLCBrZXl3b3JkU3R5bGUsIHZdO1xyXG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2KSkge1xyXG4gICAgICByZXR1cm4gW1wib2JqZWN0XCIsIHsgb2JqZWN0OiBhc1JhdyA/IHRvUmF3KHYpIDogdiB9XTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIHN0cmluZ1N0eWxlLCBTdHJpbmcodildO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBleHRyYWN0S2V5cyhpbnN0YW5jZSwgdHlwZSkge1xyXG4gICAgY29uc3QgQ29tcCA9IGluc3RhbmNlLnR5cGU7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihDb21wKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBleHRyYWN0ZWQgPSB7fTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGluc3RhbmNlLmN0eCkge1xyXG4gICAgICBpZiAoaXNLZXlPZlR5cGUoQ29tcCwga2V5LCB0eXBlKSkge1xyXG4gICAgICAgIGV4dHJhY3RlZFtrZXldID0gaW5zdGFuY2UuY3R4W2tleV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBleHRyYWN0ZWQ7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGlzS2V5T2ZUeXBlKENvbXAsIGtleSwgdHlwZSkge1xyXG4gICAgY29uc3Qgb3B0cyA9IENvbXBbdHlwZV07XHJcbiAgICBpZiAoaXNBcnJheShvcHRzKSAmJiBvcHRzLmluY2x1ZGVzKGtleSkgfHwgaXNPYmplY3Qob3B0cykgJiYga2V5IGluIG9wdHMpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoQ29tcC5leHRlbmRzICYmIGlzS2V5T2ZUeXBlKENvbXAuZXh0ZW5kcywga2V5LCB0eXBlKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChDb21wLm1peGlucyAmJiBDb21wLm1peGlucy5zb21lKChtKSA9PiBpc0tleU9mVHlwZShtLCBrZXksIHR5cGUpKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gZ2VuUmVmRmxhZyh2KSB7XHJcbiAgICBpZiAoaXNTaGFsbG93KHYpKSB7XHJcbiAgICAgIHJldHVybiBgU2hhbGxvd1JlZmA7XHJcbiAgICB9XHJcbiAgICBpZiAodi5lZmZlY3QpIHtcclxuICAgICAgcmV0dXJuIGBDb21wdXRlZFJlZmA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYFJlZmA7XHJcbiAgfVxyXG4gIGlmICh3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzKSB7XHJcbiAgICB3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzLnB1c2goZm9ybWF0dGVyKTtcclxuICB9IGVsc2Uge1xyXG4gICAgd2luZG93LmRldnRvb2xzRm9ybWF0dGVycyA9IFtmb3JtYXR0ZXJdO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gd2l0aE1lbW8obWVtbywgcmVuZGVyLCBjYWNoZSwgaW5kZXgpIHtcclxuICBjb25zdCBjYWNoZWQgPSBjYWNoZVtpbmRleF07XHJcbiAgaWYgKGNhY2hlZCAmJiBpc01lbW9TYW1lKGNhY2hlZCwgbWVtbykpIHtcclxuICAgIHJldHVybiBjYWNoZWQ7XHJcbiAgfVxyXG4gIGNvbnN0IHJldCA9IHJlbmRlcigpO1xyXG4gIHJldC5tZW1vID0gbWVtby5zbGljZSgpO1xyXG4gIHJldC5jYWNoZUluZGV4ID0gaW5kZXg7XHJcbiAgcmV0dXJuIGNhY2hlW2luZGV4XSA9IHJldDtcclxufVxyXG5mdW5jdGlvbiBpc01lbW9TYW1lKGNhY2hlZCwgbWVtbykge1xyXG4gIGNvbnN0IHByZXYgPSBjYWNoZWQubWVtbztcclxuICBpZiAocHJldi5sZW5ndGggIT0gbWVtby5sZW5ndGgpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoaGFzQ2hhbmdlZChwcmV2W2ldLCBtZW1vW2ldKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmIGN1cnJlbnRCbG9jaykge1xyXG4gICAgY3VycmVudEJsb2NrLnB1c2goY2FjaGVkKTtcclxuICB9XHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmNvbnN0IHZlcnNpb24gPSBcIjMuNS4xM1wiO1xyXG5jb25zdCB3YXJuID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHdhcm4kMSA6IE5PT1A7XHJcbmNvbnN0IEVycm9yVHlwZVN0cmluZ3MgPSBFcnJvclR5cGVTdHJpbmdzJDEgO1xyXG5jb25zdCBkZXZ0b29scyA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgdHJ1ZSA/IGRldnRvb2xzJDEgOiB2b2lkIDA7XHJcbmNvbnN0IHNldERldnRvb2xzSG9vayA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgdHJ1ZSA/IHNldERldnRvb2xzSG9vayQxIDogTk9PUDtcclxuY29uc3QgX3NzclV0aWxzID0ge1xyXG4gIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlLFxyXG4gIHNldHVwQ29tcG9uZW50LFxyXG4gIHJlbmRlckNvbXBvbmVudFJvb3QsXHJcbiAgc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlLFxyXG4gIGlzVk5vZGU6IGlzVk5vZGUsXHJcbiAgbm9ybWFsaXplVk5vZGUsXHJcbiAgZ2V0Q29tcG9uZW50UHVibGljSW5zdGFuY2UsXHJcbiAgZW5zdXJlVmFsaWRWTm9kZSxcclxuICBwdXNoV2FybmluZ0NvbnRleHQsXHJcbiAgcG9wV2FybmluZ0NvbnRleHRcclxufTtcclxuY29uc3Qgc3NyVXRpbHMgPSBfc3NyVXRpbHMgO1xyXG5jb25zdCByZXNvbHZlRmlsdGVyID0gbnVsbDtcclxuY29uc3QgY29tcGF0VXRpbHMgPSBudWxsO1xyXG5jb25zdCBEZXByZWNhdGlvblR5cGVzID0gbnVsbDtcclxuXHJcbmV4cG9ydCB7IEJhc2VUcmFuc2l0aW9uLCBCYXNlVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycywgQ29tbWVudCwgRGVwcmVjYXRpb25UeXBlcywgRXJyb3JDb2RlcywgRXJyb3JUeXBlU3RyaW5ncywgRnJhZ21lbnQsIEtlZXBBbGl2ZSwgU3RhdGljLCBTdXNwZW5zZSwgVGVsZXBvcnQsIFRleHQsIGFzc2VydE51bWJlciwgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcsIGNhbGxXaXRoRXJyb3JIYW5kbGluZywgY2xvbmVWTm9kZSwgY29tcGF0VXRpbHMsIGNvbXB1dGVkLCBjcmVhdGVCbG9jaywgY3JlYXRlQ29tbWVudFZOb2RlLCBjcmVhdGVFbGVtZW50QmxvY2ssIGNyZWF0ZUJhc2VWTm9kZSBhcyBjcmVhdGVFbGVtZW50Vk5vZGUsIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyLCBjcmVhdGVQcm9wc1Jlc3RQcm94eSwgY3JlYXRlUmVuZGVyZXIsIGNyZWF0ZVNsb3RzLCBjcmVhdGVTdGF0aWNWTm9kZSwgY3JlYXRlVGV4dFZOb2RlLCBjcmVhdGVWTm9kZSwgZGVmaW5lQXN5bmNDb21wb25lbnQsIGRlZmluZUNvbXBvbmVudCwgZGVmaW5lRW1pdHMsIGRlZmluZUV4cG9zZSwgZGVmaW5lTW9kZWwsIGRlZmluZU9wdGlvbnMsIGRlZmluZVByb3BzLCBkZWZpbmVTbG90cywgZGV2dG9vbHMsIGdldEN1cnJlbnRJbnN0YW5jZSwgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuLCBndWFyZFJlYWN0aXZlUHJvcHMsIGgsIGhhbmRsZUVycm9yLCBoYXNJbmplY3Rpb25Db250ZXh0LCBoeWRyYXRlT25JZGxlLCBoeWRyYXRlT25JbnRlcmFjdGlvbiwgaHlkcmF0ZU9uTWVkaWFRdWVyeSwgaHlkcmF0ZU9uVmlzaWJsZSwgaW5pdEN1c3RvbUZvcm1hdHRlciwgaW5qZWN0LCBpc01lbW9TYW1lLCBpc1J1bnRpbWVPbmx5LCBpc1ZOb2RlLCBtZXJnZURlZmF1bHRzLCBtZXJnZU1vZGVscywgbWVyZ2VQcm9wcywgbmV4dFRpY2ssIG9uQWN0aXZhdGVkLCBvbkJlZm9yZU1vdW50LCBvbkJlZm9yZVVubW91bnQsIG9uQmVmb3JlVXBkYXRlLCBvbkRlYWN0aXZhdGVkLCBvbkVycm9yQ2FwdHVyZWQsIG9uTW91bnRlZCwgb25SZW5kZXJUcmFja2VkLCBvblJlbmRlclRyaWdnZXJlZCwgb25TZXJ2ZXJQcmVmZXRjaCwgb25Vbm1vdW50ZWQsIG9uVXBkYXRlZCwgb3BlbkJsb2NrLCBwb3BTY29wZUlkLCBwcm92aWRlLCBwdXNoU2NvcGVJZCwgcXVldWVQb3N0Rmx1c2hDYiwgcmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIsIHJlbmRlckxpc3QsIHJlbmRlclNsb3QsIHJlc29sdmVDb21wb25lbnQsIHJlc29sdmVEaXJlY3RpdmUsIHJlc29sdmVEeW5hbWljQ29tcG9uZW50LCByZXNvbHZlRmlsdGVyLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzLCBzZXRCbG9ja1RyYWNraW5nLCBzZXREZXZ0b29sc0hvb2ssIHNldFRyYW5zaXRpb25Ib29rcywgc3NyQ29udGV4dEtleSwgc3NyVXRpbHMsIHRvSGFuZGxlcnMsIHRyYW5zZm9ybVZOb2RlQXJncywgdXNlQXR0cnMsIHVzZUlkLCB1c2VNb2RlbCwgdXNlU1NSQ29udGV4dCwgdXNlU2xvdHMsIHVzZVRlbXBsYXRlUmVmLCB1c2VUcmFuc2l0aW9uU3RhdGUsIHZlcnNpb24sIHdhcm4sIHdhdGNoLCB3YXRjaEVmZmVjdCwgd2F0Y2hQb3N0RWZmZWN0LCB3YXRjaFN5bmNFZmZlY3QsIHdpdGhBc3luY0NvbnRleHQsIHdpdGhDdHgsIHdpdGhEZWZhdWx0cywgd2l0aERpcmVjdGl2ZXMsIHdpdGhNZW1vLCB3aXRoU2NvcGVJZCB9O1xyXG4iLCIvKipcclxuKiBAdnVlL3J1bnRpbWUtZG9tIHYzLjUuMTNcclxuKiAoYykgMjAxOC1wcmVzZW50IFl1eGkgKEV2YW4pIFlvdSBhbmQgVnVlIGNvbnRyaWJ1dG9yc1xyXG4qIEBsaWNlbnNlIE1JVFxyXG4qKi9cclxuaW1wb3J0IHsgd2FybiwgaCwgQmFzZVRyYW5zaXRpb24sIGFzc2VydE51bWJlciwgQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsIGdldEN1cnJlbnRJbnN0YW5jZSwgb25CZWZvcmVVcGRhdGUsIHF1ZXVlUG9zdEZsdXNoQ2IsIG9uTW91bnRlZCwgd2F0Y2gsIG9uVW5tb3VudGVkLCBGcmFnbWVudCwgU3RhdGljLCBjYW1lbGl6ZSwgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcsIGRlZmluZUNvbXBvbmVudCwgbmV4dFRpY2ssIHVucmVmLCBjcmVhdGVWTm9kZSwgdXNlVHJhbnNpdGlvblN0YXRlLCBvblVwZGF0ZWQsIHRvUmF3LCBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4sIHNldFRyYW5zaXRpb25Ib29rcywgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcywgVGV4dCwgaXNSdW50aW1lT25seSwgY3JlYXRlUmVuZGVyZXIsIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyIH0gZnJvbSAnQHZ1ZS9ydW50aW1lLWNvcmUnO1xyXG5leHBvcnQgKiBmcm9tICdAdnVlL3J1bnRpbWUtY29yZSc7XHJcbmltcG9ydCB7IGV4dGVuZCwgaXNPYmplY3QsIHRvTnVtYmVyLCBpc0FycmF5LCBOT09QLCBpc1N0cmluZywgaHlwaGVuYXRlLCBjYXBpdGFsaXplLCBpbmNsdWRlQm9vbGVhbkF0dHIsIGlzU3ltYm9sLCBpc1NwZWNpYWxCb29sZWFuQXR0ciwgaXNGdW5jdGlvbiwgaXNPbiwgaXNNb2RlbExpc3RlbmVyLCBjYW1lbGl6ZSBhcyBjYW1lbGl6ZSQxLCBpc1BsYWluT2JqZWN0LCBoYXNPd24sIEVNUFRZX09CSiwgbG9vc2VUb051bWJlciwgbG9vc2VJbmRleE9mLCBpc1NldCwgbG9vc2VFcXVhbCwgaW52b2tlQXJyYXlGbnMsIGlzSFRNTFRhZywgaXNTVkdUYWcsIGlzTWF0aE1MVGFnIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xyXG5cclxubGV0IHBvbGljeSA9IHZvaWQgMDtcclxuY29uc3QgdHQgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy50cnVzdGVkVHlwZXM7XHJcbmlmICh0dCkge1xyXG4gIHRyeSB7XHJcbiAgICBwb2xpY3kgPSAvKiBAX19QVVJFX18gKi8gdHQuY3JlYXRlUG9saWN5KFwidnVlXCIsIHtcclxuICAgICAgY3JlYXRlSFRNTDogKHZhbCkgPT4gdmFsXHJcbiAgICB9KTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYEVycm9yIGNyZWF0aW5nIHRydXN0ZWQgdHlwZXMgcG9saWN5OiAke2V9YCk7XHJcbiAgfVxyXG59XHJcbmNvbnN0IHVuc2FmZVRvVHJ1c3RlZEhUTUwgPSBwb2xpY3kgPyAodmFsKSA9PiBwb2xpY3kuY3JlYXRlSFRNTCh2YWwpIDogKHZhbCkgPT4gdmFsO1xyXG5jb25zdCBzdmdOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcclxuY29uc3QgbWF0aG1sTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIjtcclxuY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiBudWxsO1xyXG5jb25zdCB0ZW1wbGF0ZUNvbnRhaW5lciA9IGRvYyAmJiAvKiBAX19QVVJFX18gKi8gZG9jLmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcclxuY29uc3Qgbm9kZU9wcyA9IHtcclxuICBpbnNlcnQ6IChjaGlsZCwgcGFyZW50LCBhbmNob3IpID0+IHtcclxuICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIGFuY2hvciB8fCBudWxsKTtcclxuICB9LFxyXG4gIHJlbW92ZTogKGNoaWxkKSA9PiB7XHJcbiAgICBjb25zdCBwYXJlbnQgPSBjaGlsZC5wYXJlbnROb2RlO1xyXG4gICAgaWYgKHBhcmVudCkge1xyXG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgY3JlYXRlRWxlbWVudDogKHRhZywgbmFtZXNwYWNlLCBpcywgcHJvcHMpID0+IHtcclxuICAgIGNvbnN0IGVsID0gbmFtZXNwYWNlID09PSBcInN2Z1wiID8gZG9jLmNyZWF0ZUVsZW1lbnROUyhzdmdOUywgdGFnKSA6IG5hbWVzcGFjZSA9PT0gXCJtYXRobWxcIiA/IGRvYy5jcmVhdGVFbGVtZW50TlMobWF0aG1sTlMsIHRhZykgOiBpcyA/IGRvYy5jcmVhdGVFbGVtZW50KHRhZywgeyBpcyB9KSA6IGRvYy5jcmVhdGVFbGVtZW50KHRhZyk7XHJcbiAgICBpZiAodGFnID09PSBcInNlbGVjdFwiICYmIHByb3BzICYmIHByb3BzLm11bHRpcGxlICE9IG51bGwpIHtcclxuICAgICAgZWwuc2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIiwgcHJvcHMubXVsdGlwbGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVsO1xyXG4gIH0sXHJcbiAgY3JlYXRlVGV4dDogKHRleHQpID0+IGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSxcclxuICBjcmVhdGVDb21tZW50OiAodGV4dCkgPT4gZG9jLmNyZWF0ZUNvbW1lbnQodGV4dCksXHJcbiAgc2V0VGV4dDogKG5vZGUsIHRleHQpID0+IHtcclxuICAgIG5vZGUubm9kZVZhbHVlID0gdGV4dDtcclxuICB9LFxyXG4gIHNldEVsZW1lbnRUZXh0OiAoZWwsIHRleHQpID0+IHtcclxuICAgIGVsLnRleHRDb250ZW50ID0gdGV4dDtcclxuICB9LFxyXG4gIHBhcmVudE5vZGU6IChub2RlKSA9PiBub2RlLnBhcmVudE5vZGUsXHJcbiAgbmV4dFNpYmxpbmc6IChub2RlKSA9PiBub2RlLm5leHRTaWJsaW5nLFxyXG4gIHF1ZXJ5U2VsZWN0b3I6IChzZWxlY3RvcikgPT4gZG9jLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpLFxyXG4gIHNldFNjb3BlSWQoZWwsIGlkKSB7XHJcbiAgICBlbC5zZXRBdHRyaWJ1dGUoaWQsIFwiXCIpO1xyXG4gIH0sXHJcbiAgLy8gX19VTlNBRkVfX1xyXG4gIC8vIFJlYXNvbjogaW5uZXJIVE1MLlxyXG4gIC8vIFN0YXRpYyBjb250ZW50IGhlcmUgY2FuIG9ubHkgY29tZSBmcm9tIGNvbXBpbGVkIHRlbXBsYXRlcy5cclxuICAvLyBBcyBsb25nIGFzIHRoZSB1c2VyIG9ubHkgdXNlcyB0cnVzdGVkIHRlbXBsYXRlcywgdGhpcyBpcyBzYWZlLlxyXG4gIGluc2VydFN0YXRpY0NvbnRlbnQoY29udGVudCwgcGFyZW50LCBhbmNob3IsIG5hbWVzcGFjZSwgc3RhcnQsIGVuZCkge1xyXG4gICAgY29uc3QgYmVmb3JlID0gYW5jaG9yID8gYW5jaG9yLnByZXZpb3VzU2libGluZyA6IHBhcmVudC5sYXN0Q2hpbGQ7XHJcbiAgICBpZiAoc3RhcnQgJiYgKHN0YXJ0ID09PSBlbmQgfHwgc3RhcnQubmV4dFNpYmxpbmcpKSB7XHJcbiAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShzdGFydC5jbG9uZU5vZGUodHJ1ZSksIGFuY2hvcik7XHJcbiAgICAgICAgaWYgKHN0YXJ0ID09PSBlbmQgfHwgIShzdGFydCA9IHN0YXJ0Lm5leHRTaWJsaW5nKSkgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRlbXBsYXRlQ29udGFpbmVyLmlubmVySFRNTCA9IHVuc2FmZVRvVHJ1c3RlZEhUTUwoXHJcbiAgICAgICAgbmFtZXNwYWNlID09PSBcInN2Z1wiID8gYDxzdmc+JHtjb250ZW50fTwvc3ZnPmAgOiBuYW1lc3BhY2UgPT09IFwibWF0aG1sXCIgPyBgPG1hdGg+JHtjb250ZW50fTwvbWF0aD5gIDogY29udGVudFxyXG4gICAgICApO1xyXG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRlbXBsYXRlQ29udGFpbmVyLmNvbnRlbnQ7XHJcbiAgICAgIGlmIChuYW1lc3BhY2UgPT09IFwic3ZnXCIgfHwgbmFtZXNwYWNlID09PSBcIm1hdGhtbFwiKSB7XHJcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IHRlbXBsYXRlLmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgd2hpbGUgKHdyYXBwZXIuZmlyc3RDaGlsZCkge1xyXG4gICAgICAgICAgdGVtcGxhdGUuYXBwZW5kQ2hpbGQod3JhcHBlci5maXJzdENoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGVtcGxhdGUucmVtb3ZlQ2hpbGQod3JhcHBlcik7XHJcbiAgICAgIH1cclxuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0ZW1wbGF0ZSwgYW5jaG9yKTtcclxuICAgIH1cclxuICAgIHJldHVybiBbXHJcbiAgICAgIC8vIGZpcnN0XHJcbiAgICAgIGJlZm9yZSA/IGJlZm9yZS5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkLFxyXG4gICAgICAvLyBsYXN0XHJcbiAgICAgIGFuY2hvciA/IGFuY2hvci5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnQubGFzdENoaWxkXHJcbiAgICBdO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IFRSQU5TSVRJT04gPSBcInRyYW5zaXRpb25cIjtcclxuY29uc3QgQU5JTUFUSU9OID0gXCJhbmltYXRpb25cIjtcclxuY29uc3QgdnRjS2V5ID0gU3ltYm9sKFwiX3Z0Y1wiKTtcclxuY29uc3QgRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyA9IHtcclxuICBuYW1lOiBTdHJpbmcsXHJcbiAgdHlwZTogU3RyaW5nLFxyXG4gIGNzczoge1xyXG4gICAgdHlwZTogQm9vbGVhbixcclxuICAgIGRlZmF1bHQ6IHRydWVcclxuICB9LFxyXG4gIGR1cmF0aW9uOiBbU3RyaW5nLCBOdW1iZXIsIE9iamVjdF0sXHJcbiAgZW50ZXJGcm9tQ2xhc3M6IFN0cmluZyxcclxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXHJcbiAgYXBwZWFyRnJvbUNsYXNzOiBTdHJpbmcsXHJcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcclxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXHJcbiAgbGVhdmVGcm9tQ2xhc3M6IFN0cmluZyxcclxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmdcclxufTtcclxuY29uc3QgVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyA9IC8qIEBfX1BVUkVfXyAqLyBleHRlbmQoXHJcbiAge30sXHJcbiAgQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsXHJcbiAgRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9yc1xyXG4pO1xyXG5jb25zdCBkZWNvcmF0ZSQxID0gKHQpID0+IHtcclxuICB0LmRpc3BsYXlOYW1lID0gXCJUcmFuc2l0aW9uXCI7XHJcbiAgdC5wcm9wcyA9IFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnM7XHJcbiAgcmV0dXJuIHQ7XHJcbn07XHJcbmNvbnN0IFRyYW5zaXRpb24gPSAvKiBAX19QVVJFX18gKi8gZGVjb3JhdGUkMShcclxuICAocHJvcHMsIHsgc2xvdHMgfSkgPT4gaChCYXNlVHJhbnNpdGlvbiwgcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhwcm9wcyksIHNsb3RzKVxyXG4pO1xyXG5jb25zdCBjYWxsSG9vayA9IChob29rLCBhcmdzID0gW10pID0+IHtcclxuICBpZiAoaXNBcnJheShob29rKSkge1xyXG4gICAgaG9vay5mb3JFYWNoKChoMikgPT4gaDIoLi4uYXJncykpO1xyXG4gIH0gZWxzZSBpZiAoaG9vaykge1xyXG4gICAgaG9vayguLi5hcmdzKTtcclxuICB9XHJcbn07XHJcbmNvbnN0IGhhc0V4cGxpY2l0Q2FsbGJhY2sgPSAoaG9vaykgPT4ge1xyXG4gIHJldHVybiBob29rID8gaXNBcnJheShob29rKSA/IGhvb2suc29tZSgoaDIpID0+IGgyLmxlbmd0aCA+IDEpIDogaG9vay5sZW5ndGggPiAxIDogZmFsc2U7XHJcbn07XHJcbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocmF3UHJvcHMpIHtcclxuICBjb25zdCBiYXNlUHJvcHMgPSB7fTtcclxuICBmb3IgKGNvbnN0IGtleSBpbiByYXdQcm9wcykge1xyXG4gICAgaWYgKCEoa2V5IGluIERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMpKSB7XHJcbiAgICAgIGJhc2VQcm9wc1trZXldID0gcmF3UHJvcHNba2V5XTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKHJhd1Byb3BzLmNzcyA9PT0gZmFsc2UpIHtcclxuICAgIHJldHVybiBiYXNlUHJvcHM7XHJcbiAgfVxyXG4gIGNvbnN0IHtcclxuICAgIG5hbWUgPSBcInZcIixcclxuICAgIHR5cGUsXHJcbiAgICBkdXJhdGlvbixcclxuICAgIGVudGVyRnJvbUNsYXNzID0gYCR7bmFtZX0tZW50ZXItZnJvbWAsXHJcbiAgICBlbnRlckFjdGl2ZUNsYXNzID0gYCR7bmFtZX0tZW50ZXItYWN0aXZlYCxcclxuICAgIGVudGVyVG9DbGFzcyA9IGAke25hbWV9LWVudGVyLXRvYCxcclxuICAgIGFwcGVhckZyb21DbGFzcyA9IGVudGVyRnJvbUNsYXNzLFxyXG4gICAgYXBwZWFyQWN0aXZlQ2xhc3MgPSBlbnRlckFjdGl2ZUNsYXNzLFxyXG4gICAgYXBwZWFyVG9DbGFzcyA9IGVudGVyVG9DbGFzcyxcclxuICAgIGxlYXZlRnJvbUNsYXNzID0gYCR7bmFtZX0tbGVhdmUtZnJvbWAsXHJcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzID0gYCR7bmFtZX0tbGVhdmUtYWN0aXZlYCxcclxuICAgIGxlYXZlVG9DbGFzcyA9IGAke25hbWV9LWxlYXZlLXRvYFxyXG4gIH0gPSByYXdQcm9wcztcclxuICBjb25zdCBkdXJhdGlvbnMgPSBub3JtYWxpemVEdXJhdGlvbihkdXJhdGlvbik7XHJcbiAgY29uc3QgZW50ZXJEdXJhdGlvbiA9IGR1cmF0aW9ucyAmJiBkdXJhdGlvbnNbMF07XHJcbiAgY29uc3QgbGVhdmVEdXJhdGlvbiA9IGR1cmF0aW9ucyAmJiBkdXJhdGlvbnNbMV07XHJcbiAgY29uc3Qge1xyXG4gICAgb25CZWZvcmVFbnRlcixcclxuICAgIG9uRW50ZXIsXHJcbiAgICBvbkVudGVyQ2FuY2VsbGVkLFxyXG4gICAgb25MZWF2ZSxcclxuICAgIG9uTGVhdmVDYW5jZWxsZWQsXHJcbiAgICBvbkJlZm9yZUFwcGVhciA9IG9uQmVmb3JlRW50ZXIsXHJcbiAgICBvbkFwcGVhciA9IG9uRW50ZXIsXHJcbiAgICBvbkFwcGVhckNhbmNlbGxlZCA9IG9uRW50ZXJDYW5jZWxsZWRcclxuICB9ID0gYmFzZVByb3BzO1xyXG4gIGNvbnN0IGZpbmlzaEVudGVyID0gKGVsLCBpc0FwcGVhciwgZG9uZSwgaXNDYW5jZWxsZWQpID0+IHtcclxuICAgIGVsLl9lbnRlckNhbmNlbGxlZCA9IGlzQ2FuY2VsbGVkO1xyXG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xyXG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhckFjdGl2ZUNsYXNzIDogZW50ZXJBY3RpdmVDbGFzcyk7XHJcbiAgICBkb25lICYmIGRvbmUoKTtcclxuICB9O1xyXG4gIGNvbnN0IGZpbmlzaExlYXZlID0gKGVsLCBkb25lKSA9PiB7XHJcbiAgICBlbC5faXNMZWF2aW5nID0gZmFsc2U7XHJcbiAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcclxuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcclxuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XHJcbiAgICBkb25lICYmIGRvbmUoKTtcclxuICB9O1xyXG4gIGNvbnN0IG1ha2VFbnRlckhvb2sgPSAoaXNBcHBlYXIpID0+IHtcclxuICAgIHJldHVybiAoZWwsIGRvbmUpID0+IHtcclxuICAgICAgY29uc3QgaG9vayA9IGlzQXBwZWFyID8gb25BcHBlYXIgOiBvbkVudGVyO1xyXG4gICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoRW50ZXIoZWwsIGlzQXBwZWFyLCBkb25lKTtcclxuICAgICAgY2FsbEhvb2soaG9vaywgW2VsLCByZXNvbHZlXSk7XHJcbiAgICAgIG5leHRGcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhckZyb21DbGFzcyA6IGVudGVyRnJvbUNsYXNzKTtcclxuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyVG9DbGFzcyA6IGVudGVyVG9DbGFzcyk7XHJcbiAgICAgICAgaWYgKCFoYXNFeHBsaWNpdENhbGxiYWNrKGhvb2spKSB7XHJcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGVudGVyRHVyYXRpb24sIHJlc29sdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gIH07XHJcbiAgcmV0dXJuIGV4dGVuZChiYXNlUHJvcHMsIHtcclxuICAgIG9uQmVmb3JlRW50ZXIoZWwpIHtcclxuICAgICAgY2FsbEhvb2sob25CZWZvcmVFbnRlciwgW2VsXSk7XHJcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgZW50ZXJGcm9tQ2xhc3MpO1xyXG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGVudGVyQWN0aXZlQ2xhc3MpO1xyXG4gICAgfSxcclxuICAgIG9uQmVmb3JlQXBwZWFyKGVsKSB7XHJcbiAgICAgIGNhbGxIb29rKG9uQmVmb3JlQXBwZWFyLCBbZWxdKTtcclxuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhcHBlYXJGcm9tQ2xhc3MpO1xyXG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFwcGVhckFjdGl2ZUNsYXNzKTtcclxuICAgIH0sXHJcbiAgICBvbkVudGVyOiBtYWtlRW50ZXJIb29rKGZhbHNlKSxcclxuICAgIG9uQXBwZWFyOiBtYWtlRW50ZXJIb29rKHRydWUpLFxyXG4gICAgb25MZWF2ZShlbCwgZG9uZSkge1xyXG4gICAgICBlbC5faXNMZWF2aW5nID0gdHJ1ZTtcclxuICAgICAgY29uc3QgcmVzb2x2ZSA9ICgpID0+IGZpbmlzaExlYXZlKGVsLCBkb25lKTtcclxuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XHJcbiAgICAgIGlmICghZWwuX2VudGVyQ2FuY2VsbGVkKSB7XHJcbiAgICAgICAgZm9yY2VSZWZsb3coKTtcclxuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XHJcbiAgICAgICAgZm9yY2VSZWZsb3coKTtcclxuICAgICAgfVxyXG4gICAgICBuZXh0RnJhbWUoKCkgPT4ge1xyXG4gICAgICAgIGlmICghZWwuX2lzTGVhdmluZykge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcclxuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XHJcbiAgICAgICAgaWYgKCFoYXNFeHBsaWNpdENhbGxiYWNrKG9uTGVhdmUpKSB7XHJcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGxlYXZlRHVyYXRpb24sIHJlc29sdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIGNhbGxIb29rKG9uTGVhdmUsIFtlbCwgcmVzb2x2ZV0pO1xyXG4gICAgfSxcclxuICAgIG9uRW50ZXJDYW5jZWxsZWQoZWwpIHtcclxuICAgICAgZmluaXNoRW50ZXIoZWwsIGZhbHNlLCB2b2lkIDAsIHRydWUpO1xyXG4gICAgICBjYWxsSG9vayhvbkVudGVyQ2FuY2VsbGVkLCBbZWxdKTtcclxuICAgIH0sXHJcbiAgICBvbkFwcGVhckNhbmNlbGxlZChlbCkge1xyXG4gICAgICBmaW5pc2hFbnRlcihlbCwgdHJ1ZSwgdm9pZCAwLCB0cnVlKTtcclxuICAgICAgY2FsbEhvb2sob25BcHBlYXJDYW5jZWxsZWQsIFtlbF0pO1xyXG4gICAgfSxcclxuICAgIG9uTGVhdmVDYW5jZWxsZWQoZWwpIHtcclxuICAgICAgZmluaXNoTGVhdmUoZWwpO1xyXG4gICAgICBjYWxsSG9vayhvbkxlYXZlQ2FuY2VsbGVkLCBbZWxdKTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVEdXJhdGlvbihkdXJhdGlvbikge1xyXG4gIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGR1cmF0aW9uKSkge1xyXG4gICAgcmV0dXJuIFtOdW1iZXJPZihkdXJhdGlvbi5lbnRlciksIE51bWJlck9mKGR1cmF0aW9uLmxlYXZlKV07XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnN0IG4gPSBOdW1iZXJPZihkdXJhdGlvbik7XHJcbiAgICByZXR1cm4gW24sIG5dO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBOdW1iZXJPZih2YWwpIHtcclxuICBjb25zdCByZXMgPSB0b051bWJlcih2YWwpO1xyXG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICBhc3NlcnROdW1iZXIocmVzLCBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBkdXJhdGlvblwiKTtcclxuICB9XHJcbiAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGNscykge1xyXG4gIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goKGMpID0+IGMgJiYgZWwuY2xhc3NMaXN0LmFkZChjKSk7XHJcbiAgKGVsW3Z0Y0tleV0gfHwgKGVsW3Z0Y0tleV0gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKSkuYWRkKGNscyk7XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcclxuICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKChjKSA9PiBjICYmIGVsLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xyXG4gIGNvbnN0IF92dGMgPSBlbFt2dGNLZXldO1xyXG4gIGlmIChfdnRjKSB7XHJcbiAgICBfdnRjLmRlbGV0ZShjbHMpO1xyXG4gICAgaWYgKCFfdnRjLnNpemUpIHtcclxuICAgICAgZWxbdnRjS2V5XSA9IHZvaWQgMDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZnVuY3Rpb24gbmV4dEZyYW1lKGNiKSB7XHJcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYik7XHJcbiAgfSk7XHJcbn1cclxubGV0IGVuZElkID0gMDtcclxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzKGVsLCBleHBlY3RlZFR5cGUsIGV4cGxpY2l0VGltZW91dCwgcmVzb2x2ZSkge1xyXG4gIGNvbnN0IGlkID0gZWwuX2VuZElkID0gKytlbmRJZDtcclxuICBjb25zdCByZXNvbHZlSWZOb3RTdGFsZSA9ICgpID0+IHtcclxuICAgIGlmIChpZCA9PT0gZWwuX2VuZElkKSB7XHJcbiAgICAgIHJlc29sdmUoKTtcclxuICAgIH1cclxuICB9O1xyXG4gIGlmIChleHBsaWNpdFRpbWVvdXQgIT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZUlmTm90U3RhbGUsIGV4cGxpY2l0VGltZW91dCk7XHJcbiAgfVxyXG4gIGNvbnN0IHsgdHlwZSwgdGltZW91dCwgcHJvcENvdW50IH0gPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcclxuICBpZiAoIXR5cGUpIHtcclxuICAgIHJldHVybiByZXNvbHZlKCk7XHJcbiAgfVxyXG4gIGNvbnN0IGVuZEV2ZW50ID0gdHlwZSArIFwiZW5kXCI7XHJcbiAgbGV0IGVuZGVkID0gMDtcclxuICBjb25zdCBlbmQgPSAoKSA9PiB7XHJcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGVuZEV2ZW50LCBvbkVuZCk7XHJcbiAgICByZXNvbHZlSWZOb3RTdGFsZSgpO1xyXG4gIH07XHJcbiAgY29uc3Qgb25FbmQgPSAoZSkgPT4ge1xyXG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCAmJiArK2VuZGVkID49IHByb3BDb3VudCkge1xyXG4gICAgICBlbmQoKTtcclxuICAgIH1cclxuICB9O1xyXG4gIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XHJcbiAgICAgIGVuZCgpO1xyXG4gICAgfVxyXG4gIH0sIHRpbWVvdXQgKyAxKTtcclxuICBlbC5hZGRFdmVudExpc3RlbmVyKGVuZEV2ZW50LCBvbkVuZCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSkge1xyXG4gIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcclxuICBjb25zdCBnZXRTdHlsZVByb3BlcnRpZXMgPSAoa2V5KSA9PiAoc3R5bGVzW2tleV0gfHwgXCJcIikuc3BsaXQoXCIsIFwiKTtcclxuICBjb25zdCB0cmFuc2l0aW9uRGVsYXlzID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke1RSQU5TSVRJT059RGVsYXlgKTtcclxuICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb25zID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke1RSQU5TSVRJT059RHVyYXRpb25gKTtcclxuICBjb25zdCB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XHJcbiAgY29uc3QgYW5pbWF0aW9uRGVsYXlzID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke0FOSU1BVElPTn1EZWxheWApO1xyXG4gIGNvbnN0IGFuaW1hdGlvbkR1cmF0aW9ucyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtBTklNQVRJT059RHVyYXRpb25gKTtcclxuICBjb25zdCBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XHJcbiAgbGV0IHR5cGUgPSBudWxsO1xyXG4gIGxldCB0aW1lb3V0ID0gMDtcclxuICBsZXQgcHJvcENvdW50ID0gMDtcclxuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XHJcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XHJcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xyXG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XHJcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcclxuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xyXG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xyXG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcclxuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcclxuICAgIHR5cGUgPSB0aW1lb3V0ID4gMCA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dCA/IFRSQU5TSVRJT04gOiBBTklNQVRJT04gOiBudWxsO1xyXG4gICAgcHJvcENvdW50ID0gdHlwZSA/IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aCA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGggOiAwO1xyXG4gIH1cclxuICBjb25zdCBoYXNUcmFuc2Zvcm0gPSB0eXBlID09PSBUUkFOU0lUSU9OICYmIC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS8udGVzdChcclxuICAgIGdldFN0eWxlUHJvcGVydGllcyhgJHtUUkFOU0lUSU9OfVByb3BlcnR5YCkudG9TdHJpbmcoKVxyXG4gICk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGUsXHJcbiAgICB0aW1lb3V0LFxyXG4gICAgcHJvcENvdW50LFxyXG4gICAgaGFzVHJhbnNmb3JtXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRUaW1lb3V0KGRlbGF5cywgZHVyYXRpb25zKSB7XHJcbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XHJcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XHJcbiAgfVxyXG4gIHJldHVybiBNYXRoLm1heCguLi5kdXJhdGlvbnMubWFwKChkLCBpKSA9PiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pKSk7XHJcbn1cclxuZnVuY3Rpb24gdG9NcyhzKSB7XHJcbiAgaWYgKHMgPT09IFwiYXV0b1wiKSByZXR1cm4gMDtcclxuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpLnJlcGxhY2UoXCIsXCIsIFwiLlwiKSkgKiAxZTM7XHJcbn1cclxuZnVuY3Rpb24gZm9yY2VSZWZsb3coKSB7XHJcbiAgcmV0dXJuIGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXRjaENsYXNzKGVsLCB2YWx1ZSwgaXNTVkcpIHtcclxuICBjb25zdCB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsW3Z0Y0tleV07XHJcbiAgaWYgKHRyYW5zaXRpb25DbGFzc2VzKSB7XHJcbiAgICB2YWx1ZSA9ICh2YWx1ZSA/IFt2YWx1ZSwgLi4udHJhbnNpdGlvbkNsYXNzZXNdIDogWy4uLnRyYW5zaXRpb25DbGFzc2VzXSkuam9pbihcIiBcIik7XHJcbiAgfVxyXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcclxuICB9IGVsc2UgaWYgKGlzU1ZHKSB7XHJcbiAgICBlbC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB2YWx1ZSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGVsLmNsYXNzTmFtZSA9IHZhbHVlO1xyXG4gIH1cclxufVxyXG5cclxuY29uc3QgdlNob3dPcmlnaW5hbERpc3BsYXkgPSBTeW1ib2woXCJfdm9kXCIpO1xyXG5jb25zdCB2U2hvd0hpZGRlbiA9IFN5bWJvbChcIl92c2hcIik7XHJcbmNvbnN0IHZTaG93ID0ge1xyXG4gIGJlZm9yZU1vdW50KGVsLCB7IHZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XHJcbiAgICBlbFt2U2hvd09yaWdpbmFsRGlzcGxheV0gPSBlbC5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBlbC5zdHlsZS5kaXNwbGF5O1xyXG4gICAgaWYgKHRyYW5zaXRpb24gJiYgdmFsdWUpIHtcclxuICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgfSxcclxuICBtb3VudGVkKGVsLCB7IHZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XHJcbiAgICBpZiAodHJhbnNpdGlvbiAmJiB2YWx1ZSkge1xyXG4gICAgICB0cmFuc2l0aW9uLmVudGVyKGVsKTtcclxuICAgIH1cclxuICB9LFxyXG4gIHVwZGF0ZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XHJcbiAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpIHJldHVybjtcclxuICAgIGlmICh0cmFuc2l0aW9uKSB7XHJcbiAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xyXG4gICAgICAgIHNldERpc3BsYXkoZWwsIHRydWUpO1xyXG4gICAgICAgIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRyYW5zaXRpb24ubGVhdmUoZWwsICgpID0+IHtcclxuICAgICAgICAgIHNldERpc3BsYXkoZWwsIGZhbHNlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgYmVmb3JlVW5tb3VudChlbCwgeyB2YWx1ZSB9KSB7XHJcbiAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XHJcbiAgfVxyXG59O1xyXG5pZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gIHZTaG93Lm5hbWUgPSBcInNob3dcIjtcclxufVxyXG5mdW5jdGlvbiBzZXREaXNwbGF5KGVsLCB2YWx1ZSkge1xyXG4gIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsW3ZTaG93T3JpZ2luYWxEaXNwbGF5XSA6IFwibm9uZVwiO1xyXG4gIGVsW3ZTaG93SGlkZGVuXSA9ICF2YWx1ZTtcclxufVxyXG5mdW5jdGlvbiBpbml0VlNob3dGb3JTU1IoKSB7XHJcbiAgdlNob3cuZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9KSA9PiB7XHJcbiAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgIHJldHVybiB7IHN0eWxlOiB7IGRpc3BsYXk6IFwibm9uZVwiIH0gfTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG5jb25zdCBDU1NfVkFSX1RFWFQgPSBTeW1ib2woISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IFwiQ1NTX1ZBUl9URVhUXCIgOiBcIlwiKTtcclxuZnVuY3Rpb24gdXNlQ3NzVmFycyhnZXR0ZXIpIHtcclxuICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gIGlmICghaW5zdGFuY2UpIHtcclxuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgdXNlQ3NzVmFycyBpcyBjYWxsZWQgd2l0aG91dCBjdXJyZW50IGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UuYCk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGNvbnN0IHVwZGF0ZVRlbGVwb3J0cyA9IGluc3RhbmNlLnV0ID0gKHZhcnMgPSBnZXR0ZXIoaW5zdGFuY2UucHJveHkpKSA9PiB7XHJcbiAgICBBcnJheS5mcm9tKFxyXG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGBbZGF0YS12LW93bmVyPVwiJHtpbnN0YW5jZS51aWR9XCJdYClcclxuICAgICkuZm9yRWFjaCgobm9kZSkgPT4gc2V0VmFyc09uTm9kZShub2RlLCB2YXJzKSk7XHJcbiAgfTtcclxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgaW5zdGFuY2UuZ2V0Q3NzVmFycyA9ICgpID0+IGdldHRlcihpbnN0YW5jZS5wcm94eSk7XHJcbiAgfVxyXG4gIGNvbnN0IHNldFZhcnMgPSAoKSA9PiB7XHJcbiAgICBjb25zdCB2YXJzID0gZ2V0dGVyKGluc3RhbmNlLnByb3h5KTtcclxuICAgIGlmIChpbnN0YW5jZS5jZSkge1xyXG4gICAgICBzZXRWYXJzT25Ob2RlKGluc3RhbmNlLmNlLCB2YXJzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHNldFZhcnNPblZOb2RlKGluc3RhbmNlLnN1YlRyZWUsIHZhcnMpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlVGVsZXBvcnRzKHZhcnMpO1xyXG4gIH07XHJcbiAgb25CZWZvcmVVcGRhdGUoKCkgPT4ge1xyXG4gICAgcXVldWVQb3N0Rmx1c2hDYihzZXRWYXJzKTtcclxuICB9KTtcclxuICBvbk1vdW50ZWQoKCkgPT4ge1xyXG4gICAgd2F0Y2goc2V0VmFycywgTk9PUCwgeyBmbHVzaDogXCJwb3N0XCIgfSk7XHJcbiAgICBjb25zdCBvYiA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHNldFZhcnMpO1xyXG4gICAgb2Iub2JzZXJ2ZShpbnN0YW5jZS5zdWJUcmVlLmVsLnBhcmVudE5vZGUsIHsgY2hpbGRMaXN0OiB0cnVlIH0pO1xyXG4gICAgb25Vbm1vdW50ZWQoKCkgPT4gb2IuZGlzY29ubmVjdCgpKTtcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBzZXRWYXJzT25WTm9kZSh2bm9kZSwgdmFycykge1xyXG4gIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjgpIHtcclxuICAgIGNvbnN0IHN1c3BlbnNlID0gdm5vZGUuc3VzcGVuc2U7XHJcbiAgICB2bm9kZSA9IHN1c3BlbnNlLmFjdGl2ZUJyYW5jaDtcclxuICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmICFzdXNwZW5zZS5pc0h5ZHJhdGluZykge1xyXG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goKCkgPT4ge1xyXG4gICAgICAgIHNldFZhcnNPblZOb2RlKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgdmFycyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuICB3aGlsZSAodm5vZGUuY29tcG9uZW50KSB7XHJcbiAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudC5zdWJUcmVlO1xyXG4gIH1cclxuICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMSAmJiB2bm9kZS5lbCkge1xyXG4gICAgc2V0VmFyc09uTm9kZSh2bm9kZS5lbCwgdmFycyk7XHJcbiAgfSBlbHNlIGlmICh2bm9kZS50eXBlID09PSBGcmFnbWVudCkge1xyXG4gICAgdm5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoYykgPT4gc2V0VmFyc09uVk5vZGUoYywgdmFycykpO1xyXG4gIH0gZWxzZSBpZiAodm5vZGUudHlwZSA9PT0gU3RhdGljKSB7XHJcbiAgICBsZXQgeyBlbCwgYW5jaG9yIH0gPSB2bm9kZTtcclxuICAgIHdoaWxlIChlbCkge1xyXG4gICAgICBzZXRWYXJzT25Ob2RlKGVsLCB2YXJzKTtcclxuICAgICAgaWYgKGVsID09PSBhbmNob3IpIGJyZWFrO1xyXG4gICAgICBlbCA9IGVsLm5leHRTaWJsaW5nO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBzZXRWYXJzT25Ob2RlKGVsLCB2YXJzKSB7XHJcbiAgaWYgKGVsLm5vZGVUeXBlID09PSAxKSB7XHJcbiAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xyXG4gICAgbGV0IGNzc1RleHQgPSBcIlwiO1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gdmFycykge1xyXG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShgLS0ke2tleX1gLCB2YXJzW2tleV0pO1xyXG4gICAgICBjc3NUZXh0ICs9IGAtLSR7a2V5fTogJHt2YXJzW2tleV19O2A7XHJcbiAgICB9XHJcbiAgICBzdHlsZVtDU1NfVkFSX1RFWFRdID0gY3NzVGV4dDtcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IGRpc3BsYXlSRSA9IC8oXnw7KVxccypkaXNwbGF5XFxzKjovO1xyXG5mdW5jdGlvbiBwYXRjaFN0eWxlKGVsLCBwcmV2LCBuZXh0KSB7XHJcbiAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcclxuICBjb25zdCBpc0Nzc1N0cmluZyA9IGlzU3RyaW5nKG5leHQpO1xyXG4gIGxldCBoYXNDb250cm9sbGVkRGlzcGxheSA9IGZhbHNlO1xyXG4gIGlmIChuZXh0ICYmICFpc0Nzc1N0cmluZykge1xyXG4gICAgaWYgKHByZXYpIHtcclxuICAgICAgaWYgKCFpc1N0cmluZyhwcmV2KSkge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByZXYpIHtcclxuICAgICAgICAgIGlmIChuZXh0W2tleV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZXRTdHlsZShzdHlsZSwga2V5LCBcIlwiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBwcmV2U3R5bGUgb2YgcHJldi5zcGxpdChcIjtcIikpIHtcclxuICAgICAgICAgIGNvbnN0IGtleSA9IHByZXZTdHlsZS5zbGljZSgwLCBwcmV2U3R5bGUuaW5kZXhPZihcIjpcIikpLnRyaW0oKTtcclxuICAgICAgICAgIGlmIChuZXh0W2tleV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZXRTdHlsZShzdHlsZSwga2V5LCBcIlwiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qga2V5IGluIG5leHQpIHtcclxuICAgICAgaWYgKGtleSA9PT0gXCJkaXNwbGF5XCIpIHtcclxuICAgICAgICBoYXNDb250cm9sbGVkRGlzcGxheSA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgc2V0U3R5bGUoc3R5bGUsIGtleSwgbmV4dFtrZXldKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKGlzQ3NzU3RyaW5nKSB7XHJcbiAgICAgIGlmIChwcmV2ICE9PSBuZXh0KSB7XHJcbiAgICAgICAgY29uc3QgY3NzVmFyVGV4dCA9IHN0eWxlW0NTU19WQVJfVEVYVF07XHJcbiAgICAgICAgaWYgKGNzc1ZhclRleHQpIHtcclxuICAgICAgICAgIG5leHQgKz0gXCI7XCIgKyBjc3NWYXJUZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdHlsZS5jc3NUZXh0ID0gbmV4dDtcclxuICAgICAgICBoYXNDb250cm9sbGVkRGlzcGxheSA9IGRpc3BsYXlSRS50ZXN0KG5leHQpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHByZXYpIHtcclxuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmICh2U2hvd09yaWdpbmFsRGlzcGxheSBpbiBlbCkge1xyXG4gICAgZWxbdlNob3dPcmlnaW5hbERpc3BsYXldID0gaGFzQ29udHJvbGxlZERpc3BsYXkgPyBzdHlsZS5kaXNwbGF5IDogXCJcIjtcclxuICAgIGlmIChlbFt2U2hvd0hpZGRlbl0pIHtcclxuICAgICAgc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5jb25zdCBzZW1pY29sb25SRSA9IC9bXlxcXFxdO1xccyokLztcclxuY29uc3QgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcclxuZnVuY3Rpb24gc2V0U3R5bGUoc3R5bGUsIG5hbWUsIHZhbCkge1xyXG4gIGlmIChpc0FycmF5KHZhbCkpIHtcclxuICAgIHZhbC5mb3JFYWNoKCh2KSA9PiBzZXRTdHlsZShzdHlsZSwgbmFtZSwgdikpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAodmFsID09IG51bGwpIHZhbCA9IFwiXCI7XHJcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICBpZiAoc2VtaWNvbG9uUkUudGVzdCh2YWwpKSB7XHJcbiAgICAgICAgd2FybihcclxuICAgICAgICAgIGBVbmV4cGVjdGVkIHNlbWljb2xvbiBhdCB0aGUgZW5kIG9mICcke25hbWV9JyBzdHlsZSB2YWx1ZTogJyR7dmFsfSdgXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG5hbWUuc3RhcnRzV2l0aChcIi0tXCIpKSB7XHJcbiAgICAgIHN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBwcmVmaXhlZCA9IGF1dG9QcmVmaXgoc3R5bGUsIG5hbWUpO1xyXG4gICAgICBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XHJcbiAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoXHJcbiAgICAgICAgICBoeXBoZW5hdGUocHJlZml4ZWQpLFxyXG4gICAgICAgICAgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsIFwiXCIpLFxyXG4gICAgICAgICAgXCJpbXBvcnRhbnRcIlxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3R5bGVbcHJlZml4ZWRdID0gdmFsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmNvbnN0IHByZWZpeGVzID0gW1wiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIl07XHJcbmNvbnN0IHByZWZpeENhY2hlID0ge307XHJcbmZ1bmN0aW9uIGF1dG9QcmVmaXgoc3R5bGUsIHJhd05hbWUpIHtcclxuICBjb25zdCBjYWNoZWQgPSBwcmVmaXhDYWNoZVtyYXdOYW1lXTtcclxuICBpZiAoY2FjaGVkKSB7XHJcbiAgICByZXR1cm4gY2FjaGVkO1xyXG4gIH1cclxuICBsZXQgbmFtZSA9IGNhbWVsaXplKHJhd05hbWUpO1xyXG4gIGlmIChuYW1lICE9PSBcImZpbHRlclwiICYmIG5hbWUgaW4gc3R5bGUpIHtcclxuICAgIHJldHVybiBwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IG5hbWU7XHJcbiAgfVxyXG4gIG5hbWUgPSBjYXBpdGFsaXplKG5hbWUpO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IHByZWZpeGVkID0gcHJlZml4ZXNbaV0gKyBuYW1lO1xyXG4gICAgaWYgKHByZWZpeGVkIGluIHN0eWxlKSB7XHJcbiAgICAgIHJldHVybiBwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IHByZWZpeGVkO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmF3TmFtZTtcclxufVxyXG5cclxuY29uc3QgeGxpbmtOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiO1xyXG5mdW5jdGlvbiBwYXRjaEF0dHIoZWwsIGtleSwgdmFsdWUsIGlzU1ZHLCBpbnN0YW5jZSwgaXNCb29sZWFuID0gaXNTcGVjaWFsQm9vbGVhbkF0dHIoa2V5KSkge1xyXG4gIGlmIChpc1NWRyAmJiBrZXkuc3RhcnRzV2l0aChcInhsaW5rOlwiKSkge1xyXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywga2V5LnNsaWNlKDYsIGtleS5sZW5ndGgpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBpc0Jvb2xlYW4gJiYgIWluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSkpIHtcclxuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoXHJcbiAgICAgICAga2V5LFxyXG4gICAgICAgIGlzQm9vbGVhbiA/IFwiXCIgOiBpc1N5bWJvbCh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogdmFsdWVcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhdGNoRE9NUHJvcChlbCwga2V5LCB2YWx1ZSwgcGFyZW50Q29tcG9uZW50LCBhdHRyTmFtZSkge1xyXG4gIGlmIChrZXkgPT09IFwiaW5uZXJIVE1MXCIgfHwga2V5ID09PSBcInRleHRDb250ZW50XCIpIHtcclxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgIGVsW2tleV0gPSBrZXkgPT09IFwiaW5uZXJIVE1MXCIgPyB1bnNhZmVUb1RydXN0ZWRIVE1MKHZhbHVlKSA6IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBjb25zdCB0YWcgPSBlbC50YWdOYW1lO1xyXG4gIGlmIChrZXkgPT09IFwidmFsdWVcIiAmJiB0YWcgIT09IFwiUFJPR1JFU1NcIiAmJiAvLyBjdXN0b20gZWxlbWVudHMgbWF5IHVzZSBfdmFsdWUgaW50ZXJuYWxseVxyXG4gICF0YWcuaW5jbHVkZXMoXCItXCIpKSB7XHJcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRhZyA9PT0gXCJPUFRJT05cIiA/IGVsLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpIHx8IFwiXCIgOiBlbC52YWx1ZTtcclxuICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPT0gbnVsbCA/IChcclxuICAgICAgLy8gIzExNjQ3OiB2YWx1ZSBzaG91bGQgYmUgc2V0IGFzIGVtcHR5IHN0cmluZyBmb3IgbnVsbCBhbmQgdW5kZWZpbmVkLFxyXG4gICAgICAvLyBidXQgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiPiBzaG91bGQgYmUgc2V0IGFzICdvbicuXHJcbiAgICAgIGVsLnR5cGUgPT09IFwiY2hlY2tib3hcIiA/IFwib25cIiA6IFwiXCJcclxuICAgICkgOiBTdHJpbmcodmFsdWUpO1xyXG4gICAgaWYgKG9sZFZhbHVlICE9PSBuZXdWYWx1ZSB8fCAhKFwiX3ZhbHVlXCIgaW4gZWwpKSB7XHJcbiAgICAgIGVsLnZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcclxuICAgIH1cclxuICAgIGVsLl92YWx1ZSA9IHZhbHVlO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBsZXQgbmVlZFJlbW92ZSA9IGZhbHNlO1xyXG4gIGlmICh2YWx1ZSA9PT0gXCJcIiB8fCB2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIGVsW2tleV07XHJcbiAgICBpZiAodHlwZSA9PT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgdmFsdWUgPSBpbmNsdWRlQm9vbGVhbkF0dHIodmFsdWUpO1xyXG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBudWxsICYmIHR5cGUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgdmFsdWUgPSBcIlwiO1xyXG4gICAgICBuZWVkUmVtb3ZlID0gdHJ1ZTtcclxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICB2YWx1ZSA9IDA7XHJcbiAgICAgIG5lZWRSZW1vdmUgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuICB0cnkge1xyXG4gICAgZWxba2V5XSA9IHZhbHVlO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFuZWVkUmVtb3ZlKSB7XHJcbiAgICAgIHdhcm4oXHJcbiAgICAgICAgYEZhaWxlZCBzZXR0aW5nIHByb3AgXCIke2tleX1cIiBvbiA8JHt0YWcudG9Mb3dlckNhc2UoKX0+OiB2YWx1ZSAke3ZhbHVlfSBpcyBpbnZhbGlkLmAsXHJcbiAgICAgICAgZVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuICBuZWVkUmVtb3ZlICYmIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSB8fCBrZXkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVsLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xyXG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XHJcbiAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XHJcbn1cclxuY29uc3QgdmVpS2V5ID0gU3ltYm9sKFwiX3ZlaVwiKTtcclxuZnVuY3Rpb24gcGF0Y2hFdmVudChlbCwgcmF3TmFtZSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIGluc3RhbmNlID0gbnVsbCkge1xyXG4gIGNvbnN0IGludm9rZXJzID0gZWxbdmVpS2V5XSB8fCAoZWxbdmVpS2V5XSA9IHt9KTtcclxuICBjb25zdCBleGlzdGluZ0ludm9rZXIgPSBpbnZva2Vyc1tyYXdOYW1lXTtcclxuICBpZiAobmV4dFZhbHVlICYmIGV4aXN0aW5nSW52b2tlcikge1xyXG4gICAgZXhpc3RpbmdJbnZva2VyLnZhbHVlID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNhbml0aXplRXZlbnRWYWx1ZShuZXh0VmFsdWUsIHJhd05hbWUpIDogbmV4dFZhbHVlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdCBbbmFtZSwgb3B0aW9uc10gPSBwYXJzZU5hbWUocmF3TmFtZSk7XHJcbiAgICBpZiAobmV4dFZhbHVlKSB7XHJcbiAgICAgIGNvbnN0IGludm9rZXIgPSBpbnZva2Vyc1tyYXdOYW1lXSA9IGNyZWF0ZUludm9rZXIoXHJcbiAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNhbml0aXplRXZlbnRWYWx1ZShuZXh0VmFsdWUsIHJhd05hbWUpIDogbmV4dFZhbHVlLFxyXG4gICAgICAgIGluc3RhbmNlXHJcbiAgICAgICk7XHJcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGludm9rZXIsIG9wdGlvbnMpO1xyXG4gICAgfSBlbHNlIGlmIChleGlzdGluZ0ludm9rZXIpIHtcclxuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgZXhpc3RpbmdJbnZva2VyLCBvcHRpb25zKTtcclxuICAgICAgaW52b2tlcnNbcmF3TmFtZV0gPSB2b2lkIDA7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmNvbnN0IG9wdGlvbnNNb2RpZmllclJFID0gLyg/Ok9uY2V8UGFzc2l2ZXxDYXB0dXJlKSQvO1xyXG5mdW5jdGlvbiBwYXJzZU5hbWUobmFtZSkge1xyXG4gIGxldCBvcHRpb25zO1xyXG4gIGlmIChvcHRpb25zTW9kaWZpZXJSRS50ZXN0KG5hbWUpKSB7XHJcbiAgICBvcHRpb25zID0ge307XHJcbiAgICBsZXQgbTtcclxuICAgIHdoaWxlIChtID0gbmFtZS5tYXRjaChvcHRpb25zTW9kaWZpZXJSRSkpIHtcclxuICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgbmFtZS5sZW5ndGggLSBtWzBdLmxlbmd0aCk7XHJcbiAgICAgIG9wdGlvbnNbbVswXS50b0xvd2VyQ2FzZSgpXSA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNvbnN0IGV2ZW50ID0gbmFtZVsyXSA9PT0gXCI6XCIgPyBuYW1lLnNsaWNlKDMpIDogaHlwaGVuYXRlKG5hbWUuc2xpY2UoMikpO1xyXG4gIHJldHVybiBbZXZlbnQsIG9wdGlvbnNdO1xyXG59XHJcbmxldCBjYWNoZWROb3cgPSAwO1xyXG5jb25zdCBwID0gLyogQF9fUFVSRV9fICovIFByb21pc2UucmVzb2x2ZSgpO1xyXG5jb25zdCBnZXROb3cgPSAoKSA9PiBjYWNoZWROb3cgfHwgKHAudGhlbigoKSA9PiBjYWNoZWROb3cgPSAwKSwgY2FjaGVkTm93ID0gRGF0ZS5ub3coKSk7XHJcbmZ1bmN0aW9uIGNyZWF0ZUludm9rZXIoaW5pdGlhbFZhbHVlLCBpbnN0YW5jZSkge1xyXG4gIGNvbnN0IGludm9rZXIgPSAoZSkgPT4ge1xyXG4gICAgaWYgKCFlLl92dHMpIHtcclxuICAgICAgZS5fdnRzID0gRGF0ZS5ub3coKTtcclxuICAgIH0gZWxzZSBpZiAoZS5fdnRzIDw9IGludm9rZXIuYXR0YWNoZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXHJcbiAgICAgIHBhdGNoU3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGUsIGludm9rZXIudmFsdWUpLFxyXG4gICAgICBpbnN0YW5jZSxcclxuICAgICAgNSxcclxuICAgICAgW2VdXHJcbiAgICApO1xyXG4gIH07XHJcbiAgaW52b2tlci52YWx1ZSA9IGluaXRpYWxWYWx1ZTtcclxuICBpbnZva2VyLmF0dGFjaGVkID0gZ2V0Tm93KCk7XHJcbiAgcmV0dXJuIGludm9rZXI7XHJcbn1cclxuZnVuY3Rpb24gc2FuaXRpemVFdmVudFZhbHVlKHZhbHVlLCBwcm9wTmFtZSkge1xyXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH1cclxuICB3YXJuKFxyXG4gICAgYFdyb25nIHR5cGUgcGFzc2VkIGFzIGV2ZW50IGhhbmRsZXIgdG8gJHtwcm9wTmFtZX0gLSBkaWQgeW91IGZvcmdldCBAIG9yIDogaW4gZnJvbnQgb2YgeW91ciBwcm9wP1xyXG5FeHBlY3RlZCBmdW5jdGlvbiBvciBhcnJheSBvZiBmdW5jdGlvbnMsIHJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgdmFsdWV9LmBcclxuICApO1xyXG4gIHJldHVybiBOT09QO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGNoU3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGUsIHZhbHVlKSB7XHJcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICBjb25zdCBvcmlnaW5hbFN0b3AgPSBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjtcclxuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gKCkgPT4ge1xyXG4gICAgICBvcmlnaW5hbFN0b3AuY2FsbChlKTtcclxuICAgICAgZS5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHZhbHVlLm1hcChcclxuICAgICAgKGZuKSA9PiAoZTIpID0+ICFlMi5fc3RvcHBlZCAmJiBmbiAmJiBmbihlMilcclxuICAgICk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IGlzTmF0aXZlT24gPSAoa2V5KSA9PiBrZXkuY2hhckNvZGVBdCgwKSA9PT0gMTExICYmIGtleS5jaGFyQ29kZUF0KDEpID09PSAxMTAgJiYgLy8gbG93ZXJjYXNlIGxldHRlclxyXG5rZXkuY2hhckNvZGVBdCgyKSA+IDk2ICYmIGtleS5jaGFyQ29kZUF0KDIpIDwgMTIzO1xyXG5jb25zdCBwYXRjaFByb3AgPSAoZWwsIGtleSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIG5hbWVzcGFjZSwgcGFyZW50Q29tcG9uZW50KSA9PiB7XHJcbiAgY29uc3QgaXNTVkcgPSBuYW1lc3BhY2UgPT09IFwic3ZnXCI7XHJcbiAgaWYgKGtleSA9PT0gXCJjbGFzc1wiKSB7XHJcbiAgICBwYXRjaENsYXNzKGVsLCBuZXh0VmFsdWUsIGlzU1ZHKTtcclxuICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzdHlsZVwiKSB7XHJcbiAgICBwYXRjaFN0eWxlKGVsLCBwcmV2VmFsdWUsIG5leHRWYWx1ZSk7XHJcbiAgfSBlbHNlIGlmIChpc09uKGtleSkpIHtcclxuICAgIGlmICghaXNNb2RlbExpc3RlbmVyKGtleSkpIHtcclxuICAgICAgcGF0Y2hFdmVudChlbCwga2V5LCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgcGFyZW50Q29tcG9uZW50KTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGtleVswXSA9PT0gXCIuXCIgPyAoa2V5ID0ga2V5LnNsaWNlKDEpLCB0cnVlKSA6IGtleVswXSA9PT0gXCJeXCIgPyAoa2V5ID0ga2V5LnNsaWNlKDEpLCBmYWxzZSkgOiBzaG91bGRTZXRBc1Byb3AoZWwsIGtleSwgbmV4dFZhbHVlLCBpc1NWRykpIHtcclxuICAgIHBhdGNoRE9NUHJvcChlbCwga2V5LCBuZXh0VmFsdWUpO1xyXG4gICAgaWYgKCFlbC50YWdOYW1lLmluY2x1ZGVzKFwiLVwiKSAmJiAoa2V5ID09PSBcInZhbHVlXCIgfHwga2V5ID09PSBcImNoZWNrZWRcIiB8fCBrZXkgPT09IFwic2VsZWN0ZWRcIikpIHtcclxuICAgICAgcGF0Y2hBdHRyKGVsLCBrZXksIG5leHRWYWx1ZSwgaXNTVkcsIHBhcmVudENvbXBvbmVudCwga2V5ICE9PSBcInZhbHVlXCIpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoXHJcbiAgICAvLyAjMTEwODEgZm9yY2Ugc2V0IHByb3BzIGZvciBwb3NzaWJsZSBhc3luYyBjdXN0b20gZWxlbWVudFxyXG4gICAgZWwuX2lzVnVlQ0UgJiYgKC9bQS1aXS8udGVzdChrZXkpIHx8ICFpc1N0cmluZyhuZXh0VmFsdWUpKVxyXG4gICkge1xyXG4gICAgcGF0Y2hET01Qcm9wKGVsLCBjYW1lbGl6ZSQxKGtleSksIG5leHRWYWx1ZSwgcGFyZW50Q29tcG9uZW50LCBrZXkpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoa2V5ID09PSBcInRydWUtdmFsdWVcIikge1xyXG4gICAgICBlbC5fdHJ1ZVZhbHVlID0gbmV4dFZhbHVlO1xyXG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiZmFsc2UtdmFsdWVcIikge1xyXG4gICAgICBlbC5fZmFsc2VWYWx1ZSA9IG5leHRWYWx1ZTtcclxuICAgIH1cclxuICAgIHBhdGNoQXR0cihlbCwga2V5LCBuZXh0VmFsdWUsIGlzU1ZHKTtcclxuICB9XHJcbn07XHJcbmZ1bmN0aW9uIHNob3VsZFNldEFzUHJvcChlbCwga2V5LCB2YWx1ZSwgaXNTVkcpIHtcclxuICBpZiAoaXNTVkcpIHtcclxuICAgIGlmIChrZXkgPT09IFwiaW5uZXJIVE1MXCIgfHwga2V5ID09PSBcInRleHRDb250ZW50XCIpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoa2V5IGluIGVsICYmIGlzTmF0aXZlT24oa2V5KSAmJiBpc0Z1bmN0aW9uKHZhbHVlKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgaWYgKGtleSA9PT0gXCJzcGVsbGNoZWNrXCIgfHwga2V5ID09PSBcImRyYWdnYWJsZVwiIHx8IGtleSA9PT0gXCJ0cmFuc2xhdGVcIikge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBpZiAoa2V5ID09PSBcImZvcm1cIikge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBpZiAoa2V5ID09PSBcImxpc3RcIiAmJiBlbC50YWdOYW1lID09PSBcIklOUFVUXCIpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgaWYgKGtleSA9PT0gXCJ0eXBlXCIgJiYgZWwudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIGlmIChrZXkgPT09IFwid2lkdGhcIiB8fCBrZXkgPT09IFwiaGVpZ2h0XCIpIHtcclxuICAgIGNvbnN0IHRhZyA9IGVsLnRhZ05hbWU7XHJcbiAgICBpZiAodGFnID09PSBcIklNR1wiIHx8IHRhZyA9PT0gXCJWSURFT1wiIHx8IHRhZyA9PT0gXCJDQU5WQVNcIiB8fCB0YWcgPT09IFwiU09VUkNFXCIpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoaXNOYXRpdmVPbihrZXkpICYmIGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4ga2V5IGluIGVsO1xyXG59XHJcblxyXG5jb25zdCBSRU1PVkFMID0ge307XHJcbi8qISAjX19OT19TSURFX0VGRkVDVFNfXyAqL1xyXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xyXG5mdW5jdGlvbiBkZWZpbmVDdXN0b21FbGVtZW50KG9wdGlvbnMsIGV4dHJhT3B0aW9ucywgX2NyZWF0ZUFwcCkge1xyXG4gIGNvbnN0IENvbXAgPSBkZWZpbmVDb21wb25lbnQob3B0aW9ucywgZXh0cmFPcHRpb25zKTtcclxuICBpZiAoaXNQbGFpbk9iamVjdChDb21wKSkgZXh0ZW5kKENvbXAsIGV4dHJhT3B0aW9ucyk7XHJcbiAgY2xhc3MgVnVlQ3VzdG9tRWxlbWVudCBleHRlbmRzIFZ1ZUVsZW1lbnQge1xyXG4gICAgY29uc3RydWN0b3IoaW5pdGlhbFByb3BzKSB7XHJcbiAgICAgIHN1cGVyKENvbXAsIGluaXRpYWxQcm9wcywgX2NyZWF0ZUFwcCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFZ1ZUN1c3RvbUVsZW1lbnQuZGVmID0gQ29tcDtcclxuICByZXR1cm4gVnVlQ3VzdG9tRWxlbWVudDtcclxufVxyXG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cclxuY29uc3QgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudCA9IC8qIEBfX05PX1NJREVfRUZGRUNUU19fICovIChvcHRpb25zLCBleHRyYU9wdGlvbnMpID0+IHtcclxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGRlZmluZUN1c3RvbUVsZW1lbnQob3B0aW9ucywgZXh0cmFPcHRpb25zLCBjcmVhdGVTU1JBcHApO1xyXG59O1xyXG5jb25zdCBCYXNlQ2xhc3MgPSB0eXBlb2YgSFRNTEVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBIVE1MRWxlbWVudCA6IGNsYXNzIHtcclxufTtcclxuY2xhc3MgVnVlRWxlbWVudCBleHRlbmRzIEJhc2VDbGFzcyB7XHJcbiAgY29uc3RydWN0b3IoX2RlZiwgX3Byb3BzID0ge30sIF9jcmVhdGVBcHAgPSBjcmVhdGVBcHApIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLl9kZWYgPSBfZGVmO1xyXG4gICAgdGhpcy5fcHJvcHMgPSBfcHJvcHM7XHJcbiAgICB0aGlzLl9jcmVhdGVBcHAgPSBfY3JlYXRlQXBwO1xyXG4gICAgdGhpcy5faXNWdWVDRSA9IHRydWU7XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICB0aGlzLl9hcHAgPSBudWxsO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgdGhpcy5fbm9uY2UgPSB0aGlzLl9kZWYubm9uY2U7XHJcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX3Jlc29sdmVkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9udW1iZXJQcm9wcyA9IG51bGw7XHJcbiAgICB0aGlzLl9zdHlsZUNoaWxkcmVuID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XHJcbiAgICB0aGlzLl9vYiA9IG51bGw7XHJcbiAgICBpZiAodGhpcy5zaGFkb3dSb290ICYmIF9jcmVhdGVBcHAgIT09IGNyZWF0ZUFwcCkge1xyXG4gICAgICB0aGlzLl9yb290ID0gdGhpcy5zaGFkb3dSb290O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdGhpcy5zaGFkb3dSb290KSB7XHJcbiAgICAgICAgd2FybihcclxuICAgICAgICAgIGBDdXN0b20gZWxlbWVudCBoYXMgcHJlLXJlbmRlcmVkIGRlY2xhcmF0aXZlIHNoYWRvdyByb290IGJ1dCBpcyBub3QgZGVmaW5lZCBhcyBoeWRyYXRhYmxlLiBVc2UgXFxgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudFxcYC5gXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoX2RlZi5zaGFkb3dSb290ICE9PSBmYWxzZSkge1xyXG4gICAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogXCJvcGVuXCIgfSk7XHJcbiAgICAgICAgdGhpcy5fcm9vdCA9IHRoaXMuc2hhZG93Um9vdDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9yb290ID0gdGhpcztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCF0aGlzLl9kZWYuX19hc3luY0xvYWRlcikge1xyXG4gICAgICB0aGlzLl9yZXNvbHZlUHJvcHModGhpcy5fZGVmKTtcclxuICAgIH1cclxuICB9XHJcbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XHJcbiAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQpIHJldHVybjtcclxuICAgIGlmICghdGhpcy5zaGFkb3dSb290KSB7XHJcbiAgICAgIHRoaXMuX3BhcnNlU2xvdHMoKTtcclxuICAgIH1cclxuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XHJcbiAgICBsZXQgcGFyZW50ID0gdGhpcztcclxuICAgIHdoaWxlIChwYXJlbnQgPSBwYXJlbnQgJiYgKHBhcmVudC5wYXJlbnROb2RlIHx8IHBhcmVudC5ob3N0KSkge1xyXG4gICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgVnVlRWxlbWVudCkge1xyXG4gICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xyXG4gICAgICBpZiAodGhpcy5fcmVzb2x2ZWQpIHtcclxuICAgICAgICB0aGlzLl9zZXRQYXJlbnQoKTtcclxuICAgICAgICB0aGlzLl91cGRhdGUoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC5fcGVuZGluZ1Jlc29sdmUpIHtcclxuICAgICAgICAgIHRoaXMuX3BlbmRpbmdSZXNvbHZlID0gcGFyZW50Ll9wZW5kaW5nUmVzb2x2ZS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1Jlc29sdmUgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVEZWYoKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLl9yZXNvbHZlRGVmKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIF9zZXRQYXJlbnQocGFyZW50ID0gdGhpcy5fcGFyZW50KSB7XHJcbiAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgIHRoaXMuX2luc3RhbmNlLnBhcmVudCA9IHBhcmVudC5faW5zdGFuY2U7XHJcbiAgICAgIHRoaXMuX2luc3RhbmNlLnByb3ZpZGVzID0gcGFyZW50Ll9pbnN0YW5jZS5wcm92aWRlcztcclxuICAgIH1cclxuICB9XHJcbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XHJcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcclxuICAgIG5leHRUaWNrKCgpID0+IHtcclxuICAgICAgaWYgKCF0aGlzLl9jb25uZWN0ZWQpIHtcclxuICAgICAgICBpZiAodGhpcy5fb2IpIHtcclxuICAgICAgICAgIHRoaXMuX29iLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgIHRoaXMuX29iID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYXBwICYmIHRoaXMuX2FwcC51bm1vdW50KCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlKSB0aGlzLl9pbnN0YW5jZS5jZSA9IHZvaWQgMDtcclxuICAgICAgICB0aGlzLl9hcHAgPSB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiByZXNvbHZlIGlubmVyIGNvbXBvbmVudCBkZWZpbml0aW9uIChoYW5kbGUgcG9zc2libGUgYXN5bmMgY29tcG9uZW50KVxyXG4gICAqL1xyXG4gIF9yZXNvbHZlRGVmKCkge1xyXG4gICAgaWYgKHRoaXMuX3BlbmRpbmdSZXNvbHZlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHRoaXMuX3NldEF0dHIodGhpcy5hdHRyaWJ1dGVzW2ldLm5hbWUpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fb2IgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zKSA9PiB7XHJcbiAgICAgIGZvciAoY29uc3QgbSBvZiBtdXRhdGlvbnMpIHtcclxuICAgICAgICB0aGlzLl9zZXRBdHRyKG0uYXR0cmlidXRlTmFtZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdGhpcy5fb2Iub2JzZXJ2ZSh0aGlzLCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XHJcbiAgICBjb25zdCByZXNvbHZlID0gKGRlZiwgaXNBc3luYyA9IGZhbHNlKSA9PiB7XHJcbiAgICAgIHRoaXMuX3Jlc29sdmVkID0gdHJ1ZTtcclxuICAgICAgdGhpcy5fcGVuZGluZ1Jlc29sdmUgPSB2b2lkIDA7XHJcbiAgICAgIGNvbnN0IHsgcHJvcHMsIHN0eWxlcyB9ID0gZGVmO1xyXG4gICAgICBsZXQgbnVtYmVyUHJvcHM7XHJcbiAgICAgIGlmIChwcm9wcyAmJiAhaXNBcnJheShwcm9wcykpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xyXG4gICAgICAgICAgY29uc3Qgb3B0ID0gcHJvcHNba2V5XTtcclxuICAgICAgICAgIGlmIChvcHQgPT09IE51bWJlciB8fCBvcHQgJiYgb3B0LnR5cGUgPT09IE51bWJlcikge1xyXG4gICAgICAgICAgICBpZiAoa2V5IGluIHRoaXMuX3Byb3BzKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5fcHJvcHNba2V5XSA9IHRvTnVtYmVyKHRoaXMuX3Byb3BzW2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIChudW1iZXJQcm9wcyB8fCAobnVtYmVyUHJvcHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSkpW2NhbWVsaXplJDEoa2V5KV0gPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9udW1iZXJQcm9wcyA9IG51bWJlclByb3BzO1xyXG4gICAgICBpZiAoaXNBc3luYykge1xyXG4gICAgICAgIHRoaXMuX3Jlc29sdmVQcm9wcyhkZWYpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLnNoYWRvd1Jvb3QpIHtcclxuICAgICAgICB0aGlzLl9hcHBseVN0eWxlcyhzdHlsZXMpO1xyXG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc3R5bGVzKSB7XHJcbiAgICAgICAgd2FybihcclxuICAgICAgICAgIFwiQ3VzdG9tIGVsZW1lbnQgc3R5bGUgaW5qZWN0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgd2hlbiB1c2luZyBzaGFkb3dSb290OiBmYWxzZVwiXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9tb3VudChkZWYpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGFzeW5jRGVmID0gdGhpcy5fZGVmLl9fYXN5bmNMb2FkZXI7XHJcbiAgICBpZiAoYXN5bmNEZWYpIHtcclxuICAgICAgdGhpcy5fcGVuZGluZ1Jlc29sdmUgPSBhc3luY0RlZigpLnRoZW4oXHJcbiAgICAgICAgKGRlZikgPT4gcmVzb2x2ZSh0aGlzLl9kZWYgPSBkZWYsIHRydWUpXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXNvbHZlKHRoaXMuX2RlZik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIF9tb3VudChkZWYpIHtcclxuICAgIGlmICgoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pICYmICFkZWYubmFtZSkge1xyXG4gICAgICBkZWYubmFtZSA9IFwiVnVlRWxlbWVudFwiO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fYXBwID0gdGhpcy5fY3JlYXRlQXBwKGRlZik7XHJcbiAgICBpZiAoZGVmLmNvbmZpZ3VyZUFwcCkge1xyXG4gICAgICBkZWYuY29uZmlndXJlQXBwKHRoaXMuX2FwcCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9hcHAuX2NlVk5vZGUgPSB0aGlzLl9jcmVhdGVWTm9kZSgpO1xyXG4gICAgdGhpcy5fYXBwLm1vdW50KHRoaXMuX3Jvb3QpO1xyXG4gICAgY29uc3QgZXhwb3NlZCA9IHRoaXMuX2luc3RhbmNlICYmIHRoaXMuX2luc3RhbmNlLmV4cG9zZWQ7XHJcbiAgICBpZiAoIWV4cG9zZWQpIHJldHVybjtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGV4cG9zZWQpIHtcclxuICAgICAgaWYgKCFoYXNPd24odGhpcywga2V5KSkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcclxuICAgICAgICAgIC8vIHVud3JhcCByZWYgdG8gYmUgY29uc2lzdGVudCB3aXRoIHB1YmxpYyBpbnN0YW5jZSBiZWhhdmlvclxyXG4gICAgICAgICAgZ2V0OiAoKSA9PiB1bnJlZihleHBvc2VkW2tleV0pXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgICAgIHdhcm4oYEV4cG9zZWQgcHJvcGVydHkgXCIke2tleX1cIiBhbHJlYWR5IGV4aXN0cyBvbiBjdXN0b20gZWxlbWVudC5gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBfcmVzb2x2ZVByb3BzKGRlZikge1xyXG4gICAgY29uc3QgeyBwcm9wcyB9ID0gZGVmO1xyXG4gICAgY29uc3QgZGVjbGFyZWRQcm9wS2V5cyA9IGlzQXJyYXkocHJvcHMpID8gcHJvcHMgOiBPYmplY3Qua2V5cyhwcm9wcyB8fCB7fSk7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzKSkge1xyXG4gICAgICBpZiAoa2V5WzBdICE9PSBcIl9cIiAmJiBkZWNsYXJlZFByb3BLZXlzLmluY2x1ZGVzKGtleSkpIHtcclxuICAgICAgICB0aGlzLl9zZXRQcm9wKGtleSwgdGhpc1trZXldKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBrZXkgb2YgZGVjbGFyZWRQcm9wS2V5cy5tYXAoY2FtZWxpemUkMSkpIHtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xyXG4gICAgICAgIGdldCgpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRQcm9wKGtleSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQodmFsKSB7XHJcbiAgICAgICAgICB0aGlzLl9zZXRQcm9wKGtleSwgdmFsLCB0cnVlLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuICBfc2V0QXR0cihrZXkpIHtcclxuICAgIGlmIChrZXkuc3RhcnRzV2l0aChcImRhdGEtdi1cIikpIHJldHVybjtcclxuICAgIGNvbnN0IGhhcyA9IHRoaXMuaGFzQXR0cmlidXRlKGtleSk7XHJcbiAgICBsZXQgdmFsdWUgPSBoYXMgPyB0aGlzLmdldEF0dHJpYnV0ZShrZXkpIDogUkVNT1ZBTDtcclxuICAgIGNvbnN0IGNhbWVsS2V5ID0gY2FtZWxpemUkMShrZXkpO1xyXG4gICAgaWYgKGhhcyAmJiB0aGlzLl9udW1iZXJQcm9wcyAmJiB0aGlzLl9udW1iZXJQcm9wc1tjYW1lbEtleV0pIHtcclxuICAgICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9zZXRQcm9wKGNhbWVsS2V5LCB2YWx1ZSwgZmFsc2UsIHRydWUpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBfZ2V0UHJvcChrZXkpIHtcclxuICAgIHJldHVybiB0aGlzLl9wcm9wc1trZXldO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBfc2V0UHJvcChrZXksIHZhbCwgc2hvdWxkUmVmbGVjdCA9IHRydWUsIHNob3VsZFVwZGF0ZSA9IGZhbHNlKSB7XHJcbiAgICBpZiAodmFsICE9PSB0aGlzLl9wcm9wc1trZXldKSB7XHJcbiAgICAgIGlmICh2YWwgPT09IFJFTU9WQUwpIHtcclxuICAgICAgICBkZWxldGUgdGhpcy5fcHJvcHNba2V5XTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9wcm9wc1trZXldID0gdmFsO1xyXG4gICAgICAgIGlmIChrZXkgPT09IFwia2V5XCIgJiYgdGhpcy5fYXBwKSB7XHJcbiAgICAgICAgICB0aGlzLl9hcHAuX2NlVk5vZGUua2V5ID0gdmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoc2hvdWxkVXBkYXRlICYmIHRoaXMuX2luc3RhbmNlKSB7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNob3VsZFJlZmxlY3QpIHtcclxuICAgICAgICBjb25zdCBvYiA9IHRoaXMuX29iO1xyXG4gICAgICAgIG9iICYmIG9iLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICBpZiAodmFsID09PSB0cnVlKSB7XHJcbiAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShoeXBoZW5hdGUoa2V5KSwgXCJcIik7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGh5cGhlbmF0ZShrZXkpLCB2YWwgKyBcIlwiKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCF2YWwpIHtcclxuICAgICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKGh5cGhlbmF0ZShrZXkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2IgJiYgb2Iub2JzZXJ2ZSh0aGlzLCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgX3VwZGF0ZSgpIHtcclxuICAgIHJlbmRlcih0aGlzLl9jcmVhdGVWTm9kZSgpLCB0aGlzLl9yb290KTtcclxuICB9XHJcbiAgX2NyZWF0ZVZOb2RlKCkge1xyXG4gICAgY29uc3QgYmFzZVByb3BzID0ge307XHJcbiAgICBpZiAoIXRoaXMuc2hhZG93Um9vdCkge1xyXG4gICAgICBiYXNlUHJvcHMub25Wbm9kZU1vdW50ZWQgPSBiYXNlUHJvcHMub25Wbm9kZVVwZGF0ZWQgPSB0aGlzLl9yZW5kZXJTbG90cy5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZSh0aGlzLl9kZWYsIGV4dGVuZChiYXNlUHJvcHMsIHRoaXMuX3Byb3BzKSk7XHJcbiAgICBpZiAoIXRoaXMuX2luc3RhbmNlKSB7XHJcbiAgICAgIHZub2RlLmNlID0gKGluc3RhbmNlKSA9PiB7XHJcbiAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0YW5jZTtcclxuICAgICAgICBpbnN0YW5jZS5jZSA9IHRoaXM7XHJcbiAgICAgICAgaW5zdGFuY2UuaXNDRSA9IHRydWU7XHJcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgICAgICAgIGluc3RhbmNlLmNlUmVsb2FkID0gKG5ld1N0eWxlcykgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3R5bGVzKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5fc3R5bGVzLmZvckVhY2goKHMpID0+IHRoaXMuX3Jvb3QucmVtb3ZlQ2hpbGQocykpO1xyXG4gICAgICAgICAgICAgIHRoaXMuX3N0eWxlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5U3R5bGVzKG5ld1N0eWxlcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkaXNwYXRjaCA9IChldmVudCwgYXJncykgPT4ge1xyXG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxyXG4gICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoXHJcbiAgICAgICAgICAgICAgZXZlbnQsXHJcbiAgICAgICAgICAgICAgaXNQbGFpbk9iamVjdChhcmdzWzBdKSA/IGV4dGVuZCh7IGRldGFpbDogYXJncyB9LCBhcmdzWzBdKSA6IHsgZGV0YWlsOiBhcmdzIH1cclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGluc3RhbmNlLmVtaXQgPSAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAgIGRpc3BhdGNoKGV2ZW50LCBhcmdzKTtcclxuICAgICAgICAgIGlmIChoeXBoZW5hdGUoZXZlbnQpICE9PSBldmVudCkge1xyXG4gICAgICAgICAgICBkaXNwYXRjaChoeXBoZW5hdGUoZXZlbnQpLCBhcmdzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3NldFBhcmVudCgpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZub2RlO1xyXG4gIH1cclxuICBfYXBwbHlTdHlsZXMoc3R5bGVzLCBvd25lcikge1xyXG4gICAgaWYgKCFzdHlsZXMpIHJldHVybjtcclxuICAgIGlmIChvd25lcikge1xyXG4gICAgICBpZiAob3duZXIgPT09IHRoaXMuX2RlZiB8fCB0aGlzLl9zdHlsZUNoaWxkcmVuLmhhcyhvd25lcikpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fc3R5bGVDaGlsZHJlbi5hZGQob3duZXIpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgbm9uY2UgPSB0aGlzLl9ub25jZTtcclxuICAgIGZvciAobGV0IGkgPSBzdHlsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgY29uc3QgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuICAgICAgaWYgKG5vbmNlKSBzLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcclxuICAgICAgcy50ZXh0Q29udGVudCA9IHN0eWxlc1tpXTtcclxuICAgICAgdGhpcy5zaGFkb3dSb290LnByZXBlbmQocyk7XHJcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgICAgaWYgKG93bmVyKSB7XHJcbiAgICAgICAgICBpZiAob3duZXIuX19obXJJZCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NoaWxkU3R5bGVzKSB0aGlzLl9jaGlsZFN0eWxlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgIGxldCBlbnRyeSA9IHRoaXMuX2NoaWxkU3R5bGVzLmdldChvd25lci5fX2htcklkKTtcclxuICAgICAgICAgICAgaWYgKCFlbnRyeSkge1xyXG4gICAgICAgICAgICAgIHRoaXMuX2NoaWxkU3R5bGVzLnNldChvd25lci5fX2htcklkLCBlbnRyeSA9IFtdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbnRyeS5wdXNoKHMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAodGhpcy5fc3R5bGVzIHx8ICh0aGlzLl9zdHlsZXMgPSBbXSkpLnB1c2gocyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIE9ubHkgY2FsbGVkIHdoZW4gc2hhZG93Um9vdCBpcyBmYWxzZVxyXG4gICAqL1xyXG4gIF9wYXJzZVNsb3RzKCkge1xyXG4gICAgY29uc3Qgc2xvdHMgPSB0aGlzLl9zbG90cyA9IHt9O1xyXG4gICAgbGV0IG47XHJcbiAgICB3aGlsZSAobiA9IHRoaXMuZmlyc3RDaGlsZCkge1xyXG4gICAgICBjb25zdCBzbG90TmFtZSA9IG4ubm9kZVR5cGUgPT09IDEgJiYgbi5nZXRBdHRyaWJ1dGUoXCJzbG90XCIpIHx8IFwiZGVmYXVsdFwiO1xyXG4gICAgICAoc2xvdHNbc2xvdE5hbWVdIHx8IChzbG90c1tzbG90TmFtZV0gPSBbXSkpLnB1c2gobik7XHJcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQobik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIE9ubHkgY2FsbGVkIHdoZW4gc2hhZG93Um9vdCBpcyBmYWxzZVxyXG4gICAqL1xyXG4gIF9yZW5kZXJTbG90cygpIHtcclxuICAgIGNvbnN0IG91dGxldHMgPSAodGhpcy5fdGVsZXBvcnRUYXJnZXQgfHwgdGhpcykucXVlcnlTZWxlY3RvckFsbChcInNsb3RcIik7XHJcbiAgICBjb25zdCBzY29wZUlkID0gdGhpcy5faW5zdGFuY2UudHlwZS5fX3Njb3BlSWQ7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dGxldHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgbyA9IG91dGxldHNbaV07XHJcbiAgICAgIGNvbnN0IHNsb3ROYW1lID0gby5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpIHx8IFwiZGVmYXVsdFwiO1xyXG4gICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5fc2xvdHNbc2xvdE5hbWVdO1xyXG4gICAgICBjb25zdCBwYXJlbnQgPSBvLnBhcmVudE5vZGU7XHJcbiAgICAgIGlmIChjb250ZW50KSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBuIG9mIGNvbnRlbnQpIHtcclxuICAgICAgICAgIGlmIChzY29wZUlkICYmIG4ubm9kZVR5cGUgPT09IDEpIHtcclxuICAgICAgICAgICAgY29uc3QgaWQgPSBzY29wZUlkICsgXCItc1wiO1xyXG4gICAgICAgICAgICBjb25zdCB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKG4sIDEpO1xyXG4gICAgICAgICAgICBuLnNldEF0dHJpYnV0ZShpZCwgXCJcIik7XHJcbiAgICAgICAgICAgIGxldCBjaGlsZDtcclxuICAgICAgICAgICAgd2hpbGUgKGNoaWxkID0gd2Fsa2VyLm5leHROb2RlKCkpIHtcclxuICAgICAgICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoaWQsIFwiXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG4sIG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB3aGlsZSAoby5maXJzdENoaWxkKSBwYXJlbnQuaW5zZXJ0QmVmb3JlKG8uZmlyc3RDaGlsZCwgbyk7XHJcbiAgICAgIH1cclxuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKG8pO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBfaW5qZWN0Q2hpbGRTdHlsZShjb21wKSB7XHJcbiAgICB0aGlzLl9hcHBseVN0eWxlcyhjb21wLnN0eWxlcywgY29tcCk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIF9yZW1vdmVDaGlsZFN0eWxlKGNvbXApIHtcclxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICAgIHRoaXMuX3N0eWxlQ2hpbGRyZW4uZGVsZXRlKGNvbXApO1xyXG4gICAgICBpZiAodGhpcy5fY2hpbGRTdHlsZXMgJiYgY29tcC5fX2htcklkKSB7XHJcbiAgICAgICAgY29uc3Qgb2xkU3R5bGVzID0gdGhpcy5fY2hpbGRTdHlsZXMuZ2V0KGNvbXAuX19obXJJZCk7XHJcbiAgICAgICAgaWYgKG9sZFN0eWxlcykge1xyXG4gICAgICAgICAgb2xkU3R5bGVzLmZvckVhY2goKHMpID0+IHRoaXMuX3Jvb3QucmVtb3ZlQ2hpbGQocykpO1xyXG4gICAgICAgICAgb2xkU3R5bGVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHVzZUhvc3QoY2FsbGVyKSB7XHJcbiAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICBjb25zdCBlbCA9IGluc3RhbmNlICYmIGluc3RhbmNlLmNlO1xyXG4gIGlmIChlbCkge1xyXG4gICAgcmV0dXJuIGVsO1xyXG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xyXG4gICAgaWYgKCFpbnN0YW5jZSkge1xyXG4gICAgICB3YXJuKFxyXG4gICAgICAgIGAke2NhbGxlciB8fCBcInVzZUhvc3RcIn0gY2FsbGVkIHdpdGhvdXQgYW4gYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZS5gXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB3YXJuKFxyXG4gICAgICAgIGAke2NhbGxlciB8fCBcInVzZUhvc3RcIn0gY2FuIG9ubHkgYmUgdXNlZCBpbiBjb21wb25lbnRzIGRlZmluZWQgdmlhIGRlZmluZUN1c3RvbUVsZW1lbnQuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiB1c2VTaGFkb3dSb290KCkge1xyXG4gIGNvbnN0IGVsID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHVzZUhvc3QoXCJ1c2VTaGFkb3dSb290XCIpIDogdXNlSG9zdCgpO1xyXG4gIHJldHVybiBlbCAmJiBlbC5zaGFkb3dSb290O1xyXG59XHJcblxyXG5mdW5jdGlvbiB1c2VDc3NNb2R1bGUobmFtZSA9IFwiJHN0eWxlXCIpIHtcclxuICB7XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgaWYgKCFpbnN0YW5jZSkge1xyXG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYHVzZUNzc01vZHVsZSBtdXN0IGJlIGNhbGxlZCBpbnNpZGUgc2V0dXAoKWApO1xyXG4gICAgICByZXR1cm4gRU1QVFlfT0JKO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbW9kdWxlcyA9IGluc3RhbmNlLnR5cGUuX19jc3NNb2R1bGVzO1xyXG4gICAgaWYgKCFtb2R1bGVzKSB7XHJcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgQ3VycmVudCBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIENTUyBtb2R1bGVzIGluamVjdGVkLmApO1xyXG4gICAgICByZXR1cm4gRU1QVFlfT0JKO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbW9kID0gbW9kdWxlc1tuYW1lXTtcclxuICAgIGlmICghbW9kKSB7XHJcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgQ3VycmVudCBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIENTUyBtb2R1bGUgbmFtZWQgXCIke25hbWV9XCIuYCk7XHJcbiAgICAgIHJldHVybiBFTVBUWV9PQko7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbW9kO1xyXG4gIH1cclxufVxyXG5cclxuY29uc3QgcG9zaXRpb25NYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcclxuY29uc3QgbmV3UG9zaXRpb25NYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcclxuY29uc3QgbW92ZUNiS2V5ID0gU3ltYm9sKFwiX21vdmVDYlwiKTtcclxuY29uc3QgZW50ZXJDYktleSA9IFN5bWJvbChcIl9lbnRlckNiXCIpO1xyXG5jb25zdCBkZWNvcmF0ZSA9ICh0KSA9PiB7XHJcbiAgZGVsZXRlIHQucHJvcHMubW9kZTtcclxuICByZXR1cm4gdDtcclxufTtcclxuY29uc3QgVHJhbnNpdGlvbkdyb3VwSW1wbCA9IC8qIEBfX1BVUkVfXyAqLyBkZWNvcmF0ZSh7XHJcbiAgbmFtZTogXCJUcmFuc2l0aW9uR3JvdXBcIixcclxuICBwcm9wczogLyogQF9fUFVSRV9fICovIGV4dGVuZCh7fSwgVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycywge1xyXG4gICAgdGFnOiBTdHJpbmcsXHJcbiAgICBtb3ZlQ2xhc3M6IFN0cmluZ1xyXG4gIH0pLFxyXG4gIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcclxuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICBjb25zdCBzdGF0ZSA9IHVzZVRyYW5zaXRpb25TdGF0ZSgpO1xyXG4gICAgbGV0IHByZXZDaGlsZHJlbjtcclxuICAgIGxldCBjaGlsZHJlbjtcclxuICAgIG9uVXBkYXRlZCgoKSA9PiB7XHJcbiAgICAgIGlmICghcHJldkNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBtb3ZlQ2xhc3MgPSBwcm9wcy5tb3ZlQ2xhc3MgfHwgYCR7cHJvcHMubmFtZSB8fCBcInZcIn0tbW92ZWA7XHJcbiAgICAgIGlmICghaGFzQ1NTVHJhbnNmb3JtKFxyXG4gICAgICAgIHByZXZDaGlsZHJlblswXS5lbCxcclxuICAgICAgICBpbnN0YW5jZS52bm9kZS5lbCxcclxuICAgICAgICBtb3ZlQ2xhc3NcclxuICAgICAgKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBwcmV2Q2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XHJcbiAgICAgIHByZXZDaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcclxuICAgICAgY29uc3QgbW92ZWRDaGlsZHJlbiA9IHByZXZDaGlsZHJlbi5maWx0ZXIoYXBwbHlUcmFuc2xhdGlvbik7XHJcbiAgICAgIGZvcmNlUmVmbG93KCk7XHJcbiAgICAgIG1vdmVkQ2hpbGRyZW4uZm9yRWFjaCgoYykgPT4ge1xyXG4gICAgICAgIGNvbnN0IGVsID0gYy5lbDtcclxuICAgICAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xyXG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcclxuICAgICAgICBzdHlsZS50cmFuc2Zvcm0gPSBzdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBzdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBcIlwiO1xyXG4gICAgICAgIGNvbnN0IGNiID0gZWxbbW92ZUNiS2V5XSA9IChlKSA9PiB7XHJcbiAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xyXG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCBjYik7XHJcbiAgICAgICAgICAgIGVsW21vdmVDYktleV0gPSBudWxsO1xyXG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCBjYik7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcclxuICAgICAgY29uc3QgY3NzVHJhbnNpdGlvblByb3BzID0gcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhyYXdQcm9wcyk7XHJcbiAgICAgIGxldCB0YWcgPSByYXdQcm9wcy50YWcgfHwgRnJhZ21lbnQ7XHJcbiAgICAgIHByZXZDaGlsZHJlbiA9IFtdO1xyXG4gICAgICBpZiAoY2hpbGRyZW4pIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgaWYgKGNoaWxkLmVsICYmIGNoaWxkLmVsIGluc3RhbmNlb2YgRWxlbWVudCkge1xyXG4gICAgICAgICAgICBwcmV2Q2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhcclxuICAgICAgICAgICAgICBjaGlsZCxcclxuICAgICAgICAgICAgICByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKFxyXG4gICAgICAgICAgICAgICAgY2hpbGQsXHJcbiAgICAgICAgICAgICAgICBjc3NUcmFuc2l0aW9uUHJvcHMsXHJcbiAgICAgICAgICAgICAgICBzdGF0ZSxcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlXHJcbiAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQoXHJcbiAgICAgICAgICAgICAgY2hpbGQsXHJcbiAgICAgICAgICAgICAgY2hpbGQuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ID8gZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKHNsb3RzLmRlZmF1bHQoKSkgOiBbXTtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgaWYgKGNoaWxkLmtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3MoXHJcbiAgICAgICAgICAgIGNoaWxkLFxyXG4gICAgICAgICAgICByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKGNoaWxkLCBjc3NUcmFuc2l0aW9uUHJvcHMsIHN0YXRlLCBpbnN0YW5jZSlcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNoaWxkLnR5cGUgIT09IFRleHQpIHtcclxuICAgICAgICAgIHdhcm4oYDxUcmFuc2l0aW9uR3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0YWcsIG51bGwsIGNoaWxkcmVuKTtcclxuICAgIH07XHJcbiAgfVxyXG59KTtcclxuY29uc3QgVHJhbnNpdGlvbkdyb3VwID0gVHJhbnNpdGlvbkdyb3VwSW1wbDtcclxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMoYykge1xyXG4gIGNvbnN0IGVsID0gYy5lbDtcclxuICBpZiAoZWxbbW92ZUNiS2V5XSkge1xyXG4gICAgZWxbbW92ZUNiS2V5XSgpO1xyXG4gIH1cclxuICBpZiAoZWxbZW50ZXJDYktleV0pIHtcclxuICAgIGVsW2VudGVyQ2JLZXldKCk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uKGMpIHtcclxuICBuZXdQb3NpdGlvbk1hcC5zZXQoYywgYy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbihjKSB7XHJcbiAgY29uc3Qgb2xkUG9zID0gcG9zaXRpb25NYXAuZ2V0KGMpO1xyXG4gIGNvbnN0IG5ld1BvcyA9IG5ld1Bvc2l0aW9uTWFwLmdldChjKTtcclxuICBjb25zdCBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XHJcbiAgY29uc3QgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcclxuICBpZiAoZHggfHwgZHkpIHtcclxuICAgIGNvbnN0IHMgPSBjLmVsLnN0eWxlO1xyXG4gICAgcy50cmFuc2Zvcm0gPSBzLndlYmtpdFRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtkeH1weCwke2R5fXB4KWA7XHJcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9IFwiMHNcIjtcclxuICAgIHJldHVybiBjO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBoYXNDU1NUcmFuc2Zvcm0oZWwsIHJvb3QsIG1vdmVDbGFzcykge1xyXG4gIGNvbnN0IGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XHJcbiAgY29uc3QgX3Z0YyA9IGVsW3Z0Y0tleV07XHJcbiAgaWYgKF92dGMpIHtcclxuICAgIF92dGMuZm9yRWFjaCgoY2xzKSA9PiB7XHJcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goKGMpID0+IGMgJiYgY2xvbmUuY2xhc3NMaXN0LnJlbW92ZShjKSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgbW92ZUNsYXNzLnNwbGl0KC9cXHMrLykuZm9yRWFjaCgoYykgPT4gYyAmJiBjbG9uZS5jbGFzc0xpc3QuYWRkKGMpKTtcclxuICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbiAgY29uc3QgY29udGFpbmVyID0gcm9vdC5ub2RlVHlwZSA9PT0gMSA/IHJvb3QgOiByb290LnBhcmVudE5vZGU7XHJcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNsb25lKTtcclxuICBjb25zdCB7IGhhc1RyYW5zZm9ybSB9ID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xyXG4gIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjbG9uZSk7XHJcbiAgcmV0dXJuIGhhc1RyYW5zZm9ybTtcclxufVxyXG5cclxuY29uc3QgZ2V0TW9kZWxBc3NpZ25lciA9ICh2bm9kZSkgPT4ge1xyXG4gIGNvbnN0IGZuID0gdm5vZGUucHJvcHNbXCJvblVwZGF0ZTptb2RlbFZhbHVlXCJdIHx8IGZhbHNlO1xyXG4gIHJldHVybiBpc0FycmF5KGZuKSA/ICh2YWx1ZSkgPT4gaW52b2tlQXJyYXlGbnMoZm4sIHZhbHVlKSA6IGZuO1xyXG59O1xyXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQoZSkge1xyXG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XHJcbn1cclxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZChlKSB7XHJcbiAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XHJcbiAgaWYgKHRhcmdldC5jb21wb3NpbmcpIHtcclxuICAgIHRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcclxuICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImlucHV0XCIpKTtcclxuICB9XHJcbn1cclxuY29uc3QgYXNzaWduS2V5ID0gU3ltYm9sKFwiX2Fzc2lnblwiKTtcclxuY29uc3Qgdk1vZGVsVGV4dCA9IHtcclxuICBjcmVhdGVkKGVsLCB7IG1vZGlmaWVyczogeyBsYXp5LCB0cmltLCBudW1iZXIgfSB9LCB2bm9kZSkge1xyXG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgY29uc3QgY2FzdFRvTnVtYmVyID0gbnVtYmVyIHx8IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGUgPT09IFwibnVtYmVyXCI7XHJcbiAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBsYXp5ID8gXCJjaGFuZ2VcIiA6IFwiaW5wdXRcIiwgKGUpID0+IHtcclxuICAgICAgaWYgKGUudGFyZ2V0LmNvbXBvc2luZykgcmV0dXJuO1xyXG4gICAgICBsZXQgZG9tVmFsdWUgPSBlbC52YWx1ZTtcclxuICAgICAgaWYgKHRyaW0pIHtcclxuICAgICAgICBkb21WYWx1ZSA9IGRvbVZhbHVlLnRyaW0oKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY2FzdFRvTnVtYmVyKSB7XHJcbiAgICAgICAgZG9tVmFsdWUgPSBsb29zZVRvTnVtYmVyKGRvbVZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgICBlbFthc3NpZ25LZXldKGRvbVZhbHVlKTtcclxuICAgIH0pO1xyXG4gICAgaWYgKHRyaW0pIHtcclxuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgKCkgPT4ge1xyXG4gICAgICAgIGVsLnZhbHVlID0gZWwudmFsdWUudHJpbSgpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmICghbGF6eSkge1xyXG4gICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNvbXBvc2l0aW9uc3RhcnRcIiwgb25Db21wb3NpdGlvblN0YXJ0KTtcclxuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjb21wb3NpdGlvbmVuZFwiLCBvbkNvbXBvc2l0aW9uRW5kKTtcclxuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgb25Db21wb3NpdGlvbkVuZCk7XHJcbiAgICB9XHJcbiAgfSxcclxuICAvLyBzZXQgdmFsdWUgb24gbW91bnRlZCBzbyBpdCdzIGFmdGVyIG1pbi9tYXggZm9yIHR5cGU9XCJyYW5nZVwiXHJcbiAgbW91bnRlZChlbCwgeyB2YWx1ZSB9KSB7XHJcbiAgICBlbC52YWx1ZSA9IHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWU7XHJcbiAgfSxcclxuICBiZWZvcmVVcGRhdGUoZWwsIHsgdmFsdWUsIG9sZFZhbHVlLCBtb2RpZmllcnM6IHsgbGF6eSwgdHJpbSwgbnVtYmVyIH0gfSwgdm5vZGUpIHtcclxuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgIGlmIChlbC5jb21wb3NpbmcpIHJldHVybjtcclxuICAgIGNvbnN0IGVsVmFsdWUgPSAobnVtYmVyIHx8IGVsLnR5cGUgPT09IFwibnVtYmVyXCIpICYmICEvXjBcXGQvLnRlc3QoZWwudmFsdWUpID8gbG9vc2VUb051bWJlcihlbC52YWx1ZSkgOiBlbC52YWx1ZTtcclxuICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTtcclxuICAgIGlmIChlbFZhbHVlID09PSBuZXdWYWx1ZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZWwgJiYgZWwudHlwZSAhPT0gXCJyYW5nZVwiKSB7XHJcbiAgICAgIGlmIChsYXp5ICYmIHZhbHVlID09PSBvbGRWYWx1ZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHJpbSAmJiBlbC52YWx1ZS50cmltKCkgPT09IG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xyXG4gIH1cclxufTtcclxuY29uc3Qgdk1vZGVsQ2hlY2tib3ggPSB7XHJcbiAgLy8gIzQwOTYgYXJyYXkgY2hlY2tib3hlcyBuZWVkIHRvIGJlIGRlZXAgdHJhdmVyc2VkXHJcbiAgZGVlcDogdHJ1ZSxcclxuICBjcmVhdGVkKGVsLCBfLCB2bm9kZSkge1xyXG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgKCkgPT4ge1xyXG4gICAgICBjb25zdCBtb2RlbFZhbHVlID0gZWwuX21vZGVsVmFsdWU7XHJcbiAgICAgIGNvbnN0IGVsZW1lbnRWYWx1ZSA9IGdldFZhbHVlKGVsKTtcclxuICAgICAgY29uc3QgY2hlY2tlZCA9IGVsLmNoZWNrZWQ7XHJcbiAgICAgIGNvbnN0IGFzc2lnbiA9IGVsW2Fzc2lnbktleV07XHJcbiAgICAgIGlmIChpc0FycmF5KG1vZGVsVmFsdWUpKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBsb29zZUluZGV4T2YobW9kZWxWYWx1ZSwgZWxlbWVudFZhbHVlKTtcclxuICAgICAgICBjb25zdCBmb3VuZCA9IGluZGV4ICE9PSAtMTtcclxuICAgICAgICBpZiAoY2hlY2tlZCAmJiAhZm91bmQpIHtcclxuICAgICAgICAgIGFzc2lnbihtb2RlbFZhbHVlLmNvbmNhdChlbGVtZW50VmFsdWUpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCFjaGVja2VkICYmIGZvdW5kKSB7XHJcbiAgICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IFsuLi5tb2RlbFZhbHVlXTtcclxuICAgICAgICAgIGZpbHRlcmVkLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICBhc3NpZ24oZmlsdGVyZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChpc1NldChtb2RlbFZhbHVlKSkge1xyXG4gICAgICAgIGNvbnN0IGNsb25lZCA9IG5ldyBTZXQobW9kZWxWYWx1ZSk7XHJcbiAgICAgICAgaWYgKGNoZWNrZWQpIHtcclxuICAgICAgICAgIGNsb25lZC5hZGQoZWxlbWVudFZhbHVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY2xvbmVkLmRlbGV0ZShlbGVtZW50VmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NpZ24oY2xvbmVkKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhc3NpZ24oZ2V0Q2hlY2tib3hWYWx1ZShlbCwgY2hlY2tlZCkpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9LFxyXG4gIC8vIHNldCBpbml0aWFsIGNoZWNrZWQgb24gbW91bnQgdG8gd2FpdCBmb3IgdHJ1ZS12YWx1ZS9mYWxzZS12YWx1ZVxyXG4gIG1vdW50ZWQ6IHNldENoZWNrZWQsXHJcbiAgYmVmb3JlVXBkYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xyXG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgc2V0Q2hlY2tlZChlbCwgYmluZGluZywgdm5vZGUpO1xyXG4gIH1cclxufTtcclxuZnVuY3Rpb24gc2V0Q2hlY2tlZChlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgdm5vZGUpIHtcclxuICBlbC5fbW9kZWxWYWx1ZSA9IHZhbHVlO1xyXG4gIGxldCBjaGVja2VkO1xyXG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgY2hlY2tlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpID4gLTE7XHJcbiAgfSBlbHNlIGlmIChpc1NldCh2YWx1ZSkpIHtcclxuICAgIGNoZWNrZWQgPSB2YWx1ZS5oYXModm5vZGUucHJvcHMudmFsdWUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAodmFsdWUgPT09IG9sZFZhbHVlKSByZXR1cm47XHJcbiAgICBjaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgZ2V0Q2hlY2tib3hWYWx1ZShlbCwgdHJ1ZSkpO1xyXG4gIH1cclxuICBpZiAoZWwuY2hlY2tlZCAhPT0gY2hlY2tlZCkge1xyXG4gICAgZWwuY2hlY2tlZCA9IGNoZWNrZWQ7XHJcbiAgfVxyXG59XHJcbmNvbnN0IHZNb2RlbFJhZGlvID0ge1xyXG4gIGNyZWF0ZWQoZWwsIHsgdmFsdWUgfSwgdm5vZGUpIHtcclxuICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSk7XHJcbiAgICBlbFthc3NpZ25LZXldID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNoYW5nZVwiLCAoKSA9PiB7XHJcbiAgICAgIGVsW2Fzc2lnbktleV0oZ2V0VmFsdWUoZWwpKTtcclxuICAgIH0pO1xyXG4gIH0sXHJcbiAgYmVmb3JlVXBkYXRlKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xyXG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xyXG4gICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuY29uc3Qgdk1vZGVsU2VsZWN0ID0ge1xyXG4gIC8vIDxzZWxlY3QgbXVsdGlwbGU+IHZhbHVlIG5lZWQgdG8gYmUgZGVlcCB0cmF2ZXJzZWRcclxuICBkZWVwOiB0cnVlLFxyXG4gIGNyZWF0ZWQoZWwsIHsgdmFsdWUsIG1vZGlmaWVyczogeyBudW1iZXIgfSB9LCB2bm9kZSkge1xyXG4gICAgY29uc3QgaXNTZXRNb2RlbCA9IGlzU2V0KHZhbHVlKTtcclxuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsICgpID0+IHtcclxuICAgICAgY29uc3Qgc2VsZWN0ZWRWYWwgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoZWwub3B0aW9ucywgKG8pID0+IG8uc2VsZWN0ZWQpLm1hcChcclxuICAgICAgICAobykgPT4gbnVtYmVyID8gbG9vc2VUb051bWJlcihnZXRWYWx1ZShvKSkgOiBnZXRWYWx1ZShvKVxyXG4gICAgICApO1xyXG4gICAgICBlbFthc3NpZ25LZXldKFxyXG4gICAgICAgIGVsLm11bHRpcGxlID8gaXNTZXRNb2RlbCA/IG5ldyBTZXQoc2VsZWN0ZWRWYWwpIDogc2VsZWN0ZWRWYWwgOiBzZWxlY3RlZFZhbFswXVxyXG4gICAgICApO1xyXG4gICAgICBlbC5fYXNzaWduaW5nID0gdHJ1ZTtcclxuICAgICAgbmV4dFRpY2soKCkgPT4ge1xyXG4gICAgICAgIGVsLl9hc3NpZ25pbmcgPSBmYWxzZTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICB9LFxyXG4gIC8vIHNldCB2YWx1ZSBpbiBtb3VudGVkICYgdXBkYXRlZCBiZWNhdXNlIDxzZWxlY3Q+IHJlbGllcyBvbiBpdHMgY2hpbGRyZW5cclxuICAvLyA8b3B0aW9uPnMuXHJcbiAgbW91bnRlZChlbCwgeyB2YWx1ZSB9KSB7XHJcbiAgICBzZXRTZWxlY3RlZChlbCwgdmFsdWUpO1xyXG4gIH0sXHJcbiAgYmVmb3JlVXBkYXRlKGVsLCBfYmluZGluZywgdm5vZGUpIHtcclxuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICB9LFxyXG4gIHVwZGF0ZWQoZWwsIHsgdmFsdWUgfSkge1xyXG4gICAgaWYgKCFlbC5fYXNzaWduaW5nKSB7XHJcbiAgICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5mdW5jdGlvbiBzZXRTZWxlY3RlZChlbCwgdmFsdWUpIHtcclxuICBjb25zdCBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XHJcbiAgY29uc3QgaXNBcnJheVZhbHVlID0gaXNBcnJheSh2YWx1ZSk7XHJcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIWlzQXJyYXlWYWx1ZSAmJiAhaXNTZXQodmFsdWUpKSB7XHJcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oXHJcbiAgICAgIGA8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw+IGV4cGVjdHMgYW4gQXJyYXkgb3IgU2V0IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCAke09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpfS5gXHJcbiAgICApO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBmb3IgKGxldCBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICBjb25zdCBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xyXG4gICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBnZXRWYWx1ZShvcHRpb24pO1xyXG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcclxuICAgICAgaWYgKGlzQXJyYXlWYWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvblR5cGUgPSB0eXBlb2Ygb3B0aW9uVmFsdWU7XHJcbiAgICAgICAgaWYgKG9wdGlvblR5cGUgPT09IFwic3RyaW5nXCIgfHwgb3B0aW9uVHlwZSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdmFsdWUuc29tZSgodikgPT4gU3RyaW5nKHYpID09PSBTdHJpbmcob3B0aW9uVmFsdWUpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBvcHRpb25WYWx1ZSkgPiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdmFsdWUuaGFzKG9wdGlvblZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xyXG4gICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKCFpc011bHRpcGxlICYmIGVsLnNlbGVjdGVkSW5kZXggIT09IC0xKSB7XHJcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFZhbHVlKGVsKSB7XHJcbiAgcmV0dXJuIFwiX3ZhbHVlXCIgaW4gZWwgPyBlbC5fdmFsdWUgOiBlbC52YWx1ZTtcclxufVxyXG5mdW5jdGlvbiBnZXRDaGVja2JveFZhbHVlKGVsLCBjaGVja2VkKSB7XHJcbiAgY29uc3Qga2V5ID0gY2hlY2tlZCA/IFwiX3RydWVWYWx1ZVwiIDogXCJfZmFsc2VWYWx1ZVwiO1xyXG4gIHJldHVybiBrZXkgaW4gZWwgPyBlbFtrZXldIDogY2hlY2tlZDtcclxufVxyXG5jb25zdCB2TW9kZWxEeW5hbWljID0ge1xyXG4gIGNyZWF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XHJcbiAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgbnVsbCwgXCJjcmVhdGVkXCIpO1xyXG4gIH0sXHJcbiAgbW91bnRlZChlbCwgYmluZGluZywgdm5vZGUpIHtcclxuICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBudWxsLCBcIm1vdW50ZWRcIik7XHJcbiAgfSxcclxuICBiZWZvcmVVcGRhdGUoZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpIHtcclxuICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsIFwiYmVmb3JlVXBkYXRlXCIpO1xyXG4gIH0sXHJcbiAgdXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSkge1xyXG4gICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgXCJ1cGRhdGVkXCIpO1xyXG4gIH1cclxufTtcclxuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNNb2RlbCh0YWdOYW1lLCB0eXBlKSB7XHJcbiAgc3dpdGNoICh0YWdOYW1lKSB7XHJcbiAgICBjYXNlIFwiU0VMRUNUXCI6XHJcbiAgICAgIHJldHVybiB2TW9kZWxTZWxlY3Q7XHJcbiAgICBjYXNlIFwiVEVYVEFSRUFcIjpcclxuICAgICAgcmV0dXJuIHZNb2RlbFRleHQ7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICBjYXNlIFwiY2hlY2tib3hcIjpcclxuICAgICAgICAgIHJldHVybiB2TW9kZWxDaGVja2JveDtcclxuICAgICAgICBjYXNlIFwicmFkaW9cIjpcclxuICAgICAgICAgIHJldHVybiB2TW9kZWxSYWRpbztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgcmV0dXJuIHZNb2RlbFRleHQ7XHJcbiAgICAgIH1cclxuICB9XHJcbn1cclxuZnVuY3Rpb24gY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgaG9vaykge1xyXG4gIGNvbnN0IG1vZGVsVG9Vc2UgPSByZXNvbHZlRHluYW1pY01vZGVsKFxyXG4gICAgZWwudGFnTmFtZSxcclxuICAgIHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGVcclxuICApO1xyXG4gIGNvbnN0IGZuID0gbW9kZWxUb1VzZVtob29rXTtcclxuICBmbiAmJiBmbihlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSk7XHJcbn1cclxuZnVuY3Rpb24gaW5pdFZNb2RlbEZvclNTUigpIHtcclxuICB2TW9kZWxUZXh0LmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSkgPT4gKHsgdmFsdWUgfSk7XHJcbiAgdk1vZGVsUmFkaW8uZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9LCB2bm9kZSkgPT4ge1xyXG4gICAgaWYgKHZub2RlLnByb3BzICYmIGxvb3NlRXF1YWwodm5vZGUucHJvcHMudmFsdWUsIHZhbHVlKSkge1xyXG4gICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XHJcbiAgICB9XHJcbiAgfTtcclxuICB2TW9kZWxDaGVja2JveC5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0sIHZub2RlKSA9PiB7XHJcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgaWYgKHZub2RlLnByb3BzICYmIGxvb3NlSW5kZXhPZih2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpID4gLTEpIHtcclxuICAgICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoaXNTZXQodmFsdWUpKSB7XHJcbiAgICAgIGlmICh2bm9kZS5wcm9wcyAmJiB2YWx1ZS5oYXModm5vZGUucHJvcHMudmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcclxuICAgIH1cclxuICB9O1xyXG4gIHZNb2RlbER5bmFtaWMuZ2V0U1NSUHJvcHMgPSAoYmluZGluZywgdm5vZGUpID0+IHtcclxuICAgIGlmICh0eXBlb2Ygdm5vZGUudHlwZSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBtb2RlbFRvVXNlID0gcmVzb2x2ZUR5bmFtaWNNb2RlbChcclxuICAgICAgLy8gcmVzb2x2ZUR5bmFtaWNNb2RlbCBleHBlY3RzIGFuIHVwcGVyY2FzZSB0YWcgbmFtZSwgYnV0IHZub2RlLnR5cGUgaXMgbG93ZXJjYXNlXHJcbiAgICAgIHZub2RlLnR5cGUudG9VcHBlckNhc2UoKSxcclxuICAgICAgdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZVxyXG4gICAgKTtcclxuICAgIGlmIChtb2RlbFRvVXNlLmdldFNTUlByb3BzKSB7XHJcbiAgICAgIHJldHVybiBtb2RlbFRvVXNlLmdldFNTUlByb3BzKGJpbmRpbmcsIHZub2RlKTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG5jb25zdCBzeXN0ZW1Nb2RpZmllcnMgPSBbXCJjdHJsXCIsIFwic2hpZnRcIiwgXCJhbHRcIiwgXCJtZXRhXCJdO1xyXG5jb25zdCBtb2RpZmllckd1YXJkcyA9IHtcclxuICBzdG9wOiAoZSkgPT4gZS5zdG9wUHJvcGFnYXRpb24oKSxcclxuICBwcmV2ZW50OiAoZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpLFxyXG4gIHNlbGY6IChlKSA9PiBlLnRhcmdldCAhPT0gZS5jdXJyZW50VGFyZ2V0LFxyXG4gIGN0cmw6IChlKSA9PiAhZS5jdHJsS2V5LFxyXG4gIHNoaWZ0OiAoZSkgPT4gIWUuc2hpZnRLZXksXHJcbiAgYWx0OiAoZSkgPT4gIWUuYWx0S2V5LFxyXG4gIG1ldGE6IChlKSA9PiAhZS5tZXRhS2V5LFxyXG4gIGxlZnQ6IChlKSA9PiBcImJ1dHRvblwiIGluIGUgJiYgZS5idXR0b24gIT09IDAsXHJcbiAgbWlkZGxlOiAoZSkgPT4gXCJidXR0b25cIiBpbiBlICYmIGUuYnV0dG9uICE9PSAxLFxyXG4gIHJpZ2h0OiAoZSkgPT4gXCJidXR0b25cIiBpbiBlICYmIGUuYnV0dG9uICE9PSAyLFxyXG4gIGV4YWN0OiAoZSwgbW9kaWZpZXJzKSA9PiBzeXN0ZW1Nb2RpZmllcnMuc29tZSgobSkgPT4gZVtgJHttfUtleWBdICYmICFtb2RpZmllcnMuaW5jbHVkZXMobSkpXHJcbn07XHJcbmNvbnN0IHdpdGhNb2RpZmllcnMgPSAoZm4sIG1vZGlmaWVycykgPT4ge1xyXG4gIGNvbnN0IGNhY2hlID0gZm4uX3dpdGhNb2RzIHx8IChmbi5fd2l0aE1vZHMgPSB7fSk7XHJcbiAgY29uc3QgY2FjaGVLZXkgPSBtb2RpZmllcnMuam9pbihcIi5cIik7XHJcbiAgcmV0dXJuIGNhY2hlW2NhY2hlS2V5XSB8fCAoY2FjaGVbY2FjaGVLZXldID0gKGV2ZW50LCAuLi5hcmdzKSA9PiB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBndWFyZCA9IG1vZGlmaWVyR3VhcmRzW21vZGlmaWVyc1tpXV07XHJcbiAgICAgIGlmIChndWFyZCAmJiBndWFyZChldmVudCwgbW9kaWZpZXJzKSkgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZuKGV2ZW50LCAuLi5hcmdzKTtcclxuICB9KTtcclxufTtcclxuY29uc3Qga2V5TmFtZXMgPSB7XHJcbiAgZXNjOiBcImVzY2FwZVwiLFxyXG4gIHNwYWNlOiBcIiBcIixcclxuICB1cDogXCJhcnJvdy11cFwiLFxyXG4gIGxlZnQ6IFwiYXJyb3ctbGVmdFwiLFxyXG4gIHJpZ2h0OiBcImFycm93LXJpZ2h0XCIsXHJcbiAgZG93bjogXCJhcnJvdy1kb3duXCIsXHJcbiAgZGVsZXRlOiBcImJhY2tzcGFjZVwiXHJcbn07XHJcbmNvbnN0IHdpdGhLZXlzID0gKGZuLCBtb2RpZmllcnMpID0+IHtcclxuICBjb25zdCBjYWNoZSA9IGZuLl93aXRoS2V5cyB8fCAoZm4uX3dpdGhLZXlzID0ge30pO1xyXG4gIGNvbnN0IGNhY2hlS2V5ID0gbW9kaWZpZXJzLmpvaW4oXCIuXCIpO1xyXG4gIHJldHVybiBjYWNoZVtjYWNoZUtleV0gfHwgKGNhY2hlW2NhY2hlS2V5XSA9IChldmVudCkgPT4ge1xyXG4gICAgaWYgKCEoXCJrZXlcIiBpbiBldmVudCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZXZlbnRLZXkgPSBoeXBoZW5hdGUoZXZlbnQua2V5KTtcclxuICAgIGlmIChtb2RpZmllcnMuc29tZShcclxuICAgICAgKGspID0+IGsgPT09IGV2ZW50S2V5IHx8IGtleU5hbWVzW2tdID09PSBldmVudEtleVxyXG4gICAgKSkge1xyXG4gICAgICByZXR1cm4gZm4oZXZlbnQpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59O1xyXG5cclxuY29uc3QgcmVuZGVyZXJPcHRpb25zID0gLyogQF9fUFVSRV9fICovIGV4dGVuZCh7IHBhdGNoUHJvcCB9LCBub2RlT3BzKTtcclxubGV0IHJlbmRlcmVyO1xyXG5sZXQgZW5hYmxlZEh5ZHJhdGlvbiA9IGZhbHNlO1xyXG5mdW5jdGlvbiBlbnN1cmVSZW5kZXJlcigpIHtcclxuICByZXR1cm4gcmVuZGVyZXIgfHwgKHJlbmRlcmVyID0gY3JlYXRlUmVuZGVyZXIocmVuZGVyZXJPcHRpb25zKSk7XHJcbn1cclxuZnVuY3Rpb24gZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKSB7XHJcbiAgcmVuZGVyZXIgPSBlbmFibGVkSHlkcmF0aW9uID8gcmVuZGVyZXIgOiBjcmVhdGVIeWRyYXRpb25SZW5kZXJlcihyZW5kZXJlck9wdGlvbnMpO1xyXG4gIGVuYWJsZWRIeWRyYXRpb24gPSB0cnVlO1xyXG4gIHJldHVybiByZW5kZXJlcjtcclxufVxyXG5jb25zdCByZW5kZXIgPSAoLi4uYXJncykgPT4ge1xyXG4gIGVuc3VyZVJlbmRlcmVyKCkucmVuZGVyKC4uLmFyZ3MpO1xyXG59O1xyXG5jb25zdCBoeWRyYXRlID0gKC4uLmFyZ3MpID0+IHtcclxuICBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpLmh5ZHJhdGUoLi4uYXJncyk7XHJcbn07XHJcbmNvbnN0IGNyZWF0ZUFwcCA9ICguLi5hcmdzKSA9PiB7XHJcbiAgY29uc3QgYXBwID0gZW5zdXJlUmVuZGVyZXIoKS5jcmVhdGVBcHAoLi4uYXJncyk7XHJcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICAgIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCk7XHJcbiAgICBpbmplY3RDb21waWxlck9wdGlvbnNDaGVjayhhcHApO1xyXG4gIH1cclxuICBjb25zdCB7IG1vdW50IH0gPSBhcHA7XHJcbiAgYXBwLm1vdW50ID0gKGNvbnRhaW5lck9yU2VsZWN0b3IpID0+IHtcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXJPclNlbGVjdG9yKTtcclxuICAgIGlmICghY29udGFpbmVyKSByZXR1cm47XHJcbiAgICBjb25zdCBjb21wb25lbnQgPSBhcHAuX2NvbXBvbmVudDtcclxuICAgIGlmICghaXNGdW5jdGlvbihjb21wb25lbnQpICYmICFjb21wb25lbnQucmVuZGVyICYmICFjb21wb25lbnQudGVtcGxhdGUpIHtcclxuICAgICAgY29tcG9uZW50LnRlbXBsYXRlID0gY29udGFpbmVyLmlubmVySFRNTDtcclxuICAgIH1cclxuICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IDEpIHtcclxuICAgICAgY29udGFpbmVyLnRleHRDb250ZW50ID0gXCJcIjtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb3h5ID0gbW91bnQoY29udGFpbmVyLCBmYWxzZSwgcmVzb2x2ZVJvb3ROYW1lc3BhY2UoY29udGFpbmVyKSk7XHJcbiAgICBpZiAoY29udGFpbmVyIGluc3RhbmNlb2YgRWxlbWVudCkge1xyXG4gICAgICBjb250YWluZXIucmVtb3ZlQXR0cmlidXRlKFwidi1jbG9ha1wiKTtcclxuICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtdi1hcHBcIiwgXCJcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJveHk7XHJcbiAgfTtcclxuICByZXR1cm4gYXBwO1xyXG59O1xyXG5jb25zdCBjcmVhdGVTU1JBcHAgPSAoLi4uYXJncykgPT4ge1xyXG4gIGNvbnN0IGFwcCA9IGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkuY3JlYXRlQXBwKC4uLmFyZ3MpO1xyXG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XHJcbiAgICBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApO1xyXG4gICAgaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKTtcclxuICB9XHJcbiAgY29uc3QgeyBtb3VudCB9ID0gYXBwO1xyXG4gIGFwcC5tb3VudCA9IChjb250YWluZXJPclNlbGVjdG9yKSA9PiB7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyT3JTZWxlY3Rvcik7XHJcbiAgICBpZiAoY29udGFpbmVyKSB7XHJcbiAgICAgIHJldHVybiBtb3VudChjb250YWluZXIsIHRydWUsIHJlc29sdmVSb290TmFtZXNwYWNlKGNvbnRhaW5lcikpO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgcmV0dXJuIGFwcDtcclxufTtcclxuZnVuY3Rpb24gcmVzb2x2ZVJvb3ROYW1lc3BhY2UoY29udGFpbmVyKSB7XHJcbiAgaWYgKGNvbnRhaW5lciBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIHtcclxuICAgIHJldHVybiBcInN2Z1wiO1xyXG4gIH1cclxuICBpZiAodHlwZW9mIE1hdGhNTEVsZW1lbnQgPT09IFwiZnVuY3Rpb25cIiAmJiBjb250YWluZXIgaW5zdGFuY2VvZiBNYXRoTUxFbGVtZW50KSB7XHJcbiAgICByZXR1cm4gXCJtYXRobWxcIjtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKSB7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsIFwiaXNOYXRpdmVUYWdcIiwge1xyXG4gICAgdmFsdWU6ICh0YWcpID0+IGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHVGFnKHRhZykgfHwgaXNNYXRoTUxUYWcodGFnKSxcclxuICAgIHdyaXRhYmxlOiBmYWxzZVxyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCkge1xyXG4gIGlmIChpc1J1bnRpbWVPbmx5KCkpIHtcclxuICAgIGNvbnN0IGlzQ3VzdG9tRWxlbWVudCA9IGFwcC5jb25maWcuaXNDdXN0b21FbGVtZW50O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsIFwiaXNDdXN0b21FbGVtZW50XCIsIHtcclxuICAgICAgZ2V0KCkge1xyXG4gICAgICAgIHJldHVybiBpc0N1c3RvbUVsZW1lbnQ7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldCgpIHtcclxuICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgYFRoZSBcXGBpc0N1c3RvbUVsZW1lbnRcXGAgY29uZmlnIG9wdGlvbiBpcyBkZXByZWNhdGVkLiBVc2UgXFxgY29tcGlsZXJPcHRpb25zLmlzQ3VzdG9tRWxlbWVudFxcYCBpbnN0ZWFkLmBcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGNvbXBpbGVyT3B0aW9ucyA9IGFwcC5jb25maWcuY29tcGlsZXJPcHRpb25zO1xyXG4gICAgY29uc3QgbXNnID0gYFRoZSBcXGBjb21waWxlck9wdGlvbnNcXGAgY29uZmlnIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIGEgYnVpbGQgb2YgVnVlLmpzIHRoYXQgaW5jbHVkZXMgdGhlIHJ1bnRpbWUgY29tcGlsZXIgKGFrYSBcImZ1bGwgYnVpbGRcIikuIFNpbmNlIHlvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCwgXFxgY29tcGlsZXJPcHRpb25zXFxgIG11c3QgYmUgcGFzc2VkIHRvIFxcYEB2dWUvY29tcGlsZXItZG9tXFxgIGluIHRoZSBidWlsZCBzZXR1cCBpbnN0ZWFkLlxyXG4tIEZvciB2dWUtbG9hZGVyOiBwYXNzIGl0IHZpYSB2dWUtbG9hZGVyJ3MgXFxgY29tcGlsZXJPcHRpb25zXFxgIGxvYWRlciBvcHRpb24uXHJcbi0gRm9yIHZ1ZS1jbGk6IHNlZSBodHRwczovL2NsaS52dWVqcy5vcmcvZ3VpZGUvd2VicGFjay5odG1sI21vZGlmeWluZy1vcHRpb25zLW9mLWEtbG9hZGVyXHJcbi0gRm9yIHZpdGU6IHBhc3MgaXQgdmlhIEB2aXRlanMvcGx1Z2luLXZ1ZSBvcHRpb25zLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpdGVqcy92aXRlLXBsdWdpbi12dWUvdHJlZS9tYWluL3BhY2thZ2VzL3BsdWdpbi12dWUjZXhhbXBsZS1mb3ItcGFzc2luZy1vcHRpb25zLXRvLXZ1ZWNvbXBpbGVyLXNmY2A7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgXCJjb21waWxlck9wdGlvbnNcIiwge1xyXG4gICAgICBnZXQoKSB7XHJcbiAgICAgICAgd2Fybihtc2cpO1xyXG4gICAgICAgIHJldHVybiBjb21waWxlck9wdGlvbnM7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldCgpIHtcclxuICAgICAgICB3YXJuKG1zZyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyKSB7XHJcbiAgaWYgKGlzU3RyaW5nKGNvbnRhaW5lcikpIHtcclxuICAgIGNvbnN0IHJlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyKTtcclxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFyZXMpIHtcclxuICAgICAgd2FybihcclxuICAgICAgICBgRmFpbGVkIHRvIG1vdW50IGFwcDogbW91bnQgdGFyZ2V0IHNlbGVjdG9yIFwiJHtjb250YWluZXJ9XCIgcmV0dXJuZWQgbnVsbC5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG4gIH1cclxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3aW5kb3cuU2hhZG93Um9vdCAmJiBjb250YWluZXIgaW5zdGFuY2VvZiB3aW5kb3cuU2hhZG93Um9vdCAmJiBjb250YWluZXIubW9kZSA9PT0gXCJjbG9zZWRcIikge1xyXG4gICAgd2FybihcclxuICAgICAgYG1vdW50aW5nIG9uIGEgU2hhZG93Um9vdCB3aXRoIFxcYHttb2RlOiBcImNsb3NlZFwifVxcYCBtYXkgbGVhZCB0byB1bnByZWRpY3RhYmxlIGJ1Z3NgXHJcbiAgICApO1xyXG4gIH1cclxuICByZXR1cm4gY29udGFpbmVyO1xyXG59XHJcbmxldCBzc3JEaXJlY3RpdmVJbml0aWFsaXplZCA9IGZhbHNlO1xyXG5jb25zdCBpbml0RGlyZWN0aXZlc0ZvclNTUiA9ICgpID0+IHtcclxuICBpZiAoIXNzckRpcmVjdGl2ZUluaXRpYWxpemVkKSB7XHJcbiAgICBzc3JEaXJlY3RpdmVJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICBpbml0Vk1vZGVsRm9yU1NSKCk7XHJcbiAgICBpbml0VlNob3dGb3JTU1IoKTtcclxuICB9XHJcbn0gO1xyXG5cclxuZXhwb3J0IHsgVHJhbnNpdGlvbiwgVHJhbnNpdGlvbkdyb3VwLCBWdWVFbGVtZW50LCBjcmVhdGVBcHAsIGNyZWF0ZVNTUkFwcCwgZGVmaW5lQ3VzdG9tRWxlbWVudCwgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudCwgaHlkcmF0ZSwgaW5pdERpcmVjdGl2ZXNGb3JTU1IsIHJlbmRlciwgdXNlQ3NzTW9kdWxlLCB1c2VDc3NWYXJzLCB1c2VIb3N0LCB1c2VTaGFkb3dSb290LCB2TW9kZWxDaGVja2JveCwgdk1vZGVsRHluYW1pYywgdk1vZGVsUmFkaW8sIHZNb2RlbFNlbGVjdCwgdk1vZGVsVGV4dCwgdlNob3csIHdpdGhLZXlzLCB3aXRoTW9kaWZpZXJzIH07XHJcbiIsIi8qKlxyXG4qIEB2dWUvc2hhcmVkIHYzLjUuMTNcclxuKiAoYykgMjAxOC1wcmVzZW50IFl1eGkgKEV2YW4pIFlvdSBhbmQgVnVlIGNvbnRyaWJ1dG9yc1xyXG4qIEBsaWNlbnNlIE1JVFxyXG4qKi9cclxuLyohICNfX05PX1NJREVfRUZGRUNUU19fICovXHJcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXHJcbmZ1bmN0aW9uIG1ha2VNYXAoc3RyKSB7XHJcbiAgY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgZm9yIChjb25zdCBrZXkgb2Ygc3RyLnNwbGl0KFwiLFwiKSkgbWFwW2tleV0gPSAxO1xyXG4gIHJldHVybiAodmFsKSA9PiB2YWwgaW4gbWFwO1xyXG59XHJcblxyXG5jb25zdCBFTVBUWV9PQkogPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gT2JqZWN0LmZyZWV6ZSh7fSkgOiB7fTtcclxuY29uc3QgRU1QVFlfQVJSID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IE9iamVjdC5mcmVlemUoW10pIDogW107XHJcbmNvbnN0IE5PT1AgPSAoKSA9PiB7XHJcbn07XHJcbmNvbnN0IE5PID0gKCkgPT4gZmFsc2U7XHJcbmNvbnN0IGlzT24gPSAoa2V5KSA9PiBrZXkuY2hhckNvZGVBdCgwKSA9PT0gMTExICYmIGtleS5jaGFyQ29kZUF0KDEpID09PSAxMTAgJiYgLy8gdXBwZXJjYXNlIGxldHRlclxyXG4oa2V5LmNoYXJDb2RlQXQoMikgPiAxMjIgfHwga2V5LmNoYXJDb2RlQXQoMikgPCA5Nyk7XHJcbmNvbnN0IGlzTW9kZWxMaXN0ZW5lciA9IChrZXkpID0+IGtleS5zdGFydHNXaXRoKFwib25VcGRhdGU6XCIpO1xyXG5jb25zdCBleHRlbmQgPSBPYmplY3QuYXNzaWduO1xyXG5jb25zdCByZW1vdmUgPSAoYXJyLCBlbCkgPT4ge1xyXG4gIGNvbnN0IGkgPSBhcnIuaW5kZXhPZihlbCk7XHJcbiAgaWYgKGkgPiAtMSkge1xyXG4gICAgYXJyLnNwbGljZShpLCAxKTtcclxuICB9XHJcbn07XHJcbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxuY29uc3QgaGFzT3duID0gKHZhbCwga2V5KSA9PiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbCwga2V5KTtcclxuY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XHJcbmNvbnN0IGlzTWFwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBNYXBdXCI7XHJcbmNvbnN0IGlzU2V0ID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBTZXRdXCI7XHJcbmNvbnN0IGlzRGF0ZSA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgRGF0ZV1cIjtcclxuY29uc3QgaXNSZWdFeHAgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIjtcclxuY29uc3QgaXNGdW5jdGlvbiA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIjtcclxuY29uc3QgaXNTdHJpbmcgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiO1xyXG5jb25zdCBpc1N5bWJvbCA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3ltYm9sXCI7XHJcbmNvbnN0IGlzT2JqZWN0ID0gKHZhbCkgPT4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCI7XHJcbmNvbnN0IGlzUHJvbWlzZSA9ICh2YWwpID0+IHtcclxuICByZXR1cm4gKGlzT2JqZWN0KHZhbCkgfHwgaXNGdW5jdGlvbih2YWwpKSAmJiBpc0Z1bmN0aW9uKHZhbC50aGVuKSAmJiBpc0Z1bmN0aW9uKHZhbC5jYXRjaCk7XHJcbn07XHJcbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcclxuY29uc3QgdG9UeXBlU3RyaW5nID0gKHZhbHVlKSA9PiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcclxuY29uc3QgdG9SYXdUeXBlID0gKHZhbHVlKSA9PiB7XHJcbiAgcmV0dXJuIHRvVHlwZVN0cmluZyh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xyXG59O1xyXG5jb25zdCBpc1BsYWluT2JqZWN0ID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XHJcbmNvbnN0IGlzSW50ZWdlcktleSA9IChrZXkpID0+IGlzU3RyaW5nKGtleSkgJiYga2V5ICE9PSBcIk5hTlwiICYmIGtleVswXSAhPT0gXCItXCIgJiYgXCJcIiArIHBhcnNlSW50KGtleSwgMTApID09PSBrZXk7XHJcbmNvbnN0IGlzUmVzZXJ2ZWRQcm9wID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXHJcbiAgLy8gdGhlIGxlYWRpbmcgY29tbWEgaXMgaW50ZW50aW9uYWwgc28gZW1wdHkgc3RyaW5nIFwiXCIgaXMgYWxzbyBpbmNsdWRlZFxyXG4gIFwiLGtleSxyZWYscmVmX2ZvcixyZWZfa2V5LG9uVm5vZGVCZWZvcmVNb3VudCxvblZub2RlTW91bnRlZCxvblZub2RlQmVmb3JlVXBkYXRlLG9uVm5vZGVVcGRhdGVkLG9uVm5vZGVCZWZvcmVVbm1vdW50LG9uVm5vZGVVbm1vdW50ZWRcIlxyXG4pO1xyXG5jb25zdCBpc0J1aWx0SW5EaXJlY3RpdmUgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcclxuICBcImJpbmQsY2xvYWssZWxzZS1pZixlbHNlLGZvcixodG1sLGlmLG1vZGVsLG9uLG9uY2UscHJlLHNob3csc2xvdCx0ZXh0LG1lbW9cIlxyXG4pO1xyXG5jb25zdCBjYWNoZVN0cmluZ0Z1bmN0aW9uID0gKGZuKSA9PiB7XHJcbiAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICByZXR1cm4gKHN0cikgPT4ge1xyXG4gICAgY29uc3QgaGl0ID0gY2FjaGVbc3RyXTtcclxuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcclxuICB9O1xyXG59O1xyXG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xyXG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oXHJcbiAgKHN0cikgPT4ge1xyXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiBjID8gYy50b1VwcGVyQ2FzZSgpIDogXCJcIik7XHJcbiAgfVxyXG4pO1xyXG5jb25zdCBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XHJcbmNvbnN0IGh5cGhlbmF0ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oXHJcbiAgKHN0cikgPT4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKClcclxuKTtcclxuY29uc3QgY2FwaXRhbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4ge1xyXG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XHJcbn0pO1xyXG5jb25zdCB0b0hhbmRsZXJLZXkgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKFxyXG4gIChzdHIpID0+IHtcclxuICAgIGNvbnN0IHMgPSBzdHIgPyBgb24ke2NhcGl0YWxpemUoc3RyKX1gIDogYGA7XHJcbiAgICByZXR1cm4gcztcclxuICB9XHJcbik7XHJcbmNvbnN0IGhhc0NoYW5nZWQgPSAodmFsdWUsIG9sZFZhbHVlKSA9PiAhT2JqZWN0LmlzKHZhbHVlLCBvbGRWYWx1ZSk7XHJcbmNvbnN0IGludm9rZUFycmF5Rm5zID0gKGZucywgLi4uYXJnKSA9PiB7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcclxuICAgIGZuc1tpXSguLi5hcmcpO1xyXG4gIH1cclxufTtcclxuY29uc3QgZGVmID0gKG9iaiwga2V5LCB2YWx1ZSwgd3JpdGFibGUgPSBmYWxzZSkgPT4ge1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICB3cml0YWJsZSxcclxuICAgIHZhbHVlXHJcbiAgfSk7XHJcbn07XHJcbmNvbnN0IGxvb3NlVG9OdW1iZXIgPSAodmFsKSA9PiB7XHJcbiAgY29uc3QgbiA9IHBhcnNlRmxvYXQodmFsKTtcclxuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuO1xyXG59O1xyXG5jb25zdCB0b051bWJlciA9ICh2YWwpID0+IHtcclxuICBjb25zdCBuID0gaXNTdHJpbmcodmFsKSA/IE51bWJlcih2YWwpIDogTmFOO1xyXG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XHJcbn07XHJcbmxldCBfZ2xvYmFsVGhpcztcclxuY29uc3QgZ2V0R2xvYmFsVGhpcyA9ICgpID0+IHtcclxuICByZXR1cm4gX2dsb2JhbFRoaXMgfHwgKF9nbG9iYWxUaGlzID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSk7XHJcbn07XHJcbmNvbnN0IGlkZW50UkUgPSAvXltfJGEtekEtWlxceEEwLVxcdUZGRkZdW18kYS16QS1aMC05XFx4QTAtXFx1RkZGRl0qJC87XHJcbmZ1bmN0aW9uIGdlblByb3BzQWNjZXNzRXhwKG5hbWUpIHtcclxuICByZXR1cm4gaWRlbnRSRS50ZXN0KG5hbWUpID8gYF9fcHJvcHMuJHtuYW1lfWAgOiBgX19wcm9wc1ske0pTT04uc3RyaW5naWZ5KG5hbWUpfV1gO1xyXG59XHJcbmZ1bmN0aW9uIGdlbkNhY2hlS2V5KHNvdXJjZSwgb3B0aW9ucykge1xyXG4gIHJldHVybiBzb3VyY2UgKyBKU09OLnN0cmluZ2lmeShcclxuICAgIG9wdGlvbnMsXHJcbiAgICAoXywgdmFsKSA9PiB0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCIgPyB2YWwudG9TdHJpbmcoKSA6IHZhbFxyXG4gICk7XHJcbn1cclxuXHJcbmNvbnN0IFBhdGNoRmxhZ3MgPSB7XHJcbiAgXCJURVhUXCI6IDEsXHJcbiAgXCIxXCI6IFwiVEVYVFwiLFxyXG4gIFwiQ0xBU1NcIjogMixcclxuICBcIjJcIjogXCJDTEFTU1wiLFxyXG4gIFwiU1RZTEVcIjogNCxcclxuICBcIjRcIjogXCJTVFlMRVwiLFxyXG4gIFwiUFJPUFNcIjogOCxcclxuICBcIjhcIjogXCJQUk9QU1wiLFxyXG4gIFwiRlVMTF9QUk9QU1wiOiAxNixcclxuICBcIjE2XCI6IFwiRlVMTF9QUk9QU1wiLFxyXG4gIFwiTkVFRF9IWURSQVRJT05cIjogMzIsXHJcbiAgXCIzMlwiOiBcIk5FRURfSFlEUkFUSU9OXCIsXHJcbiAgXCJTVEFCTEVfRlJBR01FTlRcIjogNjQsXHJcbiAgXCI2NFwiOiBcIlNUQUJMRV9GUkFHTUVOVFwiLFxyXG4gIFwiS0VZRURfRlJBR01FTlRcIjogMTI4LFxyXG4gIFwiMTI4XCI6IFwiS0VZRURfRlJBR01FTlRcIixcclxuICBcIlVOS0VZRURfRlJBR01FTlRcIjogMjU2LFxyXG4gIFwiMjU2XCI6IFwiVU5LRVlFRF9GUkFHTUVOVFwiLFxyXG4gIFwiTkVFRF9QQVRDSFwiOiA1MTIsXHJcbiAgXCI1MTJcIjogXCJORUVEX1BBVENIXCIsXHJcbiAgXCJEWU5BTUlDX1NMT1RTXCI6IDEwMjQsXHJcbiAgXCIxMDI0XCI6IFwiRFlOQU1JQ19TTE9UU1wiLFxyXG4gIFwiREVWX1JPT1RfRlJBR01FTlRcIjogMjA0OCxcclxuICBcIjIwNDhcIjogXCJERVZfUk9PVF9GUkFHTUVOVFwiLFxyXG4gIFwiQ0FDSEVEXCI6IC0xLFxyXG4gIFwiLTFcIjogXCJDQUNIRURcIixcclxuICBcIkJBSUxcIjogLTIsXHJcbiAgXCItMlwiOiBcIkJBSUxcIlxyXG59O1xyXG5jb25zdCBQYXRjaEZsYWdOYW1lcyA9IHtcclxuICBbMV06IGBURVhUYCxcclxuICBbMl06IGBDTEFTU2AsXHJcbiAgWzRdOiBgU1RZTEVgLFxyXG4gIFs4XTogYFBST1BTYCxcclxuICBbMTZdOiBgRlVMTF9QUk9QU2AsXHJcbiAgWzMyXTogYE5FRURfSFlEUkFUSU9OYCxcclxuICBbNjRdOiBgU1RBQkxFX0ZSQUdNRU5UYCxcclxuICBbMTI4XTogYEtFWUVEX0ZSQUdNRU5UYCxcclxuICBbMjU2XTogYFVOS0VZRURfRlJBR01FTlRgLFxyXG4gIFs1MTJdOiBgTkVFRF9QQVRDSGAsXHJcbiAgWzEwMjRdOiBgRFlOQU1JQ19TTE9UU2AsXHJcbiAgWzIwNDhdOiBgREVWX1JPT1RfRlJBR01FTlRgLFxyXG4gIFstMV06IGBIT0lTVEVEYCxcclxuICBbLTJdOiBgQkFJTGBcclxufTtcclxuXHJcbmNvbnN0IFNoYXBlRmxhZ3MgPSB7XHJcbiAgXCJFTEVNRU5UXCI6IDEsXHJcbiAgXCIxXCI6IFwiRUxFTUVOVFwiLFxyXG4gIFwiRlVOQ1RJT05BTF9DT01QT05FTlRcIjogMixcclxuICBcIjJcIjogXCJGVU5DVElPTkFMX0NPTVBPTkVOVFwiLFxyXG4gIFwiU1RBVEVGVUxfQ09NUE9ORU5UXCI6IDQsXHJcbiAgXCI0XCI6IFwiU1RBVEVGVUxfQ09NUE9ORU5UXCIsXHJcbiAgXCJURVhUX0NISUxEUkVOXCI6IDgsXHJcbiAgXCI4XCI6IFwiVEVYVF9DSElMRFJFTlwiLFxyXG4gIFwiQVJSQVlfQ0hJTERSRU5cIjogMTYsXHJcbiAgXCIxNlwiOiBcIkFSUkFZX0NISUxEUkVOXCIsXHJcbiAgXCJTTE9UU19DSElMRFJFTlwiOiAzMixcclxuICBcIjMyXCI6IFwiU0xPVFNfQ0hJTERSRU5cIixcclxuICBcIlRFTEVQT1JUXCI6IDY0LFxyXG4gIFwiNjRcIjogXCJURUxFUE9SVFwiLFxyXG4gIFwiU1VTUEVOU0VcIjogMTI4LFxyXG4gIFwiMTI4XCI6IFwiU1VTUEVOU0VcIixcclxuICBcIkNPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRVwiOiAyNTYsXHJcbiAgXCIyNTZcIjogXCJDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkVcIixcclxuICBcIkNPTVBPTkVOVF9LRVBUX0FMSVZFXCI6IDUxMixcclxuICBcIjUxMlwiOiBcIkNPTVBPTkVOVF9LRVBUX0FMSVZFXCIsXHJcbiAgXCJDT01QT05FTlRcIjogNixcclxuICBcIjZcIjogXCJDT01QT05FTlRcIlxyXG59O1xyXG5cclxuY29uc3QgU2xvdEZsYWdzID0ge1xyXG4gIFwiU1RBQkxFXCI6IDEsXHJcbiAgXCIxXCI6IFwiU1RBQkxFXCIsXHJcbiAgXCJEWU5BTUlDXCI6IDIsXHJcbiAgXCIyXCI6IFwiRFlOQU1JQ1wiLFxyXG4gIFwiRk9SV0FSREVEXCI6IDMsXHJcbiAgXCIzXCI6IFwiRk9SV0FSREVEXCJcclxufTtcclxuY29uc3Qgc2xvdEZsYWdzVGV4dCA9IHtcclxuICBbMV06IFwiU1RBQkxFXCIsXHJcbiAgWzJdOiBcIkRZTkFNSUNcIixcclxuICBbM106IFwiRk9SV0FSREVEXCJcclxufTtcclxuXHJcbmNvbnN0IEdMT0JBTFNfQUxMT1dFRCA9IFwiSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTixwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCxNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsQmlnSW50LGNvbnNvbGUsRXJyb3IsU3ltYm9sXCI7XHJcbmNvbnN0IGlzR2xvYmFsbHlBbGxvd2VkID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoR0xPQkFMU19BTExPV0VEKTtcclxuY29uc3QgaXNHbG9iYWxseVdoaXRlbGlzdGVkID0gaXNHbG9iYWxseUFsbG93ZWQ7XHJcblxyXG5jb25zdCByYW5nZSA9IDI7XHJcbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lKHNvdXJjZSwgc3RhcnQgPSAwLCBlbmQgPSBzb3VyY2UubGVuZ3RoKSB7XHJcbiAgc3RhcnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzdGFydCwgc291cmNlLmxlbmd0aCkpO1xyXG4gIGVuZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGVuZCwgc291cmNlLmxlbmd0aCkpO1xyXG4gIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFwiXCI7XHJcbiAgbGV0IGxpbmVzID0gc291cmNlLnNwbGl0KC8oXFxyP1xcbikvKTtcclxuICBjb25zdCBuZXdsaW5lU2VxdWVuY2VzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDEpO1xyXG4gIGxpbmVzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDApO1xyXG4gIGxldCBjb3VudCA9IDA7XHJcbiAgY29uc3QgcmVzID0gW107XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgKG5ld2xpbmVTZXF1ZW5jZXNbaV0gJiYgbmV3bGluZVNlcXVlbmNlc1tpXS5sZW5ndGggfHwgMCk7XHJcbiAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcclxuICAgICAgZm9yIChsZXQgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xyXG4gICAgICAgIGlmIChqIDwgMCB8fCBqID49IGxpbmVzLmxlbmd0aCkgY29udGludWU7XHJcbiAgICAgICAgY29uc3QgbGluZSA9IGogKyAxO1xyXG4gICAgICAgIHJlcy5wdXNoKFxyXG4gICAgICAgICAgYCR7bGluZX0ke1wiIFwiLnJlcGVhdChNYXRoLm1heCgzIC0gU3RyaW5nKGxpbmUpLmxlbmd0aCwgMCkpfXwgICR7bGluZXNbal19YFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBuZXdMaW5lU2VxTGVuZ3RoID0gbmV3bGluZVNlcXVlbmNlc1tqXSAmJiBuZXdsaW5lU2VxdWVuY2VzW2pdLmxlbmd0aCB8fCAwO1xyXG4gICAgICAgIGlmIChqID09PSBpKSB7XHJcbiAgICAgICAgICBjb25zdCBwYWQgPSBzdGFydCAtIChjb3VudCAtIChsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aCkpO1xyXG4gICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoXHJcbiAgICAgICAgICAgIDEsXHJcbiAgICAgICAgICAgIGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyBcIiBcIi5yZXBlYXQocGFkKSArIFwiXlwiLnJlcGVhdChsZW5ndGgpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGogPiBpKSB7XHJcbiAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcclxuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpLCAxKTtcclxuICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyBcIl5cIi5yZXBlYXQobGVuZ3RoKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXMuam9pbihcIlxcblwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGUodmFsdWUpIHtcclxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgIGNvbnN0IHJlcyA9IHt9O1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBpdGVtID0gdmFsdWVbaV07XHJcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBpc1N0cmluZyhpdGVtKSA/IHBhcnNlU3RyaW5nU3R5bGUoaXRlbSkgOiBub3JtYWxpemVTdHlsZShpdGVtKTtcclxuICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBub3JtYWxpemVkKSB7XHJcbiAgICAgICAgICByZXNba2V5XSA9IG5vcm1hbGl6ZWRba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbiAgfSBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkgfHwgaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfVxyXG59XHJcbmNvbnN0IGxpc3REZWxpbWl0ZXJSRSA9IC87KD8hW14oXSpcXCkpL2c7XHJcbmNvbnN0IHByb3BlcnR5RGVsaW1pdGVyUkUgPSAvOihbXl0rKS87XHJcbmNvbnN0IHN0eWxlQ29tbWVudFJFID0gL1xcL1xcKlteXSo/XFwqXFwvL2c7XHJcbmZ1bmN0aW9uIHBhcnNlU3RyaW5nU3R5bGUoY3NzVGV4dCkge1xyXG4gIGNvbnN0IHJldCA9IHt9O1xyXG4gIGNzc1RleHQucmVwbGFjZShzdHlsZUNvbW1lbnRSRSwgXCJcIikuc3BsaXQobGlzdERlbGltaXRlclJFKS5mb3JFYWNoKChpdGVtKSA9PiB7XHJcbiAgICBpZiAoaXRlbSkge1xyXG4gICAgICBjb25zdCB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyUkUpO1xyXG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmV0W3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHJldDtcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnlTdHlsZShzdHlsZXMpIHtcclxuICBpZiAoIXN0eWxlcykgcmV0dXJuIFwiXCI7XHJcbiAgaWYgKGlzU3RyaW5nKHN0eWxlcykpIHJldHVybiBzdHlsZXM7XHJcbiAgbGV0IHJldCA9IFwiXCI7XHJcbiAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGVzKSB7XHJcbiAgICBjb25zdCB2YWx1ZSA9IHN0eWxlc1trZXldO1xyXG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGtleS5zdGFydHNXaXRoKGAtLWApID8ga2V5IDogaHlwaGVuYXRlKGtleSk7XHJcbiAgICAgIHJldCArPSBgJHtub3JtYWxpemVkS2V5fToke3ZhbHVlfTtgO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmV0O1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzKHZhbHVlKSB7XHJcbiAgbGV0IHJlcyA9IFwiXCI7XHJcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgcmVzID0gdmFsdWU7XHJcbiAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplQ2xhc3ModmFsdWVbaV0pO1xyXG4gICAgICBpZiAobm9ybWFsaXplZCkge1xyXG4gICAgICAgIHJlcyArPSBub3JtYWxpemVkICsgXCIgXCI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgZm9yIChjb25zdCBuYW1lIGluIHZhbHVlKSB7XHJcbiAgICAgIGlmICh2YWx1ZVtuYW1lXSkge1xyXG4gICAgICAgIHJlcyArPSBuYW1lICsgXCIgXCI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlcy50cmltKCk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMocHJvcHMpIHtcclxuICBpZiAoIXByb3BzKSByZXR1cm4gbnVsbDtcclxuICBsZXQgeyBjbGFzczoga2xhc3MsIHN0eWxlIH0gPSBwcm9wcztcclxuICBpZiAoa2xhc3MgJiYgIWlzU3RyaW5nKGtsYXNzKSkge1xyXG4gICAgcHJvcHMuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhrbGFzcyk7XHJcbiAgfVxyXG4gIGlmIChzdHlsZSkge1xyXG4gICAgcHJvcHMuc3R5bGUgPSBub3JtYWxpemVTdHlsZShzdHlsZSk7XHJcbiAgfVxyXG4gIHJldHVybiBwcm9wcztcclxufVxyXG5cclxuY29uc3QgSFRNTF9UQUdTID0gXCJodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSxhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoZ3JvdXAsaDEsaDIsaDMsaDQsaDUsaDYsbmF2LHNlY3Rpb24sZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ1YnkscyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbixvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLGRldGFpbHMsZGlhbG9nLG1lbnUsc3VtbWFyeSx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdFwiO1xyXG5jb25zdCBTVkdfVEFHUyA9IFwic3ZnLGFuaW1hdGUsYW5pbWF0ZU1vdGlvbixhbmltYXRlVHJhbnNmb3JtLGNpcmNsZSxjbGlwUGF0aCxjb2xvci1wcm9maWxlLGRlZnMsZGVzYyxkaXNjYXJkLGVsbGlwc2UsZmVCbGVuZCxmZUNvbG9yTWF0cml4LGZlQ29tcG9uZW50VHJhbnNmZXIsZmVDb21wb3NpdGUsZmVDb252b2x2ZU1hdHJpeCxmZURpZmZ1c2VMaWdodGluZyxmZURpc3BsYWNlbWVudE1hcCxmZURpc3RhbnRMaWdodCxmZURyb3BTaGFkb3csZmVGbG9vZCxmZUZ1bmNBLGZlRnVuY0IsZmVGdW5jRyxmZUZ1bmNSLGZlR2F1c3NpYW5CbHVyLGZlSW1hZ2UsZmVNZXJnZSxmZU1lcmdlTm9kZSxmZU1vcnBob2xvZ3ksZmVPZmZzZXQsZmVQb2ludExpZ2h0LGZlU3BlY3VsYXJMaWdodGluZyxmZVNwb3RMaWdodCxmZVRpbGUsZmVUdXJidWxlbmNlLGZpbHRlcixmb3JlaWduT2JqZWN0LGcsaGF0Y2gsaGF0Y2hwYXRoLGltYWdlLGxpbmUsbGluZWFyR3JhZGllbnQsbWFya2VyLG1hc2ssbWVzaCxtZXNoZ3JhZGllbnQsbWVzaHBhdGNoLG1lc2hyb3csbWV0YWRhdGEsbXBhdGgscGF0aCxwYXR0ZXJuLHBvbHlnb24scG9seWxpbmUscmFkaWFsR3JhZGllbnQscmVjdCxzZXQsc29saWRjb2xvcixzdG9wLHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0UGF0aCx0aXRsZSx0c3Bhbix1bmtub3duLHVzZSx2aWV3XCI7XHJcbmNvbnN0IE1BVEhfVEFHUyA9IFwiYW5ub3RhdGlvbixhbm5vdGF0aW9uLXhtbCxtYWN0aW9uLG1hbGlnbmdyb3VwLG1hbGlnbm1hcmssbWF0aCxtZW5jbG9zZSxtZXJyb3IsbWZlbmNlZCxtZnJhYyxtZnJhY3Rpb24sbWdseXBoLG1pLG1sYWJlbGVkdHIsbWxvbmdkaXYsbW11bHRpc2NyaXB0cyxtbixtbyxtb3ZlcixtcGFkZGVkLG1waGFudG9tLG1wcmVzY3JpcHRzLG1yb290LG1yb3csbXMsbXNjYXJyaWVzLG1zY2FycnksbXNncm91cCxtc2xpbmUsbXNwYWNlLG1zcXJ0LG1zcm93LG1zdGFjayxtc3R5bGUsbXN1Yixtc3Vic3VwLG1zdXAsbXRhYmxlLG10ZCxtdGV4dCxtdHIsbXVuZGVyLG11bmRlcm92ZXIsbm9uZSxzZW1hbnRpY3NcIjtcclxuY29uc3QgVk9JRF9UQUdTID0gXCJhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGhyLGltZyxpbnB1dCxsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdiclwiO1xyXG5jb25zdCBpc0hUTUxUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChIVE1MX1RBR1MpO1xyXG5jb25zdCBpc1NWR1RhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFNWR19UQUdTKTtcclxuY29uc3QgaXNNYXRoTUxUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChNQVRIX1RBR1MpO1xyXG5jb25zdCBpc1ZvaWRUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChWT0lEX1RBR1MpO1xyXG5cclxuY29uc3Qgc3BlY2lhbEJvb2xlYW5BdHRycyA9IGBpdGVtc2NvcGUsYWxsb3dmdWxsc2NyZWVuLGZvcm1ub3ZhbGlkYXRlLGlzbWFwLG5vbW9kdWxlLG5vdmFsaWRhdGUscmVhZG9ubHlgO1xyXG5jb25zdCBpc1NwZWNpYWxCb29sZWFuQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMpO1xyXG5jb25zdCBpc0Jvb2xlYW5BdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXHJcbiAgc3BlY2lhbEJvb2xlYW5BdHRycyArIGAsYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNvbnRyb2xzLGRlZmF1bHQsZGVmZXIsZGlzYWJsZWQsaGlkZGVuLGluZXJ0LGxvb3Asb3BlbixyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3MsY2hlY2tlZCxtdXRlZCxtdWx0aXBsZSxzZWxlY3RlZGBcclxuKTtcclxuZnVuY3Rpb24gaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKSB7XHJcbiAgcmV0dXJuICEhdmFsdWUgfHwgdmFsdWUgPT09IFwiXCI7XHJcbn1cclxuY29uc3QgdW5zYWZlQXR0ckNoYXJSRSA9IC9bPi89XCInXFx1MDAwOVxcdTAwMGFcXHUwMDBjXFx1MDAyMF0vO1xyXG5jb25zdCBhdHRyVmFsaWRhdGlvbkNhY2hlID0ge307XHJcbmZ1bmN0aW9uIGlzU1NSU2FmZUF0dHJOYW1lKG5hbWUpIHtcclxuICBpZiAoYXR0clZhbGlkYXRpb25DYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgcmV0dXJuIGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV07XHJcbiAgfVxyXG4gIGNvbnN0IGlzVW5zYWZlID0gdW5zYWZlQXR0ckNoYXJSRS50ZXN0KG5hbWUpO1xyXG4gIGlmIChpc1Vuc2FmZSkge1xyXG4gICAgY29uc29sZS5lcnJvcihgdW5zYWZlIGF0dHJpYnV0ZSBuYW1lOiAke25hbWV9YCk7XHJcbiAgfVxyXG4gIHJldHVybiBhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdID0gIWlzVW5zYWZlO1xyXG59XHJcbmNvbnN0IHByb3BzVG9BdHRyTWFwID0ge1xyXG4gIGFjY2VwdENoYXJzZXQ6IFwiYWNjZXB0LWNoYXJzZXRcIixcclxuICBjbGFzc05hbWU6IFwiY2xhc3NcIixcclxuICBodG1sRm9yOiBcImZvclwiLFxyXG4gIGh0dHBFcXVpdjogXCJodHRwLWVxdWl2XCJcclxufTtcclxuY29uc3QgaXNLbm93bkh0bWxBdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXHJcbiAgYGFjY2VwdCxhY2NlcHQtY2hhcnNldCxhY2Nlc3NrZXksYWN0aW9uLGFsaWduLGFsbG93LGFsdCxhc3luYyxhdXRvY2FwaXRhbGl6ZSxhdXRvY29tcGxldGUsYXV0b2ZvY3VzLGF1dG9wbGF5LGJhY2tncm91bmQsYmdjb2xvcixib3JkZXIsYnVmZmVyZWQsY2FwdHVyZSxjaGFsbGVuZ2UsY2hhcnNldCxjaGVja2VkLGNpdGUsY2xhc3MsY29kZSxjb2RlYmFzZSxjb2xvcixjb2xzLGNvbHNwYW4sY29udGVudCxjb250ZW50ZWRpdGFibGUsY29udGV4dG1lbnUsY29udHJvbHMsY29vcmRzLGNyb3Nzb3JpZ2luLGNzcCxkYXRhLGRhdGV0aW1lLGRlY29kaW5nLGRlZmF1bHQsZGVmZXIsZGlyLGRpcm5hbWUsZGlzYWJsZWQsZG93bmxvYWQsZHJhZ2dhYmxlLGRyb3B6b25lLGVuY3R5cGUsZW50ZXJrZXloaW50LGZvcixmb3JtLGZvcm1hY3Rpb24sZm9ybWVuY3R5cGUsZm9ybW1ldGhvZCxmb3Jtbm92YWxpZGF0ZSxmb3JtdGFyZ2V0LGhlYWRlcnMsaGVpZ2h0LGhpZGRlbixoaWdoLGhyZWYsaHJlZmxhbmcsaHR0cC1lcXVpdixpY29uLGlkLGltcG9ydGFuY2UsaW5lcnQsaW50ZWdyaXR5LGlzbWFwLGl0ZW1wcm9wLGtleXR5cGUsa2luZCxsYWJlbCxsYW5nLGxhbmd1YWdlLGxvYWRpbmcsbGlzdCxsb29wLGxvdyxtYW5pZmVzdCxtYXgsbWF4bGVuZ3RoLG1pbmxlbmd0aCxtZWRpYSxtaW4sbXVsdGlwbGUsbXV0ZWQsbmFtZSxub3ZhbGlkYXRlLG9wZW4sb3B0aW11bSxwYXR0ZXJuLHBpbmcscGxhY2Vob2xkZXIscG9zdGVyLHByZWxvYWQscmFkaW9ncm91cCxyZWFkb25seSxyZWZlcnJlcnBvbGljeSxyZWwscmVxdWlyZWQscmV2ZXJzZWQscm93cyxyb3dzcGFuLHNhbmRib3gsc2NvcGUsc2NvcGVkLHNlbGVjdGVkLHNoYXBlLHNpemUsc2l6ZXMsc2xvdCxzcGFuLHNwZWxsY2hlY2ssc3JjLHNyY2RvYyxzcmNsYW5nLHNyY3NldCxzdGFydCxzdGVwLHN0eWxlLHN1bW1hcnksdGFiaW5kZXgsdGFyZ2V0LHRpdGxlLHRyYW5zbGF0ZSx0eXBlLHVzZW1hcCx2YWx1ZSx3aWR0aCx3cmFwYFxyXG4pO1xyXG5jb25zdCBpc0tub3duU3ZnQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxyXG4gIGB4bWxucyxhY2NlbnQtaGVpZ2h0LGFjY3VtdWxhdGUsYWRkaXRpdmUsYWxpZ25tZW50LWJhc2VsaW5lLGFscGhhYmV0aWMsYW1wbGl0dWRlLGFyYWJpYy1mb3JtLGFzY2VudCxhdHRyaWJ1dGVOYW1lLGF0dHJpYnV0ZVR5cGUsYXppbXV0aCxiYXNlRnJlcXVlbmN5LGJhc2VsaW5lLXNoaWZ0LGJhc2VQcm9maWxlLGJib3gsYmVnaW4sYmlhcyxieSxjYWxjTW9kZSxjYXAtaGVpZ2h0LGNsYXNzLGNsaXAsY2xpcFBhdGhVbml0cyxjbGlwLXBhdGgsY2xpcC1ydWxlLGNvbG9yLGNvbG9yLWludGVycG9sYXRpb24sY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzLGNvbG9yLXByb2ZpbGUsY29sb3ItcmVuZGVyaW5nLGNvbnRlbnRTY3JpcHRUeXBlLGNvbnRlbnRTdHlsZVR5cGUsY3Jvc3NvcmlnaW4sY3Vyc29yLGN4LGN5LGQsZGVjZWxlcmF0ZSxkZXNjZW50LGRpZmZ1c2VDb25zdGFudCxkaXJlY3Rpb24sZGlzcGxheSxkaXZpc29yLGRvbWluYW50LWJhc2VsaW5lLGR1cixkeCxkeSxlZGdlTW9kZSxlbGV2YXRpb24sZW5hYmxlLWJhY2tncm91bmQsZW5kLGV4cG9uZW50LGZpbGwsZmlsbC1vcGFjaXR5LGZpbGwtcnVsZSxmaWx0ZXIsZmlsdGVyUmVzLGZpbHRlclVuaXRzLGZsb29kLWNvbG9yLGZsb29kLW9wYWNpdHksZm9udC1mYW1pbHksZm9udC1zaXplLGZvbnQtc2l6ZS1hZGp1c3QsZm9udC1zdHJldGNoLGZvbnQtc3R5bGUsZm9udC12YXJpYW50LGZvbnQtd2VpZ2h0LGZvcm1hdCxmcm9tLGZyLGZ4LGZ5LGcxLGcyLGdseXBoLW5hbWUsZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCxnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCxnbHlwaFJlZixncmFkaWVudFRyYW5zZm9ybSxncmFkaWVudFVuaXRzLGhhbmdpbmcsaGVpZ2h0LGhyZWYsaHJlZmxhbmcsaG9yaXotYWR2LXgsaG9yaXotb3JpZ2luLXgsaWQsaWRlb2dyYXBoaWMsaW1hZ2UtcmVuZGVyaW5nLGluLGluMixpbnRlcmNlcHQsayxrMSxrMixrMyxrNCxrZXJuZWxNYXRyaXgsa2VybmVsVW5pdExlbmd0aCxrZXJuaW5nLGtleVBvaW50cyxrZXlTcGxpbmVzLGtleVRpbWVzLGxhbmcsbGVuZ3RoQWRqdXN0LGxldHRlci1zcGFjaW5nLGxpZ2h0aW5nLWNvbG9yLGxpbWl0aW5nQ29uZUFuZ2xlLGxvY2FsLG1hcmtlci1lbmQsbWFya2VyLW1pZCxtYXJrZXItc3RhcnQsbWFya2VySGVpZ2h0LG1hcmtlclVuaXRzLG1hcmtlcldpZHRoLG1hc2ssbWFza0NvbnRlbnRVbml0cyxtYXNrVW5pdHMsbWF0aGVtYXRpY2FsLG1heCxtZWRpYSxtZXRob2QsbWluLG1vZGUsbmFtZSxudW1PY3RhdmVzLG9mZnNldCxvcGFjaXR5LG9wZXJhdG9yLG9yZGVyLG9yaWVudCxvcmllbnRhdGlvbixvcmlnaW4sb3ZlcmZsb3csb3ZlcmxpbmUtcG9zaXRpb24sb3ZlcmxpbmUtdGhpY2tuZXNzLHBhbm9zZS0xLHBhaW50LW9yZGVyLHBhdGgscGF0aExlbmd0aCxwYXR0ZXJuQ29udGVudFVuaXRzLHBhdHRlcm5UcmFuc2Zvcm0scGF0dGVyblVuaXRzLHBpbmcscG9pbnRlci1ldmVudHMscG9pbnRzLHBvaW50c0F0WCxwb2ludHNBdFkscG9pbnRzQXRaLHByZXNlcnZlQWxwaGEscHJlc2VydmVBc3BlY3RSYXRpbyxwcmltaXRpdmVVbml0cyxyLHJhZGl1cyxyZWZlcnJlclBvbGljeSxyZWZYLHJlZlkscmVsLHJlbmRlcmluZy1pbnRlbnQscmVwZWF0Q291bnQscmVwZWF0RHVyLHJlcXVpcmVkRXh0ZW5zaW9ucyxyZXF1aXJlZEZlYXR1cmVzLHJlc3RhcnQscmVzdWx0LHJvdGF0ZSxyeCxyeSxzY2FsZSxzZWVkLHNoYXBlLXJlbmRlcmluZyxzbG9wZSxzcGFjaW5nLHNwZWN1bGFyQ29uc3RhbnQsc3BlY3VsYXJFeHBvbmVudCxzcGVlZCxzcHJlYWRNZXRob2Qsc3RhcnRPZmZzZXQsc3RkRGV2aWF0aW9uLHN0ZW1oLHN0ZW12LHN0aXRjaFRpbGVzLHN0b3AtY29sb3Isc3RvcC1vcGFjaXR5LHN0cmlrZXRocm91Z2gtcG9zaXRpb24sc3RyaWtldGhyb3VnaC10aGlja25lc3Msc3RyaW5nLHN0cm9rZSxzdHJva2UtZGFzaGFycmF5LHN0cm9rZS1kYXNob2Zmc2V0LHN0cm9rZS1saW5lY2FwLHN0cm9rZS1saW5lam9pbixzdHJva2UtbWl0ZXJsaW1pdCxzdHJva2Utb3BhY2l0eSxzdHJva2Utd2lkdGgsc3R5bGUsc3VyZmFjZVNjYWxlLHN5c3RlbUxhbmd1YWdlLHRhYmluZGV4LHRhYmxlVmFsdWVzLHRhcmdldCx0YXJnZXRYLHRhcmdldFksdGV4dC1hbmNob3IsdGV4dC1kZWNvcmF0aW9uLHRleHQtcmVuZGVyaW5nLHRleHRMZW5ndGgsdG8sdHJhbnNmb3JtLHRyYW5zZm9ybS1vcmlnaW4sdHlwZSx1MSx1Mix1bmRlcmxpbmUtcG9zaXRpb24sdW5kZXJsaW5lLXRoaWNrbmVzcyx1bmljb2RlLHVuaWNvZGUtYmlkaSx1bmljb2RlLXJhbmdlLHVuaXRzLXBlci1lbSx2LWFscGhhYmV0aWMsdi1oYW5naW5nLHYtaWRlb2dyYXBoaWMsdi1tYXRoZW1hdGljYWwsdmFsdWVzLHZlY3Rvci1lZmZlY3QsdmVyc2lvbix2ZXJ0LWFkdi15LHZlcnQtb3JpZ2luLXgsdmVydC1vcmlnaW4teSx2aWV3Qm94LHZpZXdUYXJnZXQsdmlzaWJpbGl0eSx3aWR0aCx3aWR0aHMsd29yZC1zcGFjaW5nLHdyaXRpbmctbW9kZSx4LHgtaGVpZ2h0LHgxLHgyLHhDaGFubmVsU2VsZWN0b3IseGxpbms6YWN0dWF0ZSx4bGluazphcmNyb2xlLHhsaW5rOmhyZWYseGxpbms6cm9sZSx4bGluazpzaG93LHhsaW5rOnRpdGxlLHhsaW5rOnR5cGUseG1sbnM6eGxpbmsseG1sOmJhc2UseG1sOmxhbmcseG1sOnNwYWNlLHkseTEseTIseUNoYW5uZWxTZWxlY3Rvcix6LHpvb21BbmRQYW5gXHJcbik7XHJcbmNvbnN0IGlzS25vd25NYXRoTUxBdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXHJcbiAgYGFjY2VudCxhY2NlbnR1bmRlcixhY3Rpb250eXBlLGFsaWduLGFsaWdubWVudHNjb3BlLGFsdGltZyxhbHRpbWctaGVpZ2h0LGFsdGltZy12YWxpZ24sYWx0aW1nLXdpZHRoLGFsdHRleHQsYmV2ZWxsZWQsY2xvc2UsY29sdW1uc2FsaWduLGNvbHVtbmxpbmVzLGNvbHVtbnNwYW4sZGVub21hbGlnbixkZXB0aCxkaXIsZGlzcGxheSxkaXNwbGF5c3R5bGUsZW5jb2RpbmcsZXF1YWxjb2x1bW5zLGVxdWFscm93cyxmZW5jZSxmb250c3R5bGUsZm9udHdlaWdodCxmb3JtLGZyYW1lLGZyYW1lc3BhY2luZyxncm91cGFsaWduLGhlaWdodCxocmVmLGlkLGluZGVudGFsaWduLGluZGVudGFsaWduZmlyc3QsaW5kZW50YWxpZ25sYXN0LGluZGVudHNoaWZ0LGluZGVudHNoaWZ0Zmlyc3QsaW5kZW50c2hpZnRsYXN0LGluZGV4dHlwZSxqdXN0aWZ5LGxhcmdldG9wLGxhcmdlb3AsbHF1b3RlLGxzcGFjZSxtYXRoYmFja2dyb3VuZCxtYXRoY29sb3IsbWF0aHNpemUsbWF0aHZhcmlhbnQsbWF4c2l6ZSxtaW5sYWJlbHNwYWNpbmcsbW9kZSxvdGhlcixvdmVyZmxvdyxwb3NpdGlvbixyb3dhbGlnbixyb3dsaW5lcyxyb3dzcGFuLHJxdW90ZSxyc3BhY2Usc2NyaXB0bGV2ZWwsc2NyaXB0bWluc2l6ZSxzY3JpcHRzaXplbXVsdGlwbGllcixzZWxlY3Rpb24sc2VwYXJhdG9yLHNlcGFyYXRvcnMsc2hpZnQsc2lkZSxzcmMsc3RhY2thbGlnbixzdHJldGNoeSxzdWJzY3JpcHRzaGlmdCxzdXBlcnNjcmlwdHNoaWZ0LHN5bW1ldHJpYyx2b2Zmc2V0LHdpZHRoLHdpZHRocyx4bGluazpocmVmLHhsaW5rOnNob3cseGxpbms6dHlwZSx4bWxuc2BcclxuKTtcclxuZnVuY3Rpb24gaXNSZW5kZXJhYmxlQXR0clZhbHVlKHZhbHVlKSB7XHJcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcclxuICByZXR1cm4gdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiO1xyXG59XHJcblxyXG5jb25zdCBlc2NhcGVSRSA9IC9bXCInJjw+XS87XHJcbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XHJcbiAgY29uc3Qgc3RyID0gXCJcIiArIHN0cmluZztcclxuICBjb25zdCBtYXRjaCA9IGVzY2FwZVJFLmV4ZWMoc3RyKTtcclxuICBpZiAoIW1hdGNoKSB7XHJcbiAgICByZXR1cm4gc3RyO1xyXG4gIH1cclxuICBsZXQgaHRtbCA9IFwiXCI7XHJcbiAgbGV0IGVzY2FwZWQ7XHJcbiAgbGV0IGluZGV4O1xyXG4gIGxldCBsYXN0SW5kZXggPSAwO1xyXG4gIGZvciAoaW5kZXggPSBtYXRjaC5pbmRleDsgaW5kZXggPCBzdHIubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xyXG4gICAgICBjYXNlIDM0OlxyXG4gICAgICAgIGVzY2FwZWQgPSBcIiZxdW90O1wiO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDM4OlxyXG4gICAgICAgIGVzY2FwZWQgPSBcIiZhbXA7XCI7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMzk6XHJcbiAgICAgICAgZXNjYXBlZCA9IFwiJiMzOTtcIjtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSA2MDpcclxuICAgICAgICBlc2NhcGVkID0gXCImbHQ7XCI7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgNjI6XHJcbiAgICAgICAgZXNjYXBlZCA9IFwiJmd0O1wiO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcclxuICAgICAgaHRtbCArPSBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCk7XHJcbiAgICB9XHJcbiAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XHJcbiAgICBodG1sICs9IGVzY2FwZWQ7XHJcbiAgfVxyXG4gIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KSA6IGh0bWw7XHJcbn1cclxuY29uc3QgY29tbWVudFN0cmlwUkUgPSAvXi0/Pnw8IS0tfC0tPnwtLSE+fDwhLSQvZztcclxuZnVuY3Rpb24gZXNjYXBlSHRtbENvbW1lbnQoc3JjKSB7XHJcbiAgcmV0dXJuIHNyYy5yZXBsYWNlKGNvbW1lbnRTdHJpcFJFLCBcIlwiKTtcclxufVxyXG5jb25zdCBjc3NWYXJOYW1lRXNjYXBlU3ltYm9sc1JFID0gL1sgIVwiIyQlJicoKSorLC4vOjs8PT4/QFtcXFxcXFxdXmB7fH1+XS9nO1xyXG5mdW5jdGlvbiBnZXRFc2NhcGVkQ3NzVmFyTmFtZShrZXksIGRvdWJsZUVzY2FwZSkge1xyXG4gIHJldHVybiBrZXkucmVwbGFjZShcclxuICAgIGNzc1Zhck5hbWVFc2NhcGVTeW1ib2xzUkUsXHJcbiAgICAocykgPT4gZG91YmxlRXNjYXBlID8gcyA9PT0gJ1wiJyA/ICdcXFxcXFxcXFxcXFxcIicgOiBgXFxcXFxcXFwke3N9YCA6IGBcXFxcJHtzfWBcclxuICApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikge1xyXG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcclxuICBsZXQgZXF1YWwgPSB0cnVlO1xyXG4gIGZvciAobGV0IGkgPSAwOyBlcXVhbCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xyXG4gICAgZXF1YWwgPSBsb29zZUVxdWFsKGFbaV0sIGJbaV0pO1xyXG4gIH1cclxuICByZXR1cm4gZXF1YWw7XHJcbn1cclxuZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XHJcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xyXG4gIGxldCBhVmFsaWRUeXBlID0gaXNEYXRlKGEpO1xyXG4gIGxldCBiVmFsaWRUeXBlID0gaXNEYXRlKGIpO1xyXG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcclxuICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKCkgOiBmYWxzZTtcclxuICB9XHJcbiAgYVZhbGlkVHlwZSA9IGlzU3ltYm9sKGEpO1xyXG4gIGJWYWxpZFR5cGUgPSBpc1N5bWJvbChiKTtcclxuICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XHJcbiAgICByZXR1cm4gYSA9PT0gYjtcclxuICB9XHJcbiAgYVZhbGlkVHlwZSA9IGlzQXJyYXkoYSk7XHJcbiAgYlZhbGlkVHlwZSA9IGlzQXJyYXkoYik7XHJcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xyXG4gICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSA6IGZhbHNlO1xyXG4gIH1cclxuICBhVmFsaWRUeXBlID0gaXNPYmplY3QoYSk7XHJcbiAgYlZhbGlkVHlwZSA9IGlzT2JqZWN0KGIpO1xyXG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcclxuICAgIGlmICghYVZhbGlkVHlwZSB8fCAhYlZhbGlkVHlwZSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYSkubGVuZ3RoO1xyXG4gICAgY29uc3QgYktleXNDb3VudCA9IE9iamVjdC5rZXlzKGIpLmxlbmd0aDtcclxuICAgIGlmIChhS2V5c0NvdW50ICE9PSBiS2V5c0NvdW50KSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qga2V5IGluIGEpIHtcclxuICAgICAgY29uc3QgYUhhc0tleSA9IGEuaGFzT3duUHJvcGVydHkoa2V5KTtcclxuICAgICAgY29uc3QgYkhhc0tleSA9IGIuaGFzT3duUHJvcGVydHkoa2V5KTtcclxuICAgICAgaWYgKGFIYXNLZXkgJiYgIWJIYXNLZXkgfHwgIWFIYXNLZXkgJiYgYkhhc0tleSB8fCAhbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpO1xyXG59XHJcbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZihhcnIsIHZhbCkge1xyXG4gIHJldHVybiBhcnIuZmluZEluZGV4KChpdGVtKSA9PiBsb29zZUVxdWFsKGl0ZW0sIHZhbCkpO1xyXG59XHJcblxyXG5jb25zdCBpc1JlZiA9ICh2YWwpID0+IHtcclxuICByZXR1cm4gISEodmFsICYmIHZhbFtcIl9fdl9pc1JlZlwiXSA9PT0gdHJ1ZSk7XHJcbn07XHJcbmNvbnN0IHRvRGlzcGxheVN0cmluZyA9ICh2YWwpID0+IHtcclxuICByZXR1cm4gaXNTdHJpbmcodmFsKSA/IHZhbCA6IHZhbCA9PSBudWxsID8gXCJcIiA6IGlzQXJyYXkodmFsKSB8fCBpc09iamVjdCh2YWwpICYmICh2YWwudG9TdHJpbmcgPT09IG9iamVjdFRvU3RyaW5nIHx8ICFpc0Z1bmN0aW9uKHZhbC50b1N0cmluZykpID8gaXNSZWYodmFsKSA/IHRvRGlzcGxheVN0cmluZyh2YWwudmFsdWUpIDogSlNPTi5zdHJpbmdpZnkodmFsLCByZXBsYWNlciwgMikgOiBTdHJpbmcodmFsKTtcclxufTtcclxuY29uc3QgcmVwbGFjZXIgPSAoX2tleSwgdmFsKSA9PiB7XHJcbiAgaWYgKGlzUmVmKHZhbCkpIHtcclxuICAgIHJldHVybiByZXBsYWNlcihfa2V5LCB2YWwudmFsdWUpO1xyXG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsKSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgW2BNYXAoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwuZW50cmllcygpXS5yZWR1Y2UoXHJcbiAgICAgICAgKGVudHJpZXMsIFtrZXksIHZhbDJdLCBpKSA9PiB7XHJcbiAgICAgICAgICBlbnRyaWVzW3N0cmluZ2lmeVN5bWJvbChrZXksIGkpICsgXCIgPT5cIl0gPSB2YWwyO1xyXG4gICAgICAgICAgcmV0dXJuIGVudHJpZXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7fVxyXG4gICAgICApXHJcbiAgICB9O1xyXG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsKSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgW2BTZXQoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwudmFsdWVzKCldLm1hcCgodikgPT4gc3RyaW5naWZ5U3ltYm9sKHYpKVxyXG4gICAgfTtcclxuICB9IGVsc2UgaWYgKGlzU3ltYm9sKHZhbCkpIHtcclxuICAgIHJldHVybiBzdHJpbmdpZnlTeW1ib2wodmFsKTtcclxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkgJiYgIWlzQXJyYXkodmFsKSAmJiAhaXNQbGFpbk9iamVjdCh2YWwpKSB7XHJcbiAgICByZXR1cm4gU3RyaW5nKHZhbCk7XHJcbiAgfVxyXG4gIHJldHVybiB2YWw7XHJcbn07XHJcbmNvbnN0IHN0cmluZ2lmeVN5bWJvbCA9ICh2LCBpID0gXCJcIikgPT4ge1xyXG4gIHZhciBfYTtcclxuICByZXR1cm4gKFxyXG4gICAgLy8gU3ltYm9sLmRlc2NyaXB0aW9uIGluIGVzMjAxOSsgc28gd2UgbmVlZCB0byBjYXN0IGhlcmUgdG8gcGFzc1xyXG4gICAgLy8gdGhlIGxpYjogZXMyMDE2IGNoZWNrXHJcbiAgICBpc1N5bWJvbCh2KSA/IGBTeW1ib2woJHsoX2EgPSB2LmRlc2NyaXB0aW9uKSAhPSBudWxsID8gX2EgOiBpfSlgIDogdlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgeyBFTVBUWV9BUlIsIEVNUFRZX09CSiwgTk8sIE5PT1AsIFBhdGNoRmxhZ05hbWVzLCBQYXRjaEZsYWdzLCBTaGFwZUZsYWdzLCBTbG90RmxhZ3MsIGNhbWVsaXplLCBjYXBpdGFsaXplLCBjc3NWYXJOYW1lRXNjYXBlU3ltYm9sc1JFLCBkZWYsIGVzY2FwZUh0bWwsIGVzY2FwZUh0bWxDb21tZW50LCBleHRlbmQsIGdlbkNhY2hlS2V5LCBnZW5Qcm9wc0FjY2Vzc0V4cCwgZ2VuZXJhdGVDb2RlRnJhbWUsIGdldEVzY2FwZWRDc3NWYXJOYW1lLCBnZXRHbG9iYWxUaGlzLCBoYXNDaGFuZ2VkLCBoYXNPd24sIGh5cGhlbmF0ZSwgaW5jbHVkZUJvb2xlYW5BdHRyLCBpbnZva2VBcnJheUZucywgaXNBcnJheSwgaXNCb29sZWFuQXR0ciwgaXNCdWlsdEluRGlyZWN0aXZlLCBpc0RhdGUsIGlzRnVuY3Rpb24sIGlzR2xvYmFsbHlBbGxvd2VkLCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQsIGlzSFRNTFRhZywgaXNJbnRlZ2VyS2V5LCBpc0tub3duSHRtbEF0dHIsIGlzS25vd25NYXRoTUxBdHRyLCBpc0tub3duU3ZnQXR0ciwgaXNNYXAsIGlzTWF0aE1MVGFnLCBpc01vZGVsTGlzdGVuZXIsIGlzT2JqZWN0LCBpc09uLCBpc1BsYWluT2JqZWN0LCBpc1Byb21pc2UsIGlzUmVnRXhwLCBpc1JlbmRlcmFibGVBdHRyVmFsdWUsIGlzUmVzZXJ2ZWRQcm9wLCBpc1NTUlNhZmVBdHRyTmFtZSwgaXNTVkdUYWcsIGlzU2V0LCBpc1NwZWNpYWxCb29sZWFuQXR0ciwgaXNTdHJpbmcsIGlzU3ltYm9sLCBpc1ZvaWRUYWcsIGxvb3NlRXF1YWwsIGxvb3NlSW5kZXhPZiwgbG9vc2VUb051bWJlciwgbWFrZU1hcCwgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVByb3BzLCBub3JtYWxpemVTdHlsZSwgb2JqZWN0VG9TdHJpbmcsIHBhcnNlU3RyaW5nU3R5bGUsIHByb3BzVG9BdHRyTWFwLCByZW1vdmUsIHNsb3RGbGFnc1RleHQsIHN0cmluZ2lmeVN0eWxlLCB0b0Rpc3BsYXlTdHJpbmcsIHRvSGFuZGxlcktleSwgdG9OdW1iZXIsIHRvUmF3VHlwZSwgdG9UeXBlU3RyaW5nIH07XHJcbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8vIHJ1bnRpbWUgaGVscGVyIGZvciBzZXR0aW5nIHByb3BlcnRpZXMgb24gY29tcG9uZW50c1xyXG4vLyBpbiBhIHRyZWUtc2hha2FibGUgd2F5XHJcbmV4cG9ydHMuZGVmYXVsdCA9IChzZmMsIHByb3BzKSA9PiB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSBzZmMuX192Y2NPcHRzIHx8IHNmYztcclxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBwcm9wcykge1xyXG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxuIiwiLyoqXHJcbiogdnVlIHYzLjUuMTNcclxuKiAoYykgMjAxOC1wcmVzZW50IFl1eGkgKEV2YW4pIFlvdSBhbmQgVnVlIGNvbnRyaWJ1dG9yc1xyXG4qIEBsaWNlbnNlIE1JVFxyXG4qKi9cclxuaW1wb3J0ICogYXMgcnVudGltZURvbSBmcm9tICdAdnVlL3J1bnRpbWUtZG9tJztcclxuaW1wb3J0IHsgaW5pdEN1c3RvbUZvcm1hdHRlciwgcmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIsIHdhcm4gfSBmcm9tICdAdnVlL3J1bnRpbWUtZG9tJztcclxuZXhwb3J0ICogZnJvbSAnQHZ1ZS9ydW50aW1lLWRvbSc7XHJcbmltcG9ydCB7IGNvbXBpbGUgfSBmcm9tICdAdnVlL2NvbXBpbGVyLWRvbSc7XHJcbmltcG9ydCB7IGlzU3RyaW5nLCBOT09QLCBnZW5DYWNoZUtleSwgZXh0ZW5kLCBnZW5lcmF0ZUNvZGVGcmFtZSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcclxuXHJcbmZ1bmN0aW9uIGluaXREZXYoKSB7XHJcbiAge1xyXG4gICAgaW5pdEN1c3RvbUZvcm1hdHRlcigpO1xyXG4gIH1cclxufVxyXG5cclxuaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcclxuICBpbml0RGV2KCk7XHJcbn1cclxuY29uc3QgY29tcGlsZUNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbmZ1bmN0aW9uIGNvbXBpbGVUb0Z1bmN0aW9uKHRlbXBsYXRlLCBvcHRpb25zKSB7XHJcbiAgaWYgKCFpc1N0cmluZyh0ZW1wbGF0ZSkpIHtcclxuICAgIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xyXG4gICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246IGAsIHRlbXBsYXRlKTtcclxuICAgICAgcmV0dXJuIE5PT1A7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNvbnN0IGtleSA9IGdlbkNhY2hlS2V5KHRlbXBsYXRlLCBvcHRpb25zKTtcclxuICBjb25zdCBjYWNoZWQgPSBjb21waWxlQ2FjaGVba2V5XTtcclxuICBpZiAoY2FjaGVkKSB7XHJcbiAgICByZXR1cm4gY2FjaGVkO1xyXG4gIH1cclxuICBpZiAodGVtcGxhdGVbMF0gPT09IFwiI1wiKSB7XHJcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGVtcGxhdGUpO1xyXG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWVsKSB7XHJcbiAgICAgIHdhcm4oYFRlbXBsYXRlIGVsZW1lbnQgbm90IGZvdW5kIG9yIGlzIGVtcHR5OiAke3RlbXBsYXRlfWApO1xyXG4gICAgfVxyXG4gICAgdGVtcGxhdGUgPSBlbCA/IGVsLmlubmVySFRNTCA6IGBgO1xyXG4gIH1cclxuICBjb25zdCBvcHRzID0gZXh0ZW5kKFxyXG4gICAge1xyXG4gICAgICBob2lzdFN0YXRpYzogdHJ1ZSxcclxuICAgICAgb25FcnJvcjogISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IG9uRXJyb3IgOiB2b2lkIDAsXHJcbiAgICAgIG9uV2FybjogISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IChlKSA9PiBvbkVycm9yKGUsIHRydWUpIDogTk9PUFxyXG4gICAgfSxcclxuICAgIG9wdGlvbnNcclxuICApO1xyXG4gIGlmICghb3B0cy5pc0N1c3RvbUVsZW1lbnQgJiYgdHlwZW9mIGN1c3RvbUVsZW1lbnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICBvcHRzLmlzQ3VzdG9tRWxlbWVudCA9ICh0YWcpID0+ICEhY3VzdG9tRWxlbWVudHMuZ2V0KHRhZyk7XHJcbiAgfVxyXG4gIGNvbnN0IHsgY29kZSB9ID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0cyk7XHJcbiAgZnVuY3Rpb24gb25FcnJvcihlcnIsIGFzV2FybmluZyA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBtZXNzYWdlID0gYXNXYXJuaW5nID8gZXJyLm1lc3NhZ2UgOiBgVGVtcGxhdGUgY29tcGlsYXRpb24gZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YDtcclxuICAgIGNvbnN0IGNvZGVGcmFtZSA9IGVyci5sb2MgJiYgZ2VuZXJhdGVDb2RlRnJhbWUoXHJcbiAgICAgIHRlbXBsYXRlLFxyXG4gICAgICBlcnIubG9jLnN0YXJ0Lm9mZnNldCxcclxuICAgICAgZXJyLmxvYy5lbmQub2Zmc2V0XHJcbiAgICApO1xyXG4gICAgd2Fybihjb2RlRnJhbWUgPyBgJHttZXNzYWdlfVxyXG4ke2NvZGVGcmFtZX1gIDogbWVzc2FnZSk7XHJcbiAgfVxyXG4gIGNvbnN0IHJlbmRlciA9IG5ldyBGdW5jdGlvbihcIlZ1ZVwiLCBjb2RlKShydW50aW1lRG9tKTtcclxuICByZW5kZXIuX3JjID0gdHJ1ZTtcclxuICByZXR1cm4gY29tcGlsZUNhY2hlW2tleV0gPSByZW5kZXI7XHJcbn1cclxucmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIoY29tcGlsZVRvRnVuY3Rpb24pO1xyXG5cclxuZXhwb3J0IHsgY29tcGlsZVRvRnVuY3Rpb24gYXMgY29tcGlsZSB9O1xyXG4iLCJpbXBvcnQgeyByZW5kZXIgfSBmcm9tIFwiLi9BcHAudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTYxN2FiMGJlXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vQXBwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmc2V0dXA9dHJ1ZSZsYW5nPWpzXCJcbmV4cG9ydCAqIGZyb20gXCIuL0FwcC52dWU/dnVlJnR5cGU9c2NyaXB0JnNldHVwPXRydWUmbGFuZz1qc1wiXG5cbmltcG9ydCBleHBvcnRDb21wb25lbnQgZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvZXhwb3J0SGVscGVyLmpzXCJcbmNvbnN0IF9fZXhwb3J0c19fID0gLyojX19QVVJFX18qL2V4cG9ydENvbXBvbmVudChzY3JpcHQsIFtbJ3JlbmRlcicscmVuZGVyXSxbJ19fZmlsZScsXCJzcmMvY29tcG9uZW50cy9BcHAudnVlXCJdXSlcbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIF9fZXhwb3J0c19fLl9faG1ySWQgPSBcIjYxN2FiMGJlXCJcbiAgY29uc3QgYXBpID0gX19WVUVfSE1SX1JVTlRJTUVfX1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghYXBpLmNyZWF0ZVJlY29yZCgnNjE3YWIwYmUnLCBfX2V4cG9ydHNfXykpIHtcbiAgICBhcGkucmVsb2FkKCc2MTdhYjBiZScsIF9fZXhwb3J0c19fKVxuICB9XG4gIFxuICBtb2R1bGUuaG90LmFjY2VwdChcIi4vQXBwLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD02MTdhYjBiZVwiLCAoKSA9PiB7XG4gICAgYXBpLnJlcmVuZGVyKCc2MTdhYjBiZScsIHJlbmRlcilcbiAgfSlcblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IF9fZXhwb3J0c19fIiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9Ac3ltZm9ueS93ZWJwYWNrLWVuY29yZS9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC0xLnVzZVswXSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzBdLnVzZVswXSEuL0FwcC52dWU/dnVlJnR5cGU9c2NyaXB0JnNldHVwPXRydWUmbGFuZz1qc1wiOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvQHN5bWZvbnkvd2VicGFjay1lbmNvcmUvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMS51c2VbMF0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXS51c2VbMF0hLi9BcHAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZzZXR1cD10cnVlJmxhbmc9anNcIiIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9Ac3ltZm9ueS93ZWJwYWNrLWVuY29yZS9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC0xLnVzZVswXSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3RlbXBsYXRlTG9hZGVyLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vQXBwLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD02MTdhYjBiZVwiIiwiaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSBcIi4vRGFzaGJvYXJkTGF5b3V0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD00OTc3ZTcxYyZzY29wZWQ9dHJ1ZVwiXG5jb25zdCBzY3JpcHQgPSB7fVxuXG5pbXBvcnQgXCIuL0Rhc2hib2FyZExheW91dC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD00OTc3ZTcxYyZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiXG5cbmltcG9ydCBleHBvcnRDb21wb25lbnQgZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvZXhwb3J0SGVscGVyLmpzXCJcbmNvbnN0IF9fZXhwb3J0c19fID0gLyojX19QVVJFX18qL2V4cG9ydENvbXBvbmVudChzY3JpcHQsIFtbJ3JlbmRlcicscmVuZGVyXSxbJ19fc2NvcGVJZCcsXCJkYXRhLXYtNDk3N2U3MWNcIl0sWydfX2ZpbGUnLFwic3JjL2xheW91dC9EYXNoYm9hcmRMYXlvdXQudnVlXCJdXSlcbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIF9fZXhwb3J0c19fLl9faG1ySWQgPSBcIjQ5NzdlNzFjXCJcbiAgY29uc3QgYXBpID0gX19WVUVfSE1SX1JVTlRJTUVfX1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghYXBpLmNyZWF0ZVJlY29yZCgnNDk3N2U3MWMnLCBfX2V4cG9ydHNfXykpIHtcbiAgICBhcGkucmVsb2FkKCc0OTc3ZTcxYycsIF9fZXhwb3J0c19fKVxuICB9XG4gIFxuICBtb2R1bGUuaG90LmFjY2VwdChcIi4vRGFzaGJvYXJkTGF5b3V0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD00OTc3ZTcxYyZzY29wZWQ9dHJ1ZVwiLCAoKSA9PiB7XG4gICAgYXBpLnJlcmVuZGVyKCc0OTc3ZTcxYycsIHJlbmRlcilcbiAgfSlcblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IF9fZXhwb3J0c19fIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2Rpc3QvbG9hZGVyLmpzPz9jbG9uZWRSdWxlU2V0LTQudXNlWzBdIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTQudXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vRGFzaGJvYXJkTGF5b3V0LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTQ5NzdlNzFjJnNjb3BlZD10cnVlJmxhbmc9Y3NzXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvQHN5bWZvbnkvd2VicGFjay1lbmNvcmUvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMS51c2VbMF0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC90ZW1wbGF0ZUxvYWRlci5qcz8/cnVsZVNldFsxXS5ydWxlc1syXSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzBdLnVzZVswXSEuL0Rhc2hib2FyZExheW91dC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NDk3N2U3MWMmc2NvcGVkPXRydWVcIiIsImltcG9ydCB7IGNyZWF0ZUFwcCB9IGZyb20gJ3Z1ZSdcclxuaW1wb3J0IEFwcCBmcm9tICcuL2NvbXBvbmVudHMvQXBwLnZ1ZSdcclxuXHJcbmNvbnN0IGFwcCA9IGNyZWF0ZUFwcChBcHApXHJcbmFwcC5tb3VudCgnI3Z1ZS1hcHAnKSJdLCJuYW1lcyI6WyJyZWYiLCJEYXNoYm9hcmRMYXlvdXQiLCJtZXNzYWdlIiwiX2NyZWF0ZUJsb2NrIiwiJHNldHVwIiwiX3dpdGhDdHgiLCJfY3JlYXRlRWxlbWVudFZOb2RlIiwiX3RvRGlzcGxheVN0cmluZyIsIl8iLCJfY3JlYXRlRWxlbWVudEJsb2NrIiwiX2hvaXN0ZWRfMSIsIl9ob2lzdGVkXzIiLCJfaG9pc3RlZF8zIiwiX2NyZWF0ZVZOb2RlIiwiX2NvbXBvbmVudF9yb3V0ZXJfbGluayIsInRvIiwiZXhhY3QiLCJfY2FjaGUiLCJzcmMiLCJhbHQiLCJfaG9pc3RlZF80IiwiX2NvbXBvbmVudF9yb3V0ZXJfdmlldyIsImNyZWF0ZUFwcCIsIkFwcCIsImFwcCIsIm1vdW50Il0sInNvdXJjZVJvb3QiOiIifQ==